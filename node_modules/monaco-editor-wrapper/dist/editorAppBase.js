import { Uri } from 'monaco-editor';
import { createConfiguredEditor, createConfiguredDiffEditor, createModelReference } from 'vscode/monaco';
import { updateUserConfiguration as vscodeUpdateUserConfiguration } from '@codingame/monaco-vscode-configuration-service-override';
export var ModelUpdateType;
(function (ModelUpdateType) {
    ModelUpdateType[ModelUpdateType["NONE"] = 0] = "NONE";
    ModelUpdateType[ModelUpdateType["CODE"] = 1] = "CODE";
    ModelUpdateType[ModelUpdateType["MODEL"] = 2] = "MODEL";
})(ModelUpdateType || (ModelUpdateType = {}));
/**
 * This is the base class for both Monaco Ediotor Apps:
 * - EditorAppClassic
 * - EditorAppExtended
 *
 * It provides the generic functionality for both implementations.
 */
export class EditorAppBase {
    id;
    editor;
    diffEditor;
    modelRef;
    modelOriginalRef;
    constructor(id) {
        this.id = id;
    }
    buildConfig(userAppConfig) {
        const config = {
            $type: userAppConfig.$type,
            languageId: userAppConfig.languageId,
            code: userAppConfig.code ?? '',
            codeOriginal: userAppConfig.codeOriginal ?? '',
            useDiffEditor: userAppConfig.useDiffEditor === true,
            codeUri: userAppConfig.codeUri ?? undefined,
            codeOriginalUri: userAppConfig.codeOriginalUri ?? undefined,
            readOnly: userAppConfig.readOnly ?? false,
            domReadOnly: userAppConfig.domReadOnly ?? false,
            overrideAutomaticLayout: userAppConfig.overrideAutomaticLayout ?? true,
            awaitExtensionReadiness: userAppConfig.awaitExtensionReadiness ?? undefined,
        };
        config.editorOptions = {
            ...userAppConfig.editorOptions,
            automaticLayout: userAppConfig.overrideAutomaticLayout ?? true
        };
        config.diffEditorOptions = {
            ...userAppConfig.diffEditorOptions,
            automaticLayout: userAppConfig.overrideAutomaticLayout ?? true
        };
        return config;
    }
    haveEditor() {
        return this.editor !== undefined || this.diffEditor !== undefined;
    }
    getEditor() {
        return this.editor;
    }
    getDiffEditor() {
        return this.diffEditor;
    }
    async createEditors(container) {
        if (this.getConfig().useDiffEditor) {
            this.diffEditor = createConfiguredDiffEditor(container, this.getConfig().diffEditorOptions);
            await this.updateDiffEditorModel();
        }
        else {
            this.editor = createConfiguredEditor(container, this.getConfig().editorOptions);
            await this.updateEditorModel();
        }
    }
    disposeEditor() {
        if (this.editor) {
            this.modelRef?.dispose();
            this.editor.dispose();
            this.editor = undefined;
        }
    }
    disposeDiffEditor() {
        if (this.diffEditor) {
            this.modelRef?.dispose();
            this.modelOriginalRef?.dispose();
            this.diffEditor.dispose();
            this.diffEditor = undefined;
        }
    }
    getModel(original) {
        if (this.getConfig().useDiffEditor) {
            return ((original === true) ? this.modelOriginalRef?.object.textEditorModel : this.modelRef?.object.textEditorModel) ?? undefined;
        }
        else {
            return this.modelRef?.object.textEditorModel ?? undefined;
        }
    }
    async updateModel(modelUpdate) {
        if (!this.editor) {
            return Promise.reject(new Error('You cannot update the editor model, because the regular editor is not configured.'));
        }
        const modelUpdateType = isModelUpdateRequired(this.getConfig(), modelUpdate);
        if (modelUpdateType === ModelUpdateType.CODE) {
            this.updateAppConfig(modelUpdate);
            if (this.getConfig().useDiffEditor) {
                this.diffEditor?.getModifiedEditor().setValue(modelUpdate.code ?? '');
                this.diffEditor?.getOriginalEditor().setValue(modelUpdate.codeOriginal ?? '');
            }
            else {
                this.editor.setValue(modelUpdate.code ?? '');
            }
        }
        else if (modelUpdateType === ModelUpdateType.MODEL) {
            this.updateAppConfig(modelUpdate);
            await this.updateEditorModel();
        }
        return Promise.resolve();
    }
    async updateEditorModel() {
        const config = this.getConfig();
        this.modelRef?.dispose();
        const uri = this.getEditorUri('code');
        this.modelRef = await createModelReference(uri, config.code);
        this.modelRef.object.setLanguageId(config.languageId);
        if (this.editor) {
            this.editor.setModel(this.modelRef.object.textEditorModel);
        }
    }
    async updateDiffModel(modelUpdate) {
        if (!this.diffEditor) {
            return Promise.reject(new Error('You cannot update the diff editor models, because the diffEditor is not configured.'));
        }
        if (isModelUpdateRequired(this.getConfig(), modelUpdate)) {
            this.updateAppConfig(modelUpdate);
            await this.updateDiffEditorModel();
        }
        return Promise.resolve();
    }
    async updateDiffEditorModel() {
        const config = this.getConfig();
        this.modelRef?.dispose();
        this.modelOriginalRef?.dispose();
        const uri = this.getEditorUri('code');
        const uriOriginal = this.getEditorUri('codeOriginal');
        const promises = [];
        promises.push(createModelReference(uri, config.code));
        promises.push(createModelReference(uriOriginal, config.codeOriginal));
        const refs = await Promise.all(promises);
        this.modelRef = refs[0];
        this.modelRef.object.setLanguageId(config.languageId);
        this.modelOriginalRef = refs[1];
        this.modelOriginalRef.object.setLanguageId(config.languageId);
        if (this.diffEditor && this.modelRef.object.textEditorModel !== null && this.modelOriginalRef.object.textEditorModel !== null) {
            this.diffEditor?.setModel({
                original: this.modelOriginalRef.object.textEditorModel,
                modified: this.modelRef.object.textEditorModel
            });
        }
    }
    updateAppConfig(modelUpdate) {
        const config = this.getConfig();
        config.languageId = modelUpdate.languageId;
        config.code = modelUpdate.code;
        config.codeUri = modelUpdate.codeUri;
        config.codeOriginal = modelUpdate.codeOriginal;
        config.codeOriginalUri = modelUpdate.codeOriginalUri;
    }
    getEditorUri(uriType) {
        const config = this.getConfig();
        const uri = uriType === 'code' ? config.codeUri : config.codeOriginalUri;
        if (uri) {
            return Uri.parse(uri);
        }
        else {
            return Uri.parse(`/workspace/model${uriType === 'codeOriginal' ? 'Original' : ''}${this.id}.${config.languageId}`);
        }
    }
    updateLayout() {
        if (this.getConfig().useDiffEditor) {
            this.diffEditor?.layout();
        }
        else {
            this.editor?.layout();
        }
    }
    async awaitReadiness(awaitExtensionReadiness) {
        if (awaitExtensionReadiness) {
            const allPromises = [];
            for (const awaitReadiness of awaitExtensionReadiness) {
                allPromises.push(awaitReadiness());
            }
            return Promise.all(allPromises);
        }
        return Promise.resolve();
    }
    updateMonacoEditorOptions(options) {
        this.getEditor()?.updateOptions(options);
    }
    async updateUserConfiguration(json) {
        if (json) {
            return vscodeUpdateUserConfiguration(json);
        }
        return Promise.resolve();
    }
}
export const isCodeUpdateRequired = (config, modelUpdate) => {
    const updateRequired = (modelUpdate.code !== undefined && modelUpdate.code !== config.code) || modelUpdate.codeOriginal !== config.codeOriginal;
    return updateRequired ? ModelUpdateType.CODE : ModelUpdateType.NONE;
};
export const isModelUpdateRequired = (config, modelUpdate) => {
    const codeUpdate = isCodeUpdateRequired(config, modelUpdate);
    const propsModelUpdate = ['languageId', 'codeUri', 'codeOriginalUri'];
    const propCompare = (name) => {
        return config[name] !== modelUpdate[name];
    };
    const updateRequired = propsModelUpdate.some(propCompare);
    return updateRequired ? ModelUpdateType.MODEL : codeUpdate;
};
/**
 * The check for equality relies on JSON.stringify for instances of type Object.
 * Everything else is directly compared.
 * In this context, the check for equality is sufficient.
 */
export const isEqual = (obj1, obj2) => {
    if (obj1 instanceof Object && obj2 instanceof Object) {
        return JSON.stringify(obj1) === JSON.stringify(obj2);
    }
    else {
        return obj1 === obj2;
    }
};
//# sourceMappingURL=editorAppBase.js.map