import { editor, languages } from 'monaco-editor';
import { EditorAppBase, ModelUpdateType, isEqual, isModelUpdateRequired } from './editorAppBase.js';
/**
 * The classic monaco-editor app uses the classic monaco-editor configuration.
 */
export class EditorAppClassic extends EditorAppBase {
    config;
    logger;
    constructor(id, userConfig, logger) {
        super(id);
        this.logger = logger;
        const userAppConfig = userConfig.wrapperConfig.editorAppConfig;
        this.config = this.buildConfig(userAppConfig);
        // default to vs-light
        this.config.theme = userAppConfig.theme ?? 'vs-light';
        this.config.languageExtensionConfig = userAppConfig.languageExtensionConfig ?? undefined;
        this.config.languageDef = userAppConfig.languageDef ?? undefined;
        this.config.themeData = userAppConfig.themeData ?? undefined;
    }
    getConfig() {
        return this.config;
    }
    specifyServices() {
        return {};
    }
    async init() {
        // await all extenson that should be ready beforehand
        await this.awaitReadiness(this.config.awaitExtensionReadiness);
        // register own language first
        const extLang = this.config.languageExtensionConfig;
        if (extLang) {
            languages.register(extLang);
        }
        const languageRegistered = languages.getLanguages().filter(x => x.id === this.config.languageId);
        if (languageRegistered.length === 0) {
            // this is only meaningful for languages supported by monaco out of the box
            languages.register({
                id: this.config.languageId
            });
        }
        // apply monarch definitions
        const tokenProvider = this.config.languageDef;
        if (tokenProvider) {
            languages.setMonarchTokensProvider(this.config.languageId, tokenProvider);
        }
        const themeData = this.config.themeData;
        if (themeData) {
            editor.defineTheme(this.config.theme, themeData);
        }
        editor.setTheme(this.config.theme);
        if (this.config.editorOptions?.['semanticHighlighting.enabled'] !== undefined) {
            // use updateConfiguration here as otherwise semantic highlighting will not work
            const json = JSON.stringify({
                'editor.semanticHighlighting.enabled': this.config.editorOptions['semanticHighlighting.enabled']
            });
            await this.updateUserConfiguration(json);
        }
        this.logger?.info('Init of Classic App was completed.');
    }
    disposeApp() {
        this.disposeEditor();
        this.disposeDiffEditor();
    }
    isAppConfigDifferent(orgConfig, config, includeModelData) {
        let different = false;
        if (includeModelData) {
            different = isModelUpdateRequired(orgConfig, config) !== ModelUpdateType.NONE;
        }
        const propsClassic = ['useDiffEditor', 'domReadOnly', 'readOnly', 'awaitExtensionReadiness', 'overrideAutomaticLayout', 'editorOptions', 'diffEditorOptions', 'languageDef', 'languageExtensionConfig', 'theme', 'themeData'];
        const propCompareClassic = (name) => {
            return !isEqual(orgConfig[name], config[name]);
        };
        different = different || propsClassic.some(propCompareClassic);
        return different;
    }
}
//# sourceMappingURL=editorAppClassic.js.map