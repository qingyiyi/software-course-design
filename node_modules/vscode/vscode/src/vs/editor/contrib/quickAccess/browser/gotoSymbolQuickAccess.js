import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { DeferredPromise } from 'monaco-editor/esm/vs/base/common/async.js';
import { CancellationTokenSource } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { pieceToQuery, scoreFuzzy2, prepareQuery } from 'monaco-editor/esm/vs/base/common/fuzzyScorer.js';
import { Disposable, toDisposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { trim, format } from 'monaco-editor/esm/vs/base/common/strings.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { SymbolKinds, getAriaLabelForSymbol } from 'monaco-editor/esm/vs/editor/common/languages.js';
import { IOutlineModelService } from 'monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/outlineModel.js';
import { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { ILanguageFeaturesService } from 'monaco-editor/esm/vs/editor/common/services/languageFeatures.js';
import { findLast } from 'monaco-editor/esm/vs/base/common/arraysFind.js';
var AbstractGotoSymbolQuickAccessProvider_1;
let AbstractGotoSymbolQuickAccessProvider = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {
    static { AbstractGotoSymbolQuickAccessProvider_1 = this; }
    static { this.PREFIX = '@'; }
    static { this.SCOPE_PREFIX = ':'; }
    static { this.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider_1.PREFIX}${AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX}`; }
    constructor(_languageFeaturesService, _outlineModelService, options = Object.create(null)) {
        super(options);
        this._languageFeaturesService = _languageFeaturesService;
        this._outlineModelService = _outlineModelService;
        this.options = options;
        this.options.canAcceptInBackground = true;
    }
    provideWithoutTextEditor(picker) {
        this.provideLabelPick(picker, ( localizeWithPath(
            'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
            'cannotRunGotoSymbolWithoutEditor',
            "To go to a symbol, first open a text editor with symbol information."
        )));
        return Disposable.None;
    }
    provideWithTextEditor(context, picker, token) {
        const editor = context.editor;
        const model = this.getModel(editor);
        if (!model) {
            return Disposable.None;
        }
        if (( this._languageFeaturesService.documentSymbolProvider.has(model))) {
            return this.doProvideWithEditorSymbols(context, model, picker, token);
        }
        return this.doProvideWithoutEditorSymbols(context, model, picker, token);
    }
    doProvideWithoutEditorSymbols(context, model, picker, token) {
        const disposables = ( new DisposableStore());
        this.provideLabelPick(picker, ( localizeWithPath(
            'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
            'cannotRunGotoSymbolWithoutSymbolProvider',
            "The active text editor does not provide symbol information."
        )));
        (async () => {
            const result = await this.waitForLanguageSymbolRegistry(model, disposables);
            if (!result || token.isCancellationRequested) {
                return;
            }
            disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));
        })();
        return disposables;
    }
    provideLabelPick(picker, label) {
        picker.items = [{ label, index: 0, kind: 14  }];
        picker.ariaLabel = label;
    }
    async waitForLanguageSymbolRegistry(model, disposables) {
        if (( this._languageFeaturesService.documentSymbolProvider.has(model))) {
            return true;
        }
        const symbolProviderRegistryPromise = ( new DeferredPromise());
        const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {
            if (( this._languageFeaturesService.documentSymbolProvider.has(model))) {
                symbolProviderListener.dispose();
                symbolProviderRegistryPromise.complete(true);
            }
        }));
        disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));
        return symbolProviderRegistryPromise.p;
    }
    doProvideWithEditorSymbols(context, model, picker, token) {
        const editor = context.editor;
        const disposables = ( new DisposableStore());
        disposables.add(picker.onDidAccept(event => {
            const [item] = picker.selectedItems;
            if (item && item.range) {
                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });
                if (!event.inBackground) {
                    picker.hide();
                }
            }
        }));
        disposables.add(picker.onDidTriggerItemButton(({ item }) => {
            if (item && item.range) {
                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });
                picker.hide();
            }
        }));
        const symbolsPromise = this.getDocumentSymbols(model, token);
        let picksCts = undefined;
        const updatePickerItems = async (positionToEnclose) => {
            picksCts?.dispose(true);
            picker.busy = false;
            picksCts = ( new CancellationTokenSource(token));
            picker.busy = true;
            try {
                const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider_1.PREFIX.length).trim());
                const items = await this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token);
                if (token.isCancellationRequested) {
                    return;
                }
                if (items.length > 0) {
                    picker.items = items;
                    if (positionToEnclose && query.original.length === 0) {
                        const candidate = findLast(items, item => Boolean(item.type !== 'separator' && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));
                        if (candidate) {
                            picker.activeItems = [candidate];
                        }
                    }
                }
                else {
                    if (query.original.length > 0) {
                        this.provideLabelPick(picker, ( localizeWithPath(
                            'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
                            'noMatchingSymbolResults',
                            "No matching editor symbols"
                        )));
                    }
                    else {
                        this.provideLabelPick(picker, ( localizeWithPath(
                            'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
                            'noSymbolResults',
                            "No editor symbols"
                        )));
                    }
                }
            }
            finally {
                if (!token.isCancellationRequested) {
                    picker.busy = false;
                }
            }
        };
        disposables.add(picker.onDidChangeValue(() => updatePickerItems(undefined)));
        updatePickerItems(editor.getSelection()?.getPosition());
        disposables.add(picker.onDidChangeActive(() => {
            const [item] = picker.activeItems;
            if (item && item.range) {
                editor.revealRangeInCenter(item.range.selection, 0 );
                this.addDecorations(editor, item.range.decoration);
            }
        }));
        return disposables;
    }
    async doGetSymbolPicks(symbolsPromise, query, options, token) {
        const symbols = await symbolsPromise;
        if (token.isCancellationRequested) {
            return [];
        }
        const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX) === 0;
        const filterPos = filterBySymbolKind ? 1 : 0;
        let symbolQuery;
        let containerQuery;
        if (query.values && query.values.length > 1) {
            symbolQuery = pieceToQuery(query.values[0]);
            containerQuery = pieceToQuery(query.values.slice(1));
        }
        else {
            symbolQuery = query;
        }
        let buttons;
        const openSideBySideDirection = this.options?.openSideBySideDirection?.();
        if (openSideBySideDirection) {
            buttons = [{
                    iconClass: openSideBySideDirection === 'right' ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),
                    tooltip: openSideBySideDirection === 'right' ? ( localizeWithPath(
                        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
                        'openToSide',
                        "Open to the Side"
                    )) : ( localizeWithPath(
                        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
                        'openToBottom',
                        "Open to the Bottom"
                    ))
                }];
        }
        const filteredSymbolPicks = [];
        for (let index = 0; index < symbols.length; index++) {
            const symbol = symbols[index];
            const symbolLabel = trim(symbol.name);
            const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;
            const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;
            let containerLabel = symbol.containerName;
            if (options?.extraContainerLabel) {
                if (containerLabel) {
                    containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;
                }
                else {
                    containerLabel = options.extraContainerLabel;
                }
            }
            let symbolScore = undefined;
            let symbolMatches = undefined;
            let containerScore = undefined;
            let containerMatches = undefined;
            if (query.original.length > filterPos) {
                let skipContainerQuery = false;
                if (symbolQuery !== query) {
                    [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, { ...query, values: undefined  }, filterPos, symbolLabelIconOffset);
                    if (typeof symbolScore === 'number') {
                        skipContainerQuery = true;
                    }
                }
                if (typeof symbolScore !== 'number') {
                    [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);
                    if (typeof symbolScore !== 'number') {
                        continue;
                    }
                }
                if (!skipContainerQuery && containerQuery) {
                    if (containerLabel && containerQuery.original.length > 0) {
                        [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);
                    }
                    if (typeof containerScore !== 'number') {
                        continue;
                    }
                    if (typeof symbolScore === 'number') {
                        symbolScore += containerScore;
                    }
                }
            }
            const deprecated = symbol.tags && symbol.tags.indexOf(1 ) >= 0;
            filteredSymbolPicks.push({
                index,
                kind: symbol.kind,
                score: symbolScore,
                label: symbolLabelWithIcon,
                ariaLabel: getAriaLabelForSymbol(symbol.name, symbol.kind),
                description: containerLabel,
                highlights: deprecated ? undefined : {
                    label: symbolMatches,
                    description: containerMatches
                },
                range: {
                    selection: Range.collapseToStart(symbol.selectionRange),
                    decoration: symbol.range
                },
                strikethrough: deprecated,
                buttons
            });
        }
        const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ?
            this.compareByKindAndScore(symbolA, symbolB) :
            this.compareByScore(symbolA, symbolB));
        let symbolPicks = [];
        if (filterBySymbolKind) {
            let lastSymbolKind = undefined;
            let lastSeparator = undefined;
            let lastSymbolKindCounter = 0;
            function updateLastSeparatorLabel() {
                if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {
                    lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);
                }
            }
            for (const symbolPick of sortedFilteredSymbolPicks) {
                if (lastSymbolKind !== symbolPick.kind) {
                    updateLastSeparatorLabel();
                    lastSymbolKind = symbolPick.kind;
                    lastSymbolKindCounter = 1;
                    lastSeparator = { type: 'separator' };
                    symbolPicks.push(lastSeparator);
                }
                else {
                    lastSymbolKindCounter++;
                }
                symbolPicks.push(symbolPick);
            }
            updateLastSeparatorLabel();
        }
        else if (sortedFilteredSymbolPicks.length > 0) {
            symbolPicks = [
                { label: ( localizeWithPath(
                    'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
                    'symbols',
                    "symbols ({0})",
                    filteredSymbolPicks.length
                )), type: 'separator' },
                ...sortedFilteredSymbolPicks
            ];
        }
        return symbolPicks;
    }
    compareByScore(symbolA, symbolB) {
        if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {
            return 1;
        }
        else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {
            return -1;
        }
        if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {
            if (symbolA.score > symbolB.score) {
                return -1;
            }
            else if (symbolA.score < symbolB.score) {
                return 1;
            }
        }
        if (symbolA.index < symbolB.index) {
            return -1;
        }
        else if (symbolA.index > symbolB.index) {
            return 1;
        }
        return 0;
    }
    compareByKindAndScore(symbolA, symbolB) {
        const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;
        const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;
        const result = kindA.localeCompare(kindB);
        if (result === 0) {
            return this.compareByScore(symbolA, symbolB);
        }
        return result;
    }
    async getDocumentSymbols(document, token) {
        const model = await this._outlineModelService.getOrCreate(document, token);
        return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();
    }
};
AbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = ( __decorate([
    ( __param(0, ILanguageFeaturesService)),
    ( __param(1, IOutlineModelService))
], AbstractGotoSymbolQuickAccessProvider));
const FALLBACK_NLS_SYMBOL_KIND = ( localizeWithPath(
    'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
    'property',
    "properties ({0})"
));
const NLS_SYMBOL_KIND_CACHE = {
    [5 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'method',
        "methods ({0})"
    )),
    [11 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'function',
        "functions ({0})"
    )),
    [8 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        '_constructor',
        "constructors ({0})"
    )),
    [12 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'variable',
        "variables ({0})"
    )),
    [4 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'class',
        "classes ({0})"
    )),
    [22 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'struct',
        "structs ({0})"
    )),
    [23 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'event',
        "events ({0})"
    )),
    [24 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'operator',
        "operators ({0})"
    )),
    [10 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'interface',
        "interfaces ({0})"
    )),
    [2 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'namespace',
        "namespaces ({0})"
    )),
    [3 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'package',
        "packages ({0})"
    )),
    [25 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'typeParameter',
        "type parameters ({0})"
    )),
    [1 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'modules',
        "modules ({0})"
    )),
    [6 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'property',
        "properties ({0})"
    )),
    [9 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'enum',
        "enumerations ({0})"
    )),
    [21 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'enumMember',
        "enumeration members ({0})"
    )),
    [14 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'string',
        "strings ({0})"
    )),
    [0 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'file',
        "files ({0})"
    )),
    [17 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'array',
        "arrays ({0})"
    )),
    [15 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'number',
        "numbers ({0})"
    )),
    [16 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'boolean',
        "booleans ({0})"
    )),
    [18 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'object',
        "objects ({0})"
    )),
    [19 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'key',
        "keys ({0})"
    )),
    [7 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'field',
        "fields ({0})"
    )),
    [13 ]: ( localizeWithPath(
        'vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess',
        'constant',
        "constants ({0})"
    ))
};
export { AbstractGotoSymbolQuickAccessProvider };
