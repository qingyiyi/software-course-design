import { LineRange } from '../core/lineRange.js';
import { Range } from '../core/range.js';

/**
 * Maps a line range in the original text model to a line range in the modified text model.
 */
declare class LineRangeMapping {
    static inverse(mapping: readonly DetailedLineRangeMapping[], originalLineCount: number, modifiedLineCount: number): DetailedLineRangeMapping[];
    /**
     * The line range in the original text model.
     */
    readonly original: LineRange;
    /**
     * The line range in the modified text model.
     */
    readonly modified: LineRange;
    constructor(originalRange: LineRange, modifiedRange: LineRange);
    toString(): string;
    flip(): LineRangeMapping;
    join(other: LineRangeMapping): LineRangeMapping;
    get changedLineCount(): number;
}
/**
 * Maps a line range in the original text model to a line range in the modified text model.
 * Also contains inner range mappings.
 */
declare class DetailedLineRangeMapping extends LineRangeMapping {
    /**
     * If inner changes have not been computed, this is set to undefined.
     * Otherwise, it represents the character-level diff in this line range.
     * The original range of each range mapping should be contained in the original line range (same for modified), exceptions are new-lines.
     * Must not be an empty array.
     */
    readonly innerChanges: RangeMapping[] | undefined;
    constructor(originalRange: LineRange, modifiedRange: LineRange, innerChanges: RangeMapping[] | undefined);
    flip(): DetailedLineRangeMapping;
}
/**
 * Maps a range in the original text model to a range in the modified text model.
 */
declare class RangeMapping {
    /**
     * The original range.
     */
    readonly originalRange: Range;
    /**
     * The modified range.
     */
    readonly modifiedRange: Range;
    constructor(originalRange: Range, modifiedRange: Range);
    toString(): string;
    flip(): RangeMapping;
}

export { DetailedLineRangeMapping, LineRangeMapping, RangeMapping };
