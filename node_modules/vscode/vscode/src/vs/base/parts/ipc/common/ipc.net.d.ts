import { VSBuffer } from '../../../common/buffer.js';
import { IDisposable } from '../../../common/lifecycle.js';

declare const enum SocketDiagnosticsEventType {
    Created = "created",
    Read = "read",
    Write = "write",
    Open = "open",
    Error = "error",
    Close = "close",
    BrowserWebSocketBlobReceived = "browserWebSocketBlobReceived",
    NodeEndReceived = "nodeEndReceived",
    NodeEndSent = "nodeEndSent",
    NodeDrainBegin = "nodeDrainBegin",
    NodeDrainEnd = "nodeDrainEnd",
    zlibInflateError = "zlibInflateError",
    zlibInflateData = "zlibInflateData",
    zlibInflateInitialWrite = "zlibInflateInitialWrite",
    zlibInflateInitialFlushFired = "zlibInflateInitialFlushFired",
    zlibInflateWrite = "zlibInflateWrite",
    zlibInflateFlushFired = "zlibInflateFlushFired",
    zlibDeflateError = "zlibDeflateError",
    zlibDeflateData = "zlibDeflateData",
    zlibDeflateWrite = "zlibDeflateWrite",
    zlibDeflateFlushFired = "zlibDeflateFlushFired",
    WebSocketNodeSocketWrite = "webSocketNodeSocketWrite",
    WebSocketNodeSocketPeekedHeader = "webSocketNodeSocketPeekedHeader",
    WebSocketNodeSocketReadHeader = "webSocketNodeSocketReadHeader",
    WebSocketNodeSocketReadData = "webSocketNodeSocketReadData",
    WebSocketNodeSocketUnmaskedData = "webSocketNodeSocketUnmaskedData",
    WebSocketNodeSocketDrainBegin = "webSocketNodeSocketDrainBegin",
    WebSocketNodeSocketDrainEnd = "webSocketNodeSocketDrainEnd",
    ProtocolHeaderRead = "protocolHeaderRead",
    ProtocolMessageRead = "protocolMessageRead",
    ProtocolHeaderWrite = "protocolHeaderWrite",
    ProtocolMessageWrite = "protocolMessageWrite",
    ProtocolWrite = "protocolWrite"
}
declare const enum SocketCloseEventType {
    NodeSocketCloseEvent = 0,
    WebSocketCloseEvent = 1
}
interface NodeSocketCloseEvent {
    /**
     * The type of the event
     */
    readonly type: SocketCloseEventType.NodeSocketCloseEvent;
    /**
     * `true` if the socket had a transmission error.
     */
    readonly hadError: boolean;
    /**
     * Underlying error.
     */
    readonly error: Error | undefined;
}
interface WebSocketCloseEvent {
    /**
     * The type of the event
     */
    readonly type: SocketCloseEventType.WebSocketCloseEvent;
    /**
     * Returns the WebSocket connection close code provided by the server.
     */
    readonly code: number;
    /**
     * Returns the WebSocket connection close reason provided by the server.
     */
    readonly reason: string;
    /**
     * Returns true if the connection closed cleanly; false otherwise.
     */
    readonly wasClean: boolean;
    /**
     * Underlying event.
     */
    readonly event: any | undefined;
}
type SocketCloseEvent = NodeSocketCloseEvent | WebSocketCloseEvent | undefined;
interface ISocket extends IDisposable {
    onData(listener: (e: VSBuffer) => void): IDisposable;
    onClose(listener: (e: SocketCloseEvent) => void): IDisposable;
    onEnd(listener: () => void): IDisposable;
    write(buffer: VSBuffer): void;
    end(): void;
    drain(): Promise<void>;
    traceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any): void;
}

export { type ISocket, type NodeSocketCloseEvent, type SocketCloseEvent, SocketCloseEventType, SocketDiagnosticsEventType, type WebSocketCloseEvent };
