import { IProcessEnvironment } from '../../../base/common/platform.js';
import { IWorkspaceFolderData } from '../../workspace/common/workspace.js';

declare enum EnvironmentVariableMutatorType {
    Replace = 1,
    Append = 2,
    Prepend = 3
}
interface IEnvironmentVariableMutator {
    readonly variable: string;
    readonly value: string;
    readonly type: EnvironmentVariableMutatorType;
    readonly scope?: EnvironmentVariableScope;
    readonly options?: IEnvironmentVariableMutatorOptions;
}
interface IEnvironmentVariableCollectionDescription {
    readonly description: string | undefined;
    readonly scope?: EnvironmentVariableScope;
}
interface IEnvironmentVariableMutatorOptions {
    applyAtProcessCreation?: boolean;
    applyAtShellIntegration?: boolean;
}
type EnvironmentVariableScope = {
    workspaceFolder?: IWorkspaceFolderData;
};
interface IEnvironmentVariableCollection {
    readonly map: ReadonlyMap<string, IEnvironmentVariableMutator>;
    readonly descriptionMap?: ReadonlyMap<string, IEnvironmentVariableCollectionDescription>;
}
/** [variable, mutator] */
type ISerializableEnvironmentVariableCollection = [string, IEnvironmentVariableMutator][];
type ISerializableEnvironmentDescriptionMap = [string, IEnvironmentVariableCollectionDescription][];
/** [extension, collection, description] */
type ISerializableEnvironmentVariableCollections = [string, ISerializableEnvironmentVariableCollection, ISerializableEnvironmentDescriptionMap][];
interface IExtensionOwnedEnvironmentVariableMutator extends IEnvironmentVariableMutator {
    readonly extensionIdentifier: string;
}
interface IMergedEnvironmentVariableCollectionDiff {
    added: ReadonlyMap<string, IExtensionOwnedEnvironmentVariableMutator[]>;
    changed: ReadonlyMap<string, IExtensionOwnedEnvironmentVariableMutator[]>;
    removed: ReadonlyMap<string, IExtensionOwnedEnvironmentVariableMutator[]>;
}
type VariableResolver = (str: string) => Promise<string>;
/**
 * Represents an environment variable collection that results from merging several collections
 * together.
 */
interface IMergedEnvironmentVariableCollection {
    readonly collections: ReadonlyMap<string, IEnvironmentVariableCollection>;
    /**
     * Gets the variable map for a given scope.
     * @param scope The scope to get the variable map for. If undefined, the global scope is used.
     */
    getVariableMap(scope: EnvironmentVariableScope | undefined): Map<string, IExtensionOwnedEnvironmentVariableMutator[]>;
    /**
     * Gets the description map for a given scope.
     * @param scope The scope to get the description map for. If undefined, description map for the
     * global scope is returned.
     */
    getDescriptionMap(scope: EnvironmentVariableScope | undefined): Map<string, string | undefined>;
    /**
     * Applies this collection to a process environment.
     * @param variableResolver An optional function to use to resolve variables within the
     * environment values.
     */
    applyToProcessEnvironment(env: IProcessEnvironment, scope: EnvironmentVariableScope | undefined, variableResolver?: VariableResolver): Promise<void>;
    /**
     * Generates a diff of this collection against another. Returns undefined if the collections are
     * the same.
     */
    diff(other: IMergedEnvironmentVariableCollection, scope: EnvironmentVariableScope | undefined): IMergedEnvironmentVariableCollectionDiff | undefined;
}

export { EnvironmentVariableMutatorType, type EnvironmentVariableScope, type IEnvironmentVariableCollection, type IEnvironmentVariableCollectionDescription, type IEnvironmentVariableMutator, type IEnvironmentVariableMutatorOptions, type IExtensionOwnedEnvironmentVariableMutator, type IMergedEnvironmentVariableCollection, type IMergedEnvironmentVariableCollectionDiff, type ISerializableEnvironmentDescriptionMap, type ISerializableEnvironmentVariableCollection, type ISerializableEnvironmentVariableCollections };
