import { streamToBuffer } from 'monaco-editor/esm/vs/base/common/buffer.js';
import { getErrorMessage } from 'monaco-editor/esm/vs/base/common/errors.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { CONTEXT_LOG_LEVEL, LogLevelToString, LogLevel } from 'monaco-editor/esm/vs/platform/log/common/log.js';
const IRequestService = ( createDecorator('requestService'));
class LoggableHeaders {
    constructor(original) {
        this.original = original;
    }
    toJSON() {
        if (!this.headers) {
            const headers = Object.create(null);
            for (const key in this.original) {
                if (key.toLowerCase() === 'authorization' || key.toLowerCase() === 'proxy-authorization') {
                    headers[key] = '*****';
                }
                else {
                    headers[key] = this.original[key];
                }
            }
            this.headers = headers;
        }
        return this.headers;
    }
}
class AbstractRequestService extends Disposable {
    constructor(loggerService) {
        super();
        this.counter = 0;
        this.logger = loggerService.createLogger('network', {
            name: ( localizeWithPath('vs/platform/request/common/request', 'request', "Network Requests")),
            when: ( CONTEXT_LOG_LEVEL.isEqualTo(LogLevelToString(LogLevel.Trace))).serialize()
        });
    }
    async logAndRequest(stack, options, request) {
        const prefix = `${stack} #${++this.counter}: ${options.url}`;
        this.logger.trace(`${prefix} - begin`, options.type, ( new LoggableHeaders(options.headers ?? {})));
        try {
            const result = await request();
            this.logger.trace(`${prefix} - end`, options.type, result.res.statusCode, result.res.headers);
            return result;
        }
        catch (error) {
            this.logger.error(`${prefix} - error`, options.type, getErrorMessage(error));
            throw error;
        }
    }
}
function isSuccess(context) {
    return (context.res.statusCode && context.res.statusCode >= 200 && context.res.statusCode < 300) || context.res.statusCode === 1223;
}
function hasNoContent(context) {
    return context.res.statusCode === 204;
}
async function asText(context) {
    if (hasNoContent(context)) {
        return null;
    }
    const buffer = await streamToBuffer(context.stream);
    return ( buffer.toString());
}
async function asTextOrError(context) {
    if (!isSuccess(context)) {
        throw new Error('Server returned ' + context.res.statusCode);
    }
    return asText(context);
}
async function asJson(context) {
    if (!isSuccess(context)) {
        throw new Error('Server returned ' + context.res.statusCode);
    }
    if (hasNoContent(context)) {
        return null;
    }
    const buffer = await streamToBuffer(context.stream);
    const str = ( buffer.toString());
    try {
        return JSON.parse(str);
    }
    catch (err) {
        err.message += ':\n' + str;
        throw err;
    }
}
export { AbstractRequestService, IRequestService, asJson, asText, asTextOrError, hasNoContent, isSuccess };
