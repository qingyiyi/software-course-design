import { ServiceIdentifier } from '../../instantiation/common/instantiation.js';
import { CancellationToken } from '../../../base/common/cancellation.js';
import { Event } from '../../../base/common/event.js';
import { IDisposable } from '../../../base/common/lifecycle.js';
import { URI } from '../../../base/common/uri.js';
import { IAddressProvider } from '../../remote/common/remoteAgentConnection.js';
import { TunnelPrivacy } from '../../remote/common/remoteAuthorityResolver.js';

interface RemoteTunnel {
    readonly tunnelRemotePort: number;
    readonly tunnelRemoteHost: string;
    readonly tunnelLocalPort?: number;
    readonly localAddress: string;
    readonly privacy: string;
    readonly protocol?: string;
    dispose(silent?: boolean): Promise<void>;
}
interface TunnelOptions {
    remoteAddress: {
        port: number;
        host: string;
    };
    localAddressPort?: number;
    label?: string;
    public?: boolean;
    privacy?: string;
    protocol?: string;
}
declare enum TunnelProtocol {
    Http = "http",
    Https = "https"
}
declare enum TunnelPrivacyId {
    ConstantPrivate = "constantPrivate",// private, and changing is unsupported
    Private = "private",
    Public = "public"
}
interface TunnelCreationOptions {
    elevationRequired?: boolean;
}
interface TunnelProviderFeatures {
    elevation: boolean;
    /**
     * @deprecated
     */
    public?: boolean;
    privacyOptions: TunnelPrivacy[];
}
interface ITunnelProvider {
    forwardPort(tunnelOptions: TunnelOptions, tunnelCreationOptions: TunnelCreationOptions): Promise<RemoteTunnel | string | undefined> | undefined;
}
declare enum ProvidedOnAutoForward {
    Notify = 1,
    OpenBrowser = 2,
    OpenPreview = 3,
    Silent = 4,
    Ignore = 5,
    OpenBrowserOnce = 6
}
interface ProvidedPortAttributes {
    port: number;
    autoForwardAction: ProvidedOnAutoForward;
}
interface PortAttributesProvider {
    providePortAttributes(ports: number[], pid: number | undefined, commandLine: string | undefined, token: CancellationToken): Promise<ProvidedPortAttributes[]>;
}

declare const ITunnelService: ServiceIdentifier<ITunnelService>;
interface ITunnelService {
    readonly _serviceBrand: undefined;
    readonly tunnels: Promise<readonly RemoteTunnel[]>;
    readonly canChangePrivacy: boolean;
    readonly privacyOptions: TunnelPrivacy[];
    readonly onTunnelOpened: Event<RemoteTunnel>;
    readonly onTunnelClosed: Event<{
        host: string;
        port: number;
    }>;
    readonly canElevate: boolean;
    readonly hasTunnelProvider: boolean;
    readonly onAddedTunnelProvider: Event<void>;
    canTunnel(uri: URI): boolean;
    openTunnel(addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost?: string, localPort?: number, elevateIfNeeded?: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined;
    getExistingTunnel(remoteHost: string, remotePort: number): Promise<RemoteTunnel | string | undefined>;
    setEnvironmentTunnel(remoteHost: string, remotePort: number, localAddress: string, privacy: string, protocol: string): void;
    closeTunnel(remoteHost: string, remotePort: number): Promise<void>;
    setTunnelProvider(provider: ITunnelProvider | undefined): IDisposable;
    setTunnelFeatures(features: TunnelProviderFeatures): void;
    isPortPrivileged(port: number): boolean;
}

export { type ITunnelProvider, ITunnelService, type PortAttributesProvider, ProvidedOnAutoForward, type ProvidedPortAttributes, type RemoteTunnel, type TunnelCreationOptions, type TunnelOptions, TunnelPrivacyId, TunnelProtocol, type TunnelProviderFeatures };
