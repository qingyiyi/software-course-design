import { toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { MainContext } from './extHost.protocol.js';
import { ChatMessageRole } from './extHostTypes.js';
import { ChatMessage, ChatFollowup } from './extHostTypeConverters.js';
import { Progress } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { raceCancellation, DeferredPromise } from 'monaco-editor/esm/vs/base/common/async.js';
class ExtHostChatSlashCommands {
    static { this._idPool = 0; }
    constructor(mainContext, _extHostChatProvider, _logService) {
        this._extHostChatProvider = _extHostChatProvider;
        this._logService = _logService;
        this._commands = ( new Map());
        this._proxy = ( mainContext.getProxy(MainContext.MainThreadChatSlashCommands));
    }
    registerCommand(extension, name, command, metadata) {
        const handle = ExtHostChatSlashCommands._idPool++;
        this._commands.set(handle, { extension, command });
        this._proxy.$registerCommand(handle, name, metadata.description);
        return toDisposable(() => {
            this._proxy.$unregisterCommand(handle);
            this._commands.delete(handle);
        });
    }
    async $executeCommand(handle, requestId, prompt, context, token) {
        const data = this._commands.get(handle);
        if (!data) {
            this._logService.warn(`[CHAT](${handle}) CANNOT execute command because the command is not registered`);
            return;
        }
        let done = false;
        function throwIfDone() {
            if (done) {
                throw new Error('Only valid while executing the command');
            }
        }
        const commandExecution = ( new DeferredPromise());
        token.onCancellationRequested(() => commandExecution.complete());
        setTimeout(() => commandExecution.complete(), 10 * 1000);
        this._extHostChatProvider.allowListExtensionWhile(data.extension, commandExecution.p);
        const task = data.command({ role: ChatMessageRole.User, content: prompt }, { history: ( context.history.map(ChatMessage.to)) }, ( new Progress(p => {
            throwIfDone();
            this._proxy.$handleProgressChunk(requestId, { content: isInteractiveProgressFileTree(p.message) ? p.message : p.message.value });
        })), token);
        try {
            return await raceCancellation(Promise.resolve(task).then((v) => {
                if (v && 'followUp' in v) {
                    const convertedFollowup = v?.followUp?.map(f => ChatFollowup.from(f));
                    return { followUp: convertedFollowup };
                }
                return undefined;
            }), token);
        }
        finally {
            done = true;
            commandExecution.complete();
        }
    }
}
function isInteractiveProgressFileTree(thing) {
    return !!thing && typeof thing === 'object' && 'treeData' in thing;
}
export { ExtHostChatSlashCommands };
