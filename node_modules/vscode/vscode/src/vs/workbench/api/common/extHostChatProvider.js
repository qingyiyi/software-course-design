import { toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { MainContext } from './extHost.protocol.js';
import { ChatMessage } from './extHostTypeConverters.js';
import { Progress } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { ExtensionIdentifierMap } from 'monaco-editor/esm/vs/platform/extensions/common/extensions.js';
class ExtHostChatProvider {
    static { this._idPool = 1; }
    constructor(mainContext, _logService) {
        this._logService = _logService;
        this._providers = ( new Map());
        this._pendingRequest = ( new Map());
        this._chatAccessAllowList = ( new ExtensionIdentifierMap());
        this._proxy = ( mainContext.getProxy(MainContext.MainThreadChatProvider));
    }
    registerProvider(extension, identifier, provider, metadata) {
        const handle = ExtHostChatProvider._idPool++;
        this._providers.set(handle, { extension, provider });
        this._proxy.$registerProvider(handle, identifier, { extension, displayName: metadata.name ?? extension.value });
        return toDisposable(() => {
            this._proxy.$unregisterProvider(handle);
            this._providers.delete(handle);
        });
    }
    async $provideChatResponse(handle, requestId, messages, options, token) {
        const data = this._providers.get(handle);
        if (!data) {
            return;
        }
        const progress = ( new Progress(async (fragment) => {
            if (token.isCancellationRequested) {
                this._logService.warn(`[CHAT](${data.extension.value}) CANNOT send progress because the REQUEST IS CANCELLED`);
                return;
            }
            await this._proxy.$handleProgressChunk(requestId, { index: fragment.index, part: fragment.part });
        }, { async: true }));
        return data.provider.provideChatResponse(( messages.map(ChatMessage.to)), options, progress, token);
    }
    allowListExtensionWhile(extension, promise) {
        this._chatAccessAllowList.set(extension, promise);
        promise.finally(() => this._chatAccessAllowList.delete(extension));
    }
    async requestChatResponseProvider(from, identifier) {
        if (!( this._chatAccessAllowList.has(from))) {
            throw new Error('Extension is NOT allowed to make chat requests');
        }
        const that = this;
        return {
            get isRevoked() {
                return !( that._chatAccessAllowList.has(from));
            },
            async makeRequest(messages, options, progress, token) {
                if (!( that._chatAccessAllowList.has(from))) {
                    throw new Error('Access to chat has been revoked');
                }
                const requestId = (Math.random() * 1e6) | 0;
                that._pendingRequest.set(requestId, progress);
                try {
                    await that._proxy.$fetchResponse(from, identifier, requestId, ( messages.map(ChatMessage.from)), options, token);
                }
                finally {
                    that._pendingRequest.delete(requestId);
                }
            },
        };
    }
    async $handleResponseFragment(requestId, chunk) {
        this._pendingRequest.get(requestId)?.report(chunk);
    }
}
export { ExtHostChatProvider };
