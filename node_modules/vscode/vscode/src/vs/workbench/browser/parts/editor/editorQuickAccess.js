import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import './media/editorquickaccess.css.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { quickPickItemScorerAccessor } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { PickerQuickAccessProvider, TriggerAction } from '../../../../platform/quickinput/browser/pickerQuickAccess.js';
import { IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.js';
import { EditorResourceAccessor, SideBySideEditor } from '../../../common/editor.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { getIconClasses } from 'monaco-editor/esm/vs/editor/common/services/getIconClasses.js';
import { prepareQuery, scoreItemFuzzy, compareItemsByFuzzyScore } from 'monaco-editor/esm/vs/base/common/fuzzyScorer.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
var ActiveGroupEditorsByMostRecentlyUsedQuickAccess_1, AllEditorsByAppearanceQuickAccess_1, AllEditorsByMostRecentlyUsedQuickAccess_1;
let BaseEditorQuickAccessProvider = class BaseEditorQuickAccessProvider extends PickerQuickAccessProvider {
    constructor(prefix, editorGroupService, editorService, modelService, languageService) {
        super(prefix, {
            canAcceptInBackground: true,
            noResultsPick: {
                label: ( localizeWithPath(
                    'vs/workbench/browser/parts/editor/editorQuickAccess',
                    'noViewResults',
                    "No matching editors"
                )),
                groupId: -1
            }
        });
        this.editorGroupService = editorGroupService;
        this.editorService = editorService;
        this.modelService = modelService;
        this.languageService = languageService;
        this.pickState = new (class {
            constructor() {
                this.scorerCache = Object.create(null);
                this.isQuickNavigating = undefined;
            }
            reset(isQuickNavigating) {
                if (!isQuickNavigating) {
                    this.scorerCache = Object.create(null);
                }
                this.isQuickNavigating = isQuickNavigating;
            }
        });
    }
    provide(picker, token) {
        this.pickState.reset(!!picker.quickNavigate);
        return super.provide(picker, token);
    }
    _getPicks(filter) {
        const query = prepareQuery(filter);
        const filteredEditorEntries = this.doGetEditorPickItems().filter(entry => {
            if (!query.normalized) {
                return true;
            }
            const itemScore = scoreItemFuzzy(entry, query, true, quickPickItemScorerAccessor, this.pickState.scorerCache);
            if (!itemScore.score) {
                return false;
            }
            entry.highlights = { label: itemScore.labelMatch, description: itemScore.descriptionMatch };
            return true;
        });
        if (query.normalized) {
            const groups = ( this.editorGroupService.getGroups(2 ).map(group => group.id));
            filteredEditorEntries.sort((entryA, entryB) => {
                if (entryA.groupId !== entryB.groupId) {
                    return groups.indexOf(entryA.groupId) - groups.indexOf(entryB.groupId);
                }
                return compareItemsByFuzzyScore(entryA, entryB, query, true, quickPickItemScorerAccessor, this.pickState.scorerCache);
            });
        }
        const filteredEditorEntriesWithSeparators = [];
        if (this.editorGroupService.count > 1) {
            let lastGroupId = undefined;
            for (const entry of filteredEditorEntries) {
                if (typeof lastGroupId !== 'number' || lastGroupId !== entry.groupId) {
                    const group = this.editorGroupService.getGroup(entry.groupId);
                    if (group) {
                        filteredEditorEntriesWithSeparators.push({ type: 'separator', label: group.label });
                    }
                    lastGroupId = entry.groupId;
                }
                filteredEditorEntriesWithSeparators.push(entry);
            }
        }
        else {
            filteredEditorEntriesWithSeparators.push(...filteredEditorEntries);
        }
        return filteredEditorEntriesWithSeparators;
    }
    doGetEditorPickItems() {
        const editors = this.doGetEditors();
        const mapGroupIdToGroupAriaLabel = ( new Map());
        for (const { groupId } of editors) {
            if (!( mapGroupIdToGroupAriaLabel.has(groupId))) {
                const group = this.editorGroupService.getGroup(groupId);
                if (group) {
                    mapGroupIdToGroupAriaLabel.set(groupId, group.ariaLabel);
                }
            }
        }
        return ( this.doGetEditors().map(({ editor, groupId }) => {
            const resource = EditorResourceAccessor.getOriginalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY });
            const isDirty = editor.isDirty() && !editor.isSaving();
            const description = editor.getDescription();
            const nameAndDescription = description ? `${editor.getName()} ${description}` : editor.getName();
            return {
                groupId,
                resource,
                label: editor.getName(),
                ariaLabel: (() => {
                    if (mapGroupIdToGroupAriaLabel.size > 1) {
                        return isDirty ?
                            ( localizeWithPath(
                                'vs/workbench/browser/parts/editor/editorQuickAccess',
                                'entryAriaLabelWithGroupDirty',
                                "{0}, unsaved changes, {1}",
                                nameAndDescription,
                                mapGroupIdToGroupAriaLabel.get(groupId)
                            )) :
                            ( localizeWithPath(
                                'vs/workbench/browser/parts/editor/editorQuickAccess',
                                'entryAriaLabelWithGroup',
                                "{0}, {1}",
                                nameAndDescription,
                                mapGroupIdToGroupAriaLabel.get(groupId)
                            ));
                    }
                    return isDirty ? ( localizeWithPath(
                        'vs/workbench/browser/parts/editor/editorQuickAccess',
                        'entryAriaLabelDirty',
                        "{0}, unsaved changes",
                        nameAndDescription
                    )) : nameAndDescription;
                })(),
                description,
                iconClasses: getIconClasses(this.modelService, this.languageService, resource).concat(editor.getLabelExtraClasses()),
                italic: !this.editorGroupService.getGroup(groupId)?.isPinned(editor),
                buttons: (() => {
                    return [
                        {
                            iconClass: isDirty ? ('dirty-editor ' + ThemeIcon.asClassName(Codicon.closeDirty)) : ThemeIcon.asClassName(Codicon.close),
                            tooltip: ( localizeWithPath(
                                'vs/workbench/browser/parts/editor/editorQuickAccess',
                                'closeEditor',
                                "Close Editor"
                            )),
                            alwaysVisible: isDirty
                        }
                    ];
                })(),
                trigger: async () => {
                    const group = this.editorGroupService.getGroup(groupId);
                    if (group) {
                        await group.closeEditor(editor, { preserveFocus: true });
                        if (!group.contains(editor)) {
                            return TriggerAction.REMOVE_ITEM;
                        }
                    }
                    return TriggerAction.NO_ACTION;
                },
                accept: (keyMods, event) => this.editorGroupService.getGroup(groupId)?.openEditor(editor, { preserveFocus: event.inBackground }),
            };
        }));
    }
};
BaseEditorQuickAccessProvider = ( __decorate([
    ( __param(1, IEditorGroupsService)),
    ( __param(2, IEditorService)),
    ( __param(3, IModelService)),
    ( __param(4, ILanguageService))
], BaseEditorQuickAccessProvider));
let ActiveGroupEditorsByMostRecentlyUsedQuickAccess = class ActiveGroupEditorsByMostRecentlyUsedQuickAccess extends BaseEditorQuickAccessProvider {
    static { ActiveGroupEditorsByMostRecentlyUsedQuickAccess_1 = this; }
    static { this.PREFIX = 'edt active '; }
    constructor(editorGroupService, editorService, modelService, languageService) {
        super(ActiveGroupEditorsByMostRecentlyUsedQuickAccess_1.PREFIX, editorGroupService, editorService, modelService, languageService);
    }
    doGetEditors() {
        const group = this.editorGroupService.activeGroup;
        return ( group.getEditors(0 ).map(editor => ({ editor, groupId: group.id })));
    }
};
ActiveGroupEditorsByMostRecentlyUsedQuickAccess = ActiveGroupEditorsByMostRecentlyUsedQuickAccess_1 = ( __decorate([
    ( __param(0, IEditorGroupsService)),
    ( __param(1, IEditorService)),
    ( __param(2, IModelService)),
    ( __param(3, ILanguageService))
], ActiveGroupEditorsByMostRecentlyUsedQuickAccess));
let AllEditorsByAppearanceQuickAccess = class AllEditorsByAppearanceQuickAccess extends BaseEditorQuickAccessProvider {
    static { AllEditorsByAppearanceQuickAccess_1 = this; }
    static { this.PREFIX = 'edt '; }
    constructor(editorGroupService, editorService, modelService, languageService) {
        super(AllEditorsByAppearanceQuickAccess_1.PREFIX, editorGroupService, editorService, modelService, languageService);
    }
    doGetEditors() {
        const entries = [];
        for (const group of this.editorGroupService.getGroups(2 )) {
            for (const editor of group.getEditors(1 )) {
                entries.push({ editor, groupId: group.id });
            }
        }
        return entries;
    }
};
AllEditorsByAppearanceQuickAccess = AllEditorsByAppearanceQuickAccess_1 = ( __decorate([
    ( __param(0, IEditorGroupsService)),
    ( __param(1, IEditorService)),
    ( __param(2, IModelService)),
    ( __param(3, ILanguageService))
], AllEditorsByAppearanceQuickAccess));
let AllEditorsByMostRecentlyUsedQuickAccess = class AllEditorsByMostRecentlyUsedQuickAccess extends BaseEditorQuickAccessProvider {
    static { AllEditorsByMostRecentlyUsedQuickAccess_1 = this; }
    static { this.PREFIX = 'edt mru '; }
    constructor(editorGroupService, editorService, modelService, languageService) {
        super(AllEditorsByMostRecentlyUsedQuickAccess_1.PREFIX, editorGroupService, editorService, modelService, languageService);
    }
    doGetEditors() {
        const entries = [];
        for (const editor of this.editorService.getEditors(0 )) {
            entries.push(editor);
        }
        return entries;
    }
};
AllEditorsByMostRecentlyUsedQuickAccess = AllEditorsByMostRecentlyUsedQuickAccess_1 = ( __decorate([
    ( __param(0, IEditorGroupsService)),
    ( __param(1, IEditorService)),
    ( __param(2, IModelService)),
    ( __param(3, ILanguageService))
], AllEditorsByMostRecentlyUsedQuickAccess));
export { ActiveGroupEditorsByMostRecentlyUsedQuickAccess, AllEditorsByAppearanceQuickAccess, AllEditorsByMostRecentlyUsedQuickAccess, BaseEditorQuickAccessProvider };
