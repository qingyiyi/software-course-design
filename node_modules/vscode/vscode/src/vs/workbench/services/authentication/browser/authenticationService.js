import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { flatten } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { Disposable, MutableDisposable, dispose } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { isFalsyOrWhitespace } from 'monaco-editor/esm/vs/base/common/strings.js';
import { isString } from 'monaco-editor/esm/vs/base/common/types.js';
import * as nls from 'monaco-editor/esm/vs/nls.js';
import { MenuRegistry, MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import '../../../../../../../override/vs/platform/dialogs/common/dialogs.js';
import { Severity } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { IProductService } from 'monaco-editor/esm/vs/platform/product/common/productService.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { IActivityService, NumberBadge } from '../../activity/common/activity.js';
import { IAuthenticationService } from '../common/authentication.js';
import { IBrowserWorkbenchEnvironmentService } from '../../environment/browser/environmentService.js';
import { IExtensionService } from '../../extensions/common/extensions.js';
import { ExtensionsRegistry } from '../../extensions/common/extensionsRegistry.js';
import { IDialogService } from '../../../../platform/dialogs/common/dialogs.js';
function getAuthenticationProviderActivationEvent(id) { return `onAuthenticationRequest:${id}`; }
function readAccountUsages(storageService, providerId, accountName) {
    const accountKey = `${providerId}-${accountName}-usages`;
    const storedUsages = storageService.get(accountKey, -1 );
    let usages = [];
    if (storedUsages) {
        try {
            usages = JSON.parse(storedUsages);
        }
        catch (e) {
        }
    }
    return usages;
}
function removeAccountUsage(storageService, providerId, accountName) {
    const accountKey = `${providerId}-${accountName}-usages`;
    storageService.remove(accountKey, -1 );
}
function addAccountUsage(storageService, providerId, accountName, extensionId, extensionName) {
    const accountKey = `${providerId}-${accountName}-usages`;
    const usages = readAccountUsages(storageService, providerId, accountName);
    const existingUsageIndex = usages.findIndex(usage => usage.extensionId === extensionId);
    if (existingUsageIndex > -1) {
        usages.splice(existingUsageIndex, 1, {
            extensionId,
            extensionName,
            lastUsed: Date.now()
        });
    }
    else {
        usages.push({
            extensionId,
            extensionName,
            lastUsed: Date.now()
        });
    }
    storageService.store(accountKey, JSON.stringify(usages), -1 , 1 );
}
async function getCurrentAuthenticationSessionInfo(secretStorageService, productService) {
    const authenticationSessionValue = await secretStorageService.get(`${productService.urlProtocol}.loginAccount`);
    if (authenticationSessionValue) {
        try {
            const authenticationSessionInfo = JSON.parse(authenticationSessionValue);
            if (authenticationSessionInfo
                && isString(authenticationSessionInfo.id)
                && isString(authenticationSessionInfo.accessToken)
                && isString(authenticationSessionInfo.providerId)) {
                return authenticationSessionInfo;
            }
        }
        catch (e) {
            console.error(`Failed parsing current auth session value: ${e}`);
        }
    }
    return undefined;
}
function readAllowedExtensions(storageService, providerId, accountName) {
    let trustedExtensions = [];
    try {
        const trustedExtensionSrc = storageService.get(`${providerId}-${accountName}`, -1 );
        if (trustedExtensionSrc) {
            trustedExtensions = JSON.parse(trustedExtensionSrc);
        }
    }
    catch (err) { }
    return trustedExtensions;
}
const SCOPESLIST_SEPARATOR = ' ';
CommandsRegistry.registerCommand('workbench.getCodeExchangeProxyEndpoints', function (accessor, _) {
    const environmentService = accessor.get(IBrowserWorkbenchEnvironmentService);
    return environmentService.options?.codeExchangeProxyEndpoints;
});
const authenticationDefinitionSchema = {
    type: 'object',
    additionalProperties: false,
    properties: {
        id: {
            type: 'string',
            description: ( nls.localizeWithPath(
                'vs/workbench/services/authentication/browser/authenticationService',
                'authentication.id',
                'The id of the authentication provider.'
            ))
        },
        label: {
            type: 'string',
            description: ( nls.localizeWithPath(
                'vs/workbench/services/authentication/browser/authenticationService',
                'authentication.label',
                'The human readable name of the authentication provider.'
            )),
        }
    }
};
const authenticationExtPoint = ( ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'authentication',
    jsonSchema: {
        description: ( nls.localizeWithPath(
            'vs/workbench/services/authentication/browser/authenticationService',
            { key: 'authenticationExtensionPoint', comment: [`'Contributes' means adds here`] },
            'Contributes authentication'
        )),
        type: 'array',
        items: authenticationDefinitionSchema
    },
    activationEventsGenerator: (authenticationProviders, result) => {
        for (const authenticationProvider of authenticationProviders) {
            if (authenticationProvider.id) {
                result.push(`onAuthenticationRequest:${authenticationProvider.id}`);
            }
        }
    }
}));
let placeholderMenuItem = MenuRegistry.appendMenuItem(MenuId.AccountsContext, {
    command: {
        id: 'noAuthenticationProviders',
        title: ( nls.localizeWithPath(
            'vs/workbench/services/authentication/browser/authenticationService',
            'authentication.Placeholder',
            "No accounts requested yet..."
        )),
        precondition: ( ContextKeyExpr.false())
    },
});
let AuthenticationService = class AuthenticationService extends Disposable {
    constructor(activityService, extensionService, storageService, dialogService, quickInputService, productService) {
        super();
        this.activityService = activityService;
        this.extensionService = extensionService;
        this.storageService = storageService;
        this.dialogService = dialogService;
        this.quickInputService = quickInputService;
        this.productService = productService;
        this._signInRequestItems = ( new Map());
        this._sessionAccessRequestItems = ( new Map());
        this._accountBadgeDisposable = this._register(( new MutableDisposable()));
        this._authenticationProviders = ( new Map());
        this.declaredProviders = [];
        this._onDidRegisterAuthenticationProvider = this._register(( new Emitter()));
        this.onDidRegisterAuthenticationProvider = this._onDidRegisterAuthenticationProvider.event;
        this._onDidUnregisterAuthenticationProvider = this._register(( new Emitter()));
        this.onDidUnregisterAuthenticationProvider = this._onDidUnregisterAuthenticationProvider.event;
        this._onDidChangeSessions = this._register(( new Emitter()));
        this.onDidChangeSessions = this._onDidChangeSessions.event;
        this._onDidChangeDeclaredProviders = this._register(( new Emitter()));
        this.onDidChangeDeclaredProviders = this._onDidChangeDeclaredProviders.event;
        authenticationExtPoint.setHandler((extensions, { added, removed }) => {
            added.forEach(point => {
                for (const provider of point.value) {
                    if (isFalsyOrWhitespace(provider.id)) {
                        point.collector.error(( nls.localizeWithPath(
                            'vs/workbench/services/authentication/browser/authenticationService',
                            'authentication.missingId',
                            'An authentication contribution must specify an id.'
                        )));
                        continue;
                    }
                    if (isFalsyOrWhitespace(provider.label)) {
                        point.collector.error(( nls.localizeWithPath(
                            'vs/workbench/services/authentication/browser/authenticationService',
                            'authentication.missingLabel',
                            'An authentication contribution must specify a label.'
                        )));
                        continue;
                    }
                    if (!( this.declaredProviders.some(p => p.id === provider.id))) {
                        this.declaredProviders.push(provider);
                    }
                    else {
                        point.collector.error(( nls.localizeWithPath(
                            'vs/workbench/services/authentication/browser/authenticationService',
                            'authentication.idConflict',
                            "This authentication id '{0}' has already been registered",
                            provider.id
                        )));
                    }
                }
            });
            const removedExtPoints = flatten(( removed.map(r => r.value)));
            removedExtPoints.forEach(point => {
                const index = this.declaredProviders.findIndex(provider => provider.id === point.id);
                if (index > -1) {
                    this.declaredProviders.splice(index, 1);
                }
            });
            this._onDidChangeDeclaredProviders.fire(this.declaredProviders);
        });
    }
    getProviderIds() {
        const providerIds = [];
        this._authenticationProviders.forEach(provider => {
            providerIds.push(provider.id);
        });
        return providerIds;
    }
    isAuthenticationProviderRegistered(id) {
        return ( this._authenticationProviders.has(id));
    }
    registerAuthenticationProvider(id, authenticationProvider) {
        this._authenticationProviders.set(id, authenticationProvider);
        this._onDidRegisterAuthenticationProvider.fire({ id, label: authenticationProvider.label });
        if (placeholderMenuItem) {
            placeholderMenuItem.dispose();
            placeholderMenuItem = undefined;
        }
    }
    unregisterAuthenticationProvider(id) {
        const provider = this._authenticationProviders.get(id);
        if (provider) {
            provider.dispose();
            this._authenticationProviders.delete(id);
            this._onDidUnregisterAuthenticationProvider.fire({ id, label: provider.label });
            const accessRequests = this._sessionAccessRequestItems.get(id) || {};
            ( Object.keys(accessRequests)).forEach(extensionId => {
                this.removeAccessRequest(id, extensionId);
            });
        }
        if (!this._authenticationProviders.size) {
            placeholderMenuItem = MenuRegistry.appendMenuItem(MenuId.AccountsContext, {
                command: {
                    id: 'noAuthenticationProviders',
                    title: ( nls.localizeWithPath(
                        'vs/workbench/services/authentication/browser/authenticationService',
                        'loading',
                        "Loading..."
                    )),
                    precondition: ( ContextKeyExpr.false())
                },
            });
        }
    }
    async sessionsUpdate(id, event) {
        const provider = this._authenticationProviders.get(id);
        if (provider) {
            this._onDidChangeSessions.fire({ providerId: id, label: provider.label, event: event });
            if (event.added) {
                await this.updateNewSessionRequests(provider, event.added);
            }
            if (event.removed) {
                await this.updateAccessRequests(id, event.removed);
            }
            this.updateBadgeCount();
        }
    }
    async updateNewSessionRequests(provider, addedSessions) {
        const existingRequestsForProvider = this._signInRequestItems.get(provider.id);
        if (!existingRequestsForProvider) {
            return;
        }
        ( Object.keys(existingRequestsForProvider)).forEach(requestedScopes => {
            if (( addedSessions.some(
                session => session.scopes.slice().join(SCOPESLIST_SEPARATOR) === requestedScopes
            ))) {
                const sessionRequest = existingRequestsForProvider[requestedScopes];
                sessionRequest?.disposables.forEach(item => item.dispose());
                delete existingRequestsForProvider[requestedScopes];
                if (( Object.keys(existingRequestsForProvider)).length === 0) {
                    this._signInRequestItems.delete(provider.id);
                }
                else {
                    this._signInRequestItems.set(provider.id, existingRequestsForProvider);
                }
            }
        });
    }
    async updateAccessRequests(providerId, removedSessions) {
        const providerRequests = this._sessionAccessRequestItems.get(providerId);
        if (providerRequests) {
            ( Object.keys(providerRequests)).forEach(extensionId => {
                removedSessions.forEach(removed => {
                    const indexOfSession = providerRequests[extensionId].possibleSessions.findIndex(session => session.id === removed.id);
                    if (indexOfSession) {
                        providerRequests[extensionId].possibleSessions.splice(indexOfSession, 1);
                    }
                });
                if (!providerRequests[extensionId].possibleSessions.length) {
                    this.removeAccessRequest(providerId, extensionId);
                }
            });
        }
    }
    updateBadgeCount() {
        this._accountBadgeDisposable.clear();
        let numberOfRequests = 0;
        this._signInRequestItems.forEach(providerRequests => {
            ( Object.keys(providerRequests)).forEach(request => {
                numberOfRequests += providerRequests[request].requestingExtensionIds.length;
            });
        });
        this._sessionAccessRequestItems.forEach(accessRequest => {
            numberOfRequests += ( Object.keys(accessRequest)).length;
        });
        if (numberOfRequests > 0) {
            const badge = ( new NumberBadge(numberOfRequests, () => ( nls.localizeWithPath(
                'vs/workbench/services/authentication/browser/authenticationService',
                'sign in',
                "Sign in requested"
            ))));
            this._accountBadgeDisposable.value = this.activityService.showAccountsActivity({ badge });
        }
    }
    removeAccessRequest(providerId, extensionId) {
        const providerRequests = this._sessionAccessRequestItems.get(providerId) || {};
        if (providerRequests[extensionId]) {
            dispose(providerRequests[extensionId].disposables);
            delete providerRequests[extensionId];
            this.updateBadgeCount();
        }
    }
    isAccessAllowed(providerId, accountName, extensionId) {
        const allowList = readAllowedExtensions(this.storageService, providerId, accountName);
        const extensionData = allowList.find(extension => extension.id === extensionId);
        if (extensionData) {
            return extensionData.allowed !== undefined
                ? extensionData.allowed
                : true;
        }
        if (this.productService.trustedExtensionAuthAccess?.includes(extensionId)) {
            return true;
        }
        return undefined;
    }
    updateAllowedExtension(providerId, accountName, extensionId, extensionName, isAllowed) {
        const allowList = readAllowedExtensions(this.storageService, providerId, accountName);
        const index = allowList.findIndex(extension => extension.id === extensionId);
        if (index === -1) {
            allowList.push({ id: extensionId, name: extensionName, allowed: isAllowed });
        }
        else {
            allowList[index].allowed = isAllowed;
        }
        this.storageService.store(`${providerId}-${accountName}`, JSON.stringify(allowList), -1 , 0 );
    }
    updateSessionPreference(providerId, extensionId, session) {
        const key = `${extensionId}-${providerId}-${session.scopes.join(' ')}`;
        this.storageService.store(key, session.id, 1 , 1 );
        this.storageService.store(key, session.id, -1 , 1 );
    }
    getSessionPreference(providerId, extensionId, scopes) {
        const key = `${extensionId}-${providerId}-${scopes.join(' ')}`;
        return this.storageService.get(key, 1 ) ?? this.storageService.get(key, -1 );
    }
    removeSessionPreference(providerId, extensionId, scopes) {
        const key = `${extensionId}-${providerId}-${scopes.join(' ')}`;
        this.storageService.remove(key, 1 );
        this.storageService.remove(key, -1 );
    }
    async showGetSessionPrompt(providerId, accountName, extensionId, extensionName) {
        const providerName = this.getLabel(providerId);
        let SessionPromptChoice;
        ( (function(SessionPromptChoice) {
            SessionPromptChoice[SessionPromptChoice["Allow"] = 0] = "Allow";
            SessionPromptChoice[SessionPromptChoice["Deny"] = 1] = "Deny";
            SessionPromptChoice[SessionPromptChoice["Cancel"] = 2] = "Cancel";
        })(SessionPromptChoice || (SessionPromptChoice = {})));
        const { result } = await this.dialogService.prompt({
            type: Severity.Info,
            message: ( nls.localizeWithPath(
                'vs/workbench/services/authentication/browser/authenticationService',
                'confirmAuthenticationAccess',
                "The extension '{0}' wants to access the {1} account '{2}'.",
                extensionName,
                providerName,
                accountName
            )),
            buttons: [
                {
                    label: ( nls.localizeWithPath(
                        'vs/workbench/services/authentication/browser/authenticationService',
                        { key: 'allow', comment: ['&& denotes a mnemonic'] },
                        "&&Allow"
                    )),
                    run: () => SessionPromptChoice.Allow
                },
                {
                    label: ( nls.localizeWithPath(
                        'vs/workbench/services/authentication/browser/authenticationService',
                        { key: 'deny', comment: ['&& denotes a mnemonic'] },
                        "&&Deny"
                    )),
                    run: () => SessionPromptChoice.Deny
                }
            ],
            cancelButton: {
                run: () => SessionPromptChoice.Cancel
            }
        });
        if (result !== SessionPromptChoice.Cancel) {
            this.updateAllowedExtension(providerId, accountName, extensionId, extensionName, result === SessionPromptChoice.Allow);
            this.removeAccessRequest(providerId, extensionId);
        }
        return result === SessionPromptChoice.Allow;
    }
    async selectSession(providerId, extensionId, extensionName, scopes, availableSessions) {
        return ( new Promise((resolve, reject) => {
            if (!availableSessions.length) {
                reject('No available sessions');
            }
            const quickPick = this.quickInputService.createQuickPick();
            quickPick.ignoreFocusOut = true;
            const items = ( availableSessions.map(session => {
                return {
                    label: session.account.label,
                    session: session
                };
            }));
            items.push({
                label: ( nls.localizeWithPath(
                    'vs/workbench/services/authentication/browser/authenticationService',
                    'useOtherAccount',
                    "Sign in to another account"
                ))
            });
            const providerName = this.getLabel(providerId);
            quickPick.items = items;
            quickPick.title = ( nls.localizeWithPath('vs/workbench/services/authentication/browser/authenticationService', {
                key: 'selectAccount',
                comment: ['The placeholder {0} is the name of an extension. {1} is the name of the type of account, such as Microsoft or GitHub.']
            }, "The extension '{0}' wants to access a {1} account", extensionName, providerName));
            quickPick.placeholder = ( nls.localizeWithPath(
                'vs/workbench/services/authentication/browser/authenticationService',
                'getSessionPlateholder',
                "Select an account for '{0}' to use or Esc to cancel",
                extensionName
            ));
            quickPick.onDidAccept(async (_) => {
                const session = quickPick.selectedItems[0].session ?? (await this.createSession(providerId, scopes));
                const accountName = session.account.label;
                this.updateAllowedExtension(providerId, accountName, extensionId, extensionName, true);
                this.updateSessionPreference(providerId, extensionId, session);
                this.removeAccessRequest(providerId, extensionId);
                quickPick.dispose();
                resolve(session);
            });
            quickPick.onDidHide(_ => {
                if (!quickPick.selectedItems[0]) {
                    reject('User did not consent to account access');
                }
                quickPick.dispose();
            });
            quickPick.show();
        }));
    }
    async completeSessionAccessRequest(providerId, extensionId, extensionName, scopes) {
        const providerRequests = this._sessionAccessRequestItems.get(providerId) || {};
        const existingRequest = providerRequests[extensionId];
        if (!existingRequest) {
            return;
        }
        const possibleSessions = existingRequest.possibleSessions;
        const supportsMultipleAccounts = this.supportsMultipleAccounts(providerId);
        let session;
        if (supportsMultipleAccounts) {
            try {
                session = await this.selectSession(providerId, extensionId, extensionName, scopes, possibleSessions);
            }
            catch (_) {
            }
        }
        else {
            const approved = await this.showGetSessionPrompt(providerId, possibleSessions[0].account.label, extensionId, extensionName);
            if (approved) {
                session = possibleSessions[0];
            }
        }
        if (session) {
            addAccountUsage(this.storageService, providerId, session.account.label, extensionId, extensionName);
            const providerName = this.getLabel(providerId);
            this._onDidChangeSessions.fire({ providerId, label: providerName, event: { added: [], removed: [], changed: [session] } });
        }
    }
    requestSessionAccess(providerId, extensionId, extensionName, scopes, possibleSessions) {
        const providerRequests = this._sessionAccessRequestItems.get(providerId) || {};
        const hasExistingRequest = providerRequests[extensionId];
        if (hasExistingRequest) {
            return;
        }
        const menuItem = MenuRegistry.appendMenuItem(MenuId.AccountsContext, {
            group: '3_accessRequests',
            command: {
                id: `${providerId}${extensionId}Access`,
                title: ( nls.localizeWithPath('vs/workbench/services/authentication/browser/authenticationService', {
                    key: 'accessRequest',
                    comment: [`The placeholder {0} will be replaced with an authentication provider''s label. {1} will be replaced with an extension name. (1) is to indicate that this menu item contributes to a badge count`]
                }, "Grant access to {0} for {1}... (1)", this.getLabel(providerId), extensionName))
            }
        });
        const accessCommand = CommandsRegistry.registerCommand({
            id: `${providerId}${extensionId}Access`,
            handler: async (accessor) => {
                const authenticationService = accessor.get(IAuthenticationService);
                authenticationService.completeSessionAccessRequest(providerId, extensionId, extensionName, scopes);
            }
        });
        providerRequests[extensionId] = { possibleSessions, disposables: [menuItem, accessCommand] };
        this._sessionAccessRequestItems.set(providerId, providerRequests);
        this.updateBadgeCount();
    }
    async requestNewSession(providerId, scopes, extensionId, extensionName) {
        let provider = this._authenticationProviders.get(providerId);
        if (!provider) {
            await ( new Promise((resolve, _) => {
                const dispose = this.onDidRegisterAuthenticationProvider(e => {
                    if (e.id === providerId) {
                        provider = this._authenticationProviders.get(providerId);
                        dispose.dispose();
                        resolve();
                    }
                });
            }));
        }
        if (!provider) {
            return;
        }
        const providerRequests = this._signInRequestItems.get(providerId);
        const scopesList = scopes.join(SCOPESLIST_SEPARATOR);
        const extensionHasExistingRequest = providerRequests
            && providerRequests[scopesList]
            && providerRequests[scopesList].requestingExtensionIds.includes(extensionId);
        if (extensionHasExistingRequest) {
            return;
        }
        const commandId = `${providerId}:${extensionId}:signIn${( Object.keys(providerRequests || [])).length}`;
        const menuItem = MenuRegistry.appendMenuItem(MenuId.AccountsContext, {
            group: '2_signInRequests',
            command: {
                id: commandId,
                title: ( nls.localizeWithPath('vs/workbench/services/authentication/browser/authenticationService', {
                    key: 'signInRequest',
                    comment: [`The placeholder {0} will be replaced with an authentication provider's label. {1} will be replaced with an extension name. (1) is to indicate that this menu item contributes to a badge count.`]
                }, "Sign in with {0} to use {1} (1)", provider.label, extensionName))
            }
        });
        const signInCommand = CommandsRegistry.registerCommand({
            id: commandId,
            handler: async (accessor) => {
                const authenticationService = accessor.get(IAuthenticationService);
                const session = await authenticationService.createSession(providerId, scopes);
                this.updateAllowedExtension(providerId, session.account.label, extensionId, extensionName, true);
                this.updateSessionPreference(providerId, extensionId, session);
            }
        });
        if (providerRequests) {
            const existingRequest = providerRequests[scopesList] || { disposables: [], requestingExtensionIds: [] };
            providerRequests[scopesList] = {
                disposables: [...existingRequest.disposables, menuItem, signInCommand],
                requestingExtensionIds: [...existingRequest.requestingExtensionIds, extensionId]
            };
            this._signInRequestItems.set(providerId, providerRequests);
        }
        else {
            this._signInRequestItems.set(providerId, {
                [scopesList]: {
                    disposables: [menuItem, signInCommand],
                    requestingExtensionIds: [extensionId]
                }
            });
        }
        this.updateBadgeCount();
    }
    getLabel(id) {
        const authProvider = this._authenticationProviders.get(id);
        if (authProvider) {
            return authProvider.label;
        }
        else {
            throw new Error(`No authentication provider '${id}' is currently registered.`);
        }
    }
    supportsMultipleAccounts(id) {
        const authProvider = this._authenticationProviders.get(id);
        if (authProvider) {
            return authProvider.supportsMultipleAccounts;
        }
        else {
            throw new Error(`No authentication provider '${id}' is currently registered.`);
        }
    }
    async tryActivateProvider(providerId, activateImmediate) {
        await this.extensionService.activateByEvent(getAuthenticationProviderActivationEvent(providerId), activateImmediate ? 1  : 0 );
        let provider = this._authenticationProviders.get(providerId);
        if (provider) {
            return provider;
        }
        const didRegister = ( new Promise((resolve, _) => {
            this.onDidRegisterAuthenticationProvider(e => {
                if (e.id === providerId) {
                    provider = this._authenticationProviders.get(providerId);
                    if (provider) {
                        resolve(provider);
                    }
                    else {
                        throw new Error(`No authentication provider '${providerId}' is currently registered.`);
                    }
                }
            });
        }));
        const didTimeout = ( new Promise((_, reject) => {
            setTimeout(() => {
                reject('Timed out waiting for authentication provider to register');
            }, 5000);
        }));
        return Promise.race([didRegister, didTimeout]);
    }
    async getSessions(id, scopes, activateImmediate = false) {
        const authProvider = this._authenticationProviders.get(id) || (await this.tryActivateProvider(id, activateImmediate));
        if (authProvider) {
            return await authProvider.getSessions(scopes);
        }
        else {
            throw new Error(`No authentication provider '${id}' is currently registered.`);
        }
    }
    async createSession(id, scopes, options) {
        const authProvider = this._authenticationProviders.get(id) || (await this.tryActivateProvider(id, !!options?.activateImmediate));
        if (authProvider) {
            return await authProvider.createSession(scopes, {
                sessionToRecreate: options?.sessionToRecreate
            });
        }
        else {
            throw new Error(`No authentication provider '${id}' is currently registered.`);
        }
    }
    async removeSession(id, sessionId) {
        const authProvider = this._authenticationProviders.get(id);
        if (authProvider) {
            return authProvider.removeSession(sessionId);
        }
        else {
            throw new Error(`No authentication provider '${id}' is currently registered.`);
        }
    }
    async manageTrustedExtensionsForAccount(id, accountName) {
        const authProvider = this._authenticationProviders.get(id);
        if (authProvider) {
            return authProvider.manageTrustedExtensions(accountName);
        }
        else {
            throw new Error(`No authentication provider '${id}' is currently registered.`);
        }
    }
    async removeAccountSessions(id, accountName, sessions) {
        const authProvider = this._authenticationProviders.get(id);
        if (authProvider) {
            return authProvider.removeAccountSessions(accountName, sessions);
        }
        else {
            throw new Error(`No authentication provider '${id}' is currently registered.`);
        }
    }
};
AuthenticationService = ( __decorate([
    ( __param(0, IActivityService)),
    ( __param(1, IExtensionService)),
    ( __param(2, IStorageService)),
    ( __param(3, IDialogService)),
    ( __param(4, IQuickInputService)),
    ( __param(5, IProductService))
], AuthenticationService));
export { AuthenticationService, addAccountUsage, getAuthenticationProviderActivationEvent, getCurrentAuthenticationSessionInfo, readAccountUsages, readAllowedExtensions, removeAccountUsage };
