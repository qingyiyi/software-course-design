import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { IExtensionManagementService, IGlobalExtensionEnablementService } from '../../../../platform/extensionManagement/common/extensionManagement.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { isResolverExtension } from 'monaco-editor/esm/vs/platform/extensions/common/extensions.js';
import { Severity, NotificationPriority, INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { IHostService } from '../../host/browser/host.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { registerAction2, Action2, MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { RawContextKey, ContextKeyExpr, IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import '../../../../../../../override/vs/platform/dialogs/common/dialogs.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions } from '../../../common/contributions.js';
import { ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { IProductService } from 'monaco-editor/esm/vs/platform/product/common/productService.js';
import { IWorkbenchIssueService } from '../../issue/common/issue.js';
import { IWorkbenchEnvironmentService } from '../../environment/common/environmentService.js';
import { areSameExtensions } from '../../../../platform/extensionManagement/common/extensionManagementUtil.js';
import { Categories } from 'monaco-editor/esm/vs/platform/action/common/actionCommonCategories.js';
import { IWorkbenchExtensionEnablementService } from '../common/extensionManagement.js';
import { IDialogService } from '../../../../platform/dialogs/common/dialogs.js';
var ExtensionBisectService_1, ExtensionBisectUi_1;
const IExtensionBisectService = ( createDecorator('IExtensionBisectService'));
class BisectState {
    static fromJSON(raw) {
        if (!raw) {
            return undefined;
        }
        try {
            const data = JSON.parse(raw);
            return ( new BisectState(data.extensions, data.low, data.high, data.mid));
        }
        catch {
            return undefined;
        }
    }
    constructor(extensions, low, high, mid = ((low + high) / 2) | 0) {
        this.extensions = extensions;
        this.low = low;
        this.high = high;
        this.mid = mid;
    }
}
let ExtensionBisectService = class ExtensionBisectService {
    static { ExtensionBisectService_1 = this; }
    static { this._storageKey = 'extensionBisectState'; }
    constructor(logService, _storageService, _envService) {
        this._storageService = _storageService;
        this._envService = _envService;
        this._disabled = ( new Map());
        const raw = _storageService.get(ExtensionBisectService_1._storageKey, -1 );
        this._state = BisectState.fromJSON(raw);
        if (this._state) {
            const { mid, high } = this._state;
            for (let i = 0; i < this._state.extensions.length; i++) {
                const isDisabled = i >= mid && i < high;
                this._disabled.set(this._state.extensions[i], isDisabled);
            }
            logService.warn('extension BISECT active', [...this._disabled]);
        }
    }
    get isActive() {
        return !!this._state;
    }
    get disabledCount() {
        return this._state ? this._state.high - this._state.mid : -1;
    }
    isDisabledByBisect(extension) {
        if (!this._state) {
            return false;
        }
        if (isResolverExtension(extension.manifest, this._envService.remoteAuthority)) {
            return false;
        }
        if (this._isEnabledInEnv(extension)) {
            return false;
        }
        const disabled = this._disabled.get(extension.identifier.id);
        return disabled ?? false;
    }
    _isEnabledInEnv(extension) {
        return Array.isArray(this._envService.enableExtensions) && ( this._envService.enableExtensions.some(id => areSameExtensions({ id }, extension.identifier)));
    }
    async start(extensions) {
        if (this._state) {
            throw new Error('invalid state');
        }
        const extensionIds = ( extensions.map(ext => ext.identifier.id));
        const newState = ( new BisectState(extensionIds, 0, extensionIds.length, 0));
        this._storageService.store(ExtensionBisectService_1._storageKey, JSON.stringify(newState), -1 , 1 );
        await this._storageService.flush();
    }
    async next(seeingBad) {
        if (!this._state) {
            throw new Error('invalid state');
        }
        if (seeingBad && this._state.mid === 0 && this._state.high === this._state.extensions.length) {
            return { bad: true, id: '' };
        }
        if (this._state.low === this._state.high - 1) {
            await this.reset();
            return { id: this._state.extensions[this._state.low], bad: seeingBad };
        }
        const nextState = ( new BisectState(
            this._state.extensions,
            seeingBad ? this._state.low : this._state.mid,
            seeingBad ? this._state.mid : this._state.high
        ));
        this._storageService.store(ExtensionBisectService_1._storageKey, JSON.stringify(nextState), -1 , 1 );
        await this._storageService.flush();
        return undefined;
    }
    async reset() {
        this._storageService.remove(ExtensionBisectService_1._storageKey, -1 );
        await this._storageService.flush();
    }
};
ExtensionBisectService = ExtensionBisectService_1 = ( __decorate([
    ( __param(0, ILogService)),
    ( __param(1, IStorageService)),
    ( __param(2, IWorkbenchEnvironmentService))
], ExtensionBisectService));
let ExtensionBisectUi = class ExtensionBisectUi {
    static { ExtensionBisectUi_1 = this; }
    static { this.ctxIsBisectActive = ( new RawContextKey('isExtensionBisectActive', false)); }
    constructor(contextKeyService, _extensionBisectService, _notificationService, _commandService) {
        this._extensionBisectService = _extensionBisectService;
        this._notificationService = _notificationService;
        this._commandService = _commandService;
        if (_extensionBisectService.isActive) {
            ExtensionBisectUi_1.ctxIsBisectActive.bindTo(contextKeyService).set(true);
            this._showBisectPrompt();
        }
    }
    _showBisectPrompt() {
        const goodPrompt = {
            label: ( localizeWithPath(
                'vs/workbench/services/extensionManagement/browser/extensionBisect',
                'I cannot reproduce',
                "I can't reproduce"
            )),
            run: () => this._commandService.executeCommand('extension.bisect.next', false)
        };
        const badPrompt = {
            label: ( localizeWithPath(
                'vs/workbench/services/extensionManagement/browser/extensionBisect',
                'This is Bad',
                "I can reproduce"
            )),
            run: () => this._commandService.executeCommand('extension.bisect.next', true)
        };
        const stop = {
            label: 'Stop Bisect',
            run: () => this._commandService.executeCommand('extension.bisect.stop')
        };
        const message = this._extensionBisectService.disabledCount === 1
            ? ( localizeWithPath(
            'vs/workbench/services/extensionManagement/browser/extensionBisect',
            'bisect.singular',
            "Extension Bisect is active and has disabled 1 extension. Check if you can still reproduce the problem and proceed by selecting from these options."
        ))
            : ( localizeWithPath(
            'vs/workbench/services/extensionManagement/browser/extensionBisect',
            'bisect.plural',
            "Extension Bisect is active and has disabled {0} extensions. Check if you can still reproduce the problem and proceed by selecting from these options.",
            this._extensionBisectService.disabledCount
        ));
        this._notificationService.prompt(Severity.Info, message, [goodPrompt, badPrompt, stop], { sticky: true, priority: NotificationPriority.URGENT });
    }
};
ExtensionBisectUi = ExtensionBisectUi_1 = ( __decorate([
    ( __param(0, IContextKeyService)),
    ( __param(1, IExtensionBisectService)),
    ( __param(2, INotificationService)),
    ( __param(3, ICommandService))
], ExtensionBisectUi));
( Registry.as(Extensions.Workbench)).registerWorkbenchContribution(ExtensionBisectUi, 3 );
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'extension.bisect.start',
            title: { value: ( localizeWithPath(
                'vs/workbench/services/extensionManagement/browser/extensionBisect',
                'title.start',
                "Start Extension Bisect"
            )), original: 'Start Extension Bisect' },
            category: Categories.Help,
            f1: true,
            precondition: ( ExtensionBisectUi.ctxIsBisectActive.negate()),
            menu: {
                id: MenuId.ViewContainerTitle,
                when: ( ContextKeyExpr.equals('viewContainer', 'workbench.view.extensions')),
                group: '2_enablement',
                order: 4
            }
        });
    }
    async run(accessor) {
        const dialogService = accessor.get(IDialogService);
        const hostService = accessor.get(IHostService);
        const extensionManagement = accessor.get(IExtensionManagementService);
        const extensionEnablementService = accessor.get(IWorkbenchExtensionEnablementService);
        const extensionsBisect = accessor.get(IExtensionBisectService);
        const extensions = (await extensionManagement.getInstalled(1 )).filter(ext => extensionEnablementService.isEnabled(ext));
        const res = await dialogService.confirm({
            message: ( localizeWithPath(
                'vs/workbench/services/extensionManagement/browser/extensionBisect',
                'msg.start',
                "Extension Bisect"
            )),
            detail: ( localizeWithPath(
                'vs/workbench/services/extensionManagement/browser/extensionBisect',
                'detail.start',
                "Extension Bisect will use binary search to find an extension that causes a problem. During the process the window reloads repeatedly (~{0} times). Each time you must confirm if you are still seeing problems.",
                2 + Math.log2(extensions.length) | 0
            )),
            primaryButton: ( localizeWithPath(
                'vs/workbench/services/extensionManagement/browser/extensionBisect',
                { key: 'msg2', comment: ['&& denotes a mnemonic'] },
                "&&Start Extension Bisect"
            ))
        });
        if (res.confirmed) {
            await extensionsBisect.start(extensions);
            hostService.reload();
        }
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'extension.bisect.next',
            title: { value: ( localizeWithPath(
                'vs/workbench/services/extensionManagement/browser/extensionBisect',
                'title.isBad',
                "Continue Extension Bisect"
            )), original: 'Continue Extension Bisect' },
            category: Categories.Help,
            f1: true,
            precondition: ExtensionBisectUi.ctxIsBisectActive
        });
    }
    async run(accessor, seeingBad) {
        const dialogService = accessor.get(IDialogService);
        const hostService = accessor.get(IHostService);
        const bisectService = accessor.get(IExtensionBisectService);
        const productService = accessor.get(IProductService);
        const extensionEnablementService = accessor.get(IGlobalExtensionEnablementService);
        const issueService = accessor.get(IWorkbenchIssueService);
        if (!bisectService.isActive) {
            return;
        }
        if (seeingBad === undefined) {
            const goodBadStopCancel = await this._checkForBad(dialogService, bisectService);
            if (goodBadStopCancel === null) {
                return;
            }
            seeingBad = goodBadStopCancel;
        }
        if (seeingBad === undefined) {
            await bisectService.reset();
            hostService.reload();
            return;
        }
        const done = await bisectService.next(seeingBad);
        if (!done) {
            hostService.reload();
            return;
        }
        if (done.bad) {
            await dialogService.info(( localizeWithPath(
                'vs/workbench/services/extensionManagement/browser/extensionBisect',
                'done.msg',
                "Extension Bisect"
            )), ( localizeWithPath(
                'vs/workbench/services/extensionManagement/browser/extensionBisect',
                'done.detail2',
                "Extension Bisect is done but no extension has been identified. This might be a problem with {0}.",
                productService.nameShort
            )));
        }
        else {
            const res = await dialogService.confirm({
                type: Severity.Info,
                message: ( localizeWithPath(
                    'vs/workbench/services/extensionManagement/browser/extensionBisect',
                    'done.msg',
                    "Extension Bisect"
                )),
                primaryButton: ( localizeWithPath(
                    'vs/workbench/services/extensionManagement/browser/extensionBisect',
                    { key: 'report', comment: ['&& denotes a mnemonic'] },
                    "&&Report Issue & Continue"
                )),
                cancelButton: ( localizeWithPath(
                    'vs/workbench/services/extensionManagement/browser/extensionBisect',
                    'continue',
                    "Continue"
                )),
                detail: ( localizeWithPath(
                    'vs/workbench/services/extensionManagement/browser/extensionBisect',
                    'done.detail',
                    "Extension Bisect is done and has identified {0} as the extension causing the problem.",
                    done.id
                )),
                checkbox: { label: ( localizeWithPath(
                    'vs/workbench/services/extensionManagement/browser/extensionBisect',
                    'done.disbale',
                    "Keep this extension disabled"
                )), checked: true }
            });
            if (res.checkboxChecked) {
                await extensionEnablementService.disableExtension({ id: done.id }, undefined);
            }
            if (res.confirmed) {
                await issueService.openReporter({ extensionId: done.id });
            }
        }
        await bisectService.reset();
        hostService.reload();
    }
    async _checkForBad(dialogService, bisectService) {
        const { result } = await dialogService.prompt({
            type: Severity.Info,
            message: ( localizeWithPath(
                'vs/workbench/services/extensionManagement/browser/extensionBisect',
                'msg.next',
                "Extension Bisect"
            )),
            detail: ( localizeWithPath(
                'vs/workbench/services/extensionManagement/browser/extensionBisect',
                'bisect',
                "Extension Bisect is active and has disabled {0} extensions. Check if you can still reproduce the problem and proceed by selecting from these options.",
                bisectService.disabledCount
            )),
            buttons: [
                {
                    label: ( localizeWithPath(
                        'vs/workbench/services/extensionManagement/browser/extensionBisect',
                        { key: 'next.good', comment: ['&& denotes a mnemonic'] },
                        "I ca&&n't reproduce"
                    )),
                    run: () => false
                },
                {
                    label: ( localizeWithPath(
                        'vs/workbench/services/extensionManagement/browser/extensionBisect',
                        { key: 'next.bad', comment: ['&& denotes a mnemonic'] },
                        "I can &&reproduce"
                    )),
                    run: () => true
                },
                {
                    label: ( localizeWithPath(
                        'vs/workbench/services/extensionManagement/browser/extensionBisect',
                        { key: 'next.stop', comment: ['&& denotes a mnemonic'] },
                        "&&Stop Bisect"
                    )),
                    run: () => undefined
                }
            ],
            cancelButton: {
                label: ( localizeWithPath(
                    'vs/workbench/services/extensionManagement/browser/extensionBisect',
                    { key: 'next.cancel', comment: ['&& denotes a mnemonic'] },
                    "&&Cancel Bisect"
                )),
                run: () => null
            }
        });
        return result;
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'extension.bisect.stop',
            title: { value: ( localizeWithPath(
                'vs/workbench/services/extensionManagement/browser/extensionBisect',
                'title.stop',
                "Stop Extension Bisect"
            )), original: 'Stop Extension Bisect' },
            category: Categories.Help,
            f1: true,
            precondition: ExtensionBisectUi.ctxIsBisectActive
        });
    }
    async run(accessor) {
        const extensionsBisect = accessor.get(IExtensionBisectService);
        const hostService = accessor.get(IHostService);
        await extensionsBisect.reset();
        hostService.reload();
    }
});
export { IExtensionBisectService };
