import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { VSBuffer, bufferToStream, newWriteableBufferStream } from 'monaco-editor/esm/vs/base/common/buffer.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { isDefined } from 'monaco-editor/esm/vs/base/common/types.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { IEnvironmentService } from 'monaco-editor/esm/vs/platform/environment/common/environment.js';
import { IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { StoredValue } from './storedValue.js';
import { HydratedTestResult } from './testResult.js';
const RETAIN_MAX_RESULTS = 128;
const RETAIN_MIN_RESULTS = 16;
const RETAIN_MAX_BYTES = 1024 * 128;
const CLEANUP_PROBABILITY = 0.2;
const ITestResultStorage = ( createDecorator('ITestResultStorage'));
const currentRevision = 1;
let BaseTestResultStorage = class BaseTestResultStorage extends Disposable {
    constructor(storageService, logService) {
        super();
        this.storageService = storageService;
        this.logService = logService;
        this.stored = this._register(( new StoredValue({
            key: 'storedTestResults',
            scope: 1 ,
            target: 1
        }, this.storageService)));
    }
    async read() {
        const results = await Promise.all(( this.stored.get([]).map(async ({ id, rev }) => {
            if (rev !== currentRevision) {
                return undefined;
            }
            try {
                const contents = await this.readForResultId(id);
                if (!contents) {
                    return undefined;
                }
                return ( new HydratedTestResult(contents));
            }
            catch (e) {
                this.logService.warn(`Error deserializing stored test result ${id}`, e);
                return undefined;
            }
        })));
        return results.filter(isDefined);
    }
    getResultOutputWriter(resultId) {
        const stream = newWriteableBufferStream();
        this.storeOutputForResultId(resultId, stream);
        return stream;
    }
    async persist(results) {
        const toDelete = ( new Map(( this.stored.get([]).map(({ id, bytes }) => [id, bytes]))));
        const toStore = [];
        const todo = [];
        let budget = RETAIN_MAX_BYTES;
        for (let i = 0; i < results.length && i < RETAIN_MAX_RESULTS && (budget > 0 || toStore.length < RETAIN_MIN_RESULTS); i++) {
            const result = results[i];
            const existingBytes = toDelete.get(result.id);
            if (existingBytes !== undefined) {
                toDelete.delete(result.id);
                toStore.push({ id: result.id, rev: currentRevision, bytes: existingBytes });
                budget -= existingBytes;
                continue;
            }
            const obj = result.toJSON();
            if (!obj) {
                continue;
            }
            const contents = VSBuffer.fromString(JSON.stringify(obj));
            todo.push(this.storeForResultId(result.id, obj));
            toStore.push({ id: result.id, rev: currentRevision, bytes: contents.byteLength });
            budget -= contents.byteLength;
        }
        for (const id of ( toDelete.keys())) {
            todo.push(this.deleteForResultId(id).catch(() => undefined));
        }
        this.stored.store(toStore);
        await Promise.all(todo);
    }
};
BaseTestResultStorage = ( __decorate([
    ( __param(0, IStorageService)),
    ( __param(1, ILogService))
], BaseTestResultStorage));
let TestResultStorage = class TestResultStorage extends BaseTestResultStorage {
    constructor(storageService, logService, workspaceContext, fileService, environmentService) {
        super(storageService, logService);
        this.fileService = fileService;
        this.directory = URI.joinPath(environmentService.workspaceStorageHome, workspaceContext.getWorkspace().id, 'testResults');
    }
    async readForResultId(id) {
        const contents = await this.fileService.readFile(this.getResultJsonPath(id));
        return JSON.parse(( contents.value.toString()));
    }
    storeForResultId(id, contents) {
        return this.fileService.writeFile(this.getResultJsonPath(id), VSBuffer.fromString(JSON.stringify(contents)));
    }
    deleteForResultId(id) {
        return this.fileService.del(this.getResultJsonPath(id)).catch(() => undefined);
    }
    async readOutputRangeForResultId(id, offset, length) {
        try {
            const { value } = await this.fileService.readFile(this.getResultOutputPath(id), { position: offset, length });
            return value;
        }
        catch {
            return VSBuffer.alloc(0);
        }
    }
    async readOutputForResultId(id) {
        try {
            const { value } = await this.fileService.readFileStream(this.getResultOutputPath(id));
            return value;
        }
        catch {
            return bufferToStream(VSBuffer.alloc(0));
        }
    }
    async storeOutputForResultId(id, input) {
        await this.fileService.createFile(this.getResultOutputPath(id), input);
    }
    async persist(results) {
        await super.persist(results);
        if (Math.random() < CLEANUP_PROBABILITY) {
            await this.cleanupDereferenced();
        }
    }
    async cleanupDereferenced() {
        const { children } = await this.fileService.resolve(this.directory);
        if (!children) {
            return;
        }
        const stored = ( new Set(( this.stored.get([]).filter(s => s.rev === currentRevision).map(s => s.id))));
        await Promise.all(( children
            .filter(child => !( stored.has(child.name.replace(/\.[a-z]+$/, ''))))
            .map(child => this.fileService.del(child.resource).catch(() => undefined))));
    }
    getResultJsonPath(id) {
        return URI.joinPath(this.directory, `${id}.json`);
    }
    getResultOutputPath(id) {
        return URI.joinPath(this.directory, `${id}.output`);
    }
};
TestResultStorage = ( __decorate([
    ( __param(0, IStorageService)),
    ( __param(1, ILogService)),
    ( __param(2, IWorkspaceContextService)),
    ( __param(3, IFileService)),
    ( __param(4, IEnvironmentService))
], TestResultStorage));
export { BaseTestResultStorage, ITestResultStorage, RETAIN_MAX_RESULTS, TestResultStorage };
