import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { splitGlobAware } from 'monaco-editor/esm/vs/base/common/glob.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { MutableObservableValue } from './observableValue.js';
import { StoredValue } from './storedValue.js';
import { namespaceTestTag } from './testTypes.js';
const ITestExplorerFilterState = ( createDecorator('testingFilterState'));
const tagRe = /!?@([^ ,:]+)/g;
const trimExtraWhitespace = (str) => str.replace(/\s\s+/g, ' ').trim();
let TestExplorerFilterState = class TestExplorerFilterState extends Disposable {
    constructor(storageService) {
        super();
        this.storageService = storageService;
        this.focusEmitter = ( new Emitter());
        this.termFilterState = {};
        this.globList = [];
        this.includeTags = ( new Set());
        this.excludeTags = ( new Set());
        this.text = this._register(( new MutableObservableValue('')));
        this.fuzzy = this._register(MutableObservableValue.stored(( new StoredValue({
            key: 'testHistoryFuzzy',
            scope: 0 ,
            target: 0 ,
        }, this.storageService)), false));
        this.reveal = this._register(( new MutableObservableValue(undefined)));
        this.onDidRequestInputFocus = this.focusEmitter.event;
    }
    focusInput() {
        this.focusEmitter.fire();
    }
    setText(text) {
        if (text === this.text.value) {
            return;
        }
        this.termFilterState = {};
        this.globList = [];
        this.includeTags.clear();
        this.excludeTags.clear();
        let globText = '';
        let lastIndex = 0;
        for (const match of text.matchAll(tagRe)) {
            let nextIndex = match.index + match[0].length;
            const tag = match[0];
            if (allTestFilterTerms.includes(tag)) {
                this.termFilterState[tag] = true;
            }
            if (text[nextIndex] === ':') {
                nextIndex++;
                let delimiter = text[nextIndex];
                if (delimiter !== `"` && delimiter !== `'`) {
                    delimiter = ' ';
                }
                else {
                    nextIndex++;
                }
                let tagId = '';
                while (nextIndex < text.length && text[nextIndex] !== delimiter) {
                    if (text[nextIndex] === '\\') {
                        tagId += text[nextIndex + 1];
                        nextIndex += 2;
                    }
                    else {
                        tagId += text[nextIndex];
                        nextIndex++;
                    }
                }
                if (match[0].startsWith('!')) {
                    this.excludeTags.add(namespaceTestTag(match[1], tagId));
                }
                else {
                    this.includeTags.add(namespaceTestTag(match[1], tagId));
                }
                nextIndex++;
            }
            globText += text.slice(lastIndex, match.index);
            lastIndex = nextIndex;
        }
        globText += text.slice(lastIndex).trim();
        if (globText.length) {
            for (const filter of ( splitGlobAware(globText, ',').map(s => s.trim())).filter(s => !!s.length)) {
                if (filter.startsWith('!')) {
                    this.globList.push({ include: false, text: filter.slice(1).toLowerCase() });
                }
                else {
                    this.globList.push({ include: true, text: filter.toLowerCase() });
                }
            }
        }
        this.text.value = text;
    }
    isFilteringFor(term) {
        return !!this.termFilterState[term];
    }
    toggleFilteringFor(term, shouldFilter) {
        const text = this.text.value.trim();
        if (shouldFilter !== false && !this.termFilterState[term]) {
            this.setText(text ? `${text} ${term}` : term);
        }
        else if (shouldFilter !== true && this.termFilterState[term]) {
            this.setText(trimExtraWhitespace(text.replace(term, '')));
        }
    }
};
TestExplorerFilterState = ( __decorate([
    ( __param(0, IStorageService))
], TestExplorerFilterState));
const allTestFilterTerms = [
    "@failed" ,
    "@executed" ,
    "@doc" ,
    "@hidden" ,
];
export { ITestExplorerFilterState, TestExplorerFilterState };
