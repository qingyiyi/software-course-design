import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { isDefined } from 'monaco-editor/esm/vs/base/common/types.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { StoredValue } from './storedValue.js';
import { testRunProfileBitsetList } from './testTypes.js';
import { TestId } from './testId.js';
import { TestingContextKeys } from './testingContextKeys.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
const ITestProfileService = ( createDecorator('testProfileService'));
const canUseProfileWithTest = (profile, test) => profile.controllerId === test.controllerId && (TestId.isRoot(test.item.extId) || !profile.tag || test.item.tags.includes(profile.tag));
const sorter = (a, b) => {
    if (a.isDefault !== b.isDefault) {
        return a.isDefault ? -1 : 1;
    }
    return a.label.localeCompare(b.label);
};
const capabilityContextKeys = (capabilities) => [
    [TestingContextKeys.hasRunnableTests.key, ((capabilities & 2) ) !== 0],
    [TestingContextKeys.hasDebuggableTests.key, ((capabilities & 4) ) !== 0],
    [TestingContextKeys.hasCoverableTests.key, ((capabilities & 8) ) !== 0],
];
let TestProfileService = class TestProfileService extends Disposable {
    constructor(contextKeyService, storageService) {
        super();
        this.changeEmitter = this._register(( new Emitter()));
        this.controllerProfiles = ( new Map());
        this.onDidChange = this.changeEmitter.event;
        this.preferredDefaults = this._register(( new StoredValue({
            key: 'testingPreferredProfiles',
            scope: 1 ,
            target: 1 ,
        }, storageService)));
        this.capabilitiesContexts = {
            [2 ]: TestingContextKeys.hasRunnableTests.bindTo(contextKeyService),
            [4 ]: TestingContextKeys.hasDebuggableTests.bindTo(contextKeyService),
            [8 ]: TestingContextKeys.hasCoverableTests.bindTo(contextKeyService),
            [16 ]: TestingContextKeys.hasNonDefaultProfile.bindTo(contextKeyService),
            [32 ]: TestingContextKeys.hasConfigurableProfile.bindTo(contextKeyService),
            [64 ]: TestingContextKeys.supportsContinuousRun.bindTo(contextKeyService),
        };
        this.refreshContextKeys();
    }
    addProfile(controller, profile) {
        let record = this.controllerProfiles.get(profile.controllerId);
        if (record) {
            record.profiles.push(profile);
            record.profiles.sort(sorter);
        }
        else {
            record = {
                profiles: [profile],
                controller,
            };
            this.controllerProfiles.set(profile.controllerId, record);
        }
        this.refreshContextKeys();
        this.changeEmitter.fire();
    }
    updateProfile(controllerId, profileId, update) {
        const ctrl = this.controllerProfiles.get(controllerId);
        if (!ctrl) {
            return;
        }
        const profile = ctrl.profiles.find(c => c.controllerId === controllerId && c.profileId === profileId);
        if (!profile) {
            return;
        }
        Object.assign(profile, update);
        ctrl.profiles.sort(sorter);
        this.changeEmitter.fire();
    }
    configure(controllerId, profileId) {
        this.controllerProfiles.get(controllerId)?.controller.configureRunProfile(profileId);
    }
    removeProfile(controllerId, profileId) {
        const ctrl = this.controllerProfiles.get(controllerId);
        if (!ctrl) {
            return;
        }
        if (!profileId) {
            this.controllerProfiles.delete(controllerId);
            this.changeEmitter.fire();
            return;
        }
        const index = ctrl.profiles.findIndex(c => c.profileId === profileId);
        if (index === -1) {
            return;
        }
        ctrl.profiles.splice(index, 1);
        this.refreshContextKeys();
        this.changeEmitter.fire();
    }
    capabilitiesForTest(test) {
        const ctrl = this.controllerProfiles.get(test.controllerId);
        if (!ctrl) {
            return 0;
        }
        let capabilities = 0;
        for (const profile of ctrl.profiles) {
            if (!profile.tag || test.item.tags.includes(profile.tag)) {
                capabilities |= capabilities & profile.group ? 16  : profile.group;
            }
        }
        return capabilities;
    }
    all() {
        return ( this.controllerProfiles.values());
    }
    getControllerProfiles(profileId) {
        return this.controllerProfiles.get(profileId)?.profiles ?? [];
    }
    getGroupDefaultProfiles(group) {
        const preferred = this.preferredDefaults.get();
        if (!preferred) {
            return this.getBaseDefaults(group);
        }
        const profiles = preferred[group]
            ?.map(p => this.controllerProfiles.get(p.controllerId)?.profiles.find(c => c.profileId === p.profileId && c.group === group))
            .filter(isDefined);
        return profiles?.length ? profiles : this.getBaseDefaults(group);
    }
    setGroupDefaultProfiles(group, profiles) {
        const next = {
            ...this.preferredDefaults.get(),
            [group]: ( profiles.map(c => ({ profileId: c.profileId, controllerId: c.controllerId }))),
        };
        if (group === 2  || group === 4 ) {
            const otherGroup = group === 2  ? 4  : 2 ;
            const previousDefaults = next[otherGroup] || [];
            let newDefaults = previousDefaults.slice();
            for (const [ctrlId, { profiles: ctrlProfiles }] of this.controllerProfiles) {
                const labels = ( new Set(( profiles.filter(p => p.controllerId === ctrlId).map(p => p.label))));
                const nextByLabels = ctrlProfiles.filter(p => ( labels.has(p.label)) && p.group === otherGroup);
                if (nextByLabels.length) {
                    newDefaults = newDefaults.filter(p => p.controllerId !== ctrlId);
                    newDefaults.push(...( nextByLabels.map(p => ({ profileId: p.profileId, controllerId: p.controllerId }))));
                }
            }
            next[otherGroup] = newDefaults;
        }
        this.preferredDefaults.store(next);
        this.changeEmitter.fire();
    }
    getBaseDefaults(group) {
        const defaults = [];
        for (const { profiles } of ( this.controllerProfiles.values())) {
            const profile = profiles.find(c => c.group === group);
            if (profile) {
                defaults.push(profile);
            }
        }
        return defaults;
    }
    refreshContextKeys() {
        let allCapabilities = 0;
        for (const { profiles } of ( this.controllerProfiles.values())) {
            for (const profile of profiles) {
                allCapabilities |= allCapabilities & profile.group ? 16  : profile.group;
                allCapabilities |= profile.supportsContinuousRun ? 64  : 0;
            }
        }
        for (const group of testRunProfileBitsetList) {
            this.capabilitiesContexts[group].set((allCapabilities & group) !== 0);
        }
    }
};
TestProfileService = ( __decorate([
    ( __param(0, IContextKeyService)),
    ( __param(1, IStorageService))
], TestProfileService));
export { ITestProfileService, TestProfileService, canUseProfileWithTest, capabilityContextKeys };
