import { TextSearchMatch } from '../../../services/search/common/search.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { PieceTreeTextBufferBuilder } from 'monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';
import { SearchParams } from 'monaco-editor/esm/vs/editor/common/model/textModelSearch.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
function isIFileMatchWithCells(object) {
    return 'cellResults' in object;
}
function contentMatchesToTextSearchMatches(contentMatches, cell) {
    return genericCellMatchesToTextSearchMatches(contentMatches, cell instanceof CellSearchModel ? cell.inputTextBuffer : cell.textBuffer);
}
function genericCellMatchesToTextSearchMatches(contentMatches, buffer, cell) {
    let previousEndLine = -1;
    const contextGroupings = [];
    let currentContextGrouping = [];
    contentMatches.forEach((match) => {
        if (match.range.startLineNumber !== previousEndLine) {
            if (currentContextGrouping.length > 0) {
                contextGroupings.push([...currentContextGrouping]);
                currentContextGrouping = [];
            }
        }
        currentContextGrouping.push(match);
        previousEndLine = match.range.endLineNumber;
    });
    if (currentContextGrouping.length > 0) {
        contextGroupings.push([...currentContextGrouping]);
    }
    const textSearchResults = ( contextGroupings.map((grouping) => {
        const lineTexts = [];
        const firstLine = grouping[0].range.startLineNumber;
        const lastLine = grouping[grouping.length - 1].range.endLineNumber;
        for (let i = firstLine; i <= lastLine; i++) {
            lineTexts.push(buffer.getLineContent(i));
        }
        return ( new TextSearchMatch(lineTexts.join('\n') + '\n', ( grouping.map(m => ( new Range(
            m.range.startLineNumber - 1,
            m.range.startColumn - 1,
            m.range.endLineNumber - 1,
            m.range.endColumn - 1
        ))))));
    }));
    return textSearchResults;
}
function webviewMatchesToTextSearchMatches(webviewMatches) {
    return ( webviewMatches
        .map(rawMatch => (rawMatch.searchPreviewInfo) ?
        ( new TextSearchMatch(rawMatch.searchPreviewInfo.line, ( new Range(
            0,
            rawMatch.searchPreviewInfo.range.start,
            0,
            rawMatch.searchPreviewInfo.range.end
        )), undefined, rawMatch.index)) : undefined)).filter((e) => !!e);
}
const rawCellPrefix = 'rawCell#';
class CellSearchModel extends Disposable {
    constructor(_source, _inputTextBuffer, _outputs, _uri, _cellIndex) {
        super();
        this._source = _source;
        this._inputTextBuffer = _inputTextBuffer;
        this._outputs = _outputs;
        this._uri = _uri;
        this._cellIndex = _cellIndex;
        this._outputTextBuffers = undefined;
    }
    get id() {
        return `${rawCellPrefix}${this._cellIndex}`;
    }
    get uri() {
        return this._uri;
    }
    _getFullModelRange(buffer) {
        const lineCount = buffer.getLineCount();
        return ( new Range(1, 1, lineCount, this._getLineMaxColumn(buffer, lineCount)));
    }
    _getLineMaxColumn(buffer, lineNumber) {
        if (lineNumber < 1 || lineNumber > buffer.getLineCount()) {
            throw new Error('Illegal value for lineNumber');
        }
        return buffer.getLineLength(lineNumber) + 1;
    }
    get inputTextBuffer() {
        if (!this._inputTextBuffer) {
            const builder = ( new PieceTreeTextBufferBuilder());
            builder.acceptChunk(this._source);
            const bufferFactory = builder.finish(true);
            const { textBuffer, disposable } = bufferFactory.create(1 );
            this._inputTextBuffer = textBuffer;
            this._register(disposable);
        }
        return this._inputTextBuffer;
    }
    get outputTextBuffers() {
        if (!this._outputTextBuffers) {
            this._outputTextBuffers = ( this._outputs.map((output) => {
                const builder = ( new PieceTreeTextBufferBuilder());
                builder.acceptChunk(( output.data.toString()));
                const bufferFactory = builder.finish(true);
                const { textBuffer, disposable } = bufferFactory.create(1 );
                this._register(disposable);
                return textBuffer;
            }));
        }
        return this._outputTextBuffers;
    }
    findInInputs(target) {
        const searchParams = ( new SearchParams(target, false, false, null));
        const searchData = searchParams.parseSearchRequest();
        if (!searchData) {
            return [];
        }
        const fullInputRange = this._getFullModelRange(this.inputTextBuffer);
        return this.inputTextBuffer.findMatchesLineByLine(fullInputRange, searchData, true, 5000);
    }
    findInOutputs(target) {
        const searchParams = ( new SearchParams(target, false, false, null));
        const searchData = searchParams.parseSearchRequest();
        if (!searchData) {
            return [];
        }
        return ( this.outputTextBuffers.map(buffer => {
            const matches = buffer.findMatchesLineByLine(this._getFullModelRange(buffer), searchData, true, 5000);
            if (matches.length === 0) {
                return undefined;
            }
            return {
                textBuffer: buffer,
                matches
            };
        })).filter((item) => !!item);
    }
}
export { CellSearchModel, contentMatchesToTextSearchMatches, genericCellMatchesToTextSearchMatches, isIFileMatchWithCells, rawCellPrefix, webviewMatchesToTextSearchMatches };
