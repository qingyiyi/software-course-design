import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { getCodeEditor } from 'monaco-editor/esm/vs/editor/browser/editorBrowser.js';
import { registerEditorAction, EditorAction } from 'monaco-editor/esm/vs/editor/browser/editorExtensions.js';
import { EditorContextKeys } from 'monaco-editor/esm/vs/editor/common/editorContextKeys.js';
import * as nls from 'monaco-editor/esm/vs/nls.js';
import { ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { CancellationToken, CancellationTokenSource } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { FormattingConflicts, getRealAndSyntheticDocumentFormattersOrdered, formatDocumentWithProvider, formatDocumentRangesWithProvider } from 'monaco-editor/esm/vs/editor/contrib/format/browser/format.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { ExtensionIdentifier } from 'monaco-editor/esm/vs/platform/extensions/common/extensions.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions as Extensions$1 } from 'monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js';
import { Extensions } from '../../../common/contributions.js';
import { toExtension, IExtensionService } from '../../../services/extensions/common/extensions.js';
import { Disposable, DisposableStore, toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { Severity, NotificationPriority, INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { IWorkbenchExtensionEnablementService } from '../../../services/extensionManagement/common/extensionManagement.js';
import { editorConfigurationBaseNode } from 'monaco-editor/esm/vs/editor/common/config/editorConfigurationSchema.js';
import '../../../../../../../override/vs/platform/dialogs/common/dialogs.js';
import { ILanguageFeaturesService } from 'monaco-editor/esm/vs/editor/common/services/languageFeatures.js';
import { ILanguageStatusService } from '../../../services/languageStatus/common/languageStatusService.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';
import { CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { generateUuid } from 'monaco-editor/esm/vs/base/common/uuid.js';
import { IDialogService } from '../../../../platform/dialogs/common/dialogs.js';
var DefaultFormatter_1;
let DefaultFormatter = class DefaultFormatter extends Disposable {
    static { DefaultFormatter_1 = this; }
    static { this.configName = 'editor.defaultFormatter'; }
    static { this.extensionIds = []; }
    static { this.extensionItemLabels = []; }
    static { this.extensionDescriptions = []; }
    constructor(_extensionService, _extensionEnablementService, _configService, _notificationService, _dialogService, _quickInputService, _languageService, _languageFeaturesService, _languageStatusService, _editorService) {
        super();
        this._extensionService = _extensionService;
        this._extensionEnablementService = _extensionEnablementService;
        this._configService = _configService;
        this._notificationService = _notificationService;
        this._dialogService = _dialogService;
        this._quickInputService = _quickInputService;
        this._languageService = _languageService;
        this._languageFeaturesService = _languageFeaturesService;
        this._languageStatusService = _languageStatusService;
        this._editorService = _editorService;
        this._languageStatusStore = this._store.add(( new DisposableStore()));
        this._store.add(this._extensionService.onDidChangeExtensions(this._updateConfigValues, this));
        this._store.add(FormattingConflicts.setFormatterSelector((formatter, document, mode) => this._selectFormatter(formatter, document, mode)));
        this._store.add(_editorService.onDidActiveEditorChange(this._updateStatus, this));
        this._store.add(_languageFeaturesService.documentFormattingEditProvider.onDidChange(this._updateStatus, this));
        this._store.add(_languageFeaturesService.documentRangeFormattingEditProvider.onDidChange(this._updateStatus, this));
        this._store.add(_configService.onDidChangeConfiguration(e => e.affectsConfiguration(DefaultFormatter_1.configName) && this._updateStatus()));
        this._updateConfigValues();
    }
    async _updateConfigValues() {
        await this._extensionService.whenInstalledExtensionsRegistered();
        let extensions = [...this._extensionService.extensions];
        extensions = extensions.sort((a, b) => {
            const boostA = a.categories?.find(cat => cat === 'Formatters' || cat === 'Programming Languages');
            const boostB = b.categories?.find(cat => cat === 'Formatters' || cat === 'Programming Languages');
            if (boostA && !boostB) {
                return -1;
            }
            else if (!boostA && boostB) {
                return 1;
            }
            else {
                return a.name.localeCompare(b.name);
            }
        });
        DefaultFormatter_1.extensionIds.length = 0;
        DefaultFormatter_1.extensionItemLabels.length = 0;
        DefaultFormatter_1.extensionDescriptions.length = 0;
        DefaultFormatter_1.extensionIds.push(null);
        DefaultFormatter_1.extensionItemLabels.push(( nls.localizeWithPath(
            'vs/workbench/contrib/format/browser/formatActionsMultiple',
            'null',
            'None'
        )));
        DefaultFormatter_1.extensionDescriptions.push(( nls.localizeWithPath(
            'vs/workbench/contrib/format/browser/formatActionsMultiple',
            'nullFormatterDescription',
            "None"
        )));
        for (const extension of extensions) {
            if (extension.main || extension.browser) {
                DefaultFormatter_1.extensionIds.push(extension.identifier.value);
                DefaultFormatter_1.extensionItemLabels.push(extension.displayName ?? '');
                DefaultFormatter_1.extensionDescriptions.push(extension.description ?? '');
            }
        }
    }
    static _maybeQuotes(s) {
        return s.match(/\s/) ? `'${s}'` : s;
    }
    async _analyzeFormatter(formatter, document) {
        const defaultFormatterId = this._configService.getValue(DefaultFormatter_1.configName, {
            resource: document.uri,
            overrideIdentifier: document.getLanguageId()
        });
        if (defaultFormatterId) {
            const defaultFormatter = formatter.find(formatter => ExtensionIdentifier.equals(formatter.extensionId, defaultFormatterId));
            if (defaultFormatter) {
                return defaultFormatter;
            }
            const extension = await this._extensionService.getExtension(defaultFormatterId);
            if (extension && this._extensionEnablementService.isEnabled(toExtension(extension))) {
                const langName = this._languageService.getLanguageName(document.getLanguageId()) || document.getLanguageId();
                const detail = ( nls.localizeWithPath(
                    'vs/workbench/contrib/format/browser/formatActionsMultiple',
                    'miss',
                    "Extension '{0}' is configured as formatter but it cannot format '{1}'-files",
                    extension.displayName || extension.name,
                    langName
                ));
                return detail;
            }
        }
        else if (formatter.length === 1) {
            return formatter[0];
        }
        const langName = this._languageService.getLanguageName(document.getLanguageId()) || document.getLanguageId();
        const message = !defaultFormatterId
            ? ( nls.localizeWithPath(
            'vs/workbench/contrib/format/browser/formatActionsMultiple',
            'config.needed',
            "There are multiple formatters for '{0}' files. One of them should be configured as default formatter.",
            DefaultFormatter_1._maybeQuotes(langName)
        ))
            : ( nls.localizeWithPath(
            'vs/workbench/contrib/format/browser/formatActionsMultiple',
            'config.bad',
            "Extension '{0}' is configured as formatter but not available. Select a different default formatter to continue.",
            defaultFormatterId
        ));
        return message;
    }
    async _selectFormatter(formatter, document, mode) {
        const formatterOrMessage = await this._analyzeFormatter(formatter, document);
        if (typeof formatterOrMessage !== 'string') {
            return formatterOrMessage;
        }
        if (mode !== 2 ) {
            const { confirmed } = await this._dialogService.confirm({
                message: ( nls.localizeWithPath(
                    'vs/workbench/contrib/format/browser/formatActionsMultiple',
                    'miss.1',
                    "Configure Default Formatter"
                )),
                detail: formatterOrMessage,
                primaryButton: ( nls.localizeWithPath(
                    'vs/workbench/contrib/format/browser/formatActionsMultiple',
                    { key: 'do.config', comment: ['&& denotes a mnemonic'] },
                    "&&Configure..."
                ))
            });
            if (confirmed) {
                return this._pickAndPersistDefaultFormatter(formatter, document);
            }
        }
        else {
            this._notificationService.prompt(Severity.Info, formatterOrMessage, [{ label: ( nls.localizeWithPath(
                'vs/workbench/contrib/format/browser/formatActionsMultiple',
                'do.config.notification',
                "Configure..."
            )), run: () => this._pickAndPersistDefaultFormatter(formatter, document) }], { priority: NotificationPriority.SILENT });
        }
        return undefined;
    }
    async _pickAndPersistDefaultFormatter(formatter, document) {
        const picks = ( formatter.map((formatter, index) => {
            return {
                index,
                label: formatter.displayName || (formatter.extensionId ? formatter.extensionId.value : '?'),
                description: formatter.extensionId && formatter.extensionId.value
            };
        }));
        const langName = this._languageService.getLanguageName(document.getLanguageId()) || document.getLanguageId();
        const pick = await this._quickInputService.pick(picks, { placeHolder: ( nls.localizeWithPath(
            'vs/workbench/contrib/format/browser/formatActionsMultiple',
            'select',
            "Select a default formatter for '{0}' files",
            DefaultFormatter_1._maybeQuotes(langName)
        )) });
        if (!pick || !formatter[pick.index].extensionId) {
            return undefined;
        }
        this._configService.updateValue(DefaultFormatter_1.configName, formatter[pick.index].extensionId.value, {
            resource: document.uri,
            overrideIdentifier: document.getLanguageId()
        });
        return formatter[pick.index];
    }
    _updateStatus() {
        this._languageStatusStore.clear();
        const editor = getCodeEditor(this._editorService.activeTextEditorControl);
        if (!editor || !editor.hasModel()) {
            return;
        }
        const document = editor.getModel();
        const formatter = getRealAndSyntheticDocumentFormattersOrdered(this._languageFeaturesService.documentFormattingEditProvider, this._languageFeaturesService.documentRangeFormattingEditProvider, document);
        if (formatter.length === 0) {
            return;
        }
        const cts = ( new CancellationTokenSource());
        this._languageStatusStore.add(toDisposable(() => cts.dispose(true)));
        this._analyzeFormatter(formatter, document).then(result => {
            if (cts.token.isCancellationRequested) {
                return;
            }
            if (typeof result !== 'string') {
                return;
            }
            const command = { id: `formatter/configure/dfl/${generateUuid()}`, title: ( nls.localizeWithPath(
                'vs/workbench/contrib/format/browser/formatActionsMultiple',
                'do.config.command',
                "Configure..."
            )) };
            this._languageStatusStore.add(CommandsRegistry.registerCommand(command.id, () => this._pickAndPersistDefaultFormatter(formatter, document)));
            this._languageStatusStore.add(this._languageStatusService.addStatus({
                id: 'formatter.conflict',
                name: ( nls.localizeWithPath(
                    'vs/workbench/contrib/format/browser/formatActionsMultiple',
                    'summary',
                    "Formatter Conflicts"
                )),
                selector: { language: document.getLanguageId(), pattern: document.uri.fsPath },
                severity: Severity.Error,
                label: ( nls.localizeWithPath(
                    'vs/workbench/contrib/format/browser/formatActionsMultiple',
                    'formatter',
                    "Formatting"
                )),
                detail: result,
                busy: false,
                source: '',
                command,
                accessibilityInfo: undefined
            }));
        });
    }
};
DefaultFormatter = DefaultFormatter_1 = ( __decorate([
    ( __param(0, IExtensionService)),
    ( __param(1, IWorkbenchExtensionEnablementService)),
    ( __param(2, IConfigurationService)),
    ( __param(3, INotificationService)),
    ( __param(4, IDialogService)),
    ( __param(5, IQuickInputService)),
    ( __param(6, ILanguageService)),
    ( __param(7, ILanguageFeaturesService)),
    ( __param(8, ILanguageStatusService)),
    ( __param(9, IEditorService))
], DefaultFormatter));
( Registry.as(Extensions.Workbench)).registerWorkbenchContribution(DefaultFormatter, 3 );
( Registry.as(Extensions$1.Configuration)).registerConfiguration({
    ...editorConfigurationBaseNode,
    properties: {
        [DefaultFormatter.configName]: {
            description: ( nls.localizeWithPath(
                'vs/workbench/contrib/format/browser/formatActionsMultiple',
                'formatter.default',
                "Defines a default formatter which takes precedence over all other formatter settings. Must be the identifier of an extension contributing a formatter."
            )),
            type: ['string', 'null'],
            default: null,
            enum: DefaultFormatter.extensionIds,
            enumItemLabels: DefaultFormatter.extensionItemLabels,
            markdownEnumDescriptions: DefaultFormatter.extensionDescriptions
        }
    }
});
function logFormatterTelemetry(telemetryService, mode, options, pick) {
    function extKey(obj) {
        return obj.extensionId ? ExtensionIdentifier.toKey(obj.extensionId) : 'unknown';
    }
    telemetryService.publicLog2('formatterpick', {
        mode,
        extensions: ( options.map(extKey)),
        pick: pick ? extKey(pick) : 'none'
    });
}
async function showFormatterPick(accessor, model, formatters) {
    const quickPickService = accessor.get(IQuickInputService);
    const configService = accessor.get(IConfigurationService);
    const languageService = accessor.get(ILanguageService);
    const overrides = { resource: model.uri, overrideIdentifier: model.getLanguageId() };
    const defaultFormatter = configService.getValue(DefaultFormatter.configName, overrides);
    let defaultFormatterPick;
    const picks = ( formatters.map((provider, index) => {
        const isDefault = ExtensionIdentifier.equals(provider.extensionId, defaultFormatter);
        const pick = {
            index,
            label: provider.displayName || '',
            description: isDefault ? ( nls.localizeWithPath(
                'vs/workbench/contrib/format/browser/formatActionsMultiple',
                'def',
                "(default)"
            )) : undefined,
        };
        if (isDefault) {
            defaultFormatterPick = pick;
        }
        return pick;
    }));
    const configurePick = {
        label: ( nls.localizeWithPath(
            'vs/workbench/contrib/format/browser/formatActionsMultiple',
            'config',
            "Configure Default Formatter..."
        ))
    };
    const pick = await quickPickService.pick([...picks, { type: 'separator' }, configurePick], {
        placeHolder: ( nls.localizeWithPath(
            'vs/workbench/contrib/format/browser/formatActionsMultiple',
            'format.placeHolder',
            "Select a formatter"
        )),
        activeItem: defaultFormatterPick
    });
    if (!pick) {
        return undefined;
    }
    else if (pick === configurePick) {
        const langName = languageService.getLanguageName(model.getLanguageId()) || model.getLanguageId();
        const pick = await quickPickService.pick(picks, { placeHolder: ( nls.localizeWithPath(
            'vs/workbench/contrib/format/browser/formatActionsMultiple',
            'select',
            "Select a default formatter for '{0}' files",
            DefaultFormatter._maybeQuotes(langName)
        )) });
        if (pick && formatters[pick.index].extensionId) {
            configService.updateValue(DefaultFormatter.configName, formatters[pick.index].extensionId.value, overrides);
        }
        return undefined;
    }
    else {
        return pick.index;
    }
}
registerEditorAction(class FormatDocumentMultipleAction extends EditorAction {
    constructor() {
        super({
            id: 'editor.action.formatDocument.multiple',
            label: ( nls.localizeWithPath(
                'vs/workbench/contrib/format/browser/formatActionsMultiple',
                'formatDocument.label.multiple',
                "Format Document With..."
            )),
            alias: 'Format Document...',
            precondition: ( ContextKeyExpr.and(
                EditorContextKeys.writable,
                EditorContextKeys.hasMultipleDocumentFormattingProvider
            )),
            contextMenuOpts: {
                group: '1_modification',
                order: 1.3
            }
        });
    }
    async run(accessor, editor, args) {
        if (!editor.hasModel()) {
            return;
        }
        const instaService = accessor.get(IInstantiationService);
        const telemetryService = accessor.get(ITelemetryService);
        const languageFeaturesService = accessor.get(ILanguageFeaturesService);
        const model = editor.getModel();
        const provider = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);
        const pick = await instaService.invokeFunction(showFormatterPick, model, provider);
        if (typeof pick === 'number') {
            await instaService.invokeFunction(formatDocumentWithProvider, provider[pick], editor, 1 , CancellationToken.None);
        }
        logFormatterTelemetry(telemetryService, 'document', provider, typeof pick === 'number' && provider[pick] || undefined);
    }
});
registerEditorAction(class FormatSelectionMultipleAction extends EditorAction {
    constructor() {
        super({
            id: 'editor.action.formatSelection.multiple',
            label: ( nls.localizeWithPath(
                'vs/workbench/contrib/format/browser/formatActionsMultiple',
                'formatSelection.label.multiple',
                "Format Selection With..."
            )),
            alias: 'Format Code...',
            precondition: ( ContextKeyExpr.and(( ContextKeyExpr.and(EditorContextKeys.writable)), EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider)),
            contextMenuOpts: {
                when: ( ContextKeyExpr.and(EditorContextKeys.hasNonEmptySelection)),
                group: '1_modification',
                order: 1.31
            }
        });
    }
    async run(accessor, editor) {
        if (!editor.hasModel()) {
            return;
        }
        const instaService = accessor.get(IInstantiationService);
        const languageFeaturesService = accessor.get(ILanguageFeaturesService);
        const telemetryService = accessor.get(ITelemetryService);
        const model = editor.getModel();
        let range = editor.getSelection();
        if (range.isEmpty()) {
            range = ( new Range(
                range.startLineNumber,
                1,
                range.startLineNumber,
                model.getLineMaxColumn(range.startLineNumber)
            ));
        }
        const provider = languageFeaturesService.documentRangeFormattingEditProvider.ordered(model);
        const pick = await instaService.invokeFunction(showFormatterPick, model, provider);
        if (typeof pick === 'number') {
            await instaService.invokeFunction(formatDocumentRangesWithProvider, provider[pick], editor, range, CancellationToken.None);
        }
        logFormatterTelemetry(telemetryService, 'range', provider, typeof pick === 'number' && provider[pick] || undefined);
    }
});
