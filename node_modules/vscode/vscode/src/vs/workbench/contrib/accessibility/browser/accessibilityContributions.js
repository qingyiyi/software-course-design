import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { AccessibilityHelpNLS } from 'monaco-editor/esm/vs/editor/common/standaloneStrings.js';
import { ToggleTabFocusModeAction } from 'monaco-editor/esm/vs/editor/contrib/toggleTabFocusMode/browser/toggleTabFocusMode.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { accessibleViewIsShown } from './accessibilityConfiguration.js';
import * as strings from 'monaco-editor/esm/vs/base/common/strings.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { NEW_UNTITLED_FILE_COMMAND_ID } from '../../files/browser/fileConstants.js';
import { ModesHoverController } from 'monaco-editor/esm/vs/editor/contrib/hover/browser/hover.js';
import { IContextViewService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { EditorContextKeys } from 'monaco-editor/esm/vs/editor/common/editorContextKeys.js';
import { getNotificationFromContext } from '../../../browser/parts/notifications/notificationsCommands.js';
import { IListService, WorkbenchList } from 'monaco-editor/esm/vs/platform/list/browser/listService.js';
import { NotificationFocusedContext } from '../../../common/contextkeys.js';
import { IAccessibleViewService } from './accessibleView.js';
import { IHoverService } from '../../../services/hover/browser/hover.js';
import { alert } from 'monaco-editor/esm/vs/base/browser/ui/aria/aria.js';
import { AccessibilityHelpAction, AccessibleViewAction } from './accessibleViewActions.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { InlineCompletionsController } from 'monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsController.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { CommentContextKeys } from '../../comments/common/commentContextKeys.js';
import { CommentAccessibilityHelpNLS } from '../../comments/browser/comments.contribution.js';
class EditorAccessibilityHelpContribution extends Disposable {
    constructor() {
        super();
        this._register(AccessibilityHelpAction.addImplementation(95, 'editor', async (accessor) => {
            const codeEditorService = accessor.get(ICodeEditorService);
            const accessibleViewService = accessor.get(IAccessibleViewService);
            const instantiationService = accessor.get(IInstantiationService);
            const commandService = accessor.get(ICommandService);
            let codeEditor = codeEditorService.getActiveCodeEditor() || codeEditorService.getFocusedCodeEditor();
            if (!codeEditor) {
                await commandService.executeCommand(NEW_UNTITLED_FILE_COMMAND_ID);
                codeEditor = codeEditorService.getActiveCodeEditor();
            }
            accessibleViewService.show(instantiationService.createInstance(EditorAccessibilityHelpProvider, codeEditor));
        }, EditorContextKeys.focus));
    }
}
let EditorAccessibilityHelpProvider = class EditorAccessibilityHelpProvider {
    onClose() {
        this._editor.focus();
    }
    constructor(_editor, _keybindingService, _contextKeyService) {
        this._editor = _editor;
        this._keybindingService = _keybindingService;
        this._contextKeyService = _contextKeyService;
        this.options = { type: "help" , readMoreUrl: 'https://go.microsoft.com/fwlink/?linkid=851010' };
        this.verbositySettingKey = "accessibility.verbosity.editor" ;
    }
    provideContent() {
        const options = this._editor.getOptions();
        const content = [];
        if (options.get(61 )) {
            if (options.get(90 )) {
                content.push(AccessibilityHelpNLS.readonlyDiffEditor);
            }
            else {
                content.push(AccessibilityHelpNLS.editableDiffEditor);
            }
        }
        else {
            if (options.get(90 )) {
                content.push(AccessibilityHelpNLS.readonlyEditor);
            }
            else {
                content.push(AccessibilityHelpNLS.editableEditor);
            }
        }
        const commentCommandInfo = getCommentCommandInfo(this._keybindingService, this._contextKeyService, this._editor);
        if (commentCommandInfo) {
            content.push(commentCommandInfo);
        }
        if (options.get(114 ).enabled) {
            content.push(descriptionForCommand('editor.action.focusStickyScroll', AccessibilityHelpNLS.stickScrollKb, AccessibilityHelpNLS.stickScrollNoKb, this._keybindingService));
        }
        if (options.get(142 )) {
            content.push(descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOnMsg, AccessibilityHelpNLS.tabFocusModeOnMsgNoKb, this._keybindingService));
        }
        else {
            content.push(descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOffMsg, AccessibilityHelpNLS.tabFocusModeOffMsgNoKb, this._keybindingService));
        }
        return content.join('\n\n');
    }
};
EditorAccessibilityHelpProvider = ( __decorate([
    ( __param(1, IKeybindingService)),
    ( __param(2, IContextKeyService))
], EditorAccessibilityHelpProvider));
function getCommentCommandInfo(keybindingService, contextKeyService, editor) {
    const editorContext = contextKeyService.getContext(editor.getDomNode());
    if (editorContext.getValue(CommentContextKeys.activeEditorHasCommentingRange.key)) {
        const commentCommandInfo = [];
        commentCommandInfo.push(CommentAccessibilityHelpNLS.intro);
        commentCommandInfo.push(descriptionForCommand("workbench.action.addComment" , CommentAccessibilityHelpNLS.addComment, CommentAccessibilityHelpNLS.addCommentNoKb, keybindingService));
        commentCommandInfo.push(descriptionForCommand("editor.action.nextCommentThreadAction" , CommentAccessibilityHelpNLS.nextCommentThreadKb, CommentAccessibilityHelpNLS.nextCommentThreadNoKb, keybindingService));
        commentCommandInfo.push(descriptionForCommand("editor.action.previousCommentThreadAction" , CommentAccessibilityHelpNLS.previousCommentThreadKb, CommentAccessibilityHelpNLS.previousCommentThreadNoKb, keybindingService));
        commentCommandInfo.push(descriptionForCommand("editor.action.nextCommentingRange" , CommentAccessibilityHelpNLS.nextRange, CommentAccessibilityHelpNLS.nextRangeNoKb, keybindingService));
        commentCommandInfo.push(descriptionForCommand("editor.action.previousCommentingRange" , CommentAccessibilityHelpNLS.previousRange, CommentAccessibilityHelpNLS.previousRangeNoKb, keybindingService));
        return commentCommandInfo.join('\n');
    }
    return;
}
function descriptionForCommand(commandId, msg, noKbMsg, keybindingService) {
    const kb = keybindingService.lookupKeybinding(commandId);
    if (kb) {
        return strings.format(msg, kb.getAriaLabel());
    }
    return strings.format(noKbMsg, commandId);
}
class HoverAccessibleViewContribution extends Disposable {
    constructor() {
        super();
        this._options = { language: 'typescript', type: "view"  };
        this._register(AccessibleViewAction.addImplementation(95, 'hover', accessor => {
            const accessibleViewService = accessor.get(IAccessibleViewService);
            const codeEditorService = accessor.get(ICodeEditorService);
            const editor = codeEditorService.getActiveCodeEditor() || codeEditorService.getFocusedCodeEditor();
            const editorHoverContent = editor ? ModesHoverController.get(editor)?.getWidgetContent() ?? undefined : undefined;
            if (!editor || !editorHoverContent) {
                return false;
            }
            this._options.language = editor?.getModel()?.getLanguageId() ?? undefined;
            accessibleViewService.show({
                verbositySettingKey: "accessibility.verbosity.hover" ,
                provideContent() { return editorHoverContent; },
                onClose() {
                    ModesHoverController.get(editor)?.focus();
                },
                options: this._options
            });
            return true;
        }, EditorContextKeys.hoverFocused));
        this._register(AccessibleViewAction.addImplementation(90, 'extension-hover', accessor => {
            const accessibleViewService = accessor.get(IAccessibleViewService);
            const contextViewService = accessor.get(IContextViewService);
            const contextViewElement = contextViewService.getContextViewElement();
            const extensionHoverContent = contextViewElement?.textContent ?? undefined;
            const hoverService = accessor.get(IHoverService);
            if (contextViewElement.classList.contains('accessible-view-container') || !extensionHoverContent) {
                return false;
            }
            accessibleViewService.show({
                verbositySettingKey: "accessibility.verbosity.hover" ,
                provideContent() { return extensionHoverContent; },
                onClose() {
                    hoverService.showAndFocusLastHover();
                },
                options: this._options
            });
            return true;
        }));
        this._register(AccessibilityHelpAction.addImplementation(115, 'accessible-view', accessor => {
            accessor.get(IAccessibleViewService).showAccessibleViewHelp();
            return true;
        }, accessibleViewIsShown));
    }
}
class NotificationAccessibleViewContribution extends Disposable {
    constructor() {
        super();
        this._register(AccessibleViewAction.addImplementation(90, 'notifications', accessor => {
            const accessibleViewService = accessor.get(IAccessibleViewService);
            const listService = accessor.get(IListService);
            const commandService = accessor.get(ICommandService);
            function renderAccessibleView() {
                const notification = getNotificationFromContext(listService);
                if (!notification) {
                    return false;
                }
                commandService.executeCommand('notifications.showList');
                let notificationIndex;
                let length;
                const list = listService.lastFocusedList;
                if (list instanceof WorkbenchList) {
                    notificationIndex = list.indexOf(notification);
                    length = list.length;
                }
                if (notificationIndex === undefined) {
                    return false;
                }
                function focusList() {
                    commandService.executeCommand('notifications.showList');
                    if (list && notificationIndex !== undefined) {
                        list.domFocus();
                        try {
                            list.setFocus([notificationIndex]);
                        }
                        catch { }
                    }
                }
                const message = ( notification.message.original.toString());
                if (!message) {
                    return false;
                }
                notification.onDidClose(() => accessibleViewService.next());
                accessibleViewService.show({
                    provideContent: () => {
                        return notification.source ? ( localizeWithPath(
                            'vs/workbench/contrib/accessibility/browser/accessibilityContributions',
                            'notification.accessibleViewSrc',
                            '{0} Source: {1}',
                            message,
                            notification.source
                        )) : ( localizeWithPath(
                            'vs/workbench/contrib/accessibility/browser/accessibilityContributions',
                            'notification.accessibleView',
                            '{0}',
                            message
                        ));
                    },
                    onClose() {
                        focusList();
                    },
                    next() {
                        if (!list) {
                            return;
                        }
                        focusList();
                        list.focusNext();
                        alertFocusChange(notificationIndex, length, 'next');
                        renderAccessibleView();
                    },
                    previous() {
                        if (!list) {
                            return;
                        }
                        focusList();
                        list.focusPrevious();
                        alertFocusChange(notificationIndex, length, 'previous');
                        renderAccessibleView();
                    },
                    verbositySettingKey: "accessibility.verbosity.notification" ,
                    options: { type: "view"  },
                    actions: getActionsFromNotification(notification)
                });
                return true;
            }
            return renderAccessibleView();
        }, NotificationFocusedContext));
    }
}
function getActionsFromNotification(notification) {
    let actions = undefined;
    if (notification.actions) {
        actions = [];
        if (notification.actions.primary) {
            actions.push(...notification.actions.primary);
        }
        if (notification.actions.secondary) {
            actions.push(...notification.actions.secondary);
        }
    }
    if (actions) {
        for (const action of actions) {
            action.class = ThemeIcon.asClassName(Codicon.bell);
            const initialAction = action.run;
            action.run = () => {
                initialAction();
                notification.close();
            };
        }
    }
    const manageExtension = actions?.find(a => a.label.includes('Manage Extension'));
    if (manageExtension) {
        manageExtension.class = ThemeIcon.asClassName(Codicon.gear);
    }
    if (actions) {
        actions.push({ id: 'clearNotification', label: ( localizeWithPath(
            'vs/workbench/contrib/accessibility/browser/accessibilityContributions',
            'clearNotification',
            "Clear Notification"
        )), tooltip: ( localizeWithPath(
            'vs/workbench/contrib/accessibility/browser/accessibilityContributions',
            'clearNotification',
            "Clear Notification"
        )), run: () => notification.close(), enabled: true, class: ThemeIcon.asClassName(Codicon.clearAll) });
    }
    return actions;
}
function alertFocusChange(index, length, type) {
    if (index === undefined || length === undefined) {
        return;
    }
    const number = index + 1;
    if (type === 'next' && number + 1 <= length) {
        alert(`Focused ${number + 1} of ${length}`);
    }
    else if (type === 'previous' && number - 1 > 0) {
        alert(`Focused ${number - 1} of ${length}`);
    }
    return;
}
class InlineCompletionsAccessibleViewContribution extends Disposable {
    constructor() {
        super();
        this._options = { type: "view"  };
        this._register(AccessibleViewAction.addImplementation(95, 'inline-completions', accessor => {
            const accessibleViewService = accessor.get(IAccessibleViewService);
            const codeEditorService = accessor.get(ICodeEditorService);
            const show = () => {
                const editor = codeEditorService.getActiveCodeEditor() || codeEditorService.getFocusedCodeEditor();
                if (!editor) {
                    return false;
                }
                const model = InlineCompletionsController.get(editor)?.model.get();
                const state = model?.state.get();
                if (!model || !state) {
                    return false;
                }
                const lineText = model.textModel.getLineContent(state.ghostText.lineNumber);
                if (!lineText) {
                    return false;
                }
                const ghostText = state.ghostText.renderForScreenReader(lineText);
                if (!ghostText) {
                    return false;
                }
                this._options.language = editor.getModel()?.getLanguageId() ?? undefined;
                accessibleViewService.show({
                    verbositySettingKey: "accessibility.verbosity.inlineCompletions" ,
                    provideContent() { return lineText + ghostText; },
                    onClose() {
                        model.stop();
                        editor.focus();
                    },
                    next() {
                        model.next();
                        setTimeout(() => show(), 50);
                    },
                    previous() {
                        model.previous();
                        setTimeout(() => show(), 50);
                    },
                    options: this._options
                });
                return true;
            };
            return show();
        }));
    }
}
export { EditorAccessibilityHelpContribution, HoverAccessibleViewContribution, InlineCompletionsAccessibleViewContribution, NotificationAccessibleViewContribution, alertFocusChange, getCommentCommandInfo };
