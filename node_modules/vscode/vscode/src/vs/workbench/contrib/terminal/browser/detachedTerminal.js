import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { Delayer } from 'monaco-editor/esm/vs/base/common/async.js';
import { onUnexpectedError } from 'monaco-editor/esm/vs/base/common/errors.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { MicrotaskDelay } from 'monaco-editor/esm/vs/base/common/symbols.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { TerminalCapabilityStore } from '../../../../platform/terminal/common/capabilities/terminalCapabilityStore.js';
import { TerminalExtensionsRegistry } from './terminalExtensions.js';
import { TerminalWidgetManager } from './widgets/widgetManager.js';
let DeatachedTerminal = class DeatachedTerminal extends Disposable {
    get xterm() {
        return this._xterm;
    }
    constructor(_xterm, options, instantiationService) {
        super();
        this._xterm = _xterm;
        this._widgets = this._register(( new TerminalWidgetManager()));
        this.capabilities = ( new TerminalCapabilityStore());
        this._contributions = ( new Map());
        this._register(_xterm);
        const contributionDescs = TerminalExtensionsRegistry.getTerminalContributions();
        for (const desc of contributionDescs) {
            if (( this._contributions.has(desc.id))) {
                onUnexpectedError(( new Error(`Cannot have two terminal contributions with the same id ${desc.id}`)));
                continue;
            }
            if (desc.canRunInDetachedTerminals === false) {
                continue;
            }
            let contribution;
            try {
                contribution = instantiationService.createInstance(desc.ctor, this, options.processInfo, this._widgets);
                this._contributions.set(desc.id, contribution);
                this._register(contribution);
            }
            catch (err) {
                onUnexpectedError(err);
            }
        }
        this._register(( new Delayer(MicrotaskDelay))).trigger(() => {
            for (const contr of ( this._contributions.values())) {
                contr.xtermReady?.(this._xterm);
            }
        });
    }
    attachToElement(container, options) {
        const screenElement = this._xterm.attachToElement(container, options);
        this._widgets.attachToElement(screenElement);
    }
};
DeatachedTerminal = ( __decorate([
    ( __param(2, IInstantiationService))
], DeatachedTerminal));
class DetachedProcessInfo {
    constructor(initialValues) {
        this.processState = 3 ;
        this.ptyProcessReady = Promise.resolve();
        this.initialCwd = '';
        this.shouldPersist = false;
        this.hasWrittenData = false;
        this.hasChildProcesses = false;
        this.capabilities = ( new TerminalCapabilityStore());
        this.shellIntegrationNonce = '';
        Object.assign(this, initialValues);
    }
}
export { DeatachedTerminal, DetachedProcessInfo };
