import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { Iterable } from 'monaco-editor/esm/vs/base/common/iterator.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions } from '../../../common/contributions.js';
import { isProposedApiEnabled } from '../../../services/extensions/common/extensions.js';
import { ExtensionsRegistry } from '../../../services/extensions/common/extensionsRegistry.js';
const slashItem = {
    type: 'object',
    required: ['command', 'detail'],
    properties: {
        command: {
            type: 'string',
            markdownDescription: ( localizeWithPath(
                'vs/workbench/contrib/chat/common/chatSlashCommands',
                'command',
                "The name of the slash command which will be used as prefix."
            ))
        },
        detail: {
            type: 'string',
            markdownDescription: ( localizeWithPath(
                'vs/workbench/contrib/chat/common/chatSlashCommands',
                'details',
                "The details of the slash command."
            ))
        },
    }
};
const slashItems = {
    description: ( localizeWithPath(
        'vs/workbench/contrib/chat/common/chatSlashCommands',
        'vscode.extension.contributes.slashes',
        "Contributes slash commands to chat"
    )),
    oneOf: [
        slashItem,
        {
            type: 'array',
            items: slashItem
        }
    ]
};
const slashesExtPoint = ( ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'slashes',
    jsonSchema: slashItems
}));
function isChatSlashData(data) {
    return typeof data === 'object' && data &&
        typeof data.command === 'string' &&
        typeof data.detail === 'string' &&
        (typeof data.sortText === 'undefined' || typeof data.sortText === 'string') &&
        (typeof data.executeImmediately === 'undefined' || typeof data.executeImmediately === 'boolean');
}
const IChatSlashCommandService = ( createDecorator('chatSlashCommandService'));
let ChatSlashCommandContribution = class ChatSlashCommandContribution {
    constructor(slashCommandService) {
        const contributions = ( new DisposableStore());
        slashesExtPoint.setHandler(extensions => {
            contributions.clear();
            for (const entry of extensions) {
                if (!isProposedApiEnabled(entry.description, 'chatSlashCommands')) {
                    entry.collector.error(`The ${slashesExtPoint.name} is proposed API`);
                    continue;
                }
                const { value } = entry;
                for (const candidate of Iterable.wrap(value)) {
                    if (!isChatSlashData(candidate)) {
                        entry.collector.error(( localizeWithPath(
                            'vs/workbench/contrib/chat/common/chatSlashCommands',
                            'invalid',
                            "Invalid {0}: {1}",
                            slashesExtPoint.name,
                            JSON.stringify(candidate)
                        )));
                        continue;
                    }
                    contributions.add(slashCommandService.registerSlashData({ ...candidate }));
                }
            }
        });
    }
};
ChatSlashCommandContribution = ( __decorate([
    ( __param(0, IChatSlashCommandService))
], ChatSlashCommandContribution));
( Registry.as(Extensions.Workbench)).registerWorkbenchContribution(ChatSlashCommandContribution, 3 );
export { IChatSlashCommandService, slashesExtPoint };
