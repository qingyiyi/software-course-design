import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { Iterable } from 'monaco-editor/esm/vs/base/common/iterator.js';
import { Disposable, toDisposable, combinedDisposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions } from '../../../common/contributions.js';
import { isProposedApiEnabled } from '../../../services/extensions/common/extensions.js';
import { ExtensionsRegistry } from '../../../services/extensions/common/extensionsRegistry.js';
const agentItem = {
    type: 'object',
    required: ['agent', 'detail'],
    properties: {
        agent: {
            type: 'string',
            markdownDescription: ( localizeWithPath(
                'vs/workbench/contrib/chat/common/chatAgents',
                'agent',
                "The name of the agent which will be used as prefix."
            ))
        },
        detail: {
            type: 'string',
            markdownDescription: ( localizeWithPath(
                'vs/workbench/contrib/chat/common/chatAgents',
                'details',
                "The details of the agent."
            ))
        },
    }
};
const agentItems = {
    description: ( localizeWithPath(
        'vs/workbench/contrib/chat/common/chatAgents',
        'vscode.extension.contributes.slashes',
        "Contributes agents to chat"
    )),
    oneOf: [
        agentItem,
        {
            type: 'array',
            items: agentItem
        }
    ]
};
const agentsExtPoint = ( ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'agents',
    jsonSchema: agentItems
}));
function isAgentData(data) {
    return typeof data === 'object' && data &&
        typeof data.id === 'string' &&
        typeof data.detail === 'string';
}
const IChatAgentService = ( createDecorator('chatAgentService'));
(class ChatAgentService extends Disposable {
    static { this.AGENT_LEADER = '@'; }
    constructor(_extensionService) {
        super();
        this._extensionService = _extensionService;
        this._agents = ( new Map());
        this._onDidChangeAgents = this._register(( new Emitter()));
        this.onDidChangeAgents = this._onDidChangeAgents.event;
    }
    dispose() {
        super.dispose();
        this._agents.clear();
    }
    registerAgentData(data) {
        if (( this._agents.has(data.id))) {
            throw new Error(`Already registered an agent with id ${data.id}}`);
        }
        this._agents.set(data.id, { data });
        this._onDidChangeAgents.fire();
        return toDisposable(() => {
            if (this._agents.delete(data.id)) {
                this._onDidChangeAgents.fire();
            }
        });
    }
    registerAgentCallback(id, agentCallback) {
        const data = this._agents.get(id);
        if (!data) {
            throw new Error(`No agent with id ${id} registered`);
        }
        data.callback = agentCallback;
        return toDisposable(() => data.callback = undefined);
    }
    registerAgent(data, callback) {
        return combinedDisposable(this.registerAgentData(data), this.registerAgentCallback(data.id, callback));
    }
    getAgents() {
        return Array.from(( this._agents.values()), v => v.data);
    }
    hasAgent(id) {
        return ( this._agents.has(id));
    }
    getAgent(id) {
        const data = this._agents.get(id);
        return data?.data;
    }
    async invokeAgent(id, prompt, progress, history, token) {
        const data = this._agents.get(id);
        if (!data) {
            throw new Error('No agent with id ${id} NOT registered');
        }
        if (!data.callback) {
            await this._extensionService.activateByEvent(`onChatAgent:${id}`);
        }
        if (!data.callback) {
            throw new Error(`No agent with id ${id} NOT resolved`);
        }
        return await data.callback(prompt, progress, history, token);
    }
});
let ChatAgentContribution = class ChatAgentContribution {
    constructor(chatAgentService) {
        const contributions = ( new DisposableStore());
        agentsExtPoint.setHandler(extensions => {
            contributions.clear();
            for (const entry of extensions) {
                if (!isProposedApiEnabled(entry.description, 'chatAgents')) {
                    entry.collector.error(`The ${agentsExtPoint.name} is proposed API`);
                    continue;
                }
                const { value } = entry;
                for (const candidate of Iterable.wrap(value)) {
                    if (!isAgentData(candidate)) {
                        entry.collector.error(( localizeWithPath(
                            'vs/workbench/contrib/chat/common/chatAgents',
                            'invalid',
                            "Invalid {0}: {1}",
                            agentsExtPoint.name,
                            JSON.stringify(candidate)
                        )));
                        continue;
                    }
                    contributions.add(chatAgentService.registerAgentData({ ...candidate }));
                }
            }
        });
    }
};
ChatAgentContribution = ( __decorate([
    ( __param(0, IChatAgentService))
], ChatAgentContribution));
( Registry.as(Extensions.Workbench)).registerWorkbenchContribution(ChatAgentContribution, 3 );
export { IChatAgentService, agentsExtPoint };
