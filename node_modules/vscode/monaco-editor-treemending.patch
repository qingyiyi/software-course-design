diff -urN -x '*.map' a/vs/base/browser/browser.js b/vs/base/browser/browser.js
--- a/vs/base/browser/browser.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/browser.js	2023-12-06 14:23:14.343854719 +0000
@@ -6,12 +6,40 @@
 import { Disposable, markAsSingleton } from '../common/lifecycle.js';
 class WindowManager {
     constructor() {
+        // --- Zoom Level
+        this._zoomLevel = 0;
         // --- Zoom Factor
         this._zoomFactor = 1;
+        // --- Fullscreen
+        this._fullscreen = false;
+        this._onDidChangeFullscreen = new Emitter();
+        this.onDidChangeFullscreen = this._onDidChangeFullscreen.event;
+    }
+    getZoomLevel() {
+        return this._zoomLevel;
+    }
+    setZoomLevel(zoomLevel) {
+        if (this._zoomLevel === zoomLevel) {
+            return;
+        }
+        this._zoomLevel = zoomLevel;
     }
     getZoomFactor() {
         return this._zoomFactor;
     }
+    setZoomFactor(zoomFactor) {
+        this._zoomFactor = zoomFactor;
+    }
+    setFullscreen(fullscreen) {
+        if (this._fullscreen === fullscreen) {
+            return;
+        }
+        this._fullscreen = fullscreen;
+        this._onDidChangeFullscreen.fire();
+    }
+    isFullscreen() {
+        return this._fullscreen;
+    }
 }
 WindowManager.INSTANCE = new WindowManager();
 /**
@@ -27,8 +55,7 @@
         this._handleChange(false);
     }
     _handleChange(fireEvent) {
-        var _a;
-        (_a = this._mediaQueryList) === null || _a === void 0 ? void 0 : _a.removeEventListener('change', this._listener);
+        this._mediaQueryList?.removeEventListener('change', this._listener);
         this._mediaQueryList = window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
         this._mediaQueryList.addEventListener('change', this._listener);
         if (fireEvent) {
@@ -99,10 +126,27 @@
  * and any measurements need to be discarded for example when a window is moved from a monitor to another.
  */
 export const PixelRatio = new PixelRatioFacade();
+/** A zoom index, e.g. 1, 2, 3 */
+export function setZoomLevel(zoomLevel) {
+    WindowManager.INSTANCE.setZoomLevel(zoomLevel);
+}
+export function getZoomLevel() {
+    return WindowManager.INSTANCE.getZoomLevel();
+}
 /** The zoom scale for an index, e.g. 1, 1.2, 1.4 */
 export function getZoomFactor() {
     return WindowManager.INSTANCE.getZoomFactor();
 }
+export function setZoomFactor(zoomFactor) {
+    WindowManager.INSTANCE.setZoomFactor(zoomFactor);
+}
+export function setFullscreen(fullscreen) {
+    WindowManager.INSTANCE.setFullscreen(fullscreen);
+}
+export function isFullscreen() {
+    return WindowManager.INSTANCE.isFullscreen();
+}
+export const onDidChangeFullscreen = WindowManager.INSTANCE.onDidChangeFullscreen;
 const userAgent = navigator.userAgent;
 export const isFirefox = (userAgent.indexOf('Firefox') >= 0);
 export const isWebKit = (userAgent.indexOf('AppleWebKit') >= 0);
@@ -129,3 +173,9 @@
 export function isStandalone() {
     return standalone;
 }
+// Visible means that the feature is enabled, not necessarily being rendered
+// e.g. visible is true even in fullscreen mode where the controls are hidden
+// See docs at https://developer.mozilla.org/en-US/docs/Web/API/WindowControlsOverlay/visible
+export function isWCOEnabled() {
+    return navigator?.windowControlsOverlay?.visible;
+}
diff -urN -x '*.map' a/vs/base/browser/defaultWorkerFactory.js b/vs/base/browser/defaultWorkerFactory.js
--- a/vs/base/browser/defaultWorkerFactory.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/defaultWorkerFactory.js	2023-12-06 14:23:14.343854719 +0000
@@ -4,8 +4,17 @@
  *--------------------------------------------------------------------------------------------*/
 import { createTrustedTypesPolicy } from './trustedTypes.js';
 import { onUnexpectedError } from '../common/errors.js';
+// ESM-comment-begin
+// import { COI } from '../common/network';
+// ESM-comment-end
 import { logOnceWebWorkerWarning } from '../common/worker/simpleWorker.js';
 const ttPolicy = createTrustedTypesPolicy('defaultWorkerFactory', { createScriptURL: value => value });
+export function createBlobWorker(blobUrl, options) {
+    if (!blobUrl.startsWith('blob:')) {
+        throw new URIError('Not a blob-url: ' + blobUrl);
+    }
+    return new Worker(ttPolicy ? ttPolicy.createScriptURL(blobUrl) : blobUrl, options);
+}
 function getWorker(label) {
     const monacoEnvironment = globalThis.MonacoEnvironment;
     if (monacoEnvironment) {
@@ -91,8 +100,7 @@
         return this.id;
     }
     postMessage(message, transfer) {
-        var _a;
-        (_a = this.worker) === null || _a === void 0 ? void 0 : _a.then(w => {
+        this.worker?.then(w => {
             try {
                 w.postMessage(message, transfer);
             }
@@ -103,8 +111,7 @@
         });
     }
     dispose() {
-        var _a;
-        (_a = this.worker) === null || _a === void 0 ? void 0 : _a.then(w => w.terminate());
+        this.worker?.then(w => w.terminate());
         this.worker = null;
     }
 }
diff -urN -x '*.map' a/vs/base/browser/dnd.js b/vs/base/browser/dnd.js
--- a/vs/base/browser/dnd.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/dnd.js	2023-12-06 14:23:14.343854719 +0000
@@ -1,4 +1,43 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { addDisposableListener } from './dom.js';
+import { Disposable } from '../common/lifecycle.js';
 import { Mimes } from '../common/mime.js';
+/**
+ * A helper that will execute a provided function when the provided HTMLElement receives
+ *  dragover event for 800ms. If the drag is aborted before, the callback will not be triggered.
+ */
+export class DelayedDragHandler extends Disposable {
+    constructor(container, callback) {
+        super();
+        this._register(addDisposableListener(container, 'dragover', e => {
+            e.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)
+            if (!this.timeout) {
+                this.timeout = setTimeout(() => {
+                    callback();
+                    this.timeout = null;
+                }, 800);
+            }
+        }));
+        ['dragleave', 'drop', 'dragend'].forEach(type => {
+            this._register(addDisposableListener(container, type, () => {
+                this.clearDragTimeout();
+            }));
+        });
+    }
+    clearDragTimeout() {
+        if (this.timeout) {
+            clearTimeout(this.timeout);
+            this.timeout = null;
+        }
+    }
+    dispose() {
+        super.dispose();
+        this.clearDragTimeout();
+    }
+}
 // Common data transfers
 export const DataTransfers = {
     /**
@@ -24,3 +63,20 @@
      */
     INTERNAL_URI_LIST: 'application/vnd.code.uri-list',
 };
+export function applyDragImage(event, label, clazz, backgroundColor, foregroundColor) {
+    const dragImage = document.createElement('div');
+    dragImage.className = clazz;
+    dragImage.textContent = label;
+    if (foregroundColor) {
+        dragImage.style.color = foregroundColor;
+    }
+    if (backgroundColor) {
+        dragImage.style.background = backgroundColor;
+    }
+    if (event.dataTransfer) {
+        document.body.appendChild(dragImage);
+        event.dataTransfer.setDragImage(dragImage, -10, -10);
+        // Removes the element when the DND operation is done
+        setTimeout(() => document.body.removeChild(dragImage), 0);
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/dom.js b/vs/base/browser/dom.js
--- a/vs/base/browser/dom.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/dom.js	2023-12-06 14:23:14.343854719 +0000
@@ -6,12 +6,14 @@
 import { BrowserFeatures } from './canIUse.js';
 import { StandardKeyboardEvent } from './keyboardEvent.js';
 import { StandardMouseEvent } from './mouseEvent.js';
+import { TimeoutTimer } from '../common/async.js';
 import { onUnexpectedError } from '../common/errors.js';
 import * as event from '../common/event.js';
 import * as dompurify from './dompurify/dompurify.js';
 import { Disposable, DisposableStore, toDisposable } from '../common/lifecycle.js';
-import { FileAccess, RemoteAuthorities } from '../common/network.js';
+import { FileAccess, RemoteAuthorities, Schemas } from '../common/network.js';
 import * as platform from '../common/platform.js';
+import { URI } from '../common/uri.js';
 export const { registerWindow, getWindows, onDidCreateWindow } = (function () {
     const windows = [];
     const onDidCreateWindow = new event.Emitter();
@@ -43,8 +45,7 @@
  * @deprecated Use node.isConnected directly
  */
 export function isInDOM(node) {
-    var _a;
-    return (_a = node === null || node === void 0 ? void 0 : node.isConnected) !== null && _a !== void 0 ? _a : false;
+    return node?.isConnected ?? false;
 }
 class DomListener {
     constructor(node, type, handler, options) {
@@ -99,6 +100,9 @@
 export function addDisposableGenericMouseDownListener(node, handler, useCapture) {
     return addDisposableListener(node, platform.isIOS && BrowserFeatures.pointerEvents ? EventType.POINTER_DOWN : EventType.MOUSE_DOWN, handler, useCapture);
 }
+export function addDisposableGenericMouseMoveListener(node, handler, useCapture) {
+    return addDisposableListener(node, platform.isIOS && BrowserFeatures.pointerEvents ? EventType.POINTER_MOVE : EventType.MOUSE_MOVE, handler, useCapture);
+}
 export function addDisposableGenericMouseUpListener(node, handler, useCapture) {
     return addDisposableListener(node, platform.isIOS && BrowserFeatures.pointerEvents ? EventType.POINTER_UP : EventType.MOUSE_UP, handler, useCapture);
 }
@@ -190,23 +194,59 @@
         }
     };
 })();
+export function measure(callback) {
+    return scheduleAtNextAnimationFrame(callback, 10000 /* must be early */);
+}
+export function modify(callback) {
+    return scheduleAtNextAnimationFrame(callback, -10000 /* must be late */);
+}
+const MINIMUM_TIME_MS = 8;
+const DEFAULT_EVENT_MERGER = function (lastEvent, currentEvent) {
+    return currentEvent;
+};
+class TimeoutThrottledDomListener extends Disposable {
+    constructor(node, type, handler, eventMerger = DEFAULT_EVENT_MERGER, minimumTimeMs = MINIMUM_TIME_MS) {
+        super();
+        let lastEvent = null;
+        let lastHandlerTime = 0;
+        const timeout = this._register(new TimeoutTimer());
+        const invokeHandler = () => {
+            lastHandlerTime = (new Date()).getTime();
+            handler(lastEvent);
+            lastEvent = null;
+        };
+        this._register(addDisposableListener(node, type, (e) => {
+            lastEvent = eventMerger(lastEvent, e);
+            const elapsedTime = (new Date()).getTime() - lastHandlerTime;
+            if (elapsedTime >= minimumTimeMs) {
+                timeout.cancel();
+                invokeHandler();
+            }
+            else {
+                timeout.setIfNotSet(invokeHandler, minimumTimeMs - elapsedTime);
+            }
+        }));
+    }
+}
+export function addDisposableThrottledListener(node, type, handler, eventMerger, minimumTimeMs) {
+    return new TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs);
+}
 export function getComputedStyle(el) {
     return el.ownerDocument.defaultView.getComputedStyle(el, null);
 }
 export function getClientArea(element) {
-    var _a;
     const elDocument = element.ownerDocument;
-    const elWindow = (_a = elDocument.defaultView) === null || _a === void 0 ? void 0 : _a.window;
+    const elWindow = elDocument.defaultView?.window;
     // Try with DOM clientWidth / clientHeight
     if (element !== elDocument.body) {
         return new Dimension(element.clientWidth, element.clientHeight);
     }
     // If visual view port exits and it's on mobile, it should be used instead of window innerWidth / innerHeight, or document.body.clientWidth / document.body.clientHeight
-    if (platform.isIOS && (elWindow === null || elWindow === void 0 ? void 0 : elWindow.visualViewport)) {
+    if (platform.isIOS && elWindow?.visualViewport) {
         return new Dimension(elWindow.visualViewport.width, elWindow.visualViewport.height);
     }
     // Try innerWidth / innerHeight
-    if ((elWindow === null || elWindow === void 0 ? void 0 : elWindow.innerWidth) && elWindow.innerHeight) {
+    if (elWindow?.innerWidth && elWindow.innerHeight) {
         return new Dimension(elWindow.innerWidth, elWindow.innerHeight);
     }
     // Try with document.body.clientWidth / document.body.clientHeight
@@ -337,15 +377,29 @@
         element.style.height = `${height}px`;
     }
 }
+export function position(element, top, right, bottom, left, position = 'absolute') {
+    if (typeof top === 'number') {
+        element.style.top = `${top}px`;
+    }
+    if (typeof right === 'number') {
+        element.style.right = `${right}px`;
+    }
+    if (typeof bottom === 'number') {
+        element.style.bottom = `${bottom}px`;
+    }
+    if (typeof left === 'number') {
+        element.style.left = `${left}px`;
+    }
+    element.style.position = position;
+}
 /**
  * Returns the position of a dom node relative to the entire page.
  */
 export function getDomNodePagePosition(domNode) {
-    var _a, _b, _c, _d;
     const bb = domNode.getBoundingClientRect();
     return {
-        left: bb.left + ((_b = (_a = domNode.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.scrollX) !== null && _b !== void 0 ? _b : 0),
-        top: bb.top + ((_d = (_c = domNode.ownerDocument.defaultView) === null || _c === void 0 ? void 0 : _c.scrollY) !== null && _d !== void 0 ? _d : 0),
+        left: bb.left + (domNode.ownerDocument.defaultView?.scrollX ?? 0),
+        top: bb.top + (domNode.ownerDocument.defaultView?.scrollY ?? 0),
         width: bb.width,
         height: bb.height
     };
@@ -376,6 +430,10 @@
     const padding = SizeUtils.getPaddingLeft(element) + SizeUtils.getPaddingRight(element);
     return element.offsetWidth - border - padding;
 }
+export function getTotalScrollWidth(element) {
+    const margin = SizeUtils.getMarginLeft(element) + SizeUtils.getMarginRight(element);
+    return element.scrollWidth + margin;
+}
 // Adapted from WinJS
 // Gets the height of the content of the specified element. The content height does not include borders or padding.
 export function getContentHeight(element) {
@@ -389,6 +447,22 @@
     const margin = SizeUtils.getMarginTop(element) + SizeUtils.getMarginBottom(element);
     return element.offsetHeight + margin;
 }
+// Gets the left coordinate of the specified element relative to the specified parent.
+function getRelativeLeft(element, parent) {
+    if (element === null) {
+        return 0;
+    }
+    const elementPosition = getTopLeftOffset(element);
+    const parentPosition = getTopLeftOffset(parent);
+    return elementPosition.left - parentPosition.left;
+}
+export function getLargestChildWidth(parent, children) {
+    const childWidths = children.map((child) => {
+        return Math.max(getTotalScrollWidth(child), getTotalWidth(child)) + getRelativeLeft(child, parent) || 0;
+    });
+    const maxWidth = Math.max(...childWidths);
+    return maxWidth;
+}
 // ----------------------------------------------------------------------------------------
 export function isAncestor(testChild, testAncestor) {
     while (testChild) {
@@ -399,6 +473,42 @@
     }
     return false;
 }
+const parentFlowToDataKey = 'parentFlowToElementId';
+/**
+ * Set an explicit parent to use for nodes that are not part of the
+ * regular dom structure.
+ */
+export function setParentFlowTo(fromChildElement, toParentElement) {
+    fromChildElement.dataset[parentFlowToDataKey] = toParentElement.id;
+}
+function getParentFlowToElement(node) {
+    const flowToParentId = node.dataset[parentFlowToDataKey];
+    if (typeof flowToParentId === 'string') {
+        return node.ownerDocument.getElementById(flowToParentId);
+    }
+    return null;
+}
+/**
+ * Check if `testAncestor` is an ancestor of `testChild`, observing the explicit
+ * parents set by `setParentFlowTo`.
+ */
+export function isAncestorUsingFlowTo(testChild, testAncestor) {
+    let node = testChild;
+    while (node) {
+        if (node === testAncestor) {
+            return true;
+        }
+        if (node instanceof HTMLElement) {
+            const flowToParentElement = getParentFlowToElement(node);
+            if (flowToParentElement) {
+                node = flowToParentElement;
+                continue;
+            }
+        }
+        node = node.parentNode;
+    }
+    return false;
+}
 export function findParentWithClass(node, clazz, stopAtClazzOrNode) {
     while (node && node.nodeType === node.ELEMENT_NODE) {
         if (node.classList.contains(clazz)) {
@@ -430,9 +540,8 @@
     return !!getShadowRoot(domNode);
 }
 export function getShadowRoot(domNode) {
-    var _a;
     while (domNode.parentNode) {
-        if (domNode === ((_a = domNode.ownerDocument) === null || _a === void 0 ? void 0 : _a.body)) {
+        if (domNode === domNode.ownerDocument?.body) {
             // reached the body
             return null;
         }
@@ -446,7 +555,7 @@
  */
 export function getActiveElement() {
     let result = getActiveDocument().activeElement;
-    while (result === null || result === void 0 ? void 0 : result.shadowRoot) {
+    while (result?.shadowRoot) {
         result = result.shadowRoot.activeElement;
     }
     return result;
@@ -456,18 +565,22 @@
  * Use this instead of `document` when reacting to dom events to handle multiple windows.
  */
 export function getActiveDocument() {
-    var _a;
     const documents = [document, ...getWindows().map(w => w.document)];
-    return (_a = documents.find(doc => doc.hasFocus())) !== null && _a !== void 0 ? _a : document;
+    return documents.find(doc => doc.hasFocus()) ?? document;
 }
 export function createStyleSheet(container = document.getElementsByTagName('head')[0], beforeAppend) {
     const style = document.createElement('style');
     style.type = 'text/css';
     style.media = 'screen';
-    beforeAppend === null || beforeAppend === void 0 ? void 0 : beforeAppend(style);
+    beforeAppend?.(style);
     container.appendChild(style);
     return style;
 }
+export function createMetaElement(container = document.getElementsByTagName('head')[0]) {
+    const meta = document.createElement('meta');
+    container.appendChild(meta);
+    return meta;
+}
 let _sharedStyleSheet = null;
 function getSharedStyleSheet() {
     if (!_sharedStyleSheet) {
@@ -476,12 +589,11 @@
     return _sharedStyleSheet;
 }
 function getDynamicStyleSheetRules(style) {
-    var _a, _b;
-    if ((_a = style === null || style === void 0 ? void 0 : style.sheet) === null || _a === void 0 ? void 0 : _a.rules) {
+    if (style?.sheet?.rules) {
         // Chrome, IE
         return style.sheet.rules;
     }
-    if ((_b = style === null || style === void 0 ? void 0 : style.sheet) === null || _b === void 0 ? void 0 : _b.cssRules) {
+    if (style?.sheet?.cssRules) {
         // FF
         return style.sheet.cssRules;
     }
@@ -660,6 +772,9 @@
             this._register(addDisposableListener(element, EventType.FOCUS_OUT, () => this._refreshStateHandler()));
         }
     }
+    refreshState() {
+        this._refreshStateHandler();
+    }
 }
 /**
  * Creates a new `IFocusTracker` instance that tracks focus changes on the given `element` and its descendants.
@@ -670,6 +785,10 @@
 export function trackFocus(element) {
     return new FocusTracker(element);
 }
+export function after(sibling, child) {
+    sibling.after(child);
+    return child;
+}
 export function append(parent, ...children) {
     parent.append(...children);
     if (children.length === 1 && typeof children[0] !== 'string') {
@@ -739,6 +858,21 @@
 $.SVG = function (description, attrs, ...children) {
     return _$(Namespace.SVG, description, attrs, ...children);
 };
+export function join(nodes, separator) {
+    const result = [];
+    nodes.forEach((node, index) => {
+        if (index > 0) {
+            if (separator instanceof Node) {
+                result.push(separator.cloneNode());
+            }
+            else {
+                result.push(document.createTextNode(separator));
+            }
+        }
+        result.push(node);
+    });
+    return result;
+}
 export function setVisibility(visible, ...elements) {
     if (visible) {
         show(...elements);
@@ -759,6 +893,47 @@
         element.setAttribute('aria-hidden', 'true');
     }
 }
+function findParentWithAttribute(node, attribute) {
+    while (node && node.nodeType === node.ELEMENT_NODE) {
+        if (node instanceof HTMLElement && node.hasAttribute(attribute)) {
+            return node;
+        }
+        node = node.parentNode;
+    }
+    return null;
+}
+export function removeTabIndexAndUpdateFocus(node) {
+    if (!node || !node.hasAttribute('tabIndex')) {
+        return;
+    }
+    // If we are the currently focused element and tabIndex is removed,
+    // standard DOM behavior is to move focus to the <body> element. We
+    // typically never want that, rather put focus to the closest element
+    // in the hierarchy of the parent DOM nodes.
+    if (node.ownerDocument.activeElement === node) {
+        const parentFocusable = findParentWithAttribute(node.parentElement, 'tabIndex');
+        parentFocusable?.focus();
+    }
+    node.removeAttribute('tabindex');
+}
+export function finalHandler(fn) {
+    return e => {
+        e.preventDefault();
+        e.stopPropagation();
+        fn(e);
+    };
+}
+export function domContentLoaded() {
+    return new Promise(resolve => {
+        const readyState = document.readyState;
+        if (readyState === 'complete' || (document && document.body !== null)) {
+            resolve(undefined);
+        }
+        else {
+            window.addEventListener('DOMContentLoaded', resolve, false);
+        }
+    });
+}
 /**
  * Find a value usable for a dom node size such that the likelihood that it would be
  * displayed with constant screen pixels size is as high as possible.
@@ -791,6 +966,50 @@
     // the creation of the window.
     window.open(url, '_blank', 'noopener');
 }
+/**
+ * Open a new window in a popup. This is the best way to do so, but you cannot tell
+ * if the window was opened or if it was blocked by the browser's popup blocker.
+ * If you want to tell if the browser blocked the new window, use {@link windowOpenWithSuccess}.
+ *
+ * Note: this does not set {@link window.opener} to null. This is to allow the opened popup to
+ * be able to use {@link window.close} to close itself. Because of this, you should only use
+ * this function on urls that you trust.
+ *
+ * In otherwords, you should almost always use {@link windowOpenNoOpener} instead of this function.
+ */
+const popupWidth = 780, popupHeight = 640;
+export function windowOpenPopup(url) {
+    const left = Math.floor(window.screenLeft + window.innerWidth / 2 - popupWidth / 2);
+    const top = Math.floor(window.screenTop + window.innerHeight / 2 - popupHeight / 2);
+    window.open(url, '_blank', `width=${popupWidth},height=${popupHeight},top=${top},left=${left}`);
+}
+/**
+ * Attempts to open a window and returns whether it succeeded. This technique is
+ * not appropriate in certain contexts, like for example when the JS context is
+ * executing inside a sandboxed iframe. If it is not necessary to know if the
+ * browser blocked the new window, use {@link windowOpenNoOpener}.
+ *
+ * See https://github.com/microsoft/monaco-editor/issues/601
+ * See https://github.com/microsoft/monaco-editor/issues/2474
+ * See https://mathiasbynens.github.io/rel-noopener/
+ *
+ * @param url the url to open
+ * @param noOpener whether or not to set the {@link window.opener} to null. You should leave the default
+ * (true) unless you trust the url that is being opened.
+ * @returns boolean indicating if the {@link window.open} call succeeded
+ */
+export function windowOpenWithSuccess(url, noOpener = true) {
+    const newTab = window.open();
+    if (newTab) {
+        if (noOpener) {
+            // see `windowOpenNoOpener` for details on why this is important
+            newTab.opener = null;
+        }
+        newTab.location.href = url;
+        return true;
+    }
+    return false;
+}
 export function animate(fn) {
     const step = () => {
         fn();
@@ -826,6 +1045,90 @@
     }
     return dflt;
 }
+export function triggerDownload(dataOrUri, name) {
+    // If the data is provided as Buffer, we create a
+    // blob URL out of it to produce a valid link
+    let url;
+    if (URI.isUri(dataOrUri)) {
+        url = dataOrUri.toString(true);
+    }
+    else {
+        const blob = new Blob([dataOrUri]);
+        url = URL.createObjectURL(blob);
+        // Ensure to free the data from DOM eventually
+        setTimeout(() => URL.revokeObjectURL(url));
+    }
+    // In order to download from the browser, the only way seems
+    // to be creating a <a> element with download attribute that
+    // points to the file to download.
+    // See also https://developers.google.com/web/updates/2011/08/Downloading-resources-in-HTML5-a-download
+    const anchor = document.createElement('a');
+    document.body.appendChild(anchor);
+    anchor.download = name;
+    anchor.href = url;
+    anchor.click();
+    // Ensure to remove the element from DOM eventually
+    setTimeout(() => document.body.removeChild(anchor));
+}
+export function triggerUpload() {
+    return new Promise(resolve => {
+        // In order to upload to the browser, create a
+        // input element of type `file` and click it
+        // to gather the selected files
+        const input = document.createElement('input');
+        document.body.appendChild(input);
+        input.type = 'file';
+        input.multiple = true;
+        // Resolve once the input event has fired once
+        event.Event.once(event.Event.fromDOMEventEmitter(input, 'input'))(() => {
+            resolve(input.files ?? undefined);
+        });
+        input.click();
+        // Ensure to remove the element from DOM eventually
+        setTimeout(() => document.body.removeChild(input));
+    });
+}
+export var DetectedFullscreenMode;
+(function (DetectedFullscreenMode) {
+    /**
+     * The document is fullscreen, e.g. because an element
+     * in the document requested to be fullscreen.
+     */
+    DetectedFullscreenMode[DetectedFullscreenMode["DOCUMENT"] = 1] = "DOCUMENT";
+    /**
+     * The browser is fullscreen, e.g. because the user enabled
+     * native window fullscreen for it.
+     */
+    DetectedFullscreenMode[DetectedFullscreenMode["BROWSER"] = 2] = "BROWSER";
+})(DetectedFullscreenMode || (DetectedFullscreenMode = {}));
+export function detectFullscreen() {
+    // Browser fullscreen: use DOM APIs to detect
+    if (document.fullscreenElement || document.webkitFullscreenElement || document.webkitIsFullScreen) {
+        return { mode: DetectedFullscreenMode.DOCUMENT, guess: false };
+    }
+    // There is no standard way to figure out if the browser
+    // is using native fullscreen. Via checking on screen
+    // height and comparing that to window height, we can guess
+    // it though.
+    if (window.innerHeight === screen.height) {
+        // if the height of the window matches the screen height, we can
+        // safely assume that the browser is fullscreen because no browser
+        // chrome is taking height away (e.g. like toolbars).
+        return { mode: DetectedFullscreenMode.BROWSER, guess: false };
+    }
+    if (platform.isMacintosh || platform.isLinux) {
+        // macOS and Linux do not properly report `innerHeight`, only Windows does
+        if (window.outerHeight === screen.height && window.outerWidth === screen.width) {
+            // if the height of the browser matches the screen height, we can
+            // only guess that we are in fullscreen. It is also possible that
+            // the user has turned off taskbars in the OS and the browser is
+            // simply able to span the entire size of the screen.
+            return { mode: DetectedFullscreenMode.BROWSER, guess: true };
+        }
+    }
+    // Not in fullscreen
+    return null;
+}
 // -- sanitize and trusted html
 /**
  * Hooks dompurify using `afterSanitizeAttributes` to check that all `href` and `src`
@@ -858,6 +1161,11 @@
         dompurify.removeHook('afterSanitizeAttributes');
     });
 }
+const defaultSafeProtocols = [
+    Schemas.http,
+    Schemas.https,
+    Schemas.command,
+];
 /**
  * List of safe, non-input html tags.
  */
@@ -936,6 +1244,43 @@
     RETURN_DOM_FRAGMENT: false,
     RETURN_TRUSTED_TYPE: true
 });
+/**
+ * Sanitizes the given `value` and reset the given `node` with it.
+ */
+export function safeInnerHtml(node, value) {
+    const hook = hookDomPurifyHrefAndSrcSanitizer(defaultSafeProtocols);
+    try {
+        const html = dompurify.sanitize(value, defaultDomPurifyConfig);
+        node.innerHTML = html;
+    }
+    finally {
+        hook.dispose();
+    }
+}
+/**
+ * Convert a Unicode string to a string in which each 16-bit unit occupies only one byte
+ *
+ * From https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/btoa
+ */
+function toBinary(str) {
+    const codeUnits = new Uint16Array(str.length);
+    for (let i = 0; i < codeUnits.length; i++) {
+        codeUnits[i] = str.charCodeAt(i);
+    }
+    let binary = '';
+    const uint8array = new Uint8Array(codeUnits.buffer);
+    for (let i = 0; i < uint8array.length; i++) {
+        binary += String.fromCharCode(uint8array[i]);
+    }
+    return binary;
+}
+/**
+ * Version of the global `btoa` function that handles multi-byte characters instead
+ * of throwing an exception.
+ */
+export function multibyteAwareBtoa(str) {
+    return btoa(toBinary(str));
+}
 export class ModifierKeyEmitter extends event.Emitter {
     constructor() {
         super();
@@ -1032,6 +1377,9 @@
     get keyStatus() {
         return this._keyStatus;
     }
+    get isModifierPressed() {
+        return this._keyStatus.altKey || this._keyStatus.ctrlKey || this._keyStatus.metaKey || this._keyStatus.shiftKey;
+    }
     /**
      * Allows to explicitly reset the key status based on more knowledge (#109062)
      */
@@ -1058,6 +1406,10 @@
         this._subscriptions.dispose();
     }
 }
+export function getCookieValue(name) {
+    const match = document.cookie.match('(^|[^;]+)\\s*' + name + '\\s*=\\s*([^;]+)'); // See https://stackoverflow.com/a/25490531
+    return match ? match.pop() : undefined;
+}
 export class DragAndDropObserver extends Disposable {
     constructor(element, callbacks) {
         super();
@@ -1079,9 +1431,8 @@
             this.callbacks.onDragEnter(e);
         }));
         this._register(addDisposableListener(this.element, EventType.DRAG_OVER, (e) => {
-            var _a, _b;
             e.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)
-            (_b = (_a = this.callbacks).onDragOver) === null || _b === void 0 ? void 0 : _b.call(_a, e, e.timeStamp - this.dragStartTime);
+            this.callbacks.onDragOver?.(e, e.timeStamp - this.dragStartTime);
         }));
         this._register(addDisposableListener(this.element, EventType.DRAG_LEAVE, (e) => {
             this.counter--;
diff -urN -x '*.map' a/vs/base/browser/fastDomNode.js b/vs/base/browser/fastDomNode.js
--- a/vs/base/browser/fastDomNode.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/fastDomNode.js	2023-12-06 14:23:14.343854719 +0000
@@ -12,7 +12,10 @@
         this._left = '';
         this._bottom = '';
         this._right = '';
+        this._paddingTop = '';
         this._paddingLeft = '';
+        this._paddingBottom = '';
+        this._paddingRight = '';
         this._fontFamily = '';
         this._fontWeight = '';
         this._fontSize = '';
@@ -88,6 +91,14 @@
         this._right = right;
         this.domNode.style.right = this._right;
     }
+    setPaddingTop(_paddingTop) {
+        const paddingTop = numberAsPixels(_paddingTop);
+        if (this._paddingTop === paddingTop) {
+            return;
+        }
+        this._paddingTop = paddingTop;
+        this.domNode.style.paddingTop = this._paddingTop;
+    }
     setPaddingLeft(_paddingLeft) {
         const paddingLeft = numberAsPixels(_paddingLeft);
         if (this._paddingLeft === paddingLeft) {
@@ -96,6 +107,22 @@
         this._paddingLeft = paddingLeft;
         this.domNode.style.paddingLeft = this._paddingLeft;
     }
+    setPaddingBottom(_paddingBottom) {
+        const paddingBottom = numberAsPixels(_paddingBottom);
+        if (this._paddingBottom === paddingBottom) {
+            return;
+        }
+        this._paddingBottom = paddingBottom;
+        this.domNode.style.paddingBottom = this._paddingBottom;
+    }
+    setPaddingRight(_paddingRight) {
+        const paddingRight = numberAsPixels(_paddingRight);
+        if (this._paddingRight === paddingRight) {
+            return;
+        }
+        this._paddingRight = paddingRight;
+        this.domNode.style.paddingRight = this._paddingRight;
+    }
     setFontFamily(fontFamily) {
         if (this._fontFamily === fontFamily) {
             return;
diff -urN -x '*.map' a/vs/base/browser/iframe.js b/vs/base/browser/iframe.js
--- a/vs/base/browser/iframe.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/iframe.js	2023-12-06 14:23:14.343854719 +0000
@@ -54,6 +54,16 @@
         return sameOriginWindowChainCache.slice(0);
     }
     /**
+     * Returns true if the current execution environment is chained in a list of iframes which at one point ends in a window with a different origin.
+     * Returns false if the current execution environment is not running inside an iframe or if the entire chain of iframes have the same origin.
+     */
+    static hasDifferentOriginAncestor() {
+        if (!sameOriginWindowChainCache) {
+            this.getSameOriginWindowChain();
+        }
+        return hasDifferentOriginAncestorFlag;
+    }
+    /**
      * Returns the position of `childWindow` relative to `ancestorWindow`
      */
     static getPositionOfChildWindowRelativeToAncestorWindow(childWindow, ancestorWindow) {
@@ -84,3 +94,23 @@
         };
     }
 }
+/**
+ * Returns a sha-256 composed of `parentOrigin` and `salt` converted to base 32
+ */
+export async function parentOriginHash(parentOrigin, salt) {
+    // This same code is also inlined at `src/vs/workbench/services/extensions/worker/webWorkerExtensionHostIframe.html`
+    if (!crypto.subtle) {
+        throw new Error(`'crypto.subtle' is not available so webviews will not work. This is likely because the editor is not running in a secure context (https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts).`);
+    }
+    const strData = JSON.stringify({ parentOrigin, salt });
+    const encoder = new TextEncoder();
+    const arrData = encoder.encode(strData);
+    const hash = await crypto.subtle.digest('sha-256', arrData);
+    return sha256AsBase32(hash);
+}
+function sha256AsBase32(bytes) {
+    const array = Array.from(new Uint8Array(bytes));
+    const hexArray = array.map(b => b.toString(16).padStart(2, '0')).join('');
+    // sha256 has 256 bits, so we need at most ceil(lg(2^256-1)/lg(32)) = 52 chars to represent it in base 32
+    return BigInt(`0x${hexArray}`).toString(32).padStart(52, '0');
+}
diff -urN -x '*.map' a/vs/base/browser/indexedDB.js b/vs/base/browser/indexedDB.js
--- a/vs/base/browser/indexedDB.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/base/browser/indexedDB.js	2023-12-06 14:23:14.343854719 +0000
@@ -0,0 +1,157 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { toErrorMessage } from '../common/errorMessage.js';
+import { getErrorMessage } from '../common/errors.js';
+import { mark } from '../common/performance.js';
+class MissingStoresError extends Error {
+    constructor(db) {
+        super('Missing stores');
+        this.db = db;
+    }
+}
+export class DBClosedError extends Error {
+    constructor(dbName) {
+        super(`IndexedDB database '${dbName}' is closed.`);
+        this.code = 'DBClosed';
+    }
+}
+export class IndexedDB {
+    static async create(name, version, stores) {
+        const database = await IndexedDB.openDatabase(name, version, stores);
+        return new IndexedDB(database, name);
+    }
+    static async openDatabase(name, version, stores) {
+        mark(`code/willOpenDatabase/${name}`);
+        try {
+            return await IndexedDB.doOpenDatabase(name, version, stores);
+        }
+        catch (err) {
+            if (err instanceof MissingStoresError) {
+                console.info(`Attempting to recreate the IndexedDB once.`, name);
+                try {
+                    // Try to delete the db
+                    await IndexedDB.deleteDatabase(err.db);
+                }
+                catch (error) {
+                    console.error(`Error while deleting the IndexedDB`, getErrorMessage(error));
+                    throw error;
+                }
+                return await IndexedDB.doOpenDatabase(name, version, stores);
+            }
+            throw err;
+        }
+        finally {
+            mark(`code/didOpenDatabase/${name}`);
+        }
+    }
+    static doOpenDatabase(name, version, stores) {
+        return new Promise((c, e) => {
+            const request = window.indexedDB.open(name, version);
+            request.onerror = () => e(request.error);
+            request.onsuccess = () => {
+                const db = request.result;
+                for (const store of stores) {
+                    if (!db.objectStoreNames.contains(store)) {
+                        console.error(`Error while opening IndexedDB. Could not find '${store}'' object store`);
+                        e(new MissingStoresError(db));
+                        return;
+                    }
+                }
+                c(db);
+            };
+            request.onupgradeneeded = () => {
+                const db = request.result;
+                for (const store of stores) {
+                    if (!db.objectStoreNames.contains(store)) {
+                        db.createObjectStore(store);
+                    }
+                }
+            };
+        });
+    }
+    static deleteDatabase(indexedDB) {
+        return new Promise((c, e) => {
+            // Close any opened connections
+            indexedDB.close();
+            // Delete the db
+            const deleteRequest = window.indexedDB.deleteDatabase(indexedDB.name);
+            deleteRequest.onerror = (err) => e(deleteRequest.error);
+            deleteRequest.onsuccess = () => c();
+        });
+    }
+    constructor(database, name) {
+        this.name = name;
+        this.database = null;
+        this.pendingTransactions = [];
+        this.database = database;
+    }
+    hasPendingTransactions() {
+        return this.pendingTransactions.length > 0;
+    }
+    close() {
+        if (this.pendingTransactions.length) {
+            this.pendingTransactions.splice(0, this.pendingTransactions.length).forEach(transaction => transaction.abort());
+        }
+        this.database?.close();
+        this.database = null;
+    }
+    async runInTransaction(store, transactionMode, dbRequestFn) {
+        if (!this.database) {
+            throw new DBClosedError(this.name);
+        }
+        const transaction = this.database.transaction(store, transactionMode);
+        this.pendingTransactions.push(transaction);
+        return new Promise((c, e) => {
+            transaction.oncomplete = () => {
+                if (Array.isArray(request)) {
+                    c(request.map(r => r.result));
+                }
+                else {
+                    c(request.result);
+                }
+            };
+            transaction.onerror = () => e(transaction.error);
+            transaction.onabort = () => e(transaction.error);
+            const request = dbRequestFn(transaction.objectStore(store));
+        }).finally(() => this.pendingTransactions.splice(this.pendingTransactions.indexOf(transaction), 1));
+    }
+    async getKeyValues(store, isValid) {
+        if (!this.database) {
+            throw new DBClosedError(this.name);
+        }
+        const transaction = this.database.transaction(store, 'readonly');
+        this.pendingTransactions.push(transaction);
+        return new Promise(resolve => {
+            const items = new Map();
+            const objectStore = transaction.objectStore(store);
+            // Open a IndexedDB Cursor to iterate over key/values
+            const cursor = objectStore.openCursor();
+            if (!cursor) {
+                return resolve(items); // this means the `ItemTable` was empty
+            }
+            // Iterate over rows of `ItemTable` until the end
+            cursor.onsuccess = () => {
+                if (cursor.result) {
+                    // Keep cursor key/value in our map
+                    if (isValid(cursor.result.value)) {
+                        items.set(cursor.result.key.toString(), cursor.result.value);
+                    }
+                    // Advance cursor to next row
+                    cursor.result.continue();
+                }
+                else {
+                    resolve(items); // reached end of table
+                }
+            };
+            // Error handlers
+            const onError = (error) => {
+                console.error(`IndexedDB getKeyValues(): ${toErrorMessage(error, true)}`);
+                resolve(items);
+            };
+            cursor.onerror = () => onError(cursor.error);
+            transaction.onerror = () => onError(transaction.error);
+        }).finally(() => this.pendingTransactions.splice(this.pendingTransactions.indexOf(transaction), 1));
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/keyboardEvent.js b/vs/base/browser/keyboardEvent.js
--- a/vs/base/browser/keyboardEvent.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/keyboardEvent.js	2023-12-06 14:23:14.343854719 +0000
@@ -53,6 +53,38 @@
 const altKeyMod = 512 /* KeyMod.Alt */;
 const shiftKeyMod = 1024 /* KeyMod.Shift */;
 const metaKeyMod = (platform.isMacintosh ? 2048 /* KeyMod.CtrlCmd */ : 256 /* KeyMod.WinCtrl */);
+export function printKeyboardEvent(e) {
+    const modifiers = [];
+    if (e.ctrlKey) {
+        modifiers.push(`ctrl`);
+    }
+    if (e.shiftKey) {
+        modifiers.push(`shift`);
+    }
+    if (e.altKey) {
+        modifiers.push(`alt`);
+    }
+    if (e.metaKey) {
+        modifiers.push(`meta`);
+    }
+    return `modifiers: [${modifiers.join(',')}], code: ${e.code}, keyCode: ${e.keyCode}, key: ${e.key}`;
+}
+export function printStandardKeyboardEvent(e) {
+    const modifiers = [];
+    if (e.ctrlKey) {
+        modifiers.push(`ctrl`);
+    }
+    if (e.shiftKey) {
+        modifiers.push(`shift`);
+    }
+    if (e.altKey) {
+        modifiers.push(`alt`);
+    }
+    if (e.metaKey) {
+        modifiers.push(`meta`);
+    }
+    return `modifiers: [${modifiers.join(',')}], code: ${e.code}, keyCode: ${e.keyCode} ('${KeyCodeUtils.toString(e.keyCode)}')`;
+}
 export class StandardKeyboardEvent {
     constructor(source) {
         this._standardKeyboardEventBrand = true;
diff -urN -x '*.map' a/vs/base/browser/markdownRenderer.js b/vs/base/browser/markdownRenderer.js
--- a/vs/base/browser/markdownRenderer.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/markdownRenderer.js	2023-12-06 14:23:14.343854719 +0000
@@ -71,7 +71,6 @@
  * which comes with support for pretty code block rendering and which uses the default way of handling links.
  */
 export function renderMarkdown(markdown, options = {}, markedOptions = {}) {
-    var _a, _b;
     const disposables = new DisposableStore();
     let isDisposed = false;
     const element = createElement(options);
@@ -204,7 +203,7 @@
     }
     markedOptions.renderer = renderer;
     // values that are too long will freeze the UI
-    let value = (_a = markdown.value) !== null && _a !== void 0 ? _a : '';
+    let value = markdown.value ?? '';
     if (value.length > 100000) {
         value = `${value.substr(0, 100000)}…`;
     }
@@ -215,7 +214,10 @@
     let renderedMarkdown;
     if (options.fillInIncompleteTokens) {
         // The defaults are applied by parse but not lexer()/parser(), and they need to be present
-        const opts = Object.assign(Object.assign({}, marked.defaults), markedOptions);
+        const opts = {
+            ...marked.defaults,
+            ...markedOptions
+        };
         const tokens = marked.lexer(value, opts);
         const newTokens = fillInIncompleteTokens(tokens);
         renderedMarkdown = marked.parser(newTokens, opts);
@@ -266,26 +268,25 @@
     element.innerHTML = sanitizeRenderedMarkdown(markdown, markdownHtmlDoc.body.innerHTML);
     if (codeBlocks.length > 0) {
         Promise.all(codeBlocks).then((tuples) => {
-            var _a, _b;
             if (isDisposed) {
                 return;
             }
             const renderedElements = new Map(tuples);
             const placeholderElements = element.querySelectorAll(`div[data-code]`);
             for (const placeholderElement of placeholderElements) {
-                const renderedElement = renderedElements.get((_a = placeholderElement.dataset['code']) !== null && _a !== void 0 ? _a : '');
+                const renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');
                 if (renderedElement) {
                     DOM.reset(placeholderElement, renderedElement);
                 }
             }
-            (_b = options.asyncRenderCallback) === null || _b === void 0 ? void 0 : _b.call(options);
+            options.asyncRenderCallback?.();
         });
     }
     else if (syncCodeBlocks.length > 0) {
         const renderedElements = new Map(syncCodeBlocks);
         const placeholderElements = element.querySelectorAll(`div[data-code]`);
         for (const placeholderElement of placeholderElements) {
-            const renderedElement = renderedElements.get((_b = placeholderElement.dataset['code']) !== null && _b !== void 0 ? _b : '');
+            const renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');
             if (renderedElement) {
                 DOM.reset(placeholderElement, renderedElement);
             }
@@ -350,7 +351,7 @@
     });
     const hook = DOM.hookDomPurifyHrefAndSrcSanitizer(allowedSchemes);
     try {
-        return dompurify.sanitize(renderedMarkdown, Object.assign(Object.assign({}, config), { RETURN_TRUSTED_TYPE: true }));
+        return dompurify.sanitize(renderedMarkdown, { ...config, RETURN_TRUSTED_TYPE: true });
     }
     finally {
         dompurify.removeHook('uponSanitizeAttribute');
@@ -416,13 +417,12 @@
  * Strips all markdown from `markdown`. For example `# Header` would be output as `Header`.
  */
 export function renderMarkdownAsPlaintext(markdown) {
-    var _a;
     // values that are too long will freeze the UI
-    let value = (_a = markdown.value) !== null && _a !== void 0 ? _a : '';
+    let value = markdown.value ?? '';
     if (value.length > 100000) {
         value = `${value.substr(0, 100000)}…`;
     }
-    const html = marked.parse(value, { renderer: plainTextRenderer.value }).replace(/&(#\d+|[a-zA-Z]+);/g, m => { var _a; return (_a = unescapeInfo.get(m)) !== null && _a !== void 0 ? _a : m; });
+    const html = marked.parse(value, { renderer: plainTextRenderer.value }).replace(/&(#\d+|[a-zA-Z]+);/g, m => unescapeInfo.get(m) ?? m);
     return sanitizeRenderedMarkdown({ isTrusted: false }, html).toString();
 }
 const unescapeInfo = new Map([
diff -urN -x '*.map' a/vs/base/browser/mouseEvent.js b/vs/base/browser/mouseEvent.js
--- a/vs/base/browser/mouseEvent.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/mouseEvent.js	2023-12-06 14:23:14.343854719 +0000
@@ -43,6 +43,12 @@
         this.browserEvent.stopPropagation();
     }
 }
+export class DragMouseEvent extends StandardMouseEvent {
+    constructor(e) {
+        super(e);
+        this.dataTransfer = e.dataTransfer;
+    }
+}
 export class StandardWheelEvent {
     constructor(e, deltaX = 0, deltaY = 0) {
         this.browserEvent = e || null;
@@ -113,11 +119,9 @@
         }
     }
     preventDefault() {
-        var _a;
-        (_a = this.browserEvent) === null || _a === void 0 ? void 0 : _a.preventDefault();
+        this.browserEvent?.preventDefault();
     }
     stopPropagation() {
-        var _a;
-        (_a = this.browserEvent) === null || _a === void 0 ? void 0 : _a.stopPropagation();
+        this.browserEvent?.stopPropagation();
     }
 }
diff -urN -x '*.map' a/vs/base/browser/performance.js b/vs/base/browser/performance.js
--- a/vs/base/browser/performance.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/performance.js	2023-12-06 14:23:14.343854719 +0000
@@ -5,9 +5,9 @@
 export var inputLatency;
 (function (inputLatency) {
     const totalKeydownTime = { total: 0, min: Number.MAX_VALUE, max: 0 };
-    const totalInputTime = Object.assign({}, totalKeydownTime);
-    const totalRenderTime = Object.assign({}, totalKeydownTime);
-    const totalInputLatencyTime = Object.assign({}, totalKeydownTime);
+    const totalInputTime = { ...totalKeydownTime };
+    const totalRenderTime = { ...totalKeydownTime };
+    const totalInputLatencyTime = { ...totalKeydownTime };
     let measurementsCount = 0;
     const state = {
         keydown: 0 /* EventPhase.Before */,
diff -urN -x '*.map' a/vs/base/browser/trustedTypes.js b/vs/base/browser/trustedTypes.js
--- a/vs/base/browser/trustedTypes.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/trustedTypes.js	2023-12-06 14:23:14.343854719 +0000
@@ -4,9 +4,8 @@
  *--------------------------------------------------------------------------------------------*/
 import { onUnexpectedError } from '../common/errors.js';
 export function createTrustedTypesPolicy(policyName, policyOptions) {
-    var _a;
     const monacoEnvironment = globalThis.MonacoEnvironment;
-    if (monacoEnvironment === null || monacoEnvironment === void 0 ? void 0 : monacoEnvironment.createTrustedTypesPolicy) {
+    if (monacoEnvironment?.createTrustedTypesPolicy) {
         try {
             return monacoEnvironment.createTrustedTypesPolicy(policyName, policyOptions);
         }
@@ -16,7 +15,7 @@
         }
     }
     try {
-        return (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy(policyName, policyOptions);
+        return window.trustedTypes?.createPolicy(policyName, policyOptions);
     }
     catch (err) {
         onUnexpectedError(err);
diff -urN -x '*.map' a/vs/base/browser/ui/actionbar/actionViewItems.js b/vs/base/browser/ui/actionbar/actionViewItems.js
--- a/vs/base/browser/ui/actionbar/actionViewItems.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/actionbar/actionViewItems.js	2023-12-06 14:23:14.343854719 +0000
@@ -75,7 +75,7 @@
             container.draggable = true;
             if (isFirefox) {
                 // Firefox: requires to set a text data transfer to get going
-                this._register(addDisposableListener(container, EventType.DRAG_START, e => { var _a; return (_a = e.dataTransfer) === null || _a === void 0 ? void 0 : _a.setData(DataTransfers.TEXT, this._action.label); }));
+                this._register(addDisposableListener(container, EventType.DRAG_START, e => e.dataTransfer?.setData(DataTransfers.TEXT, this._action.label)));
             }
         }
         this._register(addDisposableListener(element, TouchEventType.Tap, e => this.onClick(e, true))); // Preserve focus on tap #125470
@@ -116,9 +116,8 @@
         });
     }
     onClick(event, preserveFocus = false) {
-        var _a;
         EventHelper.stop(event, true);
-        const context = types.isUndefinedOrNull(this._context) ? ((_a = this.options) === null || _a === void 0 ? void 0 : _a.useEventAsContext) ? event : { preserveFocus } : this._context;
+        const context = types.isUndefinedOrNull(this._context) ? this.options?.useEventAsContext ? event : { preserveFocus } : this._context;
         this.actionRunner.run(this._action, context);
     }
     // Only set the tabIndex on the element once it is about to get focused
@@ -130,6 +129,9 @@
             this.element.classList.add('focused');
         }
     }
+    isFocused() {
+        return !!this.element?.classList.contains('focused');
+    }
     blur() {
         if (this.element) {
             this.element.blur();
@@ -155,11 +157,10 @@
         return this.action.tooltip;
     }
     updateTooltip() {
-        var _a;
         if (!this.element) {
             return;
         }
-        const title = (_a = this.getTooltip()) !== null && _a !== void 0 ? _a : '';
+        const title = this.getTooltip() ?? '';
         this.updateAriaLabel();
         if (!this.options.hoverDelegate) {
             this.element.title = title;
@@ -176,9 +177,8 @@
         }
     }
     updateAriaLabel() {
-        var _a;
         if (this.element) {
-            const title = (_a = this.getTooltip()) !== null && _a !== void 0 ? _a : '';
+            const title = this.getTooltip() ?? '';
             this.element.setAttribute('aria-label', title);
         }
     }
@@ -243,6 +243,9 @@
             this.label.focus();
         }
     }
+    isFocused() {
+        return !!this.label && this.label?.tabIndex === 0;
+    }
     blur() {
         if (this.label) {
             this.label.tabIndex = -1;
@@ -266,13 +269,12 @@
         else if (!this.options.label && this.action.label && this.options.icon) {
             title = this.action.label;
             if (this.options.keybinding) {
-                title = nls.localize({ key: 'titleLabel', comment: ['action title', 'action keybinding'] }, "{0} ({1})", title, this.options.keybinding);
+                title = nls.localizeWithPath('vs/base/browser/ui/actionbar/actionViewItems', { key: 'titleLabel', comment: ['action title', 'action keybinding'] }, "{0} ({1})", title, this.options.keybinding);
             }
         }
-        return title !== null && title !== void 0 ? title : undefined;
+        return title ?? undefined;
     }
     updateClass() {
-        var _a;
         if (this.cssClass && this.label) {
             this.label.classList.remove(...this.cssClass.split(' '));
         }
@@ -287,30 +289,28 @@
             this.updateEnabled();
         }
         else {
-            (_a = this.label) === null || _a === void 0 ? void 0 : _a.classList.remove('codicon');
+            this.label?.classList.remove('codicon');
         }
     }
     updateEnabled() {
-        var _a, _b;
         if (this.action.enabled) {
             if (this.label) {
                 this.label.removeAttribute('aria-disabled');
                 this.label.classList.remove('disabled');
             }
-            (_a = this.element) === null || _a === void 0 ? void 0 : _a.classList.remove('disabled');
+            this.element?.classList.remove('disabled');
         }
         else {
             if (this.label) {
                 this.label.setAttribute('aria-disabled', 'true');
                 this.label.classList.add('disabled');
             }
-            (_b = this.element) === null || _b === void 0 ? void 0 : _b.classList.add('disabled');
+            this.element?.classList.add('disabled');
         }
     }
     updateAriaLabel() {
-        var _a;
         if (this.label) {
-            const title = (_a = this.getTooltip()) !== null && _a !== void 0 ? _a : '';
+            const title = this.getTooltip() ?? '';
             this.label.setAttribute('aria-label', title);
         }
     }
@@ -337,6 +337,9 @@
         this._register(this.selectBox);
         this.registerListeners();
     }
+    setOptions(options, selected) {
+        this.selectBox.setOptions(options, selected);
+    }
     select(index) {
         this.selectBox.select(index);
     }
@@ -353,12 +356,10 @@
         this.selectBox.setFocusable(focusable);
     }
     focus() {
-        var _a;
-        (_a = this.selectBox) === null || _a === void 0 ? void 0 : _a.focus();
+        this.selectBox?.focus();
     }
     blur() {
-        var _a;
-        (_a = this.selectBox) === null || _a === void 0 ? void 0 : _a.blur();
+        this.selectBox?.blur();
     }
     render(container) {
         this.selectBox.render(container);
diff -urN -x '*.map' a/vs/base/browser/ui/actionbar/actionbar.js b/vs/base/browser/ui/actionbar/actionbar.js
--- a/vs/base/browser/ui/actionbar/actionbar.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/base/browser/ui/actionbar/actionbar.js	2023-12-06 14:23:14.343854719 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import * as DOM from '../../dom.js';
 import { StandardKeyboardEvent } from '../../keyboardEvent.js';
 import { ActionViewItem, BaseActionViewItem } from './actionViewItems.js';
@@ -21,7 +12,6 @@
 import './actionbar.css';
 export class ActionBar extends Disposable {
     constructor(container, options = {}) {
-        var _a, _b, _c, _d, _e, _f;
         super();
         this._actionRunnerDisposables = this._register(new DisposableStore());
         this.viewItemDisposables = this._register(new DisposableMap());
@@ -38,11 +28,11 @@
         this._onWillRun = this._register(new Emitter());
         this.onWillRun = this._onWillRun.event;
         this.options = options;
-        this._context = (_a = options.context) !== null && _a !== void 0 ? _a : null;
-        this._orientation = (_b = this.options.orientation) !== null && _b !== void 0 ? _b : 0 /* ActionsOrientation.HORIZONTAL */;
+        this._context = options.context ?? null;
+        this._orientation = this.options.orientation ?? 0 /* ActionsOrientation.HORIZONTAL */;
         this._triggerKeys = {
-            keyDown: (_d = (_c = this.options.triggerKeys) === null || _c === void 0 ? void 0 : _c.keyDown) !== null && _d !== void 0 ? _d : false,
-            keys: (_f = (_e = this.options.triggerKeys) === null || _e === void 0 ? void 0 : _e.keys) !== null && _f !== void 0 ? _f : [3 /* KeyCode.Enter */, 10 /* KeyCode.Space */]
+            keyDown: this.options.triggerKeys?.keyDown ?? false,
+            keys: this.options.triggerKeys?.keys ?? [3 /* KeyCode.Enter */, 10 /* KeyCode.Space */]
         };
         if (this.options.actionRunner) {
             this._actionRunner = this.options.actionRunner;
@@ -158,6 +148,14 @@
             this.actionsList.setAttribute('role', 'presentation');
         }
     }
+    setAriaLabel(label) {
+        if (label) {
+            this.actionsList.setAttribute('aria-label', label);
+        }
+        else {
+            this.actionsList.removeAttribute('aria-label');
+        }
+    }
     // Some action bars should not be focusable at times
     // When an action bar is not focusable make sure to make all the elements inside it not focusable
     // When an action bar is focusable again, make sure the first item can be focused
@@ -215,11 +213,13 @@
     getContainer() {
         return this.domNode;
     }
+    hasAction(action) {
+        return this.viewItems.findIndex(candidate => candidate.action.id === action.id) !== -1;
+    }
     getAction(indexOrElement) {
-        var _a;
         // by index
         if (typeof indexOrElement === 'number') {
-            return (_a = this.viewItems[indexOrElement]) === null || _a === void 0 ? void 0 : _a.action;
+            return this.viewItems[indexOrElement]?.action;
         }
         // by element
         if (indexOrElement instanceof HTMLElement) {
@@ -245,7 +245,7 @@
             actionViewItemElement.className = 'action-item';
             actionViewItemElement.setAttribute('role', 'presentation');
             let item;
-            const viewItemOptions = Object.assign({ hoverDelegate: this.options.hoverDelegate }, options);
+            const viewItemOptions = { hoverDelegate: this.options.hoverDelegate, ...options };
             if (this.options.actionViewItemProvider) {
                 item = this.options.actionViewItemProvider(action, viewItemOptions);
             }
@@ -281,6 +281,32 @@
         }
         this.refreshRole();
     }
+    getWidth(index) {
+        if (index >= 0 && index < this.actionsList.children.length) {
+            const item = this.actionsList.children.item(index);
+            if (item) {
+                return item.clientWidth;
+            }
+        }
+        return 0;
+    }
+    getHeight(index) {
+        if (index >= 0 && index < this.actionsList.children.length) {
+            const item = this.actionsList.children.item(index);
+            if (item) {
+                return item.clientHeight;
+            }
+        }
+        return 0;
+    }
+    pull(index) {
+        if (index >= 0 && index < this.viewItems.length) {
+            this.actionsList.removeChild(this.actionsList.childNodes[index]);
+            this.viewItemDisposables.deleteAndDispose(this.viewItems[index]);
+            dispose(this.viewItems.splice(index, 1));
+            this.refreshRole();
+        }
+    }
     clear() {
         if (this.isEmpty()) {
             return;
@@ -373,12 +399,11 @@
         return true;
     }
     updateFocus(fromRight, preventScroll, forceFocus = false) {
-        var _a;
         if (typeof this.focusedItem === 'undefined') {
             this.actionsList.focus({ preventScroll });
         }
         if (this.previouslyFocusedItem !== undefined && this.previouslyFocusedItem !== this.focusedItem) {
-            (_a = this.viewItems[this.previouslyFocusedItem]) === null || _a === void 0 ? void 0 : _a.blur();
+            this.viewItems[this.previouslyFocusedItem]?.blur();
         }
         const actionViewItem = this.focusedItem !== undefined && this.viewItems[this.focusedItem];
         if (actionViewItem) {
@@ -413,10 +438,8 @@
             this.run(actionViewItem._action, context);
         }
     }
-    run(action, context) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield this._actionRunner.run(action, context);
-        });
+    async run(action, context) {
+        await this._actionRunner.run(action, context);
     }
     dispose() {
         this._context = undefined;
@@ -425,3 +448,46 @@
         super.dispose();
     }
 }
+export function prepareActions(actions) {
+    if (!actions.length) {
+        return actions;
+    }
+    // Clean up leading separators
+    let firstIndexOfAction = -1;
+    for (let i = 0; i < actions.length; i++) {
+        if (actions[i].id === Separator.ID) {
+            continue;
+        }
+        firstIndexOfAction = i;
+        break;
+    }
+    if (firstIndexOfAction === -1) {
+        return [];
+    }
+    actions = actions.slice(firstIndexOfAction);
+    // Clean up trailing separators
+    for (let h = actions.length - 1; h >= 0; h--) {
+        const isSeparator = actions[h].id === Separator.ID;
+        if (isSeparator) {
+            actions.splice(h, 1);
+        }
+        else {
+            break;
+        }
+    }
+    // Clean up separator duplicates
+    let foundAction = false;
+    for (let k = actions.length - 1; k >= 0; k--) {
+        const isSeparator = actions[k].id === Separator.ID;
+        if (isSeparator && !foundAction) {
+            actions.splice(k, 1);
+        }
+        else if (!isSeparator) {
+            foundAction = true;
+        }
+        else if (isSeparator) {
+            foundAction = false;
+        }
+    }
+    return actions;
+}
diff -urN -x '*.map' a/vs/base/browser/ui/breadcrumbs/breadcrumbsWidget.js b/vs/base/browser/ui/breadcrumbs/breadcrumbsWidget.js
--- a/vs/base/browser/ui/breadcrumbs/breadcrumbsWidget.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/breadcrumbs/breadcrumbsWidget.js	2023-12-06 14:23:14.343854719 +0000
@@ -1 +1,299 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import * as dom from '../../dom.js';
+import { DomScrollableElement } from '../scrollbar/scrollableElement.js';
+import { commonPrefixLength } from '../../../common/arrays.js';
+import { ThemeIcon } from '../../../common/themables.js';
+import { Emitter } from '../../../common/event.js';
+import { DisposableStore, dispose } from '../../../common/lifecycle.js';
 import './breadcrumbsWidget.css';
+export class BreadcrumbsItem {
+    dispose() { }
+}
+export class BreadcrumbsWidget {
+    constructor(container, horizontalScrollbarSize, separatorIcon, styles) {
+        this._disposables = new DisposableStore();
+        this._onDidSelectItem = new Emitter();
+        this._onDidFocusItem = new Emitter();
+        this._onDidChangeFocus = new Emitter();
+        this.onDidSelectItem = this._onDidSelectItem.event;
+        this.onDidFocusItem = this._onDidFocusItem.event;
+        this.onDidChangeFocus = this._onDidChangeFocus.event;
+        this._items = new Array();
+        this._nodes = new Array();
+        this._freeNodes = new Array();
+        this._enabled = true;
+        this._focusedItemIdx = -1;
+        this._selectedItemIdx = -1;
+        this._domNode = document.createElement('div');
+        this._domNode.className = 'monaco-breadcrumbs';
+        this._domNode.tabIndex = 0;
+        this._domNode.setAttribute('role', 'list');
+        this._scrollable = new DomScrollableElement(this._domNode, {
+            vertical: 2 /* ScrollbarVisibility.Hidden */,
+            horizontal: 1 /* ScrollbarVisibility.Auto */,
+            horizontalScrollbarSize,
+            useShadows: false,
+            scrollYToX: true
+        });
+        this._separatorIcon = separatorIcon;
+        this._disposables.add(this._scrollable);
+        this._disposables.add(dom.addStandardDisposableListener(this._domNode, 'click', e => this._onClick(e)));
+        container.appendChild(this._scrollable.getDomNode());
+        const styleElement = dom.createStyleSheet(this._domNode);
+        this._style(styleElement, styles);
+        const focusTracker = dom.trackFocus(this._domNode);
+        this._disposables.add(focusTracker);
+        this._disposables.add(focusTracker.onDidBlur(_ => this._onDidChangeFocus.fire(false)));
+        this._disposables.add(focusTracker.onDidFocus(_ => this._onDidChangeFocus.fire(true)));
+    }
+    setHorizontalScrollbarSize(size) {
+        this._scrollable.updateOptions({
+            horizontalScrollbarSize: size
+        });
+    }
+    dispose() {
+        this._disposables.dispose();
+        this._pendingLayout?.dispose();
+        this._onDidSelectItem.dispose();
+        this._onDidFocusItem.dispose();
+        this._onDidChangeFocus.dispose();
+        this._domNode.remove();
+        this._nodes.length = 0;
+        this._freeNodes.length = 0;
+    }
+    layout(dim) {
+        if (dim && dom.Dimension.equals(dim, this._dimension)) {
+            return;
+        }
+        this._pendingLayout?.dispose();
+        if (dim) {
+            // only measure
+            this._pendingLayout = this._updateDimensions(dim);
+        }
+        else {
+            this._pendingLayout = this._updateScrollbar();
+        }
+    }
+    _updateDimensions(dim) {
+        const disposables = new DisposableStore();
+        disposables.add(dom.modify(() => {
+            this._dimension = dim;
+            this._domNode.style.width = `${dim.width}px`;
+            this._domNode.style.height = `${dim.height}px`;
+            disposables.add(this._updateScrollbar());
+        }));
+        return disposables;
+    }
+    _updateScrollbar() {
+        return dom.measure(() => {
+            dom.measure(() => {
+                this._scrollable.setRevealOnScroll(false);
+                this._scrollable.scanDomNode();
+                this._scrollable.setRevealOnScroll(true);
+            });
+        });
+    }
+    _style(styleElement, style) {
+        let content = '';
+        if (style.breadcrumbsBackground) {
+            content += `.monaco-breadcrumbs { background-color: ${style.breadcrumbsBackground}}`;
+        }
+        if (style.breadcrumbsForeground) {
+            content += `.monaco-breadcrumbs .monaco-breadcrumb-item { color: ${style.breadcrumbsForeground}}\n`;
+        }
+        if (style.breadcrumbsFocusForeground) {
+            content += `.monaco-breadcrumbs .monaco-breadcrumb-item.focused { color: ${style.breadcrumbsFocusForeground}}\n`;
+        }
+        if (style.breadcrumbsFocusAndSelectionForeground) {
+            content += `.monaco-breadcrumbs .monaco-breadcrumb-item.focused.selected { color: ${style.breadcrumbsFocusAndSelectionForeground}}\n`;
+        }
+        if (style.breadcrumbsHoverForeground) {
+            content += `.monaco-breadcrumbs:not(.disabled	) .monaco-breadcrumb-item:hover:not(.focused):not(.selected) { color: ${style.breadcrumbsHoverForeground}}\n`;
+        }
+        styleElement.innerText = content;
+    }
+    setEnabled(value) {
+        this._enabled = value;
+        this._domNode.classList.toggle('disabled', !this._enabled);
+    }
+    domFocus() {
+        const idx = this._focusedItemIdx >= 0 ? this._focusedItemIdx : this._items.length - 1;
+        if (idx >= 0 && idx < this._items.length) {
+            this._focus(idx, undefined);
+        }
+        else {
+            this._domNode.focus();
+        }
+    }
+    isDOMFocused() {
+        let candidate = document.activeElement;
+        while (candidate) {
+            if (this._domNode === candidate) {
+                return true;
+            }
+            candidate = candidate.parentElement;
+        }
+        return false;
+    }
+    getFocused() {
+        return this._items[this._focusedItemIdx];
+    }
+    setFocused(item, payload) {
+        this._focus(this._items.indexOf(item), payload);
+    }
+    focusPrev(payload) {
+        if (this._focusedItemIdx > 0) {
+            this._focus(this._focusedItemIdx - 1, payload);
+        }
+    }
+    focusNext(payload) {
+        if (this._focusedItemIdx + 1 < this._nodes.length) {
+            this._focus(this._focusedItemIdx + 1, payload);
+        }
+    }
+    _focus(nth, payload) {
+        this._focusedItemIdx = -1;
+        for (let i = 0; i < this._nodes.length; i++) {
+            const node = this._nodes[i];
+            if (i !== nth) {
+                node.classList.remove('focused');
+            }
+            else {
+                this._focusedItemIdx = i;
+                node.classList.add('focused');
+                node.focus();
+            }
+        }
+        this._reveal(this._focusedItemIdx, true);
+        this._onDidFocusItem.fire({ type: 'focus', item: this._items[this._focusedItemIdx], node: this._nodes[this._focusedItemIdx], payload });
+    }
+    reveal(item) {
+        const idx = this._items.indexOf(item);
+        if (idx >= 0) {
+            this._reveal(idx, false);
+        }
+    }
+    revealLast() {
+        this._reveal(this._items.length - 1, false);
+    }
+    _reveal(nth, minimal) {
+        if (nth < 0 || nth >= this._nodes.length) {
+            return;
+        }
+        const node = this._nodes[nth];
+        if (!node) {
+            return;
+        }
+        const { width } = this._scrollable.getScrollDimensions();
+        const { scrollLeft } = this._scrollable.getScrollPosition();
+        if (!minimal || node.offsetLeft > scrollLeft + width || node.offsetLeft < scrollLeft) {
+            this._scrollable.setRevealOnScroll(false);
+            this._scrollable.setScrollPosition({ scrollLeft: node.offsetLeft });
+            this._scrollable.setRevealOnScroll(true);
+        }
+    }
+    getSelection() {
+        return this._items[this._selectedItemIdx];
+    }
+    setSelection(item, payload) {
+        this._select(this._items.indexOf(item), payload);
+    }
+    _select(nth, payload) {
+        this._selectedItemIdx = -1;
+        for (let i = 0; i < this._nodes.length; i++) {
+            const node = this._nodes[i];
+            if (i !== nth) {
+                node.classList.remove('selected');
+            }
+            else {
+                this._selectedItemIdx = i;
+                node.classList.add('selected');
+            }
+        }
+        this._onDidSelectItem.fire({ type: 'select', item: this._items[this._selectedItemIdx], node: this._nodes[this._selectedItemIdx], payload });
+    }
+    getItems() {
+        return this._items;
+    }
+    setItems(items) {
+        let prefix;
+        let removed = [];
+        try {
+            prefix = commonPrefixLength(this._items, items, (a, b) => a.equals(b));
+            removed = this._items.splice(prefix, this._items.length - prefix, ...items.slice(prefix));
+            this._render(prefix);
+            dispose(removed);
+            this._focus(-1, undefined);
+        }
+        catch (e) {
+            const newError = new Error(`BreadcrumbsItem#setItems: newItems: ${items.length}, prefix: ${prefix}, removed: ${removed.length}`);
+            newError.name = e.name;
+            newError.stack = e.stack;
+            throw newError;
+        }
+    }
+    _render(start) {
+        let didChange = false;
+        for (; start < this._items.length && start < this._nodes.length; start++) {
+            const item = this._items[start];
+            const node = this._nodes[start];
+            this._renderItem(item, node);
+            didChange = true;
+        }
+        // case a: more nodes -> remove them
+        while (start < this._nodes.length) {
+            const free = this._nodes.pop();
+            if (free) {
+                this._freeNodes.push(free);
+                free.remove();
+                didChange = true;
+            }
+        }
+        // case b: more items -> render them
+        for (; start < this._items.length; start++) {
+            const item = this._items[start];
+            const node = this._freeNodes.length > 0 ? this._freeNodes.pop() : document.createElement('div');
+            if (node) {
+                this._renderItem(item, node);
+                this._domNode.appendChild(node);
+                this._nodes.push(node);
+                didChange = true;
+            }
+        }
+        if (didChange) {
+            this.layout(undefined);
+        }
+    }
+    _renderItem(item, container) {
+        dom.clearNode(container);
+        container.className = '';
+        try {
+            item.render(container);
+        }
+        catch (err) {
+            container.innerText = '<<RENDER ERROR>>';
+            console.error(err);
+        }
+        container.tabIndex = -1;
+        container.setAttribute('role', 'listitem');
+        container.classList.add('monaco-breadcrumb-item');
+        const iconContainer = dom.$(ThemeIcon.asCSSSelector(this._separatorIcon));
+        container.appendChild(iconContainer);
+    }
+    _onClick(event) {
+        if (!this._enabled) {
+            return;
+        }
+        for (let el = event.target; el; el = el.parentElement) {
+            const idx = this._nodes.indexOf(el);
+            if (idx >= 0) {
+                this._focus(idx, event);
+                this._select(idx, event);
+                break;
+            }
+        }
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/ui/button/button.js b/vs/base/browser/ui/button/button.js
--- a/vs/base/browser/ui/button/button.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/button/button.js	2023-12-06 14:23:14.343854719 +0000
@@ -1,14 +1,22 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 import { addDisposableListener, EventHelper, EventType, reset, trackFocus } from '../../dom.js';
 import { sanitize } from '../../dompurify/dompurify.js';
 import { StandardKeyboardEvent } from '../../keyboardEvent.js';
 import { renderMarkdown, renderStringAsPlaintext } from '../../markdownRenderer.js';
 import { Gesture, EventType as TouchEventType } from '../../touch.js';
 import { renderLabelWithIcons } from '../iconLabel/iconLabels.js';
+import { Action } from '../../../common/actions.js';
+import { Codicon } from '../../../common/codicons.js';
 import { Color } from '../../../common/color.js';
 import { Emitter } from '../../../common/event.js';
 import { isMarkdownString, markdownStringEqual } from '../../../common/htmlContent.js';
-import { Disposable } from '../../../common/lifecycle.js';
+import { Disposable, DisposableStore } from '../../../common/lifecycle.js';
+import { ThemeIcon } from '../../../common/themables.js';
 import './button.css';
+import { localizeWithPath } from '../../../../nls.js';
 export const unthemedButtonStyles = {
     buttonBackground: '#0E639C',
     buttonHoverBackground: '#006BB3',
@@ -127,7 +135,6 @@
         return this._element;
     }
     set label(value) {
-        var _a;
         if (this._label === value) {
             return;
         }
@@ -140,7 +147,7 @@
             const rendered = renderMarkdown(value, { inline: true });
             rendered.dispose();
             // Don't include outer `<p>`
-            const root = (_a = rendered.element.querySelector('p')) === null || _a === void 0 ? void 0 : _a.innerHTML;
+            const root = rendered.element.querySelector('p')?.innerHTML;
             if (root) {
                 // Only allow a very limited set of inline html tags
                 const sanitized = sanitize(root, { ADD_TAGS: ['b', 'i', 'u', 'code', 'span'], ALLOWED_ATTR: ['class'], RETURN_TRUSTED_TYPE: true });
@@ -169,6 +176,20 @@
     get label() {
         return this._label;
     }
+    set labelShort(value) {
+        if (!this.options.supportShortLabel || !this._labelShortElement) {
+            return;
+        }
+        if (this.options.supportIcons) {
+            reset(this._labelShortElement, ...this.getContentElements(value));
+        }
+        else {
+            this._labelShortElement.textContent = value;
+        }
+    }
+    set icon(icon) {
+        this._element.classList.add(...ThemeIcon.asClassNameArray(icon));
+    }
     set enabled(value) {
         if (value) {
             this._element.classList.remove('disabled');
@@ -183,4 +204,179 @@
     get enabled() {
         return !this._element.classList.contains('disabled');
     }
+    focus() {
+        this._element.focus();
+    }
+    hasFocus() {
+        return this._element === document.activeElement;
+    }
+}
+export class ButtonWithDropdown extends Disposable {
+    constructor(container, options) {
+        super();
+        this._onDidClick = this._register(new Emitter());
+        this.onDidClick = this._onDidClick.event;
+        this.element = document.createElement('div');
+        this.element.classList.add('monaco-button-dropdown');
+        container.appendChild(this.element);
+        this.button = this._register(new Button(this.element, options));
+        this._register(this.button.onDidClick(e => this._onDidClick.fire(e)));
+        this.action = this._register(new Action('primaryAction', renderStringAsPlaintext(this.button.label), undefined, true, async () => this._onDidClick.fire(undefined)));
+        this.separatorContainer = document.createElement('div');
+        this.separatorContainer.classList.add('monaco-button-dropdown-separator');
+        this.separator = document.createElement('div');
+        this.separatorContainer.appendChild(this.separator);
+        this.element.appendChild(this.separatorContainer);
+        // Separator styles
+        const border = options.buttonBorder;
+        if (border) {
+            this.separatorContainer.style.borderTop = '1px solid ' + border;
+            this.separatorContainer.style.borderBottom = '1px solid ' + border;
+        }
+        const buttonBackground = options.secondary ? options.buttonSecondaryBackground : options.buttonBackground;
+        this.separatorContainer.style.backgroundColor = buttonBackground ?? '';
+        this.separator.style.backgroundColor = options.buttonSeparator ?? '';
+        this.dropdownButton = this._register(new Button(this.element, { ...options, title: false, supportIcons: true }));
+        this.dropdownButton.element.title = localizeWithPath('vs/base/browser/ui/button/button', "button dropdown more actions", 'More Actions...');
+        this.dropdownButton.element.setAttribute('aria-haspopup', 'true');
+        this.dropdownButton.element.setAttribute('aria-expanded', 'false');
+        this.dropdownButton.element.classList.add('monaco-dropdown-button');
+        this.dropdownButton.icon = Codicon.dropDownButton;
+        this._register(this.dropdownButton.onDidClick(e => {
+            options.contextMenuProvider.showContextMenu({
+                getAnchor: () => this.dropdownButton.element,
+                getActions: () => options.addPrimaryActionToDropdown === false ? [...options.actions] : [this.action, ...options.actions],
+                actionRunner: options.actionRunner,
+                onHide: () => this.dropdownButton.element.setAttribute('aria-expanded', 'false')
+            });
+            this.dropdownButton.element.setAttribute('aria-expanded', 'true');
+        }));
+    }
+    dispose() {
+        super.dispose();
+        this.element.remove();
+    }
+    set label(value) {
+        this.button.label = value;
+        this.action.label = value;
+    }
+    set icon(icon) {
+        this.button.icon = icon;
+    }
+    set enabled(enabled) {
+        this.button.enabled = enabled;
+        this.dropdownButton.enabled = enabled;
+        this.element.classList.toggle('disabled', !enabled);
+    }
+    get enabled() {
+        return this.button.enabled;
+    }
+    focus() {
+        this.button.focus();
+    }
+    hasFocus() {
+        return this.button.hasFocus() || this.dropdownButton.hasFocus();
+    }
+}
+export class ButtonWithDescription {
+    constructor(container, options) {
+        this.options = options;
+        this._element = document.createElement('div');
+        this._element.classList.add('monaco-description-button');
+        this._button = new Button(this._element, options);
+        this._descriptionElement = document.createElement('div');
+        this._descriptionElement.classList.add('monaco-button-description');
+        this._element.appendChild(this._descriptionElement);
+        container.appendChild(this._element);
+    }
+    get onDidClick() {
+        return this._button.onDidClick;
+    }
+    get element() {
+        return this._element;
+    }
+    set label(value) {
+        this._button.label = value;
+    }
+    set icon(icon) {
+        this._button.icon = icon;
+    }
+    get enabled() {
+        return this._button.enabled;
+    }
+    set enabled(enabled) {
+        this._button.enabled = enabled;
+    }
+    focus() {
+        this._button.focus();
+    }
+    hasFocus() {
+        return this._button.hasFocus();
+    }
+    dispose() {
+        this._button.dispose();
+    }
+    set description(value) {
+        if (this.options.supportIcons) {
+            reset(this._descriptionElement, ...renderLabelWithIcons(value));
+        }
+        else {
+            this._descriptionElement.textContent = value;
+        }
+    }
+}
+export class ButtonBar {
+    constructor(container) {
+        this.container = container;
+        this._buttons = [];
+        this._buttonStore = new DisposableStore();
+    }
+    dispose() {
+        this._buttonStore.dispose();
+    }
+    get buttons() {
+        return this._buttons;
+    }
+    clear() {
+        this._buttonStore.clear();
+        this._buttons.length = 0;
+    }
+    addButton(options) {
+        const button = this._buttonStore.add(new Button(this.container, options));
+        this.pushButton(button);
+        return button;
+    }
+    addButtonWithDescription(options) {
+        const button = this._buttonStore.add(new ButtonWithDescription(this.container, options));
+        this.pushButton(button);
+        return button;
+    }
+    addButtonWithDropdown(options) {
+        const button = this._buttonStore.add(new ButtonWithDropdown(this.container, options));
+        this.pushButton(button);
+        return button;
+    }
+    pushButton(button) {
+        this._buttons.push(button);
+        const index = this._buttons.length - 1;
+        this._buttonStore.add(addDisposableListener(button.element, EventType.KEY_DOWN, e => {
+            const event = new StandardKeyboardEvent(e);
+            let eventHandled = true;
+            // Next / Previous Button
+            let buttonIndexToFocus;
+            if (event.equals(15 /* KeyCode.LeftArrow */)) {
+                buttonIndexToFocus = index > 0 ? index - 1 : this._buttons.length - 1;
+            }
+            else if (event.equals(17 /* KeyCode.RightArrow */)) {
+                buttonIndexToFocus = index === this._buttons.length - 1 ? 0 : index + 1;
+            }
+            else {
+                eventHandled = false;
+            }
+            if (eventHandled && typeof buttonIndexToFocus === 'number') {
+                this._buttons[buttonIndexToFocus].focus();
+                EventHelper.stop(e, true);
+            }
+        }));
+    }
 }
diff -urN -x '*.map' a/vs/base/browser/ui/contextview/contextview.js b/vs/base/browser/ui/contextview/contextview.js
--- a/vs/base/browser/ui/contextview/contextview.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/contextview/contextview.js	2023-12-06 14:23:14.343854719 +0000
@@ -61,13 +61,12 @@
         this._register(toDisposable(() => this.setContainer(null, 1 /* ContextViewDOMPosition.ABSOLUTE */)));
     }
     setContainer(container, domPosition) {
-        var _a;
         if (this.container) {
             this.toDisposeOnSetContainer.dispose();
             if (this.shadowRoot) {
                 this.shadowRoot.removeChild(this.view);
                 this.shadowRoot = null;
-                (_a = this.shadowRootHostElement) === null || _a === void 0 ? void 0 : _a.remove();
+                this.shadowRootHostElement?.remove();
                 this.shadowRootHostElement = null;
             }
             else {
@@ -107,7 +106,6 @@
         }
     }
     show(delegate) {
-        var _a, _b;
         if (this.isVisible()) {
             this.hide();
         }
@@ -126,7 +124,7 @@
         // Layout
         this.doLayout();
         // Focus
-        (_b = (_a = this.delegate).focus) === null || _b === void 0 ? void 0 : _b.call(_a);
+        this.delegate.focus?.();
     }
     getViewElement() {
         return this.view;
@@ -226,7 +224,7 @@
     hide(data) {
         const delegate = this.delegate;
         this.delegate = null;
-        if (delegate === null || delegate === void 0 ? void 0 : delegate.onHide) {
+        if (delegate?.onHide) {
             delegate.onHide(data);
         }
         this.toDisposeOnClean.dispose();
diff -urN -x '*.map' a/vs/base/browser/ui/countBadge/countBadge.js b/vs/base/browser/ui/countBadge/countBadge.js
--- a/vs/base/browser/ui/countBadge/countBadge.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/countBadge/countBadge.js	2023-12-06 14:23:14.343854719 +0000
@@ -5,6 +5,11 @@
 import { $, append } from '../../dom.js';
 import { format } from '../../../common/strings.js';
 import './countBadge.css';
+export const unthemedCountStyles = {
+    badgeBackground: '#4D4D4D',
+    badgeForeground: '#FFFFFF',
+    badgeBorder: undefined
+};
 export class CountBadge {
     constructor(container, options, styles) {
         this.options = options;
@@ -19,16 +24,19 @@
         this.count = count;
         this.render();
     }
+    setCountFormat(countFormat) {
+        this.countFormat = countFormat;
+        this.render();
+    }
     setTitleFormat(titleFormat) {
         this.titleFormat = titleFormat;
         this.render();
     }
     render() {
-        var _a, _b;
         this.element.textContent = format(this.countFormat, this.count);
         this.element.title = format(this.titleFormat, this.count);
-        this.element.style.backgroundColor = (_a = this.styles.badgeBackground) !== null && _a !== void 0 ? _a : '';
-        this.element.style.color = (_b = this.styles.badgeForeground) !== null && _b !== void 0 ? _b : '';
+        this.element.style.backgroundColor = this.styles.badgeBackground ?? '';
+        this.element.style.color = this.styles.badgeForeground ?? '';
         if (this.styles.badgeBorder) {
             this.element.style.border = `1px solid ${this.styles.badgeBorder}`;
         }
diff -urN -x '*.map' a/vs/base/browser/ui/dialog/dialog.js b/vs/base/browser/ui/dialog/dialog.js
--- a/vs/base/browser/ui/dialog/dialog.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/dialog/dialog.js	2023-12-06 14:23:14.343854719 +0000
@@ -1 +1,388 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { $, addDisposableListener, clearNode, EventHelper, EventType, hide, isAncestor, show } from '../../dom.js';
+import { StandardKeyboardEvent } from '../../keyboardEvent.js';
+import { ActionBar } from '../actionbar/actionbar.js';
+import { ButtonBar, ButtonWithDescription } from '../button/button.js';
+import { Checkbox } from '../toggle/toggle.js';
+import { InputBox } from '../inputbox/inputBox.js';
+import { Action } from '../../../common/actions.js';
+import { Codicon } from '../../../common/codicons.js';
+import { ThemeIcon } from '../../../common/themables.js';
+import { mnemonicButtonLabel } from '../../../common/labels.js';
+import { Disposable } from '../../../common/lifecycle.js';
+import { isLinux, isMacintosh, isWindows } from '../../../common/platform.js';
 import './dialog.css';
+import * as nls from '../../../../nls.js';
+export class Dialog extends Disposable {
+    constructor(container, message, buttons, options) {
+        super();
+        this.container = container;
+        this.message = message;
+        this.options = options;
+        this.modalElement = this.container.appendChild($(`.monaco-dialog-modal-block.dimmed`));
+        this.shadowElement = this.modalElement.appendChild($('.dialog-shadow'));
+        this.element = this.shadowElement.appendChild($('.monaco-dialog-box'));
+        this.element.setAttribute('role', 'dialog');
+        this.element.tabIndex = -1;
+        hide(this.element);
+        this.buttonStyles = options.buttonStyles;
+        if (Array.isArray(buttons) && buttons.length > 0) {
+            this.buttons = buttons;
+        }
+        else if (!this.options.disableDefaultAction) {
+            this.buttons = [nls.localizeWithPath('vs/base/browser/ui/dialog/dialog', 'ok', "OK")];
+        }
+        else {
+            this.buttons = [];
+        }
+        const buttonsRowElement = this.element.appendChild($('.dialog-buttons-row'));
+        this.buttonsContainer = buttonsRowElement.appendChild($('.dialog-buttons'));
+        const messageRowElement = this.element.appendChild($('.dialog-message-row'));
+        this.iconElement = messageRowElement.appendChild($('#monaco-dialog-icon.dialog-icon'));
+        this.iconElement.setAttribute('aria-label', this.getIconAriaLabel());
+        this.messageContainer = messageRowElement.appendChild($('.dialog-message-container'));
+        if (this.options.detail || this.options.renderBody) {
+            const messageElement = this.messageContainer.appendChild($('.dialog-message'));
+            const messageTextElement = messageElement.appendChild($('#monaco-dialog-message-text.dialog-message-text'));
+            messageTextElement.innerText = this.message;
+        }
+        this.messageDetailElement = this.messageContainer.appendChild($('#monaco-dialog-message-detail.dialog-message-detail'));
+        if (this.options.detail || !this.options.renderBody) {
+            this.messageDetailElement.innerText = this.options.detail ? this.options.detail : message;
+        }
+        else {
+            this.messageDetailElement.style.display = 'none';
+        }
+        if (this.options.renderBody) {
+            const customBody = this.messageContainer.appendChild($('#monaco-dialog-message-body.dialog-message-body'));
+            this.options.renderBody(customBody);
+            for (const el of this.messageContainer.querySelectorAll('a')) {
+                el.tabIndex = 0;
+            }
+        }
+        if (this.options.inputs) {
+            this.inputs = this.options.inputs.map(input => {
+                const inputRowElement = this.messageContainer.appendChild($('.dialog-message-input'));
+                const inputBox = this._register(new InputBox(inputRowElement, undefined, {
+                    placeholder: input.placeholder,
+                    type: input.type ?? 'text',
+                    inputBoxStyles: options.inputBoxStyles
+                }));
+                if (input.value) {
+                    inputBox.value = input.value;
+                }
+                return inputBox;
+            });
+        }
+        else {
+            this.inputs = [];
+        }
+        if (this.options.checkboxLabel) {
+            const checkboxRowElement = this.messageContainer.appendChild($('.dialog-checkbox-row'));
+            const checkbox = this.checkbox = this._register(new Checkbox(this.options.checkboxLabel, !!this.options.checkboxChecked, options.checkboxStyles));
+            checkboxRowElement.appendChild(checkbox.domNode);
+            const checkboxMessageElement = checkboxRowElement.appendChild($('.dialog-checkbox-message'));
+            checkboxMessageElement.innerText = this.options.checkboxLabel;
+            this._register(addDisposableListener(checkboxMessageElement, EventType.CLICK, () => checkbox.checked = !checkbox.checked));
+        }
+        const toolbarRowElement = this.element.appendChild($('.dialog-toolbar-row'));
+        this.toolbarContainer = toolbarRowElement.appendChild($('.dialog-toolbar'));
+        this.applyStyles();
+    }
+    getIconAriaLabel() {
+        let typeLabel = nls.localizeWithPath('vs/base/browser/ui/dialog/dialog', 'dialogInfoMessage', 'Info');
+        switch (this.options.type) {
+            case 'error':
+                typeLabel = nls.localizeWithPath('vs/base/browser/ui/dialog/dialog', 'dialogErrorMessage', 'Error');
+                break;
+            case 'warning':
+                typeLabel = nls.localizeWithPath('vs/base/browser/ui/dialog/dialog', 'dialogWarningMessage', 'Warning');
+                break;
+            case 'pending':
+                typeLabel = nls.localizeWithPath('vs/base/browser/ui/dialog/dialog', 'dialogPendingMessage', 'In Progress');
+                break;
+            case 'none':
+            case 'info':
+            case 'question':
+            default:
+                break;
+        }
+        return typeLabel;
+    }
+    updateMessage(message) {
+        this.messageDetailElement.innerText = message;
+    }
+    async show() {
+        this.focusToReturn = document.activeElement;
+        return new Promise((resolve) => {
+            clearNode(this.buttonsContainer);
+            const buttonBar = this.buttonBar = this._register(new ButtonBar(this.buttonsContainer));
+            const buttonMap = this.rearrangeButtons(this.buttons, this.options.cancelId);
+            // Handle button clicks
+            buttonMap.forEach((entry, index) => {
+                const primary = buttonMap[index].index === 0;
+                const button = this.options.buttonDetails ? this._register(buttonBar.addButtonWithDescription({ title: true, secondary: !primary, ...this.buttonStyles })) : this._register(buttonBar.addButton({ title: true, secondary: !primary, ...this.buttonStyles }));
+                button.label = mnemonicButtonLabel(buttonMap[index].label, true);
+                if (button instanceof ButtonWithDescription) {
+                    button.description = this.options.buttonDetails[buttonMap[index].index];
+                }
+                this._register(button.onDidClick(e => {
+                    if (e) {
+                        EventHelper.stop(e);
+                    }
+                    resolve({
+                        button: buttonMap[index].index,
+                        checkboxChecked: this.checkbox ? this.checkbox.checked : undefined,
+                        values: this.inputs.length > 0 ? this.inputs.map(input => input.value) : undefined
+                    });
+                }));
+            });
+            // Handle keyboard events globally: Tab, Arrow-Left/Right
+            this._register(addDisposableListener(window, 'keydown', e => {
+                const evt = new StandardKeyboardEvent(e);
+                if (evt.equals(512 /* KeyMod.Alt */)) {
+                    evt.preventDefault();
+                }
+                if (evt.equals(3 /* KeyCode.Enter */)) {
+                    // Enter in input field should OK the dialog
+                    if (this.inputs.some(input => input.hasFocus())) {
+                        EventHelper.stop(e);
+                        resolve({
+                            button: buttonMap.find(button => button.index !== this.options.cancelId)?.index ?? 0,
+                            checkboxChecked: this.checkbox ? this.checkbox.checked : undefined,
+                            values: this.inputs.length > 0 ? this.inputs.map(input => input.value) : undefined
+                        });
+                    }
+                    return; // leave default handling
+                }
+                if (evt.equals(10 /* KeyCode.Space */)) {
+                    return; // leave default handling
+                }
+                let eventHandled = false;
+                // Focus: Next / Previous
+                if (evt.equals(2 /* KeyCode.Tab */) || evt.equals(17 /* KeyCode.RightArrow */) || evt.equals(1024 /* KeyMod.Shift */ | 2 /* KeyCode.Tab */) || evt.equals(15 /* KeyCode.LeftArrow */)) {
+                    // Build a list of focusable elements in their visual order
+                    const focusableElements = [];
+                    let focusedIndex = -1;
+                    if (this.messageContainer) {
+                        const links = this.messageContainer.querySelectorAll('a');
+                        for (const link of links) {
+                            focusableElements.push(link);
+                            if (link === document.activeElement) {
+                                focusedIndex = focusableElements.length - 1;
+                            }
+                        }
+                    }
+                    for (const input of this.inputs) {
+                        focusableElements.push(input);
+                        if (input.hasFocus()) {
+                            focusedIndex = focusableElements.length - 1;
+                        }
+                    }
+                    if (this.checkbox) {
+                        focusableElements.push(this.checkbox);
+                        if (this.checkbox.hasFocus()) {
+                            focusedIndex = focusableElements.length - 1;
+                        }
+                    }
+                    if (this.buttonBar) {
+                        for (const button of this.buttonBar.buttons) {
+                            focusableElements.push(button);
+                            if (button.hasFocus()) {
+                                focusedIndex = focusableElements.length - 1;
+                            }
+                        }
+                    }
+                    // Focus next element (with wrapping)
+                    if (evt.equals(2 /* KeyCode.Tab */) || evt.equals(17 /* KeyCode.RightArrow */)) {
+                        if (focusedIndex === -1) {
+                            focusedIndex = 0; // default to focus first element if none have focus
+                        }
+                        const newFocusedIndex = (focusedIndex + 1) % focusableElements.length;
+                        focusableElements[newFocusedIndex].focus();
+                    }
+                    // Focus previous element (with wrapping)
+                    else {
+                        if (focusedIndex === -1) {
+                            focusedIndex = focusableElements.length; // default to focus last element if none have focus
+                        }
+                        let newFocusedIndex = focusedIndex - 1;
+                        if (newFocusedIndex === -1) {
+                            newFocusedIndex = focusableElements.length - 1;
+                        }
+                        focusableElements[newFocusedIndex].focus();
+                    }
+                    eventHandled = true;
+                }
+                if (eventHandled) {
+                    EventHelper.stop(e, true);
+                }
+                else if (this.options.keyEventProcessor) {
+                    this.options.keyEventProcessor(evt);
+                }
+            }, true));
+            this._register(addDisposableListener(window, 'keyup', e => {
+                EventHelper.stop(e, true);
+                const evt = new StandardKeyboardEvent(e);
+                if (!this.options.disableCloseAction && evt.equals(9 /* KeyCode.Escape */)) {
+                    resolve({
+                        button: this.options.cancelId || 0,
+                        checkboxChecked: this.checkbox ? this.checkbox.checked : undefined
+                    });
+                }
+            }, true));
+            // Detect focus out
+            this._register(addDisposableListener(this.element, 'focusout', e => {
+                if (!!e.relatedTarget && !!this.element) {
+                    if (!isAncestor(e.relatedTarget, this.element)) {
+                        this.focusToReturn = e.relatedTarget;
+                        if (e.target) {
+                            e.target.focus();
+                            EventHelper.stop(e, true);
+                        }
+                    }
+                }
+            }, false));
+            const spinModifierClassName = 'codicon-modifier-spin';
+            this.iconElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.dialogError), ...ThemeIcon.asClassNameArray(Codicon.dialogWarning), ...ThemeIcon.asClassNameArray(Codicon.dialogInfo), ...ThemeIcon.asClassNameArray(Codicon.loading), spinModifierClassName);
+            if (this.options.icon) {
+                this.iconElement.classList.add(...ThemeIcon.asClassNameArray(this.options.icon));
+            }
+            else {
+                switch (this.options.type) {
+                    case 'error':
+                        this.iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.dialogError));
+                        break;
+                    case 'warning':
+                        this.iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.dialogWarning));
+                        break;
+                    case 'pending':
+                        this.iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.loading), spinModifierClassName);
+                        break;
+                    case 'none':
+                        this.iconElement.classList.add('no-codicon');
+                        break;
+                    case 'info':
+                    case 'question':
+                    default:
+                        this.iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.dialogInfo));
+                        break;
+                }
+            }
+            if (!this.options.disableCloseAction) {
+                const actionBar = this._register(new ActionBar(this.toolbarContainer, {}));
+                const action = this._register(new Action('dialog.close', nls.localizeWithPath('vs/base/browser/ui/dialog/dialog', 'dialogClose', "Close Dialog"), ThemeIcon.asClassName(Codicon.dialogClose), true, async () => {
+                    resolve({
+                        button: this.options.cancelId || 0,
+                        checkboxChecked: this.checkbox ? this.checkbox.checked : undefined
+                    });
+                }));
+                actionBar.push(action, { icon: true, label: false });
+            }
+            this.applyStyles();
+            this.element.setAttribute('aria-modal', 'true');
+            this.element.setAttribute('aria-labelledby', 'monaco-dialog-icon monaco-dialog-message-text');
+            this.element.setAttribute('aria-describedby', 'monaco-dialog-icon monaco-dialog-message-text monaco-dialog-message-detail monaco-dialog-message-body');
+            show(this.element);
+            // Focus first element (input or button)
+            if (this.inputs.length > 0) {
+                this.inputs[0].focus();
+                this.inputs[0].select();
+            }
+            else {
+                buttonMap.forEach((value, index) => {
+                    if (value.index === 0) {
+                        buttonBar.buttons[index].focus();
+                    }
+                });
+            }
+        });
+    }
+    applyStyles() {
+        const style = this.options.dialogStyles;
+        const fgColor = style.dialogForeground;
+        const bgColor = style.dialogBackground;
+        const shadowColor = style.dialogShadow ? `0 0px 8px ${style.dialogShadow}` : '';
+        const border = style.dialogBorder ? `1px solid ${style.dialogBorder}` : '';
+        const linkFgColor = style.textLinkForeground;
+        this.shadowElement.style.boxShadow = shadowColor;
+        this.element.style.color = fgColor ?? '';
+        this.element.style.backgroundColor = bgColor ?? '';
+        this.element.style.border = border;
+        // TODO fix
+        // if (fgColor && bgColor) {
+        // 	const messageDetailColor = fgColor.transparent(.9);
+        // 	this.messageDetailElement.style.mixBlendMode = messageDetailColor.makeOpaque(bgColor).toString();
+        // }
+        if (linkFgColor) {
+            for (const el of this.messageContainer.getElementsByTagName('a')) {
+                el.style.color = linkFgColor;
+            }
+        }
+        let color;
+        switch (this.options.type) {
+            case 'error':
+                color = style.errorIconForeground;
+                break;
+            case 'warning':
+                color = style.warningIconForeground;
+                break;
+            default:
+                color = style.infoIconForeground;
+                break;
+        }
+        if (color) {
+            this.iconElement.style.color = color;
+        }
+    }
+    dispose() {
+        super.dispose();
+        if (this.modalElement) {
+            this.modalElement.remove();
+            this.modalElement = undefined;
+        }
+        if (this.focusToReturn && isAncestor(this.focusToReturn, document.body)) {
+            this.focusToReturn.focus();
+            this.focusToReturn = undefined;
+        }
+    }
+    rearrangeButtons(buttons, cancelId) {
+        // Maps each button to its current label and old index
+        // so that when we move them around it's not a problem
+        const buttonMap = buttons.map((label, index) => ({ label, index }));
+        if (buttons.length < 2) {
+            return buttonMap; // only need to rearrange if there are 2+ buttons
+        }
+        if (isMacintosh || isLinux) {
+            // Linux: the GNOME HIG (https://developer.gnome.org/hig/patterns/feedback/dialogs.html?highlight=dialog)
+            // recommend the following:
+            // "Always ensure that the cancel button appears first, before the affirmative button. In left-to-right
+            //  locales, this is on the left. This button order ensures that users become aware of, and are reminded
+            //  of, the ability to cancel prior to encountering the affirmative button."
+            // macOS: the HIG (https://developer.apple.com/design/human-interface-guidelines/components/presentation/alerts)
+            // recommend the following:
+            // "Place buttons where people expect. In general, place the button people are most likely to choose on the trailing side in a
+            //  row of buttons or at the top in a stack of buttons. Always place the default button on the trailing side of a row or at the
+            //  top of a stack. Cancel buttons are typically on the leading side of a row or at the bottom of a stack."
+            if (typeof cancelId === 'number' && buttonMap[cancelId]) {
+                const cancelButton = buttonMap.splice(cancelId, 1)[0];
+                buttonMap.splice(1, 0, cancelButton);
+            }
+            buttonMap.reverse();
+        }
+        else if (isWindows) {
+            // Windows: the HIG (https://learn.microsoft.com/en-us/windows/win32/uxguide/win-dialog-box)
+            // recommend the following:
+            // "One of the following sets of concise commands: Yes/No, Yes/No/Cancel, [Do it]/Cancel,
+            //  [Do it]/[Don't do it], [Do it]/[Don't do it]/Cancel."
+            if (typeof cancelId === 'number' && buttonMap[cancelId]) {
+                const cancelButton = buttonMap.splice(cancelId, 1)[0];
+                buttonMap.push(cancelButton);
+            }
+        }
+        return buttonMap;
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/ui/dropdown/dropdown.js b/vs/base/browser/ui/dropdown/dropdown.js
--- a/vs/base/browser/ui/dropdown/dropdown.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/dropdown/dropdown.js	2023-12-06 14:23:14.343854719 +0000
@@ -61,6 +61,14 @@
     get element() {
         return this._element;
     }
+    get label() {
+        return this._label;
+    }
+    set tooltip(tooltip) {
+        if (this._label) {
+            this._label.title = tooltip;
+        }
+    }
     show() {
         if (!this.visible) {
             this.visible = true;
@@ -73,6 +81,12 @@
             this._onDidChangeVisibility.fire(false);
         }
     }
+    isVisible() {
+        return !!this.visible;
+    }
+    onEvent(_e, activeElement) {
+        this.hide();
+    }
     dispose() {
         super.dispose();
         this.hide();
diff -urN -x '*.map' a/vs/base/browser/ui/dropdown/dropdownActionViewItem.js b/vs/base/browser/ui/dropdown/dropdownActionViewItem.js
--- a/vs/base/browser/ui/dropdown/dropdownActionViewItem.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/dropdown/dropdownActionViewItem.js	2023-12-06 14:23:14.343854719 +0000
@@ -1,6 +1,15 @@
-import { $, append } from '../../dom.js';
-import { BaseActionViewItem } from '../actionbar/actionViewItems.js';
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import * as nls from '../../../../nls.js';
+import { $, addDisposableListener, append, EventType, h } from '../../dom.js';
+import { StandardKeyboardEvent } from '../../keyboardEvent.js';
+import { ActionViewItem, BaseActionViewItem } from '../actionbar/actionViewItems.js';
 import { DropdownMenu } from './dropdown.js';
+import { Action } from '../../../common/actions.js';
+import { Codicon } from '../../../common/codicons.js';
+import { ThemeIcon } from '../../../common/themables.js';
 import { Emitter } from '../../../common/event.js';
 import './dropdown.css';
 export class DropdownMenuActionViewItem extends BaseActionViewItem {
@@ -50,8 +59,7 @@
         };
         this.dropdownMenu = this._register(new DropdownMenu(container, options));
         this._register(this.dropdownMenu.onDidChangeVisibility(visible => {
-            var _a;
-            (_a = this.element) === null || _a === void 0 ? void 0 : _a.setAttribute('aria-expanded', `${visible}`);
+            this.element?.setAttribute('aria-expanded', `${visible}`);
             this._onDidChangeVisibility.fire(visible);
         }));
         this.dropdownMenu.menuOptions = {
@@ -62,9 +70,12 @@
         };
         if (this.options.anchorAlignmentProvider) {
             const that = this;
-            this.dropdownMenu.menuOptions = Object.assign(Object.assign({}, this.dropdownMenu.menuOptions), { get anchorAlignment() {
+            this.dropdownMenu.menuOptions = {
+                ...this.dropdownMenu.menuOptions,
+                get anchorAlignment() {
                     return that.options.anchorAlignmentProvider();
-                } });
+                }
+            };
         }
         this.updateTooltip();
         this.updateEnabled();
@@ -77,7 +88,7 @@
         else if (this.action.label) {
             title = this.action.label;
         }
-        return title !== null && title !== void 0 ? title : undefined;
+        return title ?? undefined;
     }
     setActionContext(newContext) {
         super.setActionContext(newContext);
@@ -91,13 +102,61 @@
         }
     }
     show() {
-        var _a;
-        (_a = this.dropdownMenu) === null || _a === void 0 ? void 0 : _a.show();
+        this.dropdownMenu?.show();
     }
     updateEnabled() {
-        var _a, _b;
         const disabled = !this.action.enabled;
-        (_a = this.actionItem) === null || _a === void 0 ? void 0 : _a.classList.toggle('disabled', disabled);
-        (_b = this.element) === null || _b === void 0 ? void 0 : _b.classList.toggle('disabled', disabled);
+        this.actionItem?.classList.toggle('disabled', disabled);
+        this.element?.classList.toggle('disabled', disabled);
+    }
+}
+export class ActionWithDropdownActionViewItem extends ActionViewItem {
+    constructor(context, action, options, contextMenuProvider) {
+        super(context, action, options);
+        this.contextMenuProvider = contextMenuProvider;
+    }
+    render(container) {
+        super.render(container);
+        if (this.element) {
+            this.element.classList.add('action-dropdown-item');
+            const menuActionsProvider = {
+                getActions: () => {
+                    const actionsProvider = this.options.menuActionsOrProvider;
+                    return Array.isArray(actionsProvider) ? actionsProvider : actionsProvider.getActions(); // TODO: microsoft/TypeScript#42768
+                }
+            };
+            const menuActionClassNames = this.options.menuActionClassNames || [];
+            const separator = h('div.action-dropdown-item-separator', [h('div', {})]).root;
+            separator.classList.toggle('prominent', menuActionClassNames.includes('prominent'));
+            append(this.element, separator);
+            this.dropdownMenuActionViewItem = new DropdownMenuActionViewItem(this._register(new Action('dropdownAction', nls.localizeWithPath('vs/base/browser/ui/dropdown/dropdownActionViewItem', 'moreActions', "More Actions..."))), menuActionsProvider, this.contextMenuProvider, { classNames: ['dropdown', ...ThemeIcon.asClassNameArray(Codicon.dropDownButton), ...menuActionClassNames] });
+            this.dropdownMenuActionViewItem.render(this.element);
+            this._register(addDisposableListener(this.element, EventType.KEY_DOWN, e => {
+                const event = new StandardKeyboardEvent(e);
+                let handled = false;
+                if (this.dropdownMenuActionViewItem?.isFocused() && event.equals(15 /* KeyCode.LeftArrow */)) {
+                    handled = true;
+                    this.dropdownMenuActionViewItem?.blur();
+                    this.focus();
+                }
+                else if (this.isFocused() && event.equals(17 /* KeyCode.RightArrow */)) {
+                    handled = true;
+                    this.blur();
+                    this.dropdownMenuActionViewItem?.focus();
+                }
+                if (handled) {
+                    event.preventDefault();
+                    event.stopPropagation();
+                }
+            }));
+        }
+    }
+    blur() {
+        super.blur();
+        this.dropdownMenuActionViewItem?.blur();
+    }
+    setFocusable(focusable) {
+        super.setFocusable(focusable);
+        this.dropdownMenuActionViewItem?.setFocusable(focusable);
     }
 }
diff -urN -x '*.map' a/vs/base/browser/ui/findinput/findInput.js b/vs/base/browser/ui/findinput/findInput.js
--- a/vs/base/browser/ui/findinput/findInput.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/findinput/findInput.js	2023-12-06 14:23:14.343854719 +0000
@@ -10,7 +10,7 @@
 import './findInput.css';
 import * as nls from '../../../../nls.js';
 import { DisposableStore, MutableDisposable } from '../../../common/lifecycle.js';
-const NLS_DEFAULT_LABEL = nls.localize('defaultLabel', "input");
+const NLS_DEFAULT_LABEL = nls.localizeWithPath('vs/base/browser/ui/findinput/findInput', 'defaultLabel', "input");
 export class FindInput extends Widget {
     constructor(parent, contextViewProvider, options) {
         super();
@@ -25,7 +25,9 @@
         this._onMouseDown = this._register(new Emitter());
         this.onMouseDown = this._onMouseDown.event;
         this._onInput = this._register(new Emitter());
+        this.onInput = this._onInput.event;
         this._onKeyUp = this._register(new Emitter());
+        this.onKeyUp = this._onKeyUp.event;
         this._onCaseSensitiveKeyDown = this._register(new Emitter());
         this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event;
         this._onRegexKeyDown = this._register(new Emitter());
@@ -58,7 +60,11 @@
             inputBoxStyles: options.inputBoxStyles,
         }));
         if (this.showCommonFindToggles) {
-            this.regex = this._register(new RegexToggle(Object.assign({ appendTitle: appendRegexLabel, isChecked: false }, options.toggleStyles)));
+            this.regex = this._register(new RegexToggle({
+                appendTitle: appendRegexLabel,
+                isChecked: false,
+                ...options.toggleStyles
+            }));
             this._register(this.regex.onChange(viaKeyboard => {
                 this._onDidOptionChange.fire(viaKeyboard);
                 if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
@@ -69,7 +75,11 @@
             this._register(this.regex.onKeyDown(e => {
                 this._onRegexKeyDown.fire(e);
             }));
-            this.wholeWords = this._register(new WholeWordsToggle(Object.assign({ appendTitle: appendWholeWordsLabel, isChecked: false }, options.toggleStyles)));
+            this.wholeWords = this._register(new WholeWordsToggle({
+                appendTitle: appendWholeWordsLabel,
+                isChecked: false,
+                ...options.toggleStyles
+            }));
             this._register(this.wholeWords.onChange(viaKeyboard => {
                 this._onDidOptionChange.fire(viaKeyboard);
                 if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
@@ -77,7 +87,11 @@
                 }
                 this.validate();
             }));
-            this.caseSensitive = this._register(new CaseSensitiveToggle(Object.assign({ appendTitle: appendCaseSensitiveLabel, isChecked: false }, options.toggleStyles)));
+            this.caseSensitive = this._register(new CaseSensitiveToggle({
+                appendTitle: appendCaseSensitiveLabel,
+                isChecked: false,
+                ...options.toggleStyles
+            }));
             this._register(this.caseSensitive.onChange(viaKeyboard => {
                 this._onDidOptionChange.fire(viaKeyboard);
                 if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
@@ -130,11 +144,11 @@
         if (this.regex) {
             this.controls.appendChild(this.regex.domNode);
         }
-        this.setAdditionalToggles(options === null || options === void 0 ? void 0 : options.additionalToggles);
+        this.setAdditionalToggles(options?.additionalToggles);
         if (this.controls) {
             this.domNode.appendChild(this.controls);
         }
-        parent === null || parent === void 0 ? void 0 : parent.appendChild(this.domNode);
+        parent?.appendChild(this.domNode);
         this._register(dom.addDisposableListener(this.inputBox.inputElement, 'compositionstart', (e) => {
             this.imeSessionInProgress = true;
         }));
@@ -147,6 +161,9 @@
         this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());
         this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));
     }
+    get isImeSessionInProgress() {
+        return this.imeSessionInProgress;
+    }
     get onDidChange() {
         return this.inputBox.onDidChange;
     }
@@ -155,23 +172,21 @@
         this.updateInputBoxPadding(style.collapsedFindWidget);
     }
     enable() {
-        var _a, _b, _c;
         this.domNode.classList.remove('disabled');
         this.inputBox.enable();
-        (_a = this.regex) === null || _a === void 0 ? void 0 : _a.enable();
-        (_b = this.wholeWords) === null || _b === void 0 ? void 0 : _b.enable();
-        (_c = this.caseSensitive) === null || _c === void 0 ? void 0 : _c.enable();
+        this.regex?.enable();
+        this.wholeWords?.enable();
+        this.caseSensitive?.enable();
         for (const toggle of this.additionalToggles) {
             toggle.enable();
         }
     }
     disable() {
-        var _a, _b, _c;
         this.domNode.classList.add('disabled');
         this.inputBox.disable();
-        (_a = this.regex) === null || _a === void 0 ? void 0 : _a.disable();
-        (_b = this.wholeWords) === null || _b === void 0 ? void 0 : _b.disable();
-        (_c = this.caseSensitive) === null || _c === void 0 ? void 0 : _c.disable();
+        this.regex?.disable();
+        this.wholeWords?.disable();
+        this.caseSensitive?.disable();
         for (const toggle of this.additionalToggles) {
             toggle.disable();
         }
@@ -193,7 +208,7 @@
         }
         this.additionalToggles = [];
         this.additionalTogglesDisposables.value = new DisposableStore();
-        for (const toggle of toggles !== null && toggles !== void 0 ? toggles : []) {
+        for (const toggle of toggles ?? []) {
             this.additionalTogglesDisposables.value.add(toggle);
             this.controls.appendChild(toggle.domNode);
             this.additionalTogglesDisposables.value.add(toggle.onChange(viaKeyboard => {
@@ -210,16 +225,20 @@
         this.updateInputBoxPadding();
     }
     updateInputBoxPadding(controlsHidden = false) {
-        var _a, _b, _c, _d, _e, _f;
         if (controlsHidden) {
             this.inputBox.paddingRight = 0;
         }
         else {
             this.inputBox.paddingRight =
-                (((_b = (_a = this.caseSensitive) === null || _a === void 0 ? void 0 : _a.width()) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = this.wholeWords) === null || _c === void 0 ? void 0 : _c.width()) !== null && _d !== void 0 ? _d : 0) + ((_f = (_e = this.regex) === null || _e === void 0 ? void 0 : _e.width()) !== null && _f !== void 0 ? _f : 0))
+                ((this.caseSensitive?.width() ?? 0) + (this.wholeWords?.width() ?? 0) + (this.regex?.width() ?? 0))
                     + this.additionalToggles.reduce((r, t) => r + t.width(), 0);
         }
     }
+    clear() {
+        this.clearValidation();
+        this.setValue('');
+        this.focus();
+    }
     getValue() {
         return this.inputBox.value;
     }
@@ -228,6 +247,9 @@
             this.inputBox.value = value;
         }
     }
+    onSearchSubmit() {
+        this.inputBox.addToHistory();
+    }
     select() {
         this.inputBox.select();
     }
@@ -235,8 +257,7 @@
         this.inputBox.focus();
     }
     getCaseSensitive() {
-        var _a, _b;
-        return (_b = (_a = this.caseSensitive) === null || _a === void 0 ? void 0 : _a.checked) !== null && _b !== void 0 ? _b : false;
+        return this.caseSensitive?.checked ?? false;
     }
     setCaseSensitive(value) {
         if (this.caseSensitive) {
@@ -244,8 +265,7 @@
         }
     }
     getWholeWords() {
-        var _a, _b;
-        return (_b = (_a = this.wholeWords) === null || _a === void 0 ? void 0 : _a.checked) !== null && _b !== void 0 ? _b : false;
+        return this.wholeWords?.checked ?? false;
     }
     setWholeWords(value) {
         if (this.wholeWords) {
@@ -253,8 +273,7 @@
         }
     }
     getRegex() {
-        var _a, _b;
-        return (_b = (_a = this.regex) === null || _a === void 0 ? void 0 : _a.checked) !== null && _b !== void 0 ? _b : false;
+        return this.regex?.checked ?? false;
     }
     setRegex(value) {
         if (this.regex) {
@@ -263,8 +282,10 @@
         }
     }
     focusOnCaseSensitive() {
-        var _a;
-        (_a = this.caseSensitive) === null || _a === void 0 ? void 0 : _a.focus();
+        this.caseSensitive?.focus();
+    }
+    focusOnRegex() {
+        this.regex?.focus();
     }
     highlightFindOptions() {
         this.domNode.classList.remove('highlight-' + (this._lastHighlightFindOptions));
@@ -280,4 +301,8 @@
     clearMessage() {
         this.inputBox.hideMessage();
     }
+    clearValidation() {
+        this.inputBox.hideMessage();
+    }
 }
+FindInput.OPTION_CHANGE = 'optionChange';
diff -urN -x '*.map' a/vs/base/browser/ui/findinput/findInputToggles.js b/vs/base/browser/ui/findinput/findInputToggles.js
--- a/vs/base/browser/ui/findinput/findInputToggles.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/findinput/findInputToggles.js	2023-12-06 14:23:14.343854719 +0000
@@ -5,9 +5,9 @@
 import { Toggle } from '../toggle/toggle.js';
 import { Codicon } from '../../../common/codicons.js';
 import * as nls from '../../../../nls.js';
-const NLS_CASE_SENSITIVE_TOGGLE_LABEL = nls.localize('caseDescription', "Match Case");
-const NLS_WHOLE_WORD_TOGGLE_LABEL = nls.localize('wordsDescription', "Match Whole Word");
-const NLS_REGEX_TOGGLE_LABEL = nls.localize('regexDescription', "Use Regular Expression");
+const NLS_CASE_SENSITIVE_TOGGLE_LABEL = nls.localizeWithPath('vs/base/browser/ui/findinput/findInputToggles', 'caseDescription', "Match Case");
+const NLS_WHOLE_WORD_TOGGLE_LABEL = nls.localizeWithPath('vs/base/browser/ui/findinput/findInputToggles', 'wordsDescription', "Match Whole Word");
+const NLS_REGEX_TOGGLE_LABEL = nls.localizeWithPath('vs/base/browser/ui/findinput/findInputToggles', 'regexDescription', "Use Regular Expression");
 export class CaseSensitiveToggle extends Toggle {
     constructor(opts) {
         super({
diff -urN -x '*.map' a/vs/base/browser/ui/findinput/replaceInput.js b/vs/base/browser/ui/findinput/replaceInput.js
--- a/vs/base/browser/ui/findinput/replaceInput.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/findinput/replaceInput.js	2023-12-06 14:23:14.343854719 +0000
@@ -10,8 +10,8 @@
 import { Emitter } from '../../../common/event.js';
 import './findInput.css';
 import * as nls from '../../../../nls.js';
-const NLS_DEFAULT_LABEL = nls.localize('defaultLabel', "input");
-const NLS_PRESERVE_CASE_LABEL = nls.localize('label.preserveCaseToggle', "Preserve Case");
+const NLS_DEFAULT_LABEL = nls.localizeWithPath('vs/base/browser/ui/findinput/replaceInput', 'defaultLabel', "input");
+const NLS_PRESERVE_CASE_LABEL = nls.localizeWithPath('vs/base/browser/ui/findinput/replaceInput', 'label.preserveCaseToggle', "Preserve Case");
 class PreserveCaseToggle extends Toggle {
     constructor(opts) {
         super({
@@ -36,10 +36,14 @@
         this._onKeyDown = this._register(new Emitter());
         this.onKeyDown = this._onKeyDown.event;
         this._onMouseDown = this._register(new Emitter());
+        this.onMouseDown = this._onMouseDown.event;
         this._onInput = this._register(new Emitter());
+        this.onInput = this._onInput.event;
         this._onKeyUp = this._register(new Emitter());
+        this.onKeyUp = this._onKeyUp.event;
         this._onPreserveCaseKeyDown = this._register(new Emitter());
         this.onPreserveCaseKeyDown = this._onPreserveCaseKeyDown.event;
+        this._lastHighlightFindOptions = 0;
         this.contextViewProvider = contextViewProvider;
         this.placeholder = options.placeholder || '';
         this.validation = options.validation;
@@ -64,7 +68,11 @@
             flexibleMaxHeight,
             inputBoxStyles: options.inputBoxStyles
         }));
-        this.preserveCase = this._register(new PreserveCaseToggle(Object.assign({ appendTitle: appendPreserveCaseLabel, isChecked: false }, options.toggleStyles)));
+        this.preserveCase = this._register(new PreserveCaseToggle({
+            appendTitle: appendPreserveCaseLabel,
+            isChecked: false,
+            ...options.toggleStyles
+        }));
         this._register(this.preserveCase.onChange(viaKeyboard => {
             this._onDidOptionChange.fire(viaKeyboard);
             if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
@@ -115,7 +123,7 @@
         controls.style.display = this._showOptionButtons ? 'block' : 'none';
         controls.appendChild(this.preserveCase.domNode);
         this.domNode.appendChild(controls);
-        parent === null || parent === void 0 ? void 0 : parent.appendChild(this.domNode);
+        parent?.appendChild(this.domNode);
         this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));
         this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));
         this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());
@@ -131,6 +139,9 @@
         this.inputBox.disable();
         this.preserveCase.disable();
     }
+    setFocusInputOnOptionClick(value) {
+        this.fixFocusOnOptionClickEnabled = value;
+    }
     setEnabled(enabled) {
         if (enabled) {
             this.enable();
@@ -139,6 +150,24 @@
             this.disable();
         }
     }
+    clear() {
+        this.clearValidation();
+        this.setValue('');
+        this.focus();
+    }
+    getValue() {
+        return this.inputBox.value;
+    }
+    setValue(value) {
+        if (this.inputBox.value !== value) {
+            this.inputBox.value = value;
+        }
+    }
+    onSearchSubmit() {
+        this.inputBox.addToHistory();
+    }
+    applyStyles() {
+    }
     select() {
         this.inputBox.select();
     }
@@ -154,9 +183,22 @@
     focusOnPreserve() {
         this.preserveCase.focus();
     }
+    highlightFindOptions() {
+        this.domNode.classList.remove('highlight-' + (this._lastHighlightFindOptions));
+        this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions;
+        this.domNode.classList.add('highlight-' + (this._lastHighlightFindOptions));
+    }
     validate() {
-        var _a;
-        (_a = this.inputBox) === null || _a === void 0 ? void 0 : _a.validate();
+        this.inputBox?.validate();
+    }
+    showMessage(message) {
+        this.inputBox?.showMessage(message);
+    }
+    clearMessage() {
+        this.inputBox?.hideMessage();
+    }
+    clearValidation() {
+        this.inputBox?.hideMessage();
     }
     set width(newWidth) {
         this.inputBox.paddingRight = this.cachedOptionsWidth;
@@ -166,3 +208,4 @@
         super.dispose();
     }
 }
+ReplaceInput.OPTION_CHANGE = 'optionChange';
diff -urN -x '*.map' a/vs/base/browser/ui/highlightedlabel/highlightedLabel.js b/vs/base/browser/ui/highlightedlabel/highlightedLabel.js
--- a/vs/base/browser/ui/highlightedlabel/highlightedLabel.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/ui/highlightedlabel/highlightedLabel.js	2023-12-06 14:23:14.343854719 +0000
@@ -16,12 +16,11 @@
      * @param container The parent container to append to.
      */
     constructor(container, options) {
-        var _a;
         this.text = '';
         this.title = '';
         this.highlights = [];
         this.didEverRender = false;
-        this.supportIcons = (_a = options === null || options === void 0 ? void 0 : options.supportIcons) !== null && _a !== void 0 ? _a : false;
+        this.supportIcons = options?.supportIcons ?? false;
         this.domNode = dom.append(container, dom.$('span.monaco-highlighted-label'));
     }
     /**
diff -urN -x '*.map' a/vs/base/browser/ui/hover/hoverWidget.js b/vs/base/browser/ui/hover/hoverWidget.js
--- a/vs/base/browser/ui/hover/hoverWidget.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/hover/hoverWidget.js	2023-12-06 14:23:14.343854719 +0000
@@ -7,7 +7,7 @@
 import { DomScrollableElement } from '../scrollbar/scrollableElement.js';
 import { Disposable } from '../../../common/lifecycle.js';
 import './hover.css';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 const $ = dom.$;
 export class HoverWidget extends Disposable {
     constructor() {
@@ -69,5 +69,5 @@
     }
 }
 export function getHoverAccessibleViewHint(shouldHaveHint, keybinding) {
-    return shouldHaveHint && keybinding ? localize('acessibleViewHint', "Inspect this in the accessible view with {0}.", keybinding) : shouldHaveHint ? localize('acessibleViewHintNoKbOpen', "Inspect this in the accessible view via the command Open Accessible View which is currently not triggerable via keybinding.") : '';
+    return shouldHaveHint && keybinding ? localizeWithPath('vs/base/browser/ui/hover/hoverWidget', 'acessibleViewHint', "Inspect this in the accessible view with {0}.", keybinding) : shouldHaveHint ? localizeWithPath('vs/base/browser/ui/hover/hoverWidget', 'acessibleViewHintNoKbOpen', "Inspect this in the accessible view via the command Open Accessible View which is currently not triggerable via keybinding.") : '';
 }
diff -urN -x '*.map' a/vs/base/browser/ui/iconLabel/iconLabel.js b/vs/base/browser/ui/iconLabel/iconLabel.js
--- a/vs/base/browser/ui/iconLabel/iconLabel.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/iconLabel/iconLabel.js	2023-12-06 14:23:14.347854727 +0000
@@ -49,13 +49,13 @@
         this.domNode = this._register(new FastLabelNode(dom.append(container, dom.$('.monaco-icon-label'))));
         this.labelContainer = dom.append(this.domNode.element, dom.$('.monaco-icon-label-container'));
         const nameContainer = dom.append(this.labelContainer, dom.$('span.monaco-icon-name-container'));
-        if ((options === null || options === void 0 ? void 0 : options.supportHighlights) || (options === null || options === void 0 ? void 0 : options.supportIcons)) {
+        if (options?.supportHighlights || options?.supportIcons) {
             this.nameNode = new LabelWithHighlights(nameContainer, !!options.supportIcons);
         }
         else {
             this.nameNode = new Label(nameContainer);
         }
-        this.hoverDelegate = options === null || options === void 0 ? void 0 : options.hoverDelegate;
+        this.hoverDelegate = options?.hoverDelegate;
     }
     get element() {
         return this.domNode.element;
@@ -84,17 +84,17 @@
         this.domNode.className = labelClasses.join(' ');
         this.domNode.element.setAttribute('aria-label', ariaLabel);
         this.labelContainer.className = containerClasses.join(' ');
-        this.setupHover((options === null || options === void 0 ? void 0 : options.descriptionTitle) ? this.labelContainer : this.element, options === null || options === void 0 ? void 0 : options.title);
+        this.setupHover(options?.descriptionTitle ? this.labelContainer : this.element, options?.title);
         this.nameNode.setLabel(label, options);
         if (description || this.descriptionNode) {
             const descriptionNode = this.getOrCreateDescriptionNode();
             if (descriptionNode instanceof HighlightedLabel) {
-                descriptionNode.set(description || '', options ? options.descriptionMatches : undefined, undefined, options === null || options === void 0 ? void 0 : options.labelEscapeNewLines);
-                this.setupHover(descriptionNode.element, options === null || options === void 0 ? void 0 : options.descriptionTitle);
+                descriptionNode.set(description || '', options ? options.descriptionMatches : undefined, undefined, options?.labelEscapeNewLines);
+                this.setupHover(descriptionNode.element, options?.descriptionTitle);
             }
             else {
-                descriptionNode.textContent = description && (options === null || options === void 0 ? void 0 : options.labelEscapeNewLines) ? HighlightedLabel.escapeNewLines(description, []) : (description || '');
-                this.setupHover(descriptionNode.element, (options === null || options === void 0 ? void 0 : options.descriptionTitle) || '');
+                descriptionNode.textContent = description && options?.labelEscapeNewLines ? HighlightedLabel.escapeNewLines(description, []) : (description || '');
+                this.setupHover(descriptionNode.element, options?.descriptionTitle || '');
                 descriptionNode.empty = !description;
             }
         }
@@ -127,10 +127,9 @@
         this.customHovers.clear();
     }
     getOrCreateDescriptionNode() {
-        var _a;
         if (!this.descriptionNode) {
             const descriptionContainer = this._register(new FastLabelNode(dom.append(this.labelContainer, dom.$('span.monaco-icon-description-container'))));
-            if ((_a = this.creationOptions) === null || _a === void 0 ? void 0 : _a.supportDescriptionHighlights) {
+            if (this.creationOptions?.supportDescriptionHighlights) {
                 this.descriptionNode = new HighlightedLabel(dom.append(descriptionContainer.element, dom.$('span.label-description')), { supportIcons: !!this.creationOptions.supportIcons });
             }
             else {
@@ -156,7 +155,7 @@
             if (!this.singleLabel) {
                 this.container.innerText = '';
                 this.container.classList.remove('multiple');
-                this.singleLabel = dom.append(this.container, dom.$('a.label-name', { id: options === null || options === void 0 ? void 0 : options.domId }));
+                this.singleLabel = dom.append(this.container, dom.$('a.label-name', { id: options?.domId }));
             }
             this.singleLabel.textContent = label;
         }
@@ -166,10 +165,10 @@
             this.singleLabel = undefined;
             for (let i = 0; i < label.length; i++) {
                 const l = label[i];
-                const id = (options === null || options === void 0 ? void 0 : options.domId) && `${options === null || options === void 0 ? void 0 : options.domId}_${i}`;
+                const id = options?.domId && `${options?.domId}_${i}`;
                 dom.append(this.container, dom.$('a.label-name', { id, 'data-icon-label-count': label.length, 'data-icon-label-index': i, 'role': 'treeitem' }, l));
                 if (i < label.length - 1) {
-                    dom.append(this.container, dom.$('span.label-separator', undefined, (options === null || options === void 0 ? void 0 : options.separator) || '/'));
+                    dom.append(this.container, dom.$('span.label-separator', undefined, options?.separator || '/'));
                 }
             }
         }
@@ -207,23 +206,23 @@
             if (!this.singleLabel) {
                 this.container.innerText = '';
                 this.container.classList.remove('multiple');
-                this.singleLabel = new HighlightedLabel(dom.append(this.container, dom.$('a.label-name', { id: options === null || options === void 0 ? void 0 : options.domId })), { supportIcons: this.supportIcons });
+                this.singleLabel = new HighlightedLabel(dom.append(this.container, dom.$('a.label-name', { id: options?.domId })), { supportIcons: this.supportIcons });
             }
-            this.singleLabel.set(label, options === null || options === void 0 ? void 0 : options.matches, undefined, options === null || options === void 0 ? void 0 : options.labelEscapeNewLines);
+            this.singleLabel.set(label, options?.matches, undefined, options?.labelEscapeNewLines);
         }
         else {
             this.container.innerText = '';
             this.container.classList.add('multiple');
             this.singleLabel = undefined;
-            const separator = (options === null || options === void 0 ? void 0 : options.separator) || '/';
-            const matches = splitMatches(label, separator, options === null || options === void 0 ? void 0 : options.matches);
+            const separator = options?.separator || '/';
+            const matches = splitMatches(label, separator, options?.matches);
             for (let i = 0; i < label.length; i++) {
                 const l = label[i];
                 const m = matches ? matches[i] : undefined;
-                const id = (options === null || options === void 0 ? void 0 : options.domId) && `${options === null || options === void 0 ? void 0 : options.domId}_${i}`;
+                const id = options?.domId && `${options?.domId}_${i}`;
                 const name = dom.$('a.label-name', { id, 'data-icon-label-count': label.length, 'data-icon-label-index': i, 'role': 'treeitem' });
                 const highlightedLabel = new HighlightedLabel(dom.append(this.container, name), { supportIcons: this.supportIcons });
-                highlightedLabel.set(l, m, undefined, options === null || options === void 0 ? void 0 : options.labelEscapeNewLines);
+                highlightedLabel.set(l, m, undefined, options?.labelEscapeNewLines);
                 if (i < label.length - 1) {
                     dom.append(name, dom.$('span.label-separator', undefined, separator));
                 }
diff -urN -x '*.map' a/vs/base/browser/ui/iconLabel/iconLabelHover.js b/vs/base/browser/ui/iconLabel/iconLabelHover.js
--- a/vs/base/browser/ui/iconLabel/iconLabelHover.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/iconLabel/iconLabelHover.js	2023-12-06 14:23:14.347854727 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import * as dom from '../../dom.js';
 import { TimeoutTimer } from '../../../common/async.js';
 import { CancellationTokenSource } from '../../../common/cancellation.js';
@@ -18,13 +9,13 @@
 import { stripIcons } from '../../../common/iconLabels.js';
 import { DisposableStore } from '../../../common/lifecycle.js';
 import { isFunction, isString } from '../../../common/types.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 export function setupNativeHover(htmlElement, tooltip) {
     if (isString(tooltip)) {
         // Icons don't render in the native hover so we strip them out
         htmlElement.title = stripIcons(tooltip);
     }
-    else if (tooltip === null || tooltip === void 0 ? void 0 : tooltip.markdownNotSupportedFallback) {
+    else if (tooltip?.markdownNotSupportedFallback) {
         htmlElement.title = tooltip.markdownNotSupportedFallback;
     }
     else {
@@ -37,53 +28,57 @@
         this.target = target;
         this.fadeInAnimation = fadeInAnimation;
     }
-    update(content, focus, options) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            if (this._cancellationTokenSource) {
-                // there's an computation ongoing, cancel it
-                this._cancellationTokenSource.dispose(true);
-                this._cancellationTokenSource = undefined;
-            }
-            if (this.isDisposed) {
+    async update(content, focus, options) {
+        if (this._cancellationTokenSource) {
+            // there's an computation ongoing, cancel it
+            this._cancellationTokenSource.dispose(true);
+            this._cancellationTokenSource = undefined;
+        }
+        if (this.isDisposed) {
+            return;
+        }
+        let resolvedContent;
+        if (content === undefined || isString(content) || content instanceof HTMLElement) {
+            resolvedContent = content;
+        }
+        else if (!isFunction(content.markdown)) {
+            resolvedContent = content.markdown ?? content.markdownNotSupportedFallback;
+        }
+        else {
+            // compute the content, potentially long-running
+            // show 'Loading' if no hover is up yet
+            if (!this._hoverWidget) {
+                this.show(localizeWithPath('vs/base/browser/ui/iconLabel/iconLabelHover', 'iconLabel.loading', "Loading..."), focus);
+            }
+            // compute the content
+            this._cancellationTokenSource = new CancellationTokenSource();
+            const token = this._cancellationTokenSource.token;
+            resolvedContent = await content.markdown(token);
+            if (resolvedContent === undefined) {
+                resolvedContent = content.markdownNotSupportedFallback;
+            }
+            if (this.isDisposed || token.isCancellationRequested) {
+                // either the widget has been closed in the meantime
+                // or there has been a new call to `update`
                 return;
             }
-            let resolvedContent;
-            if (content === undefined || isString(content) || content instanceof HTMLElement) {
-                resolvedContent = content;
-            }
-            else if (!isFunction(content.markdown)) {
-                resolvedContent = (_a = content.markdown) !== null && _a !== void 0 ? _a : content.markdownNotSupportedFallback;
-            }
-            else {
-                // compute the content, potentially long-running
-                // show 'Loading' if no hover is up yet
-                if (!this._hoverWidget) {
-                    this.show(localize('iconLabel.loading', "Loading..."), focus);
-                }
-                // compute the content
-                this._cancellationTokenSource = new CancellationTokenSource();
-                const token = this._cancellationTokenSource.token;
-                resolvedContent = yield content.markdown(token);
-                if (resolvedContent === undefined) {
-                    resolvedContent = content.markdownNotSupportedFallback;
-                }
-                if (this.isDisposed || token.isCancellationRequested) {
-                    // either the widget has been closed in the meantime
-                    // or there has been a new call to `update`
-                    return;
-                }
-            }
-            this.show(resolvedContent, focus, options);
-        });
+        }
+        this.show(resolvedContent, focus, options);
     }
     show(content, focus, options) {
         const oldHoverWidget = this._hoverWidget;
         if (this.hasContent(content)) {
-            const hoverOptions = Object.assign({ content, target: this.target, showPointer: this.hoverDelegate.placement === 'element', hoverPosition: 2 /* HoverPosition.BELOW */, skipFadeInAnimation: !this.fadeInAnimation || !!oldHoverWidget }, options);
+            const hoverOptions = {
+                content,
+                target: this.target,
+                showPointer: this.hoverDelegate.placement === 'element',
+                hoverPosition: 2 /* HoverPosition.BELOW */,
+                skipFadeInAnimation: !this.fadeInAnimation || !!oldHoverWidget, // do not fade in if the hover is already showing
+                ...options
+            };
             this._hoverWidget = this.hoverDelegate.showHover(hoverOptions, focus);
         }
-        oldHoverWidget === null || oldHoverWidget === void 0 ? void 0 : oldHoverWidget.dispose();
+        oldHoverWidget?.dispose();
     }
     hasContent(content) {
         if (!content) {
@@ -95,13 +90,11 @@
         return true;
     }
     get isDisposed() {
-        var _a;
-        return (_a = this._hoverWidget) === null || _a === void 0 ? void 0 : _a.isDisposed;
+        return this._hoverWidget?.isDisposed;
     }
     dispose() {
-        var _a, _b;
-        (_a = this._hoverWidget) === null || _a === void 0 ? void 0 : _a.dispose();
-        (_b = this._cancellationTokenSource) === null || _b === void 0 ? void 0 : _b.dispose(true);
+        this._hoverWidget?.dispose();
+        this._cancellationTokenSource?.dispose(true);
         this._cancellationTokenSource = undefined;
     }
 }
@@ -109,27 +102,26 @@
     let hoverPreparation;
     let hoverWidget;
     const hideHover = (disposeWidget, disposePreparation) => {
-        var _a;
         const hadHover = hoverWidget !== undefined;
         if (disposeWidget) {
-            hoverWidget === null || hoverWidget === void 0 ? void 0 : hoverWidget.dispose();
+            hoverWidget?.dispose();
             hoverWidget = undefined;
         }
         if (disposePreparation) {
-            hoverPreparation === null || hoverPreparation === void 0 ? void 0 : hoverPreparation.dispose();
+            hoverPreparation?.dispose();
             hoverPreparation = undefined;
         }
         if (hadHover) {
-            (_a = hoverDelegate.onDidHideHover) === null || _a === void 0 ? void 0 : _a.call(hoverDelegate);
+            hoverDelegate.onDidHideHover?.();
         }
     };
     const triggerShowHover = (delay, focus, target) => {
-        return new TimeoutTimer(() => __awaiter(this, void 0, void 0, function* () {
+        return new TimeoutTimer(async () => {
             if (!hoverWidget || hoverWidget.isDisposed) {
                 hoverWidget = new UpdatableHoverWidget(hoverDelegate, target || htmlElement, delay > 0);
-                yield hoverWidget.update(content, focus, options);
+                await hoverWidget.update(content, focus, options);
             }
-        }), delay);
+        }, delay);
     };
     const onMouseOver = () => {
         if (hoverPreparation) {
@@ -166,10 +158,10 @@
         hide: () => {
             hideHover(true, true);
         },
-        update: (newContent, hoverOptions) => __awaiter(this, void 0, void 0, function* () {
+        update: async (newContent, hoverOptions) => {
             content = newContent;
-            yield (hoverWidget === null || hoverWidget === void 0 ? void 0 : hoverWidget.update(content, undefined, hoverOptions));
-        }),
+            await hoverWidget?.update(content, undefined, hoverOptions);
+        },
         dispose: () => {
             mouseOverDomEmitter.dispose();
             hideHover(true, true);
diff -urN -x '*.map' a/vs/base/browser/ui/inputbox/inputBox.js b/vs/base/browser/ui/inputbox/inputBox.js
--- a/vs/base/browser/ui/inputbox/inputBox.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/inputbox/inputBox.js	2023-12-06 14:23:14.347854727 +0000
@@ -31,7 +31,6 @@
 };
 export class InputBox extends Widget {
     constructor(container, contextViewProvider, options) {
-        var _a;
         super();
         this.state = 'idle';
         this.maxHeight = Number.POSITIVE_INFINITY;
@@ -43,7 +42,7 @@
         this.options = options;
         this.message = null;
         this.placeholder = this.options.placeholder || '';
-        this.tooltip = (_a = this.options.tooltip) !== null && _a !== void 0 ? _a : (this.placeholder || '');
+        this.tooltip = this.options.tooltip ?? (this.placeholder || '');
         this.ariaLabel = this.options.ariaLabel || '';
         if (this.options.validationOptions) {
             this.validation = this.options.validationOptions.validation;
@@ -74,7 +73,7 @@
             const onSelectionChange = this._register(new DomEmitter(document, 'selectionchange'));
             const onAnchoredSelectionChange = Event.filter(onSelectionChange.event, () => {
                 const selection = document.getSelection();
-                return (selection === null || selection === void 0 ? void 0 : selection.anchorNode) === wrapper;
+                return selection?.anchorNode === wrapper;
             });
             // from DOM to ScrollableElement
             this._register(onAnchoredSelectionChange(this.updateScrollDimensions, this));
@@ -125,6 +124,21 @@
         this.tooltip = tooltip;
         this.input.title = tooltip;
     }
+    setAriaLabel(label) {
+        this.ariaLabel = label;
+        if (label) {
+            this.input.setAttribute('aria-label', this.ariaLabel);
+        }
+        else {
+            this.input.removeAttribute('aria-label');
+        }
+    }
+    getAriaLabel() {
+        return this.ariaLabel;
+    }
+    get mirrorElement() {
+        return this.mirror;
+    }
     get inputElement() {
         return this.input;
     }
@@ -137,6 +151,12 @@
             this.onValueChange();
         }
     }
+    get step() {
+        return this.input.step;
+    }
+    set step(newValue) {
+        this.input.step = newValue;
+    }
     get height() {
         return typeof this.cachedHeight === 'number' ? this.cachedHeight : dom.getTotalHeight(this.element);
     }
@@ -169,6 +189,35 @@
         this.input.disabled = true;
         this._hideMessage();
     }
+    setEnabled(enabled) {
+        if (enabled) {
+            this.enable();
+        }
+        else {
+            this.disable();
+        }
+    }
+    get width() {
+        return dom.getTotalWidth(this.input);
+    }
+    set width(width) {
+        if (this.options.flexibleHeight && this.options.flexibleWidth) {
+            // textarea with horizontal scrolling
+            let horizontalPadding = 0;
+            if (this.mirror) {
+                const paddingLeft = parseFloat(this.mirror.style.paddingLeft || '') || 0;
+                const paddingRight = parseFloat(this.mirror.style.paddingRight || '') || 0;
+                horizontalPadding = paddingLeft + paddingRight;
+            }
+            this.input.style.width = (width - horizontalPadding) + 'px';
+        }
+        else {
+            this.input.style.width = width + 'px';
+        }
+        if (this.mirror) {
+            this.mirror.style.width = width + 'px';
+        }
+    }
     set paddingRight(paddingRight) {
         // Set width to avoid hint text overlapping buttons
         this.input.style.width = `calc(100% - ${paddingRight}px)`;
@@ -212,6 +261,9 @@
         this._hideMessage();
         this.applyStyles();
     }
+    isInputValid() {
+        return !!this.validation && !this.validation(this.value);
+    }
     validate() {
         let errorMsg = null;
         if (this.validation) {
@@ -225,7 +277,7 @@
                 this.hideMessage();
             }
         }
-        return errorMsg === null || errorMsg === void 0 ? void 0 : errorMsg.type;
+        return errorMsg?.type;
     }
     stylesForType(type) {
         const styles = this.options.inputBoxStyles;
@@ -252,7 +304,6 @@
             getAnchor: () => this.element,
             anchorAlignment: 1 /* AnchorAlignment.RIGHT */,
             render: (container) => {
-                var _a, _b;
                 if (!this.message) {
                     return null;
                 }
@@ -267,8 +318,8 @@
                     : renderText(this.message.content, renderOptions));
                 spanElement.classList.add(this.classForType(this.message.type));
                 const styles = this.stylesForType(this.message.type);
-                spanElement.style.backgroundColor = (_a = styles.background) !== null && _a !== void 0 ? _a : '';
-                spanElement.style.color = (_b = styles.foreground) !== null && _b !== void 0 ? _b : '';
+                spanElement.style.backgroundColor = styles.background ?? '';
+                spanElement.style.color = styles.foreground ?? '';
                 spanElement.style.border = styles.border ? `1px solid ${styles.border}` : '';
                 dom.append(div, spanElement);
                 return null;
@@ -281,13 +332,13 @@
         // ARIA Support
         let alertText;
         if (this.message.type === 3 /* MessageType.ERROR */) {
-            alertText = nls.localize('alertErrorMessage', "Error: {0}", this.message.content);
+            alertText = nls.localizeWithPath('vs/base/browser/ui/inputbox/inputBox', 'alertErrorMessage', "Error: {0}", this.message.content);
         }
         else if (this.message.type === 2 /* MessageType.WARNING */) {
-            alertText = nls.localize('alertWarningMessage', "Warning: {0}", this.message.content);
+            alertText = nls.localizeWithPath('vs/base/browser/ui/inputbox/inputBox', 'alertWarningMessage', "Warning: {0}", this.message.content);
         }
         else {
-            alertText = nls.localize('alertInfoMessage', "Info: {0}", this.message.content);
+            alertText = nls.localizeWithPath('vs/base/browser/ui/inputbox/inputBox', 'alertInfoMessage', "Info: {0}", this.message.content);
         }
         aria.alert(alertText);
         this.state = 'open';
@@ -328,11 +379,10 @@
         this.layout();
     }
     applyStyles() {
-        var _a, _b, _c;
         const styles = this.options.inputBoxStyles;
-        const background = (_a = styles.inputBackground) !== null && _a !== void 0 ? _a : '';
-        const foreground = (_b = styles.inputForeground) !== null && _b !== void 0 ? _b : '';
-        const border = (_c = styles.inputBorder) !== null && _c !== void 0 ? _c : '';
+        const background = styles.inputBackground ?? '';
+        const foreground = styles.inputForeground ?? '';
+        const border = styles.inputBorder ?? '';
         this.element.style.backgroundColor = background;
         this.element.style.color = foreground;
         this.input.style.backgroundColor = 'inherit';
@@ -364,16 +414,15 @@
         }
     }
     dispose() {
-        var _a;
         this._hideMessage();
         this.message = null;
-        (_a = this.actionbar) === null || _a === void 0 ? void 0 : _a.dispose();
+        this.actionbar?.dispose();
         super.dispose();
     }
 }
 export class HistoryInputBox extends InputBox {
     constructor(container, contextViewProvider, options) {
-        const NLS_PLACEHOLDER_HISTORY_HINT = nls.localize({ key: 'history.inputbox.hint', comment: ['Text will be prefixed with \u21C5 plus a single space, then used as a hint where input field keeps history'] }, "for history");
+        const NLS_PLACEHOLDER_HISTORY_HINT = nls.localizeWithPath('vs/base/browser/ui/inputbox/inputBox', { key: 'history.inputbox.hint', comment: ['Text will be prefixed with \u21C5 plus a single space, then used as a hint where input field keeps history'] }, "for history");
         const NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX = ` or \u21C5 ${NLS_PLACEHOLDER_HISTORY_HINT}`;
         const NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS = ` (\u21C5 ${NLS_PLACEHOLDER_HISTORY_HINT})`;
         super(container, contextViewProvider, options);
@@ -439,6 +488,22 @@
             this.history.add(this.value);
         }
     }
+    prependHistory(restoredHistory) {
+        const newHistory = this.getHistory();
+        this.clearHistory();
+        restoredHistory.forEach((item) => {
+            this.history.add(item);
+        });
+        newHistory.forEach(item => {
+            this.history.add(item);
+        });
+    }
+    getHistory() {
+        return this.history.getHistory();
+    }
+    isAtFirstInHistory() {
+        return this.history.isFirst();
+    }
     isAtLastInHistory() {
         return this.history.isLast();
     }
@@ -453,8 +518,8 @@
         if (next) {
             next = next === this.value ? this.getNextValue() : next;
         }
-        this.value = next !== null && next !== void 0 ? next : '';
-        aria.status(this.value ? this.value : nls.localize('clearedInput', "Cleared Input"));
+        this.value = next ?? '';
+        aria.status(this.value ? this.value : nls.localizeWithPath('vs/base/browser/ui/inputbox/inputBox', 'clearedInput', "Cleared Input"));
     }
     showPreviousValue() {
         if (!this.history.has(this.value)) {
@@ -469,6 +534,9 @@
             aria.status(this.value);
         }
     }
+    clearHistory() {
+        this.history.clear();
+    }
     onBlur() {
         super.onBlur();
         this._onDidBlur.fire();
diff -urN -x '*.map' a/vs/base/browser/ui/keybindingLabel/keybindingLabel.js b/vs/base/browser/ui/keybindingLabel/keybindingLabel.js
--- a/vs/base/browser/ui/keybindingLabel/keybindingLabel.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/keybindingLabel/keybindingLabel.js	2023-12-06 14:23:14.347854727 +0000
@@ -6,7 +6,7 @@
 import { UILabelProvider } from '../../../common/keybindingLabels.js';
 import { equals } from '../../../common/objects.js';
 import './keybindingLabel.css';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 const $ = dom.$;
 export const unthemedKeybindingLabelOptions = {
     keybindingLabelBackground: undefined,
@@ -40,7 +40,6 @@
         this.render();
     }
     render() {
-        var _a;
         this.clear();
         if (this.keybinding) {
             const chords = this.keybinding.getChords();
@@ -51,7 +50,7 @@
                 dom.append(this.domNode, $('span.monaco-keybinding-key-chord-separator', undefined, ' '));
                 this.renderChord(this.domNode, chords[i], this.matches ? this.matches.chordPart : null);
             }
-            const title = ((_a = this.options.disableTitle) !== null && _a !== void 0 ? _a : false) ? undefined : this.keybinding.getAriaLabel() || undefined;
+            const title = (this.options.disableTitle ?? false) ? undefined : this.keybinding.getAriaLabel() || undefined;
             if (title !== undefined) {
                 this.domNode.title = title;
             }
@@ -71,20 +70,20 @@
     renderChord(parent, chord, match) {
         const modifierLabels = UILabelProvider.modifierLabels[this.os];
         if (chord.ctrlKey) {
-            this.renderKey(parent, modifierLabels.ctrlKey, Boolean(match === null || match === void 0 ? void 0 : match.ctrlKey), modifierLabels.separator);
+            this.renderKey(parent, modifierLabels.ctrlKey, Boolean(match?.ctrlKey), modifierLabels.separator);
         }
         if (chord.shiftKey) {
-            this.renderKey(parent, modifierLabels.shiftKey, Boolean(match === null || match === void 0 ? void 0 : match.shiftKey), modifierLabels.separator);
+            this.renderKey(parent, modifierLabels.shiftKey, Boolean(match?.shiftKey), modifierLabels.separator);
         }
         if (chord.altKey) {
-            this.renderKey(parent, modifierLabels.altKey, Boolean(match === null || match === void 0 ? void 0 : match.altKey), modifierLabels.separator);
+            this.renderKey(parent, modifierLabels.altKey, Boolean(match?.altKey), modifierLabels.separator);
         }
         if (chord.metaKey) {
-            this.renderKey(parent, modifierLabels.metaKey, Boolean(match === null || match === void 0 ? void 0 : match.metaKey), modifierLabels.separator);
+            this.renderKey(parent, modifierLabels.metaKey, Boolean(match?.metaKey), modifierLabels.separator);
         }
         const keyLabel = chord.keyLabel;
         if (keyLabel) {
-            this.renderKey(parent, keyLabel, Boolean(match === null || match === void 0 ? void 0 : match.keyCode), '');
+            this.renderKey(parent, keyLabel, Boolean(match?.keyCode), '');
         }
     }
     renderKey(parent, label, highlight, separator) {
@@ -94,7 +93,7 @@
         }
     }
     renderUnbound(parent) {
-        dom.append(parent, this.createKeyElement(localize('unbound', "Unbound")));
+        dom.append(parent, this.createKeyElement(localizeWithPath('vs/base/browser/ui/keybindingLabel/keybindingLabel', 'unbound', "Unbound")));
     }
     createKeyElement(label, extraClass = '') {
         const keyElement = $('span.monaco-keybinding-key' + extraClass, undefined, label);
diff -urN -x '*.map' a/vs/base/browser/ui/list/list.js b/vs/base/browser/ui/list/list.js
--- a/vs/base/browser/ui/list/list.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/list/list.js	2023-12-06 14:23:14.347854727 +0000
@@ -2,8 +2,25 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+export const ListDragOverReactions = {
+    reject() { return { accept: false }; },
+    accept() { return { accept: true }; },
+};
 export class ListError extends Error {
     constructor(user, message) {
         super(`ListError [${user}] ${message}`);
     }
 }
+export class CachedListVirtualDelegate {
+    constructor() {
+        this.cache = new WeakMap();
+    }
+    getHeight(element) {
+        return this.cache.get(element) ?? this.estimateHeight(element);
+    }
+    setDynamicHeight(element, height) {
+        if (height > 0) {
+            this.cache.set(element, height);
+        }
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/ui/list/listPaging.js b/vs/base/browser/ui/list/listPaging.js
--- a/vs/base/browser/ui/list/listPaging.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/list/listPaging.js	2023-12-06 14:23:14.347854727 +0000
@@ -19,8 +19,7 @@
         return { data, disposable: Disposable.None };
     }
     renderElement(index, _, data, height) {
-        var _a;
-        (_a = data.disposable) === null || _a === void 0 ? void 0 : _a.dispose();
+        data.disposable?.dispose();
         if (!data.data) {
             return;
         }
@@ -62,7 +61,10 @@
     }
 }
 function fromPagedListOptions(modelProvider, options) {
-    return Object.assign(Object.assign({}, options), { accessibilityProvider: options.accessibilityProvider && new PagedAccessibilityProvider(modelProvider, options.accessibilityProvider) });
+    return {
+        ...options,
+        accessibilityProvider: options.accessibilityProvider && new PagedAccessibilityProvider(modelProvider, options.accessibilityProvider)
+    };
 }
 export class PagedList {
     constructor(user, container, virtualDelegate, renderers, options = {}) {
@@ -76,24 +78,45 @@
     getHTMLElement() {
         return this.list.getHTMLElement();
     }
+    isDOMFocused() {
+        return this.list.getHTMLElement() === document.activeElement;
+    }
+    domFocus() {
+        this.list.domFocus();
+    }
     get onDidFocus() {
         return this.list.onDidFocus;
     }
+    get onDidBlur() {
+        return this.list.onDidBlur;
+    }
     get widget() {
         return this.list;
     }
     get onDidDispose() {
         return this.list.onDidDispose;
     }
+    get onMouseClick() {
+        return Event.map(this.list.onMouseClick, ({ element, index, browserEvent }) => ({ element: element === undefined ? undefined : this._model.get(element), index, browserEvent }));
+    }
     get onMouseDblClick() {
         return Event.map(this.list.onMouseDblClick, ({ element, index, browserEvent }) => ({ element: element === undefined ? undefined : this._model.get(element), index, browserEvent }));
     }
+    get onTap() {
+        return Event.map(this.list.onTap, ({ element, index, browserEvent }) => ({ element: element === undefined ? undefined : this._model.get(element), index, browserEvent }));
+    }
     get onPointer() {
         return Event.map(this.list.onPointer, ({ element, index, browserEvent }) => ({ element: element === undefined ? undefined : this._model.get(element), index, browserEvent }));
     }
+    get onDidChangeFocus() {
+        return Event.map(this.list.onDidChangeFocus, ({ elements, indexes, browserEvent }) => ({ elements: elements.map(e => this._model.get(e)), indexes, browserEvent }));
+    }
     get onDidChangeSelection() {
         return Event.map(this.list.onDidChangeSelection, ({ elements, indexes, browserEvent }) => ({ elements: elements.map(e => this._model.get(e)), indexes, browserEvent }));
     }
+    get onContextMenu() {
+        return Event.map(this.list.onContextMenu, ({ element, index, anchor, browserEvent }) => (typeof element === 'undefined' ? { element, index, anchor, browserEvent } : { element: this._model.get(element), index, anchor, browserEvent }));
+    }
     get model() {
         return this._model;
     }
@@ -101,15 +124,69 @@
         this._model = model;
         this.list.splice(0, this.list.length, range(model.length));
     }
+    get length() {
+        return this.list.length;
+    }
+    get scrollTop() {
+        return this.list.scrollTop;
+    }
+    set scrollTop(scrollTop) {
+        this.list.scrollTop = scrollTop;
+    }
+    get scrollLeft() {
+        return this.list.scrollLeft;
+    }
+    set scrollLeft(scrollLeft) {
+        this.list.scrollLeft = scrollLeft;
+    }
+    setAnchor(index) {
+        this.list.setAnchor(index);
+    }
+    getAnchor() {
+        return this.list.getAnchor();
+    }
+    setFocus(indexes) {
+        this.list.setFocus(indexes);
+    }
+    focusNext(n, loop) {
+        this.list.focusNext(n, loop);
+    }
+    focusPrevious(n, loop) {
+        this.list.focusPrevious(n, loop);
+    }
+    focusNextPage() {
+        return this.list.focusNextPage();
+    }
+    focusPreviousPage() {
+        return this.list.focusPreviousPage();
+    }
+    focusLast() {
+        this.list.focusLast();
+    }
+    focusFirst() {
+        this.list.focusFirst();
+    }
     getFocus() {
         return this.list.getFocus();
     }
+    setSelection(indexes, browserEvent) {
+        this.list.setSelection(indexes, browserEvent);
+    }
     getSelection() {
         return this.list.getSelection();
     }
     getSelectedElements() {
         return this.getSelection().map(i => this.model.get(i));
     }
+    layout(height, width) {
+        this.list.layout(height, width);
+    }
+    triggerTypeNavigation() {
+        this.list.triggerTypeNavigation();
+    }
+    reveal(index, relativeTop) {
+        this.list.reveal(index, relativeTop);
+    }
     style(styles) {
         this.list.style(styles);
     }
diff -urN -x '*.map' a/vs/base/browser/ui/list/listView.js b/vs/base/browser/ui/list/listView.js
--- a/vs/base/browser/ui/list/listView.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/list/listView.js	2023-12-06 14:23:14.347854727 +0000
@@ -45,6 +45,12 @@
     alwaysConsumeMouseWheel: true,
 };
 export class ElementsDragAndDropData {
+    get context() {
+        return this._context;
+    }
+    set context(value) {
+        this._context = value;
+    }
     constructor(elements) {
         this.elements = elements;
     }
@@ -96,25 +102,25 @@
 }
 class ListViewAccessibilityProvider {
     constructor(accessibilityProvider) {
-        if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getSetSize) {
+        if (accessibilityProvider?.getSetSize) {
             this.getSetSize = accessibilityProvider.getSetSize.bind(accessibilityProvider);
         }
         else {
             this.getSetSize = (e, i, l) => l;
         }
-        if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getPosInSet) {
+        if (accessibilityProvider?.getPosInSet) {
             this.getPosInSet = accessibilityProvider.getPosInSet.bind(accessibilityProvider);
         }
         else {
             this.getPosInSet = (e, i) => i + 1;
         }
-        if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getRole) {
+        if (accessibilityProvider?.getRole) {
             this.getRole = accessibilityProvider.getRole.bind(accessibilityProvider);
         }
         else {
             this.getRole = _ => 'listitem';
         }
-        if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.isChecked) {
+        if (accessibilityProvider?.isChecked) {
             this.isChecked = accessibilityProvider.isChecked.bind(accessibilityProvider);
         }
         else {
@@ -134,7 +140,11 @@
  */
 export class ListView {
     get contentHeight() { return this.rangeMap.size; }
+    get contentWidth() { return this.scrollWidth ?? 0; }
     get onDidScroll() { return this.scrollableElement.onScroll; }
+    get onWillScroll() { return this.scrollableElement.onWillScroll; }
+    get containerDomNode() { return this.rowsContainer; }
+    get scrollableElementDomNode() { return this.scrollableElement.getDomNode(); }
     get horizontalScrolling() { return this._horizontalScrolling; }
     set horizontalScrolling(value) {
         if (value === this._horizontalScrolling) {
@@ -160,7 +170,6 @@
         }
     }
     constructor(container, virtualDelegate, renderers, options = DefaultOptions) {
-        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
         this.virtualDelegate = virtualDelegate;
         this.domId = `list_id_${++ListView.InstanceCount}`;
         this.renderers = new Map();
@@ -177,13 +186,15 @@
         this.disposables = new DisposableStore();
         this._onDidChangeContentHeight = new Emitter();
         this._onDidChangeContentWidth = new Emitter();
+        this.onDidChangeContentHeight = Event.latch(this._onDidChangeContentHeight.event, undefined, this.disposables);
+        this.onDidChangeContentWidth = Event.latch(this._onDidChangeContentWidth.event, undefined, this.disposables);
         this._horizontalScrolling = false;
         if (options.horizontalScrolling && options.supportDynamicHeights) {
             throw new Error('Horizontal scrolling and dynamic heights not supported simultaneously');
         }
         this.items = [];
         this.itemId = 0;
-        this.rangeMap = new RangeMap((_a = options.paddingTop) !== null && _a !== void 0 ? _a : 0);
+        this.rangeMap = new RangeMap(options.paddingTop ?? 0);
         for (const renderer of renderers) {
             this.renderers.set(renderer.templateId, renderer);
         }
@@ -195,13 +206,13 @@
         this.domNode.classList.add(this.domId);
         this.domNode.tabIndex = 0;
         this.domNode.classList.toggle('mouse-support', typeof options.mouseSupport === 'boolean' ? options.mouseSupport : true);
-        this._horizontalScrolling = (_b = options.horizontalScrolling) !== null && _b !== void 0 ? _b : DefaultOptions.horizontalScrolling;
+        this._horizontalScrolling = options.horizontalScrolling ?? DefaultOptions.horizontalScrolling;
         this.domNode.classList.toggle('horizontal-scrolling', this._horizontalScrolling);
         this.paddingBottom = typeof options.paddingBottom === 'undefined' ? 0 : options.paddingBottom;
         this.accessibilityProvider = new ListViewAccessibilityProvider(options.accessibilityProvider);
         this.rowsContainer = document.createElement('div');
         this.rowsContainer.className = 'monaco-list-rows';
-        const transformOptimization = (_c = options.transformOptimization) !== null && _c !== void 0 ? _c : DefaultOptions.transformOptimization;
+        const transformOptimization = options.transformOptimization ?? DefaultOptions.transformOptimization;
         if (transformOptimization) {
             this.rowsContainer.style.transform = 'translate3d(0px, 0px, 0px)';
             this.rowsContainer.style.overflow = 'hidden';
@@ -210,14 +221,14 @@
         this.disposables.add(Gesture.addTarget(this.rowsContainer));
         this.scrollable = this.disposables.add(new Scrollable({
             forceIntegerValues: true,
-            smoothScrollDuration: ((_d = options.smoothScrolling) !== null && _d !== void 0 ? _d : false) ? 125 : 0,
+            smoothScrollDuration: (options.smoothScrolling ?? false) ? 125 : 0,
             scheduleAtNextAnimationFrame: cb => scheduleAtNextAnimationFrame(cb)
         }));
         this.scrollableElement = this.disposables.add(new SmoothScrollableElement(this.rowsContainer, {
-            alwaysConsumeMouseWheel: (_e = options.alwaysConsumeMouseWheel) !== null && _e !== void 0 ? _e : DefaultOptions.alwaysConsumeMouseWheel,
+            alwaysConsumeMouseWheel: options.alwaysConsumeMouseWheel ?? DefaultOptions.alwaysConsumeMouseWheel,
             horizontal: 1 /* ScrollbarVisibility.Auto */,
-            vertical: (_f = options.verticalScrollMode) !== null && _f !== void 0 ? _f : DefaultOptions.verticalScrollMode,
-            useShadows: (_g = options.useShadows) !== null && _g !== void 0 ? _g : DefaultOptions.useShadows,
+            vertical: options.verticalScrollMode ?? DefaultOptions.verticalScrollMode,
+            useShadows: options.useShadows ?? DefaultOptions.useShadows,
             mouseWheelScrollSensitivity: options.mouseWheelScrollSensitivity,
             fastScrollSensitivity: options.fastScrollSensitivity,
             scrollByPage: options.scrollByPage
@@ -233,11 +244,11 @@
         this.disposables.add(addDisposableListener(this.domNode, 'drop', e => this.onDrop(this.toDragEvent(e))));
         this.disposables.add(addDisposableListener(this.domNode, 'dragleave', e => this.onDragLeave(this.toDragEvent(e))));
         this.disposables.add(addDisposableListener(this.domNode, 'dragend', e => this.onDragEnd(e)));
-        this.setRowLineHeight = (_h = options.setRowLineHeight) !== null && _h !== void 0 ? _h : DefaultOptions.setRowLineHeight;
-        this.setRowHeight = (_j = options.setRowHeight) !== null && _j !== void 0 ? _j : DefaultOptions.setRowHeight;
-        this.supportDynamicHeights = (_k = options.supportDynamicHeights) !== null && _k !== void 0 ? _k : DefaultOptions.supportDynamicHeights;
-        this.dnd = (_l = options.dnd) !== null && _l !== void 0 ? _l : this.disposables.add(DefaultOptions.dnd);
-        this.layout((_m = options.initialSize) === null || _m === void 0 ? void 0 : _m.height, (_o = options.initialSize) === null || _o === void 0 ? void 0 : _o.width);
+        this.setRowLineHeight = options.setRowLineHeight ?? DefaultOptions.setRowLineHeight;
+        this.setRowHeight = options.setRowHeight ?? DefaultOptions.setRowHeight;
+        this.supportDynamicHeights = options.supportDynamicHeights ?? DefaultOptions.supportDynamicHeights;
+        this.dnd = options.dnd ?? this.disposables.add(DefaultOptions.dnd);
+        this.layout(options.initialSize?.height, options.initialSize?.width);
     }
     updateOptions(options) {
         if (options.paddingBottom !== undefined) {
@@ -252,13 +263,13 @@
         }
         let scrollableOptions;
         if (options.scrollByPage !== undefined) {
-            scrollableOptions = Object.assign(Object.assign({}, (scrollableOptions !== null && scrollableOptions !== void 0 ? scrollableOptions : {})), { scrollByPage: options.scrollByPage });
+            scrollableOptions = { ...(scrollableOptions ?? {}), scrollByPage: options.scrollByPage };
         }
         if (options.mouseWheelScrollSensitivity !== undefined) {
-            scrollableOptions = Object.assign(Object.assign({}, (scrollableOptions !== null && scrollableOptions !== void 0 ? scrollableOptions : {})), { mouseWheelScrollSensitivity: options.mouseWheelScrollSensitivity });
+            scrollableOptions = { ...(scrollableOptions ?? {}), mouseWheelScrollSensitivity: options.mouseWheelScrollSensitivity };
         }
         if (options.fastScrollSensitivity !== undefined) {
-            scrollableOptions = Object.assign(Object.assign({}, (scrollableOptions !== null && scrollableOptions !== void 0 ? scrollableOptions : {})), { fastScrollSensitivity: options.fastScrollSensitivity });
+            scrollableOptions = { ...(scrollableOptions ?? {}), fastScrollSensitivity: options.fastScrollSensitivity };
         }
         if (scrollableOptions) {
             this.scrollableElement.updateOptions(scrollableOptions);
@@ -276,6 +287,53 @@
             }
         }
     }
+    delegateScrollFromMouseWheelEvent(browserEvent) {
+        this.scrollableElement.delegateScrollFromMouseWheelEvent(browserEvent);
+    }
+    delegateVerticalScrollbarPointerDown(browserEvent) {
+        this.scrollableElement.delegateVerticalScrollbarPointerDown(browserEvent);
+    }
+    updateElementHeight(index, size, anchorIndex) {
+        if (index < 0 || index >= this.items.length) {
+            return;
+        }
+        const originalSize = this.items[index].size;
+        if (typeof size === 'undefined') {
+            if (!this.supportDynamicHeights) {
+                console.warn('Dynamic heights not supported');
+                return;
+            }
+            this.items[index].lastDynamicHeightWidth = undefined;
+            size = originalSize + this.probeDynamicHeight(index);
+        }
+        if (originalSize === size) {
+            return;
+        }
+        const lastRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
+        let heightDiff = 0;
+        if (index < lastRenderRange.start) {
+            // do not scroll the viewport if resized element is out of viewport
+            heightDiff = size - originalSize;
+        }
+        else {
+            if (anchorIndex !== null && anchorIndex > index && anchorIndex < lastRenderRange.end) {
+                // anchor in viewport
+                // resized element in viewport and above the anchor
+                heightDiff = size - originalSize;
+            }
+            else {
+                heightDiff = 0;
+            }
+        }
+        this.rangeMap.splice(index, 1, [{ size: size }]);
+        this.items[index].size = size;
+        this.render(lastRenderRange, Math.max(0, this.lastRenderTop + heightDiff), this.lastRenderHeight, undefined, undefined, true);
+        this.setScrollTop(this.lastRenderTop);
+        this.eventuallyUpdateScrollDimensions();
+        if (this.supportDynamicHeights) {
+            this._rerender(this.lastRenderTop, this.lastRenderHeight);
+        }
+    }
     splice(start, deleteCount, elements = []) {
         if (this.splicing) {
             throw new Error('Can\'t run recursive splices.');
@@ -363,7 +421,7 @@
             for (let i = range.start; i < range.end; i++) {
                 const item = this.items[i];
                 const rows = rowsToDispose.get(item.templateId);
-                const row = rows === null || rows === void 0 ? void 0 : rows.pop();
+                const row = rows?.pop();
                 this.insertItemInDOM(i, beforeElement, row);
             }
         }
@@ -410,6 +468,18 @@
         this.scrollableElement.setScrollDimensions({ scrollWidth: scrollWidth === 0 ? 0 : (scrollWidth + 10) });
         this._onDidChangeContentWidth.fire(this.scrollWidth);
     }
+    updateWidth(index) {
+        if (!this.horizontalScrolling || typeof this.scrollWidth === 'undefined') {
+            return;
+        }
+        const item = this.items[index];
+        this.measureItemWidth(item);
+        if (typeof item.width !== 'undefined' && item.width > this.scrollWidth) {
+            this.scrollWidth = item.width;
+            this.scrollableElement.setScrollDimensions({ scrollWidth: this.scrollWidth + 10 });
+            this._onDidChangeContentWidth.fire(this.scrollWidth);
+        }
+    }
     rerender() {
         if (!this.supportDynamicHeights) {
             return;
@@ -438,9 +508,16 @@
         }
         return range.start;
     }
+    get lastVisibleIndex() {
+        const range = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
+        return range.end - 1;
+    }
     element(index) {
         return this.items[index].element;
     }
+    indexOf(element) {
+        return this.items.findIndex(item => item.element === element);
+    }
     domElement(index) {
         const row = this.items[index].row;
         return row && row.domNode;
@@ -551,7 +628,7 @@
         if (!renderer) {
             throw new Error(`No renderer found for template id ${item.templateId}`);
         }
-        renderer === null || renderer === void 0 ? void 0 : renderer.renderElement(item.element, index, item.row.templateData, item.size);
+        renderer?.renderElement(item.element, index, item.row.templateData, item.size);
         const uri = this.dnd.getDragURI(item.element);
         item.dragStartDisposable.dispose();
         item.row.domNode.draggable = !!uri;
@@ -622,6 +699,18 @@
         }
         this.scrollableElement.setScrollPosition({ scrollTop, reuseAnimation });
     }
+    getScrollLeft() {
+        const scrollPosition = this.scrollableElement.getScrollPosition();
+        return scrollPosition.scrollLeft;
+    }
+    setScrollLeft(scrollLeft) {
+        if (this.scrollableElementUpdateDisposable) {
+            this.scrollableElementUpdateDisposable.dispose();
+            this.scrollableElementUpdateDisposable = null;
+            this.scrollableElement.setScrollDimensions({ scrollWidth: this.scrollWidth });
+        }
+        this.scrollableElement.setScrollPosition({ scrollLeft });
+    }
     get scrollTop() {
         return this.getScrollTop();
     }
@@ -635,8 +724,10 @@
     get onMouseClick() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'click')).event, e => this.toMouseEvent(e), this.disposables); }
     get onMouseDblClick() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'dblclick')).event, e => this.toMouseEvent(e), this.disposables); }
     get onMouseMiddleClick() { return Event.filter(Event.map(this.disposables.add(new DomEmitter(this.domNode, 'auxclick')).event, e => this.toMouseEvent(e), this.disposables), e => e.browserEvent.button === 1, this.disposables); }
+    get onMouseUp() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'mouseup')).event, e => this.toMouseEvent(e), this.disposables); }
     get onMouseDown() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'mousedown')).event, e => this.toMouseEvent(e), this.disposables); }
     get onMouseOver() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'mouseover')).event, e => this.toMouseEvent(e), this.disposables); }
+    get onMouseMove() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'mousemove')).event, e => this.toMouseEvent(e), this.disposables); }
     get onMouseOut() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'mouseout')).event, e => this.toMouseEvent(e), this.disposables); }
     get onContextMenu() { return Event.any(Event.map(this.disposables.add(new DomEmitter(this.domNode, 'contextmenu')).event, e => this.toMouseEvent(e), this.disposables), Event.map(this.disposables.add(new DomEmitter(this.domNode, TouchEventType.Contextmenu)).event, e => this.toGestureEvent(e), this.disposables)); }
     get onTouchStart() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'touchstart')).event, e => this.toTouchEvent(e), this.disposables); }
@@ -685,7 +776,6 @@
     }
     // DND
     onDragStart(element, uri, event) {
-        var _a, _b;
         if (!event.dataTransfer) {
             return;
         }
@@ -716,10 +806,9 @@
         this.domNode.classList.add('dragging');
         this.currentDragData = new ElementsDragAndDropData(elements);
         StaticDND.CurrentDragAndDropData = new ExternalElementsDragAndDropData(elements);
-        (_b = (_a = this.dnd).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, this.currentDragData, event);
+        this.dnd.onDragStart?.(this.currentDragData, event);
     }
     onDragOver(event) {
-        var _a;
         event.browserEvent.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)
         this.onDragLeaveTimeout.dispose();
         if (StaticDND.CurrentDragAndDropData && StaticDND.CurrentDragAndDropData.getData() === 'vscode-ui') {
@@ -783,25 +872,23 @@
             for (const index of feedback) {
                 const item = this.items[index];
                 item.dropTarget = true;
-                (_a = item.row) === null || _a === void 0 ? void 0 : _a.domNode.classList.add('drop-target');
+                item.row?.domNode.classList.add('drop-target');
             }
             this.currentDragFeedbackDisposable = toDisposable(() => {
-                var _a;
                 for (const index of feedback) {
                     const item = this.items[index];
                     item.dropTarget = false;
-                    (_a = item.row) === null || _a === void 0 ? void 0 : _a.domNode.classList.remove('drop-target');
+                    item.row?.domNode.classList.remove('drop-target');
                 }
             });
         }
         return true;
     }
     onDragLeave(event) {
-        var _a, _b;
         this.onDragLeaveTimeout.dispose();
         this.onDragLeaveTimeout = disposableTimeout(() => this.clearDragOverFeedback(), 100, this.disposables);
         if (this.currentDragData) {
-            (_b = (_a = this.dnd).onDragLeave) === null || _b === void 0 ? void 0 : _b.call(_a, this.currentDragData, event.element, event.index, event.browserEvent);
+            this.dnd.onDragLeave?.(this.currentDragData, event.element, event.index, event.browserEvent);
         }
     }
     onDrop(event) {
@@ -822,14 +909,13 @@
         this.dnd.drop(dragData, event.element, event.index, event.browserEvent);
     }
     onDragEnd(event) {
-        var _a, _b;
         this.canDrop = false;
         this.teardownDragAndDropScrollTopAnimation();
         this.clearDragOverFeedback();
         this.domNode.classList.remove('dragging');
         this.currentDragData = undefined;
         StaticDND.CurrentDragAndDropData = undefined;
-        (_b = (_a = this.dnd).onDragEnd) === null || _b === void 0 ? void 0 : _b.call(_a, event);
+        this.dnd.onDragEnd?.(event);
     }
     clearDragOverFeedback() {
         this.currentDragFeedback = undefined;
@@ -965,7 +1051,6 @@
         }
     }
     probeDynamicHeight(index) {
-        var _a, _b, _c;
         const item = this.items[index];
         if (!!this.virtualDelegate.getDynamicHeight) {
             const newSize = this.virtualDelegate.getDynamicHeight(item.element);
@@ -998,8 +1083,8 @@
         }
         renderer.renderElement(item.element, index, row.templateData, undefined);
         item.size = row.domNode.offsetHeight;
-        (_a = renderer.disposeElement) === null || _a === void 0 ? void 0 : _a.call(renderer, item.element, index, row.templateData, undefined);
-        (_c = (_b = this.virtualDelegate).setDynamicHeight) === null || _c === void 0 ? void 0 : _c.call(_b, item.element, item.size);
+        renderer.disposeElement?.(item.element, index, row.templateData, undefined);
+        this.virtualDelegate.setDynamicHeight?.(item.element, item.size);
         item.lastDynamicHeightWidth = this.renderWidth;
         this.rowsContainer.removeChild(row.domNode);
         this.cache.release(row);
@@ -1024,14 +1109,13 @@
     }
     // Dispose
     dispose() {
-        var _a, _b;
         for (const item of this.items) {
             item.dragStartDisposable.dispose();
             item.checkedDisposable.dispose();
             if (item.row) {
                 const renderer = this.renderers.get(item.row.templateId);
                 if (renderer) {
-                    (_a = renderer.disposeElement) === null || _a === void 0 ? void 0 : _a.call(renderer, item.element, -1, item.row.templateData, undefined);
+                    renderer.disposeElement?.(item.element, -1, item.row.templateData, undefined);
                     renderer.disposeTemplate(item.row.templateData);
                 }
             }
@@ -1040,7 +1124,7 @@
         if (this.domNode && this.domNode.parentNode) {
             this.domNode.parentNode.removeChild(this.domNode);
         }
-        (_b = this.dragOverAnimationDisposable) === null || _b === void 0 ? void 0 : _b.dispose();
+        this.dragOverAnimationDisposable?.dispose();
         this.disposables.dispose();
     }
 }
@@ -1056,12 +1140,18 @@
 ], ListView.prototype, "onMouseMiddleClick", null);
 __decorate([
     memoize
+], ListView.prototype, "onMouseUp", null);
+__decorate([
+    memoize
 ], ListView.prototype, "onMouseDown", null);
 __decorate([
     memoize
 ], ListView.prototype, "onMouseOver", null);
 __decorate([
     memoize
+], ListView.prototype, "onMouseMove", null);
+__decorate([
+    memoize
 ], ListView.prototype, "onMouseOut", null);
 __decorate([
     memoize
diff -urN -x '*.map' a/vs/base/browser/ui/list/listWidget.js b/vs/base/browser/ui/list/listWidget.js
--- a/vs/base/browser/ui/list/listWidget.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/list/listWidget.js	2023-12-06 14:23:14.347854727 +0000
@@ -8,15 +8,6 @@
     else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
     return c > 3 && r && Object.defineProperty(target, key, r), r;
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { asCssValueWithDefault, createStyleSheet, EventHelper } from '../../dom.js';
 import { DomEmitter } from '../../event.js';
 import { StandardKeyboardEvent } from '../../keyboardEvent.js';
@@ -105,7 +96,6 @@
         this.onChange = this._onChange.event;
     }
     splice(start, deleteCount, elements) {
-        var _a;
         deleteCount = Math.max(0, Math.min(deleteCount, this.length - start));
         const diff = elements.length - deleteCount;
         const end = start + deleteCount;
@@ -124,7 +114,7 @@
         }
         const length = this.length + diff;
         if (this.sortedIndexes.length > 0 && sortedIndexes.length === 0 && length > 0) {
-            const first = (_a = this.sortedIndexes.find(index => index >= start)) !== null && _a !== void 0 ? _a : length - 1;
+            const first = this.sortedIndexes.find(index => index >= start) ?? length - 1;
             sortedIndexes.push(Math.min(first, length - 1));
         }
         this.renderer.splice(start, deleteCount, elements.length);
@@ -378,14 +368,16 @@
         this.updateOptions(list.options);
     }
     updateOptions(options) {
-        var _a, _b;
-        if ((_a = options.typeNavigationEnabled) !== null && _a !== void 0 ? _a : true) {
+        if (options.typeNavigationEnabled ?? true) {
             this.enable();
         }
         else {
             this.disable();
         }
-        this.mode = (_b = options.typeNavigationMode) !== null && _b !== void 0 ? _b : TypeNavigationMode.Automatic;
+        this.mode = options.typeNavigationMode ?? TypeNavigationMode.Automatic;
+    }
+    trigger() {
+        this.triggered = !this.triggered;
     }
     enable() {
         if (this.enabled) {
@@ -417,12 +409,11 @@
         this.triggered = false;
     }
     onClear() {
-        var _a;
         const focus = this.list.getFocus();
         if (focus.length > 0 && focus[0] === this.previouslyFocused) {
             // List: re-announce element on typing end since typed keys will interrupt aria label of focused element
             // Do not announce if there was a focus change at the end to prevent duplication https://github.com/microsoft/vscode/issues/95961
-            const ariaLabel = (_a = this.list.options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getAriaLabel(this.list.element(focus[0]));
+            const ariaLabel = this.list.options.accessibilityProvider?.getAriaLabel(this.list.element(focus[0]));
             if (ariaLabel) {
                 alert(ariaLabel);
             }
@@ -636,7 +627,7 @@
         if (this.isSelectionRangeChangeEvent(e)) {
             if (typeof anchor === 'undefined') {
                 const currentFocus = this.list.getFocus()[0];
-                anchor = currentFocus !== null && currentFocus !== void 0 ? currentFocus : focus;
+                anchor = currentFocus ?? focus;
                 this.list.setAnchor(anchor);
             }
             const min = Math.min(anchor, focus);
@@ -674,7 +665,6 @@
         this.selectorSuffix = selectorSuffix;
     }
     style(styles) {
-        var _a, _b;
         const suffix = this.selectorSuffix && `.${this.selectorSuffix}`;
         const content = [];
         if (styles.listBackground) {
@@ -736,7 +726,7 @@
         /**
          * Outlines
          */
-        const focusAndSelectionOutline = asCssValueWithDefault(styles.listFocusAndSelectionOutline, asCssValueWithDefault(styles.listSelectionOutline, (_a = styles.listFocusOutline) !== null && _a !== void 0 ? _a : ''));
+        const focusAndSelectionOutline = asCssValueWithDefault(styles.listFocusAndSelectionOutline, asCssValueWithDefault(styles.listSelectionOutline, styles.listFocusOutline ?? ''));
         if (focusAndSelectionOutline) { // default: listFocusOutline
             content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused.selected { outline: 1px solid ${focusAndSelectionOutline}; outline-offset: -1px;}`);
         }
@@ -747,7 +737,7 @@
 				.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }
 			`);
         }
-        const inactiveFocusAndSelectionOutline = asCssValueWithDefault(styles.listSelectionOutline, (_b = styles.listInactiveFocusOutline) !== null && _b !== void 0 ? _b : '');
+        const inactiveFocusAndSelectionOutline = asCssValueWithDefault(styles.listSelectionOutline, styles.listInactiveFocusOutline ?? '');
         if (inactiveFocusAndSelectionOutline) {
             content.push(`.monaco-list${suffix} .monaco-list-row.focused.selected { outline: 1px dotted ${inactiveFocusAndSelectionOutline}; outline-offset: -1px; }`);
         }
@@ -927,10 +917,9 @@
         }
     }
     disposeElement(element, index, templateData, height) {
-        var _a;
         let i = 0;
         for (const renderer of this.renderers) {
-            (_a = renderer.disposeElement) === null || _a === void 0 ? void 0 : _a.call(renderer, element, index, templateData[i], height);
+            renderer.disposeElement?.(element, index, templateData[i], height);
             i += 1;
         }
     }
@@ -989,19 +978,16 @@
         return undefined;
     }
     onDragStart(data, originalEvent) {
-        var _a, _b;
-        (_b = (_a = this.dnd).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, data, originalEvent);
+        this.dnd.onDragStart?.(data, originalEvent);
     }
     onDragOver(data, targetElement, targetIndex, originalEvent) {
         return this.dnd.onDragOver(data, targetElement, targetIndex, originalEvent);
     }
     onDragLeave(data, targetElement, targetIndex, originalEvent) {
-        var _a, _b;
-        (_b = (_a = this.dnd).onDragLeave) === null || _b === void 0 ? void 0 : _b.call(_a, data, targetElement, targetIndex, originalEvent);
+        this.dnd.onDragLeave?.(data, targetElement, targetIndex, originalEvent);
     }
     onDragEnd(originalEvent) {
-        var _a, _b;
-        (_b = (_a = this.dnd).onDragEnd) === null || _b === void 0 ? void 0 : _b.call(_a, originalEvent);
+        this.dnd.onDragEnd?.(originalEvent);
     }
     drop(data, targetElement, targetIndex, originalEvent) {
         this.dnd.drop(data, targetElement, targetIndex, originalEvent);
@@ -1038,8 +1024,10 @@
     get onMouseDblClick() { return this.view.onMouseDblClick; }
     get onMouseMiddleClick() { return this.view.onMouseMiddleClick; }
     get onPointer() { return this.mouseController.onPointer; }
+    get onMouseUp() { return this.view.onMouseUp; }
     get onMouseDown() { return this.view.onMouseDown; }
     get onMouseOver() { return this.view.onMouseOver; }
+    get onMouseMove() { return this.view.onMouseMove; }
     get onMouseOut() { return this.view.onMouseOut; }
     get onTouchStart() { return this.view.onTouchStart; }
     get onTap() { return this.view.onTap; }
@@ -1072,9 +1060,11 @@
         return Event.any(fromKeyDown, fromKeyUp, fromMouse);
     }
     get onKeyDown() { return this.disposables.add(new DomEmitter(this.view.domNode, 'keydown')).event; }
+    get onKeyUp() { return this.disposables.add(new DomEmitter(this.view.domNode, 'keyup')).event; }
+    get onKeyPress() { return this.disposables.add(new DomEmitter(this.view.domNode, 'keypress')).event; }
     get onDidFocus() { return Event.signal(this.disposables.add(new DomEmitter(this.view.domNode, 'focus', true)).event); }
+    get onDidBlur() { return Event.signal(this.disposables.add(new DomEmitter(this.view.domNode, 'blur', true)).event); }
     constructor(user, container, virtualDelegate, renderers, _options = DefaultOptions) {
-        var _a, _b, _c, _d;
         this.user = user;
         this._options = _options;
         this.focus = new Trait('focused');
@@ -1084,16 +1074,19 @@
         this.disposables = new DisposableStore();
         this._onDidDispose = new Emitter();
         this.onDidDispose = this._onDidDispose.event;
-        const role = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (_a = this._options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getWidgetRole() : 'list';
+        const role = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? this._options.accessibilityProvider?.getWidgetRole() : 'list';
         this.selection = new SelectionTrait(role !== 'listbox');
         const baseRenderers = [this.focus.renderer, this.selection.renderer];
         this.accessibilityProvider = _options.accessibilityProvider;
         if (this.accessibilityProvider) {
             baseRenderers.push(new AccessibiltyRenderer(this.accessibilityProvider));
-            (_c = (_b = this.accessibilityProvider).onDidChangeActiveDescendant) === null || _c === void 0 ? void 0 : _c.call(_b, this.onDidChangeActiveDescendant, this, this.disposables);
+            this.accessibilityProvider.onDidChangeActiveDescendant?.(this.onDidChangeActiveDescendant, this, this.disposables);
         }
         renderers = renderers.map(r => new PipelineRenderer(r.templateId, [...baseRenderers, r]));
-        const viewOptions = Object.assign(Object.assign({}, _options), { dnd: _options.dnd && new ListViewDragAndDrop(this, _options.dnd) });
+        const viewOptions = {
+            ..._options,
+            dnd: _options.dnd && new ListViewDragAndDrop(this, _options.dnd)
+        };
         this.view = this.createListView(container, virtualDelegate, renderers, viewOptions);
         this.view.domNode.setAttribute('role', role);
         if (_options.styleController) {
@@ -1121,7 +1114,7 @@
         }
         if (_options.keyboardNavigationLabelProvider) {
             const delegate = _options.keyboardNavigationDelegate || DefaultKeyboardNavigationDelegate;
-            this.typeNavigationController = new TypeNavigationController(this, this.view, _options.keyboardNavigationLabelProvider, (_d = _options.keyboardNavigationEventFilter) !== null && _d !== void 0 ? _d : (() => true), delegate);
+            this.typeNavigationController = new TypeNavigationController(this, this.view, _options.keyboardNavigationLabelProvider, _options.keyboardNavigationEventFilter ?? (() => true), delegate);
             this.disposables.add(this.typeNavigationController);
         }
         this.mouseController = this.createMouseController(_options);
@@ -1142,9 +1135,8 @@
         return new MouseController(this);
     }
     updateOptions(optionsUpdate = {}) {
-        var _a, _b;
-        this._options = Object.assign(Object.assign({}, this._options), optionsUpdate);
-        (_a = this.typeNavigationController) === null || _a === void 0 ? void 0 : _a.updateOptions(this._options);
+        this._options = { ...this._options, ...optionsUpdate };
+        this.typeNavigationController?.updateOptions(this._options);
         if (this._options.multipleSelectionController !== undefined) {
             if (this._options.multipleSelectionSupport) {
                 this.view.domNode.setAttribute('aria-multiselectable', 'true');
@@ -1154,7 +1146,7 @@
             }
         }
         this.mouseController.updateOptions(optionsUpdate);
-        (_b = this.keyboardController) === null || _b === void 0 ? void 0 : _b.updateOptions(optionsUpdate);
+        this.keyboardController?.updateOptions(optionsUpdate);
         this.view.updateOptions(optionsUpdate);
     }
     get options() {
@@ -1172,24 +1164,48 @@
         }
         this.eventBufferer.bufferEvents(() => this.spliceable.splice(start, deleteCount, elements));
     }
+    updateWidth(index) {
+        this.view.updateWidth(index);
+    }
+    updateElementHeight(index, size) {
+        this.view.updateElementHeight(index, size, null);
+    }
     rerender() {
         this.view.rerender();
     }
     element(index) {
         return this.view.element(index);
     }
+    indexOf(element) {
+        return this.view.indexOf(element);
+    }
     get length() {
         return this.view.length;
     }
     get contentHeight() {
         return this.view.contentHeight;
     }
+    get contentWidth() {
+        return this.view.contentWidth;
+    }
+    get onDidChangeContentHeight() {
+        return this.view.onDidChangeContentHeight;
+    }
+    get onDidChangeContentWidth() {
+        return this.view.onDidChangeContentWidth;
+    }
     get scrollTop() {
         return this.view.getScrollTop();
     }
     set scrollTop(scrollTop) {
         this.view.setScrollTop(scrollTop);
     }
+    get scrollLeft() {
+        return this.view.getScrollLeft();
+    }
+    set scrollLeft(scrollLeft) {
+        this.view.setScrollLeft(scrollLeft);
+    }
     get scrollHeight() {
         return this.view.scrollHeight;
     }
@@ -1199,6 +1215,9 @@
     get firstVisibleIndex() {
         return this.view.firstVisibleIndex;
     }
+    get lastVisibleIndex() {
+        return this.view.lastVisibleIndex;
+    }
     get ariaLabel() {
         return this._ariaLabel;
     }
@@ -1212,6 +1231,9 @@
     layout(height, width) {
         this.view.layout(height, width);
     }
+    triggerTypeNavigation() {
+        this.typeNavigationController?.trigger();
+    }
     setSelection(indexes, browserEvent) {
         for (const index of indexes) {
             if (index < 0 || index >= this.length) {
@@ -1271,68 +1293,64 @@
             this.setFocus([index], browserEvent);
         }
     }
-    focusNextPage(browserEvent, filter) {
-        return __awaiter(this, void 0, void 0, function* () {
-            let lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
-            lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;
-            const currentlyFocusedElementIndex = this.getFocus()[0];
-            if (currentlyFocusedElementIndex !== lastPageIndex && (currentlyFocusedElementIndex === undefined || lastPageIndex > currentlyFocusedElementIndex)) {
-                const lastGoodPageIndex = this.findPreviousIndex(lastPageIndex, false, filter);
-                if (lastGoodPageIndex > -1 && currentlyFocusedElementIndex !== lastGoodPageIndex) {
-                    this.setFocus([lastGoodPageIndex], browserEvent);
-                }
-                else {
-                    this.setFocus([lastPageIndex], browserEvent);
-                }
+    async focusNextPage(browserEvent, filter) {
+        let lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
+        lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;
+        const currentlyFocusedElementIndex = this.getFocus()[0];
+        if (currentlyFocusedElementIndex !== lastPageIndex && (currentlyFocusedElementIndex === undefined || lastPageIndex > currentlyFocusedElementIndex)) {
+            const lastGoodPageIndex = this.findPreviousIndex(lastPageIndex, false, filter);
+            if (lastGoodPageIndex > -1 && currentlyFocusedElementIndex !== lastGoodPageIndex) {
+                this.setFocus([lastGoodPageIndex], browserEvent);
             }
             else {
-                const previousScrollTop = this.view.getScrollTop();
-                let nextpageScrollTop = previousScrollTop + this.view.renderHeight;
-                if (lastPageIndex > currentlyFocusedElementIndex) {
-                    // scroll last page element to the top only if the last page element is below the focused element
-                    nextpageScrollTop -= this.view.elementHeight(lastPageIndex);
-                }
-                this.view.setScrollTop(nextpageScrollTop);
-                if (this.view.getScrollTop() !== previousScrollTop) {
-                    this.setFocus([]);
-                    // Let the scroll event listener run
-                    yield timeout(0);
-                    yield this.focusNextPage(browserEvent, filter);
-                }
+                this.setFocus([lastPageIndex], browserEvent);
+            }
+        }
+        else {
+            const previousScrollTop = this.view.getScrollTop();
+            let nextpageScrollTop = previousScrollTop + this.view.renderHeight;
+            if (lastPageIndex > currentlyFocusedElementIndex) {
+                // scroll last page element to the top only if the last page element is below the focused element
+                nextpageScrollTop -= this.view.elementHeight(lastPageIndex);
+            }
+            this.view.setScrollTop(nextpageScrollTop);
+            if (this.view.getScrollTop() !== previousScrollTop) {
+                this.setFocus([]);
+                // Let the scroll event listener run
+                await timeout(0);
+                await this.focusNextPage(browserEvent, filter);
             }
-        });
+        }
     }
-    focusPreviousPage(browserEvent, filter) {
-        return __awaiter(this, void 0, void 0, function* () {
-            let firstPageIndex;
-            const scrollTop = this.view.getScrollTop();
-            if (scrollTop === 0) {
-                firstPageIndex = this.view.indexAt(scrollTop);
+    async focusPreviousPage(browserEvent, filter) {
+        let firstPageIndex;
+        const scrollTop = this.view.getScrollTop();
+        if (scrollTop === 0) {
+            firstPageIndex = this.view.indexAt(scrollTop);
+        }
+        else {
+            firstPageIndex = this.view.indexAfter(scrollTop - 1);
+        }
+        const currentlyFocusedElementIndex = this.getFocus()[0];
+        if (currentlyFocusedElementIndex !== firstPageIndex && (currentlyFocusedElementIndex === undefined || currentlyFocusedElementIndex >= firstPageIndex)) {
+            const firstGoodPageIndex = this.findNextIndex(firstPageIndex, false, filter);
+            if (firstGoodPageIndex > -1 && currentlyFocusedElementIndex !== firstGoodPageIndex) {
+                this.setFocus([firstGoodPageIndex], browserEvent);
             }
             else {
-                firstPageIndex = this.view.indexAfter(scrollTop - 1);
+                this.setFocus([firstPageIndex], browserEvent);
             }
-            const currentlyFocusedElementIndex = this.getFocus()[0];
-            if (currentlyFocusedElementIndex !== firstPageIndex && (currentlyFocusedElementIndex === undefined || currentlyFocusedElementIndex >= firstPageIndex)) {
-                const firstGoodPageIndex = this.findNextIndex(firstPageIndex, false, filter);
-                if (firstGoodPageIndex > -1 && currentlyFocusedElementIndex !== firstGoodPageIndex) {
-                    this.setFocus([firstGoodPageIndex], browserEvent);
-                }
-                else {
-                    this.setFocus([firstPageIndex], browserEvent);
-                }
-            }
-            else {
-                const previousScrollTop = scrollTop;
-                this.view.setScrollTop(scrollTop - this.view.renderHeight);
-                if (this.view.getScrollTop() !== previousScrollTop) {
-                    this.setFocus([]);
-                    // Let the scroll event listener run
-                    yield timeout(0);
-                    yield this.focusPreviousPage(browserEvent, filter);
-                }
+        }
+        else {
+            const previousScrollTop = scrollTop;
+            this.view.setScrollTop(scrollTop - this.view.renderHeight);
+            if (this.view.getScrollTop() !== previousScrollTop) {
+                this.setFocus([]);
+                // Let the scroll event listener run
+                await timeout(0);
+                await this.focusPreviousPage(browserEvent, filter);
             }
-        });
+        }
     }
     focusLast(browserEvent, filter) {
         if (this.length === 0) {
@@ -1413,6 +1431,27 @@
             }
         }
     }
+    /**
+     * Returns the relative position of an element rendered in the list.
+     * Returns `null` if the element isn't *entirely* in the visible viewport.
+     */
+    getRelativeTop(index) {
+        if (index < 0 || index >= this.length) {
+            throw new ListError(this.user, `Invalid index ${index}`);
+        }
+        const scrollTop = this.view.getScrollTop();
+        const elementTop = this.view.elementTop(index);
+        const elementHeight = this.view.elementHeight(index);
+        if (elementTop < scrollTop || elementTop + elementHeight > scrollTop + this.view.renderHeight) {
+            return null;
+        }
+        // y = mx + b
+        const m = elementHeight - this.view.renderHeight;
+        return Math.abs((scrollTop - elementTop) / m);
+    }
+    isDOMFocused() {
+        return this.view.domNode === document.activeElement;
+    }
     getHTMLElement() {
         return this.view.domNode;
     }
@@ -1431,11 +1470,10 @@
         this.onDidChangeActiveDescendant();
     }
     onDidChangeActiveDescendant() {
-        var _a;
         const focus = this.focus.get();
         if (focus.length > 0) {
             let id;
-            if ((_a = this.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getActiveDescendantId) {
+            if (this.accessibilityProvider?.getActiveDescendantId) {
                 id = this.accessibilityProvider.getActiveDescendantId(this.view.element(focus[0]));
             }
             this.view.domNode.setAttribute('aria-activedescendant', id || this.view.getElementDomId(focus[0]));
@@ -1470,4 +1508,13 @@
 ], List.prototype, "onKeyDown", null);
 __decorate([
     memoize
+], List.prototype, "onKeyUp", null);
+__decorate([
+    memoize
+], List.prototype, "onKeyPress", null);
+__decorate([
+    memoize
 ], List.prototype, "onDidFocus", null);
+__decorate([
+    memoize
+], List.prototype, "onDidBlur", null);
diff -urN -x '*.map' a/vs/base/browser/ui/list/rangeMap.js b/vs/base/browser/ui/list/rangeMap.js
--- a/vs/base/browser/ui/list/rangeMap.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/list/rangeMap.js	2023-12-06 14:23:14.347854727 +0000
@@ -74,7 +74,7 @@
         this.groups = [];
         this._size = 0;
         this._paddingTop = 0;
-        this._paddingTop = topPadding !== null && topPadding !== void 0 ? topPadding : 0;
+        this._paddingTop = topPadding ?? 0;
         this._size = this._paddingTop;
     }
     splice(index, deleteCount, items = []) {
diff -urN -x '*.map' a/vs/base/browser/ui/list/rowCache.js b/vs/base/browser/ui/list/rowCache.js
--- a/vs/base/browser/ui/list/rowCache.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/list/rowCache.js	2023-12-06 14:23:14.347854727 +0000
@@ -4,9 +4,8 @@
  *--------------------------------------------------------------------------------------------*/
 import { $ } from '../../dom.js';
 function removeFromParent(element) {
-    var _a;
     try {
-        (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(element);
+        element.parentElement?.removeChild(element);
     }
     catch (e) {
         // this will throw if this happens due to a blur event, nasty business
diff -urN -x '*.map' a/vs/base/browser/ui/menu/menu.js b/vs/base/browser/ui/menu/menu.js
--- a/vs/base/browser/ui/menu/menu.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/ui/menu/menu.js	2023-12-06 14:23:14.347854727 +0000
@@ -26,6 +26,20 @@
     Direction[Direction["Right"] = 0] = "Right";
     Direction[Direction["Left"] = 1] = "Left";
 })(Direction || (Direction = {}));
+export const unthemedMenuStyles = {
+    shadowColor: undefined,
+    borderColor: undefined,
+    foregroundColor: undefined,
+    backgroundColor: undefined,
+    selectionForegroundColor: undefined,
+    selectionBackgroundColor: undefined,
+    selectionBorderColor: undefined,
+    separatorColor: undefined,
+    scrollbarShadow: undefined,
+    scrollbarSliderBackground: undefined,
+    scrollbarSliderHoverBackground: undefined,
+    scrollbarSliderActiveBackground: undefined
+};
 export class Menu extends ActionBar {
     constructor(container, actions, options, menuStyles) {
         container.classList.add('monaco-menu-container');
@@ -165,8 +179,7 @@
         }));
         menuElement.style.maxHeight = `${Math.max(10, window.innerHeight - container.getBoundingClientRect().top - 35)}px`;
         actions = actions.filter(a => {
-            var _a;
-            if ((_a = options.submenuIds) === null || _a === void 0 ? void 0 : _a.has(a.id)) {
+            if (options.submenuIds?.has(a.id)) {
                 console.warn(`Found submenu cycle: ${a.id}`);
                 return false;
             }
@@ -194,9 +207,8 @@
         this.styleSheet.textContent = getMenuWidgetCSS(style, isInShadowDOM(container));
     }
     styleScrollElement(scrollElement, style) {
-        var _a, _b;
-        const fgColor = (_a = style.foregroundColor) !== null && _a !== void 0 ? _a : '';
-        const bgColor = (_b = style.backgroundColor) !== null && _b !== void 0 ? _b : '';
+        const fgColor = style.foregroundColor ?? '';
+        const bgColor = style.backgroundColor ?? '';
         const border = style.borderColor ? `1px solid ${style.borderColor}` : '';
         const borderRadius = '5px';
         const shadow = style.shadowColor ? `0 2px 8px ${style.shadowColor}` : '';
@@ -212,6 +224,24 @@
     get onScroll() {
         return this.scrollableElement.onScroll;
     }
+    get scrollOffset() {
+        return this.menuElement.scrollTop;
+    }
+    trigger(index) {
+        if (index <= this.viewItems.length && index >= 0) {
+            const item = this.viewItems[index];
+            if (item instanceof SubmenuMenuActionViewItem) {
+                super.focus(index);
+                item.open(true);
+            }
+            else if (item instanceof BaseMenuActionViewItem) {
+                super.run(item._action, item._context);
+            }
+            else {
+                return;
+            }
+        }
+    }
     focusItemByElement(element) {
         const lastFocusedItem = this.focusedItem;
         this.setFocusedItem(element);
@@ -244,7 +274,7 @@
             return new MenuSeparatorActionViewItem(options.context, action, { icon: true }, this.menuStyles);
         }
         else if (action instanceof SubmenuAction) {
-            const menuActionViewItem = new SubmenuMenuActionViewItem(action, action.actions, parentData, Object.assign(Object.assign({}, options), { submenuIds: new Set([...(options.submenuIds || []), action.id]) }), this.menuStyles);
+            const menuActionViewItem = new SubmenuMenuActionViewItem(action, action.actions, parentData, { ...options, submenuIds: new Set([...(options.submenuIds || []), action.id]) }, this.menuStyles);
             if (options.enableMnemonics) {
                 const mnemonic = menuActionViewItem.getMnemonic();
                 if (mnemonic && menuActionViewItem.isEnabled()) {
@@ -382,9 +412,8 @@
         this.applyStyle();
     }
     focus() {
-        var _a;
         super.focus();
-        (_a = this.item) === null || _a === void 0 ? void 0 : _a.focus();
+        this.item?.focus();
         this.applyStyle();
     }
     updatePositionInSet(pos, setSize) {
@@ -394,7 +423,6 @@
         }
     }
     updateLabel() {
-        var _a;
         if (!this.label) {
             return;
         }
@@ -424,7 +452,7 @@
                     else {
                         this.label.innerText = replaceDoubleEscapes(label).trim();
                     }
-                    (_a = this.item) === null || _a === void 0 ? void 0 : _a.setAttribute('aria-keyshortcuts', (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase());
+                    this.item?.setAttribute('aria-keyshortcuts', (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase());
                 }
                 else {
                     this.label.innerText = label.replace(/&&/g, '&').trim();
@@ -499,13 +527,13 @@
         const outline = isSelected && this.menuStyle.selectionBorderColor ? `1px solid ${this.menuStyle.selectionBorderColor}` : '';
         const outlineOffset = isSelected && this.menuStyle.selectionBorderColor ? `-1px` : '';
         if (this.item) {
-            this.item.style.color = fgColor !== null && fgColor !== void 0 ? fgColor : '';
-            this.item.style.backgroundColor = bgColor !== null && bgColor !== void 0 ? bgColor : '';
+            this.item.style.color = fgColor ?? '';
+            this.item.style.backgroundColor = bgColor ?? '';
             this.item.style.outline = outline;
             this.item.style.outlineOffset = outlineOffset;
         }
         if (this.check) {
-            this.check.style.color = fgColor !== null && fgColor !== void 0 ? fgColor : '';
+            this.check.style.color = fgColor ?? '';
         }
     }
 }
@@ -586,6 +614,10 @@
         // native menus do not observe enablement on sumbenus
         // we mimic that behavior
     }
+    open(selectFirst) {
+        this.cleanupExistingSubmenu(false);
+        this.createSubmenu(selectFirst);
+    }
     onClick(e) {
         // stop clicking from trying to run an action
         EventHelper.stop(e, true);
@@ -598,7 +630,7 @@
             try {
                 this.parentData.submenu.dispose();
             }
-            catch (_a) { }
+            catch { }
             this.parentData.submenu = undefined;
             this.updateAriaExpanded('false');
             if (this.submenuContainer) {
@@ -684,9 +716,8 @@
         }
     }
     updateAriaExpanded(value) {
-        var _a;
         if (this.item) {
-            (_a = this.item) === null || _a === void 0 ? void 0 : _a.setAttribute('aria-expanded', value);
+            this.item?.setAttribute('aria-expanded', value);
         }
     }
     applyStyle() {
@@ -694,7 +725,7 @@
         const isSelected = this.element && this.element.classList.contains('focused');
         const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
         if (this.submenuIndicator) {
-            this.submenuIndicator.style.color = fgColor !== null && fgColor !== void 0 ? fgColor : '';
+            this.submenuIndicator.style.color = fgColor ?? '';
         }
     }
     dispose() {
diff -urN -x '*.map' a/vs/base/browser/ui/progressbar/progressbar.js b/vs/base/browser/ui/progressbar/progressbar.js
--- a/vs/base/browser/ui/progressbar/progressbar.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/progressbar/progressbar.js	2023-12-06 14:23:14.347854727 +0000
@@ -2,15 +2,19 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-import { show } from '../../dom.js';
+import { hide, show } from '../../dom.js';
 import { RunOnceScheduler } from '../../../common/async.js';
 import { Disposable } from '../../../common/lifecycle.js';
+import { isNumber } from '../../../common/types.js';
 import './progressbar.css';
 const CSS_DONE = 'done';
 const CSS_ACTIVE = 'active';
 const CSS_INFINITE = 'infinite';
 const CSS_INFINITE_LONG_RUNNING = 'infinite-long-running';
 const CSS_DISCRETE = 'discrete';
+export const unthemedProgressBarOptions = {
+    progressBarBackground: undefined
+};
 /**
  * A progress bar with support for infinite or discrete progress.
  */
@@ -30,7 +34,7 @@
         container.appendChild(this.element);
         this.bit = document.createElement('div');
         this.bit.classList.add('progress-bit');
-        this.bit.style.backgroundColor = (options === null || options === void 0 ? void 0 : options.progressBarBackground) || '#0E70C0';
+        this.bit.style.backgroundColor = options?.progressBarBackground || '#0E70C0';
         this.element.appendChild(this.bit);
     }
     off() {
@@ -42,6 +46,12 @@
         this.longRunningScheduler.cancel();
     }
     /**
+     * Indicates to the progress bar that all work is done.
+     */
+    done() {
+        return this.doDone(true);
+    }
+    /**
      * Stops the progressbar from showing any progress instantly without fading out.
      */
     stop() {
@@ -85,9 +95,62 @@
     infiniteLongRunning() {
         this.element.classList.add(CSS_INFINITE_LONG_RUNNING);
     }
+    /**
+     * Tells the progress bar the total number of work. Use in combination with workedVal() to let
+     * the progress bar show the actual progress based on the work that is done.
+     */
+    total(value) {
+        this.workedVal = 0;
+        this.totalWork = value;
+        this.element.setAttribute('aria-valuemax', value.toString());
+        return this;
+    }
+    /**
+     * Finds out if this progress bar is configured with total work
+     */
+    hasTotal() {
+        return isNumber(this.totalWork);
+    }
+    /**
+     * Tells the progress bar that an increment of work has been completed.
+     */
+    worked(value) {
+        value = Math.max(1, Number(value));
+        return this.doSetWorked(this.workedVal + value);
+    }
+    /**
+     * Tells the progress bar the total amount of work that has been completed.
+     */
+    setWorked(value) {
+        value = Math.max(1, Number(value));
+        return this.doSetWorked(value);
+    }
+    doSetWorked(value) {
+        const totalWork = this.totalWork || 100;
+        this.workedVal = value;
+        this.workedVal = Math.min(totalWork, this.workedVal);
+        this.element.classList.remove(CSS_INFINITE, CSS_INFINITE_LONG_RUNNING, CSS_DONE);
+        this.element.classList.add(CSS_ACTIVE, CSS_DISCRETE);
+        this.element.setAttribute('aria-valuenow', value.toString());
+        this.bit.style.width = 100 * (this.workedVal / (totalWork)) + '%';
+        return this;
+    }
     getContainer() {
         return this.element;
     }
+    show(delay) {
+        this.showDelayedScheduler.cancel();
+        if (typeof delay === 'number') {
+            this.showDelayedScheduler.schedule(delay);
+        }
+        else {
+            show(this.element);
+        }
+    }
+    hide() {
+        hide(this.element);
+        this.showDelayedScheduler.cancel();
+    }
 }
 /**
  * After a certain time of showing the progress bar, switch
diff -urN -x '*.map' a/vs/base/browser/ui/sash/sash.js b/vs/base/browser/ui/sash/sash.js
--- a/vs/base/browser/ui/sash/sash.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/sash/sash.js	2023-12-06 14:23:14.347854727 +0000
@@ -31,8 +31,16 @@
 })(OrthogonalEdge || (OrthogonalEdge = {}));
 let globalSize = 4;
 const onDidChangeGlobalSize = new Emitter();
+export function setGlobalSashSize(size) {
+    globalSize = size;
+    onDidChangeGlobalSize.fire(size);
+}
 let globalHoverDelay = 300;
 const onDidChangeHoverDelay = new Emitter();
+export function setGlobalHoverDelay(size) {
+    globalHoverDelay = size;
+    onDidChangeHoverDelay.fire(size);
+}
 class MouseEventFactory {
     constructor() {
         this.disposables = new DisposableStore();
@@ -431,8 +439,7 @@
         }
     }
     getOrthogonalSash(e) {
-        var _a;
-        const target = (_a = e.initialTarget) !== null && _a !== void 0 ? _a : e.target;
+        const target = e.initialTarget ?? e.target;
         if (!target || !(target instanceof HTMLElement)) {
             return undefined;
         }
diff -urN -x '*.map' a/vs/base/browser/ui/scrollbar/scrollableElement.js b/vs/base/browser/ui/scrollbar/scrollableElement.js
--- a/vs/base/browser/ui/scrollbar/scrollableElement.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/scrollbar/scrollableElement.js	2023-12-06 14:23:14.347854727 +0000
@@ -127,6 +127,7 @@
         this._onScroll = this._register(new Emitter());
         this.onScroll = this._onScroll.event;
         this._onWillScroll = this._register(new Emitter());
+        this.onWillScroll = this._onWillScroll.event;
         element.style.overflow = 'hidden';
         this._options = resolveOptions(options);
         this._scrollable = scrollable;
@@ -255,6 +256,9 @@
             this._render();
         }
     }
+    setRevealOnScroll(value) {
+        this._revealOnScroll = value;
+    }
     delegateScrollFromMouseWheelEvent(browserEvent) {
         this._onMouseWheel(new StandardWheelEvent(browserEvent));
     }
@@ -276,8 +280,7 @@
         }
     }
     _onMouseWheel(e) {
-        var _a;
-        if ((_a = e.browserEvent) === null || _a === void 0 ? void 0 : _a.defaultPrevented) {
+        if (e.browserEvent?.defaultPrevented) {
             return;
         }
         const classifier = MouseWheelClassifier.INSTANCE;
@@ -451,6 +454,9 @@
     setScrollPosition(update) {
         this._scrollable.setScrollPositionNow(update);
     }
+    getScrollPosition() {
+        return this._scrollable.getCurrentScrollPosition();
+    }
 }
 export class SmoothScrollableElement extends AbstractScrollableElement {
     constructor(element, options, scrollable) {
diff -urN -x '*.map' a/vs/base/browser/ui/scrollbar/scrollbarVisibilityController.js b/vs/base/browser/ui/scrollbar/scrollbarVisibilityController.js
--- a/vs/base/browser/ui/scrollbar/scrollbarVisibilityController.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/scrollbar/scrollbarVisibilityController.js	2023-12-06 14:23:14.347854727 +0000
@@ -76,17 +76,15 @@
         this._isVisible = true;
         // The CSS animation doesn't play otherwise
         this._revealTimer.setIfNotSet(() => {
-            var _a;
-            (_a = this._domNode) === null || _a === void 0 ? void 0 : _a.setClassName(this._visibleClassName);
+            this._domNode?.setClassName(this._visibleClassName);
         }, 0);
     }
     _hide(withFadeAway) {
-        var _a;
         this._revealTimer.cancel();
         if (!this._isVisible) {
             return;
         }
         this._isVisible = false;
-        (_a = this._domNode) === null || _a === void 0 ? void 0 : _a.setClassName(this._invisibleClassName + (withFadeAway ? ' fade' : ''));
+        this._domNode?.setClassName(this._invisibleClassName + (withFadeAway ? ' fade' : ''));
     }
 }
diff -urN -x '*.map' a/vs/base/browser/ui/selectBox/selectBox.js b/vs/base/browser/ui/selectBox/selectBox.js
--- a/vs/base/browser/ui/selectBox/selectBox.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/selectBox/selectBox.js	2023-12-06 14:23:14.347854727 +0000
@@ -2,16 +2,27 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+import { unthemedListStyles } from '../list/listWidget.js';
 import { SelectBoxList } from './selectBoxCustom.js';
 import { SelectBoxNative } from './selectBoxNative.js';
 import { Widget } from '../widget.js';
 import { isMacintosh } from '../../../common/platform.js';
 import './selectBox.css';
+export const unthemedSelectBoxStyles = {
+    ...unthemedListStyles,
+    selectBackground: '#3C3C3C',
+    selectForeground: '#F0F0F0',
+    selectBorder: '#3C3C3C',
+    decoratorRightForeground: undefined,
+    selectListBackground: undefined,
+    selectListBorder: undefined,
+    focusBorder: undefined,
+};
 export class SelectBox extends Widget {
     constructor(options, selected, contextViewProvider, styles, selectBoxOptions) {
         super();
         // Default to native SelectBox for OSX unless overridden
-        if (isMacintosh && !(selectBoxOptions === null || selectBoxOptions === void 0 ? void 0 : selectBoxOptions.useCustomDrawn)) {
+        if (isMacintosh && !selectBoxOptions?.useCustomDrawn) {
             this.selectBoxDelegate = new SelectBoxNative(options, selected, styles, selectBoxOptions);
         }
         else {
@@ -29,6 +40,9 @@
     select(index) {
         this.selectBoxDelegate.select(index);
     }
+    setAriaLabel(label) {
+        this.selectBoxDelegate.setAriaLabel(label);
+    }
     focus() {
         this.selectBoxDelegate.focus();
     }
diff -urN -x '*.map' a/vs/base/browser/ui/selectBox/selectBoxCustom.js b/vs/base/browser/ui/selectBox/selectBoxCustom.js
--- a/vs/base/browser/ui/selectBox/selectBoxCustom.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/selectBox/selectBoxCustom.js	2023-12-06 14:23:14.347854727 +0000
@@ -13,7 +13,7 @@
 import { Disposable } from '../../../common/lifecycle.js';
 import { isMacintosh } from '../../../common/platform.js';
 import './selectBoxCustom.css';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 const $ = dom.$;
 const SELECT_OPTION_ENTRY_TEMPLATE_ID = 'selectOption.entry.template';
 class SelectListRenderer {
@@ -201,10 +201,9 @@
         }
     }
     setOptionsList() {
-        var _a;
         // Mirror options in drop-down
         // Populate select list for non-native select mode
-        (_a = this.selectList) === null || _a === void 0 ? void 0 : _a.splice(0, this.selectList.length, this.options);
+        this.selectList?.splice(0, this.selectList.length, this.options);
     }
     select(index) {
         if (index >= 0 && index < this.options.length) {
@@ -223,6 +222,10 @@
             this.selectElement.title = this.options[this.selected].text;
         }
     }
+    setAriaLabel(label) {
+        this.selectBoxOptions.ariaLabel = label;
+        this.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);
+    }
     focus() {
         if (this.selectElement) {
             this.selectElement.tabIndex = 0;
@@ -286,21 +289,19 @@
         this.styleElement.textContent = content.join('\n');
     }
     styleSelectElement() {
-        var _a, _b, _c;
-        const background = (_a = this.styles.selectBackground) !== null && _a !== void 0 ? _a : '';
-        const foreground = (_b = this.styles.selectForeground) !== null && _b !== void 0 ? _b : '';
-        const border = (_c = this.styles.selectBorder) !== null && _c !== void 0 ? _c : '';
+        const background = this.styles.selectBackground ?? '';
+        const foreground = this.styles.selectForeground ?? '';
+        const border = this.styles.selectBorder ?? '';
         this.selectElement.style.backgroundColor = background;
         this.selectElement.style.color = foreground;
         this.selectElement.style.borderColor = border;
     }
     styleList() {
-        var _a, _b;
-        const background = (_a = this.styles.selectBackground) !== null && _a !== void 0 ? _a : '';
+        const background = this.styles.selectBackground ?? '';
         const listBackground = dom.asCssValueWithDefault(this.styles.selectListBackground, background);
         this.selectDropDownListContainer.style.backgroundColor = listBackground;
         this.selectionDetailsPane.style.backgroundColor = listBackground;
-        const optionsBorder = (_b = this.styles.focusBorder) !== null && _b !== void 0 ? _b : '';
+        const optionsBorder = this.styles.focusBorder ?? '';
         this.selectDropDownContainer.style.outlineColor = optionsBorder;
         this.selectDropDownContainer.style.outlineOffset = '-1px';
         this.selectList.style(this.styles);
@@ -564,7 +565,7 @@
                     }
                     return label;
                 },
-                getWidgetAriaLabel: () => localize({ key: 'selectBox', comment: ['Behave like native select dropdown element.'] }, "Select Box"),
+                getWidgetAriaLabel: () => localizeWithPath('vs/base/browser/ui/selectBox/selectBoxCustom', { key: 'selectBox', comment: ['Behave like native select dropdown element.'] }, "Select Box"),
                 getRole: () => isMacintosh ? '' : 'option',
                 getWidgetRole: () => 'listbox'
             }
@@ -681,11 +682,10 @@
         this.updateDetail(e.indexes[0]);
     }
     updateDetail(selectedIndex) {
-        var _a, _b;
         this.selectionDetailsPane.innerText = '';
         const option = this.options[selectedIndex];
-        const description = (_a = option === null || option === void 0 ? void 0 : option.description) !== null && _a !== void 0 ? _a : '';
-        const descriptionIsMarkdown = (_b = option === null || option === void 0 ? void 0 : option.descriptionIsMarkdown) !== null && _b !== void 0 ? _b : false;
+        const description = option?.description ?? '';
+        const descriptionIsMarkdown = option?.descriptionIsMarkdown ?? false;
         if (description) {
             if (descriptionIsMarkdown) {
                 const actionHandler = option.descriptionMarkdownActionHandler;
diff -urN -x '*.map' a/vs/base/browser/ui/selectBox/selectBoxNative.js b/vs/base/browser/ui/selectBox/selectBoxNative.js
--- a/vs/base/browser/ui/selectBox/selectBoxNative.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/selectBox/selectBoxNative.js	2023-12-06 14:23:14.347854727 +0000
@@ -100,6 +100,10 @@
             this.selectElement.title = '';
         }
     }
+    setAriaLabel(label) {
+        this.selectBoxOptions.ariaLabel = label;
+        this.selectElement.setAttribute('aria-label', label);
+    }
     focus() {
         if (this.selectElement) {
             this.selectElement.tabIndex = 0;
@@ -121,13 +125,16 @@
         this.setOptions(this.options, this.selected);
         this.applyStyles();
     }
+    style(styles) {
+        this.styles = styles;
+        this.applyStyles();
+    }
     applyStyles() {
-        var _a, _b, _c;
         // Style native select
         if (this.selectElement) {
-            this.selectElement.style.backgroundColor = (_a = this.styles.selectBackground) !== null && _a !== void 0 ? _a : '';
-            this.selectElement.style.color = (_b = this.styles.selectForeground) !== null && _b !== void 0 ? _b : '';
-            this.selectElement.style.borderColor = (_c = this.styles.selectBorder) !== null && _c !== void 0 ? _c : '';
+            this.selectElement.style.backgroundColor = this.styles.selectBackground ?? '';
+            this.selectElement.style.color = this.styles.selectForeground ?? '';
+            this.selectElement.style.borderColor = this.styles.selectBorder ?? '';
         }
     }
     createOption(value, index, disabled) {
diff -urN -x '*.map' a/vs/base/browser/ui/splitview/splitview.js b/vs/base/browser/ui/splitview/splitview.js
--- a/vs/base/browser/ui/splitview/splitview.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/splitview/splitview.js	2023-12-06 14:23:14.347854727 +0000
@@ -24,11 +24,11 @@
     get size() {
         return this._size;
     }
+    get cachedVisibleSize() { return this._cachedVisibleSize; }
     get visible() {
         return typeof this._cachedVisibleSize === 'undefined';
     }
     setVisible(visible, size) {
-        var _a, _b;
         if (visible === this.visible) {
             return;
         }
@@ -41,14 +41,14 @@
             this.size = 0;
         }
         this.container.classList.toggle('visible', visible);
-        (_b = (_a = this.view).setVisible) === null || _b === void 0 ? void 0 : _b.call(_a, visible);
+        this.view.setVisible?.(visible);
     }
     get minimumSize() { return this.visible ? this.view.minimumSize : 0; }
     get viewMinimumSize() { return this.view.minimumSize; }
     get maximumSize() { return this.visible ? this.view.maximumSize : 0; }
     get viewMaximumSize() { return this.view.maximumSize; }
     get priority() { return this.view.priority; }
-    get proportionalLayout() { var _a; return (_a = this.view.proportionalLayout) !== null && _a !== void 0 ? _a : true; }
+    get proportionalLayout() { return this.view.proportionalLayout ?? true; }
     get snap() { return !!this.view.snap; }
     set enabled(enabled) {
         this.container.style.pointerEvents = enabled ? '' : 'none';
@@ -147,6 +147,24 @@
  * - Alt key modifier behavior, macOS style
  */
 export class SplitView extends Disposable {
+    /**
+     * The amount of views in this {@link SplitView}.
+     */
+    get length() {
+        return this.viewItems.length;
+    }
+    /**
+     * The minimum size of this {@link SplitView}.
+     */
+    get minimumSize() {
+        return this.viewItems.reduce((r, item) => r + item.minimumSize, 0);
+    }
+    /**
+     * The maximum size of this {@link SplitView}.
+     */
+    get maximumSize() {
+        return this.length === 0 ? Number.POSITIVE_INFINITY : this.viewItems.reduce((r, item) => r + item.maximumSize, 0);
+    }
     get orthogonalStartSash() { return this._orthogonalStartSash; }
     get orthogonalEndSash() { return this._orthogonalEndSash; }
     get startSnappingEnabled() { return this._startSnappingEnabled; }
@@ -174,6 +192,12 @@
         this._orthogonalEndSash = sash;
     }
     /**
+     * The internal sashes within this {@link SplitView}.
+     */
+    get sashes() {
+        return this.sashItems.map(s => s.sash);
+    }
+    /**
      * Enable/disable snapping at the beginning of this {@link SplitView}.
      */
     set startSnappingEnabled(startSnappingEnabled) {
@@ -197,7 +221,6 @@
      * Create a new {@link SplitView} instance.
      */
     constructor(container, options = {}) {
-        var _a, _b, _c, _d, _e;
         super();
         this.size = 0;
         this.contentSize = 0;
@@ -217,9 +240,9 @@
          * Fires whenever the user double clicks a {@link Sash sash}.
          */
         this.onDidSashReset = this._onDidSashReset.event;
-        this.orientation = (_a = options.orientation) !== null && _a !== void 0 ? _a : 0 /* Orientation.VERTICAL */;
-        this.inverseAltBehavior = (_b = options.inverseAltBehavior) !== null && _b !== void 0 ? _b : false;
-        this.proportionalLayout = (_c = options.proportionalLayout) !== null && _c !== void 0 ? _c : true;
+        this.orientation = options.orientation ?? 0 /* Orientation.VERTICAL */;
+        this.inverseAltBehavior = options.inverseAltBehavior ?? false;
+        this.proportionalLayout = options.proportionalLayout ?? true;
         this.getSashOrthogonalSize = options.getSashOrthogonalSize;
         this.el = document.createElement('div');
         this.el.classList.add('monaco-split-view2');
@@ -233,8 +256,8 @@
             scheduleAtNextAnimationFrame
         }));
         this.scrollableElement = this._register(new SmoothScrollableElement(this.viewContainer, {
-            vertical: this.orientation === 0 /* Orientation.VERTICAL */ ? ((_d = options.scrollbarVisibility) !== null && _d !== void 0 ? _d : 1 /* ScrollbarVisibility.Auto */) : 2 /* ScrollbarVisibility.Hidden */,
-            horizontal: this.orientation === 1 /* Orientation.HORIZONTAL */ ? ((_e = options.scrollbarVisibility) !== null && _e !== void 0 ? _e : 1 /* ScrollbarVisibility.Auto */) : 2 /* ScrollbarVisibility.Hidden */
+            vertical: this.orientation === 0 /* Orientation.VERTICAL */ ? (options.scrollbarVisibility ?? 1 /* ScrollbarVisibility.Auto */) : 2 /* ScrollbarVisibility.Hidden */,
+            horizontal: this.orientation === 1 /* Orientation.HORIZONTAL */ ? (options.scrollbarVisibility ?? 1 /* ScrollbarVisibility.Auto */) : 2 /* ScrollbarVisibility.Hidden */
         }, this.scrollable));
         // https://github.com/microsoft/vscode/issues/157737
         const onDidScrollViewContainer = this._register(new DomEmitter(this.viewContainer, 'scroll')).event;
@@ -292,6 +315,143 @@
         this.doAddView(view, size, index, skipLayout);
     }
     /**
+     * Remove a {@link IView view} from this {@link SplitView}.
+     *
+     * @param index The index where the {@link IView view} is located.
+     * @param sizing Whether to distribute other {@link IView view}'s sizes.
+     */
+    removeView(index, sizing) {
+        if (this.state !== State.Idle) {
+            throw new Error('Cant modify splitview');
+        }
+        this.state = State.Busy;
+        if (index < 0 || index >= this.viewItems.length) {
+            throw new Error('Index out of bounds');
+        }
+        if (sizing?.type === 'auto') {
+            if (this.areViewsDistributed()) {
+                sizing = { type: 'distribute' };
+            }
+            else {
+                sizing = { type: 'split', index: sizing.index };
+            }
+        }
+        // Save referene view, in case of `split` sizing
+        const referenceViewItem = sizing?.type === 'split' ? this.viewItems[sizing.index] : undefined;
+        // Remove view
+        const viewItemToRemove = this.viewItems.splice(index, 1)[0];
+        // Resize reference view, in case of `split` sizing
+        if (referenceViewItem) {
+            referenceViewItem.size += viewItemToRemove.size;
+        }
+        // Remove sash
+        if (this.viewItems.length >= 1) {
+            const sashIndex = Math.max(index - 1, 0);
+            const sashItem = this.sashItems.splice(sashIndex, 1)[0];
+            sashItem.disposable.dispose();
+        }
+        this.relayout();
+        this.state = State.Idle;
+        if (sizing?.type === 'distribute') {
+            this.distributeViewSizes();
+        }
+        const result = viewItemToRemove.view;
+        viewItemToRemove.dispose();
+        return result;
+    }
+    removeAllViews() {
+        if (this.state !== State.Idle) {
+            throw new Error('Cant modify splitview');
+        }
+        this.state = State.Busy;
+        const viewItems = this.viewItems.splice(0, this.viewItems.length);
+        for (const viewItem of viewItems) {
+            viewItem.dispose();
+        }
+        const sashItems = this.sashItems.splice(0, this.sashItems.length);
+        for (const sashItem of sashItems) {
+            sashItem.disposable.dispose();
+        }
+        this.relayout();
+        this.state = State.Idle;
+        return viewItems.map(i => i.view);
+    }
+    /**
+     * Move a {@link IView view} to a different index.
+     *
+     * @param from The source index.
+     * @param to The target index.
+     */
+    moveView(from, to) {
+        if (this.state !== State.Idle) {
+            throw new Error('Cant modify splitview');
+        }
+        const cachedVisibleSize = this.getViewCachedVisibleSize(from);
+        const sizing = typeof cachedVisibleSize === 'undefined' ? this.getViewSize(from) : Sizing.Invisible(cachedVisibleSize);
+        const view = this.removeView(from);
+        this.addView(view, sizing, to);
+    }
+    /**
+     * Swap two {@link IView views}.
+     *
+     * @param from The source index.
+     * @param to The target index.
+     */
+    swapViews(from, to) {
+        if (this.state !== State.Idle) {
+            throw new Error('Cant modify splitview');
+        }
+        if (from > to) {
+            return this.swapViews(to, from);
+        }
+        const fromSize = this.getViewSize(from);
+        const toSize = this.getViewSize(to);
+        const toView = this.removeView(to);
+        const fromView = this.removeView(from);
+        this.addView(toView, fromSize, from);
+        this.addView(fromView, toSize, to);
+    }
+    /**
+     * Returns whether the {@link IView view} is visible.
+     *
+     * @param index The {@link IView view} index.
+     */
+    isViewVisible(index) {
+        if (index < 0 || index >= this.viewItems.length) {
+            throw new Error('Index out of bounds');
+        }
+        const viewItem = this.viewItems[index];
+        return viewItem.visible;
+    }
+    /**
+     * Set a {@link IView view}'s visibility.
+     *
+     * @param index The {@link IView view} index.
+     * @param visible Whether the {@link IView view} should be visible.
+     */
+    setViewVisible(index, visible) {
+        if (index < 0 || index >= this.viewItems.length) {
+            throw new Error('Index out of bounds');
+        }
+        const viewItem = this.viewItems[index];
+        viewItem.setVisible(visible);
+        this.distributeEmptySpace(index);
+        this.layoutViews();
+        this.saveProportions();
+    }
+    /**
+     * Returns the {@link IView view}'s size previously to being hidden.
+     *
+     * @param index The {@link IView view} index.
+     */
+    getViewCachedVisibleSize(index) {
+        if (index < 0 || index >= this.viewItems.length) {
+            throw new Error('Index out of bounds');
+        }
+        const viewItem = this.viewItems[index];
+        return viewItem.cachedVisibleSize;
+    }
+    /**
      * Layout the {@link SplitView}.
      *
      * @param size The entire size of the {@link SplitView}.
@@ -471,6 +631,20 @@
         this.state = State.Idle;
     }
     /**
+     * Returns whether all other {@link IView views} are at their minimum size.
+     */
+    isViewSizeMaximized(index) {
+        if (index < 0 || index >= this.viewItems.length) {
+            return false;
+        }
+        for (const item of this.viewItems) {
+            if (item !== this.viewItems[index] && item.size > item.minimumSize) {
+                return false;
+            }
+        }
+        return true;
+    }
+    /**
      * Distribute the entire {@link SplitView} size among all {@link IView views}.
      */
     distributeViewSizes() {
@@ -547,8 +721,8 @@
         if (this.viewItems.length > 1) {
             const opts = { orthogonalStartSash: this.orthogonalStartSash, orthogonalEndSash: this.orthogonalEndSash };
             const sash = this.orientation === 0 /* Orientation.VERTICAL */
-                ? new Sash(this.sashContainer, { getHorizontalSashTop: s => this.getSashPosition(s), getHorizontalSashWidth: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, opts), { orientation: 1 /* Orientation.HORIZONTAL */ }))
-                : new Sash(this.sashContainer, { getVerticalSashLeft: s => this.getSashPosition(s), getVerticalSashHeight: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, opts), { orientation: 0 /* Orientation.VERTICAL */ }));
+                ? new Sash(this.sashContainer, { getHorizontalSashTop: s => this.getSashPosition(s), getHorizontalSashWidth: this.getSashOrthogonalSize }, { ...opts, orientation: 1 /* Orientation.HORIZONTAL */ })
+                : new Sash(this.sashContainer, { getVerticalSashLeft: s => this.getSashPosition(s), getVerticalSashHeight: this.getSashOrthogonalSize }, { ...opts, orientation: 0 /* Orientation.VERTICAL */ });
             const sashEventMapper = this.orientation === 0 /* Orientation.VERTICAL */
                 ? (e) => ({ sash, start: e.startY, current: e.currentY, alt: e.altKey })
                 : (e) => ({ sash, start: e.startX, current: e.currentX, alt: e.altKey });
@@ -798,8 +972,7 @@
         return true;
     }
     dispose() {
-        var _a;
-        (_a = this.sashDragState) === null || _a === void 0 ? void 0 : _a.disposable.dispose();
+        this.sashDragState?.disposable.dispose();
         dispose(this.viewItems);
         this.viewItems = [];
         this.sashItems.forEach(i => i.disposable.dispose());
diff -urN -x '*.map' a/vs/base/browser/ui/table/table.js b/vs/base/browser/ui/table/table.js
--- a/vs/base/browser/ui/table/table.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/table/table.js	2023-12-06 14:23:14.347854727 +0000
@@ -2,4 +2,8 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-export {};
+export class TableError extends Error {
+    constructor(user, message) {
+        super(`TableError [${user}] ${message}`);
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/ui/table/tableWidget.js b/vs/base/browser/ui/table/tableWidget.js
--- a/vs/base/browser/ui/table/tableWidget.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/table/tableWidget.js	2023-12-06 14:23:14.347854727 +0000
@@ -2,7 +2,7 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-import { $, append, clearNode, createStyleSheet } from '../../dom.js';
+import { $, append, clearNode, createStyleSheet, getContentHeight, getContentWidth } from '../../dom.js';
 import { List, unthemedListStyles } from '../list/listWidget.js';
 import { SplitView } from '../splitview/splitview.js';
 import { Emitter, Event } from '../../../common/event.js';
@@ -79,9 +79,9 @@
     };
 }
 class ColumnHeader {
-    get minimumSize() { var _a; return (_a = this.column.minimumWidth) !== null && _a !== void 0 ? _a : 120; }
-    get maximumSize() { var _a; return (_a = this.column.maximumWidth) !== null && _a !== void 0 ? _a : Number.POSITIVE_INFINITY; }
-    get onDidChange() { var _a; return (_a = this.column.onDidChangeWidthConstraints) !== null && _a !== void 0 ? _a : Event.None; }
+    get minimumSize() { return this.column.minimumWidth ?? 120; }
+    get maximumSize() { return this.column.maximumWidth ?? Number.POSITIVE_INFINITY; }
+    get onDidChange() { return this.column.onDidChangeWidthConstraints ?? Event.None; }
     constructor(column, index) {
         this.column = column;
         this.index = index;
@@ -97,11 +97,24 @@
     get onDidChangeFocus() { return this.list.onDidChangeFocus; }
     get onDidChangeSelection() { return this.list.onDidChangeSelection; }
     get onDidScroll() { return this.list.onDidScroll; }
+    get onMouseClick() { return this.list.onMouseClick; }
     get onMouseDblClick() { return this.list.onMouseDblClick; }
+    get onMouseMiddleClick() { return this.list.onMouseMiddleClick; }
     get onPointer() { return this.list.onPointer; }
+    get onMouseUp() { return this.list.onMouseUp; }
+    get onMouseDown() { return this.list.onMouseDown; }
+    get onMouseOver() { return this.list.onMouseOver; }
+    get onMouseMove() { return this.list.onMouseMove; }
+    get onMouseOut() { return this.list.onMouseOut; }
+    get onTouchStart() { return this.list.onTouchStart; }
+    get onTap() { return this.list.onTap; }
+    get onContextMenu() { return this.list.onContextMenu; }
     get onDidFocus() { return this.list.onDidFocus; }
+    get onDidBlur() { return this.list.onDidBlur; }
     get scrollTop() { return this.list.scrollTop; }
     set scrollTop(scrollTop) { this.list.scrollTop = scrollTop; }
+    get scrollLeft() { return this.list.scrollLeft; }
+    set scrollLeft(scrollLeft) { this.list.scrollLeft = scrollLeft; }
     get scrollHeight() { return this.list.scrollHeight; }
     get renderHeight() { return this.list.renderHeight; }
     get onDidDispose() { return this.list.onDidDispose; }
@@ -142,9 +155,34 @@
     splice(start, deleteCount, elements = []) {
         this.list.splice(start, deleteCount, elements);
     }
+    rerender() {
+        this.list.rerender();
+    }
+    row(index) {
+        return this.list.element(index);
+    }
+    indexOf(element) {
+        return this.list.indexOf(element);
+    }
+    get length() {
+        return this.list.length;
+    }
     getHTMLElement() {
         return this.domNode;
     }
+    layout(height, width) {
+        height = height ?? getContentHeight(this.domNode);
+        width = width ?? getContentWidth(this.domNode);
+        this.cachedWidth = width;
+        this.cachedHeight = height;
+        this.splitview.layout(width);
+        const listHeight = height - this.virtualDelegate.headerRowHeight;
+        this.list.getHTMLElement().style.height = `${listHeight}px`;
+        this.list.layout(listHeight, width);
+    }
+    triggerTypeNavigation() {
+        this.list.triggerTypeNavigation();
+    }
     style(styles) {
         const content = [];
         content.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
@@ -154,15 +192,57 @@
         this.styleElement.textContent = content.join('\n');
         this.list.style(styles);
     }
+    domFocus() {
+        this.list.domFocus();
+    }
+    setAnchor(index) {
+        this.list.setAnchor(index);
+    }
+    getAnchor() {
+        return this.list.getAnchor();
+    }
     getSelectedElements() {
         return this.list.getSelectedElements();
     }
+    setSelection(indexes, browserEvent) {
+        this.list.setSelection(indexes, browserEvent);
+    }
     getSelection() {
         return this.list.getSelection();
     }
+    setFocus(indexes, browserEvent) {
+        this.list.setFocus(indexes, browserEvent);
+    }
+    focusNext(n = 1, loop = false, browserEvent) {
+        this.list.focusNext(n, loop, browserEvent);
+    }
+    focusPrevious(n = 1, loop = false, browserEvent) {
+        this.list.focusPrevious(n, loop, browserEvent);
+    }
+    focusNextPage(browserEvent) {
+        return this.list.focusNextPage(browserEvent);
+    }
+    focusPreviousPage(browserEvent) {
+        return this.list.focusPreviousPage(browserEvent);
+    }
+    focusFirst(browserEvent) {
+        this.list.focusFirst(browserEvent);
+    }
+    focusLast(browserEvent) {
+        this.list.focusLast(browserEvent);
+    }
     getFocus() {
         return this.list.getFocus();
     }
+    getFocusedElements() {
+        return this.list.getFocusedElements();
+    }
+    getRelativeTop(index) {
+        return this.list.getRelativeTop(index);
+    }
+    reveal(index, relativeTop) {
+        this.list.reveal(index, relativeTop);
+    }
     dispose() {
         this.disposables.dispose();
     }
diff -urN -x '*.map' a/vs/base/browser/ui/toggle/toggle.js b/vs/base/browser/ui/toggle/toggle.js
--- a/vs/base/browser/ui/toggle/toggle.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/ui/toggle/toggle.js	2023-12-06 14:23:14.347854727 +0000
@@ -2,7 +2,9 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+import { BaseActionViewItem } from '../actionbar/actionViewItems.js';
 import { Widget } from '../widget.js';
+import { Codicon } from '../../../common/codicons.js';
 import { ThemeIcon } from '../../../common/themables.js';
 import { Emitter } from '../../../common/event.js';
 import './toggle.css';
@@ -11,6 +13,49 @@
     inputActiveOptionForeground: '#FFFFFF',
     inputActiveOptionBackground: '#0E639C50'
 };
+export class ToggleActionViewItem extends BaseActionViewItem {
+    constructor(context, action, options) {
+        super(context, action, options);
+        this.toggle = this._register(new Toggle({
+            actionClassName: this._action.class,
+            isChecked: !!this._action.checked,
+            title: this.options.keybinding ? `${this._action.label} (${this.options.keybinding})` : this._action.label,
+            notFocusable: true,
+            inputActiveOptionBackground: options.toggleStyles?.inputActiveOptionBackground,
+            inputActiveOptionBorder: options.toggleStyles?.inputActiveOptionBorder,
+            inputActiveOptionForeground: options.toggleStyles?.inputActiveOptionForeground,
+        }));
+        this._register(this.toggle.onChange(() => this._action.checked = !!this.toggle && this.toggle.checked));
+    }
+    render(container) {
+        this.element = container;
+        this.element.appendChild(this.toggle.domNode);
+    }
+    updateEnabled() {
+        if (this.toggle) {
+            if (this.isEnabled()) {
+                this.toggle.enable();
+            }
+            else {
+                this.toggle.disable();
+            }
+        }
+    }
+    updateChecked() {
+        this.toggle.checked = !!this._action.checked;
+    }
+    focus() {
+        this.toggle.domNode.tabIndex = 0;
+        this.toggle.focus();
+    }
+    blur() {
+        this.toggle.domNode.tabIndex = -1;
+        this.toggle.domNode.blur();
+    }
+    setFocusable(focusable) {
+        this.toggle.domNode.tabIndex = focusable ? 0 : -1;
+    }
+}
 export class Toggle extends Widget {
     constructor(opts) {
         super();
@@ -75,6 +120,15 @@
         this.domNode.classList.toggle('checked', this._checked);
         this.applyStyles();
     }
+    setIcon(icon) {
+        if (this._icon) {
+            this.domNode.classList.remove(...ThemeIcon.asClassNameArray(this._icon));
+        }
+        this._icon = icon;
+        if (this._icon) {
+            this.domNode.classList.add(...ThemeIcon.asClassNameArray(this._icon));
+        }
+    }
     width() {
         return 2 /*margin left*/ + 2 /*border*/ + 2 /*padding*/ + 16 /* icon width */;
     }
@@ -91,4 +145,38 @@
     disable() {
         this.domNode.setAttribute('aria-disabled', String(true));
     }
+    setTitle(newTitle) {
+        this.domNode.title = newTitle;
+        this.domNode.setAttribute('aria-label', newTitle);
+    }
+}
+export class Checkbox extends Widget {
+    constructor(title, isChecked, styles) {
+        super();
+        this.title = title;
+        this.isChecked = isChecked;
+        this.checkbox = new Toggle({ title: this.title, isChecked: this.isChecked, icon: Codicon.check, actionClassName: 'monaco-checkbox', ...unthemedToggleStyles });
+        this.domNode = this.checkbox.domNode;
+        this.styles = styles;
+        this.applyStyles();
+        this._register(this.checkbox.onChange(() => this.applyStyles()));
+    }
+    get checked() {
+        return this.checkbox.checked;
+    }
+    set checked(newIsChecked) {
+        this.checkbox.checked = newIsChecked;
+        this.applyStyles();
+    }
+    focus() {
+        this.domNode.focus();
+    }
+    hasFocus() {
+        return this.domNode === document.activeElement;
+    }
+    applyStyles() {
+        this.domNode.style.color = this.styles.checkboxForeground || '';
+        this.domNode.style.backgroundColor = this.styles.checkboxBackground || '';
+        this.domNode.style.borderColor = this.styles.checkboxBorder || '';
+    }
 }
diff -urN -x '*.map' a/vs/base/browser/ui/toolbar/toolbar.js b/vs/base/browser/ui/toolbar/toolbar.js
--- a/vs/base/browser/ui/toolbar/toolbar.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/ui/toolbar/toolbar.js	2023-12-06 14:23:14.347854727 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { ActionBar } from '../actionbar/actionbar.js';
 import { DropdownMenuActionViewItem } from '../dropdown/dropdownActionViewItem.js';
 import { Action, SubmenuAction } from '../../../common/actions.js';
@@ -33,7 +24,7 @@
         this.disposables = this._register(new DisposableStore());
         this.options = options;
         this.lookupKeybindings = typeof this.options.getKeyBinding === 'function';
-        this.toggleMenuAction = this._register(new ToggleMenuAction(() => { var _a; return (_a = this.toggleMenuActionViewItem) === null || _a === void 0 ? void 0 : _a.show(); }, options.toggleMenuTitle));
+        this.toggleMenuAction = this._register(new ToggleMenuAction(() => this.toggleMenuActionViewItem?.show(), options.toggleMenuTitle));
         this.element = document.createElement('div');
         this.element.className = 'monaco-toolbar';
         container.appendChild(this.element);
@@ -44,13 +35,12 @@
             allowContextMenu: options.allowContextMenu,
             highlightToggledItems: options.highlightToggledItems,
             actionViewItemProvider: (action, viewItemOptions) => {
-                var _a;
                 if (action.id === ToggleMenuAction.ID) {
                     this.toggleMenuActionViewItem = new DropdownMenuActionViewItem(action, action.menuActions, contextMenuProvider, {
                         actionViewItemProvider: this.options.actionViewItemProvider,
                         actionRunner: this.actionRunner,
                         keybindingProvider: this.options.getKeyBinding,
-                        classNames: ThemeIcon.asClassNameArray((_a = options.moreIcon) !== null && _a !== void 0 ? _a : Codicon.toolBarMore),
+                        classNames: ThemeIcon.asClassNameArray(options.moreIcon ?? Codicon.toolBarMore),
                         anchorAlignmentProvider: this.options.anchorAlignmentProvider,
                         menuAsChild: !!this.options.renderDropdownAsChildElement,
                         skipTelemetry: this.options.skipTelemetry
@@ -90,12 +80,38 @@
     get actionRunner() {
         return this.actionBar.actionRunner;
     }
+    set context(context) {
+        this.actionBar.context = context;
+        this.toggleMenuActionViewItem?.setActionContext(context);
+        for (const actionViewItem of this.submenuActionViewItems) {
+            actionViewItem.setActionContext(context);
+        }
+    }
     getElement() {
         return this.element;
     }
+    focus() {
+        this.actionBar.focus();
+    }
+    getItemsWidth() {
+        let itemsWidth = 0;
+        for (let i = 0; i < this.actionBar.length(); i++) {
+            itemsWidth += this.actionBar.getWidth(i);
+        }
+        return itemsWidth;
+    }
     getItemAction(indexOrElement) {
         return this.actionBar.getAction(indexOrElement);
     }
+    getItemWidth(index) {
+        return this.actionBar.getWidth(index);
+    }
+    getItemsLength() {
+        return this.actionBar.length();
+    }
+    setAriaLabel(label) {
+        this.actionBar.setAriaLabel(label);
+    }
     setActions(primaryActions, secondaryActions) {
         this.clear();
         const primaryActionsToSet = primaryActions ? primaryActions.slice(0) : [];
@@ -109,10 +125,12 @@
             this.actionBar.push(action, { icon: true, label: false, keybinding: this.getKeybindingLabel(action) });
         });
     }
+    isEmpty() {
+        return this.actionBar.isEmpty();
+    }
     getKeybindingLabel(action) {
-        var _a, _b, _c;
-        const key = this.lookupKeybindings ? (_b = (_a = this.options).getKeyBinding) === null || _b === void 0 ? void 0 : _b.call(_a, action) : undefined;
-        return (_c = key === null || key === void 0 ? void 0 : key.getLabel()) !== null && _c !== void 0 ? _c : undefined;
+        const key = this.lookupKeybindings ? this.options.getKeyBinding?.(action) : undefined;
+        return key?.getLabel() ?? undefined;
     }
     clear() {
         this.submenuActionViewItems = [];
@@ -127,15 +145,13 @@
 }
 export class ToggleMenuAction extends Action {
     constructor(toggleDropdownMenu, title) {
-        title = title || nls.localize('moreActions', "More Actions...");
+        title = title || nls.localizeWithPath('vs/base/browser/ui/toolbar/toolbar', 'moreActions', "More Actions...");
         super(ToggleMenuAction.ID, title, undefined, true);
         this._menuActions = [];
         this.toggleDropdownMenu = toggleDropdownMenu;
     }
-    run() {
-        return __awaiter(this, void 0, void 0, function* () {
-            this.toggleDropdownMenu();
-        });
+    async run() {
+        this.toggleDropdownMenu();
     }
     get menuActions() {
         return this._menuActions;
diff -urN -x '*.map' a/vs/base/browser/ui/tree/abstractTree.js b/vs/base/browser/ui/tree/abstractTree.js
--- a/vs/base/browser/ui/tree/abstractTree.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/ui/tree/abstractTree.js	2023-12-06 14:23:14.347854727 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { $, append, clearNode, createStyleSheet, h, hasParentWithClass } from '../../dom.js';
 import { DomEmitter } from '../../event.js';
 import { StandardKeyboardEvent } from '../../keyboardEvent.js';
@@ -21,9 +12,9 @@
 import { isButton, isInputElement, isMonacoEditor, List, MouseController } from '../list/listWidget.js';
 import { Toggle, unthemedToggleStyles } from '../toggle/toggle.js';
 import { getVisibleState, isFilterResult } from './indexTreeModel.js';
-import { TreeMouseEventTarget } from './tree.js';
+import { TreeError, TreeMouseEventTarget } from './tree.js';
 import { Action } from '../../../common/actions.js';
-import { distinct, equals, range } from '../../../common/arrays.js';
+import { distinct, equals, firstOrDefault, range } from '../../../common/arrays.js';
 import { Delayer, disposableTimeout, timeout } from '../../../common/async.js';
 import { Codicon } from '../../../common/codicons.js';
 import { ThemeIcon } from '../../../common/themables.js';
@@ -34,8 +25,14 @@
 import { clamp } from '../../../common/numbers.js';
 import { isNumber } from '../../../common/types.js';
 import './media/tree.css';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 class TreeElementsDragAndDropData extends ElementsDragAndDropData {
+    set context(context) {
+        this.data.context = context;
+    }
+    get context() {
+        return this.data.context;
+    }
     constructor(data) {
         super(data.elements.map(node => node.element));
         this.data = data;
@@ -64,8 +61,7 @@
         return undefined;
     }
     onDragStart(data, originalEvent) {
-        var _a, _b;
-        (_b = (_a = this.dnd).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, asTreeDragAndDropData(data), originalEvent);
+        this.dnd.onDragStart?.(asTreeDragAndDropData(data), originalEvent);
     }
     onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {
         const result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
@@ -107,7 +103,7 @@
         const ref = model.getNodeLocation(targetNode);
         const start = model.getListIndex(ref);
         const length = model.getListRenderCount(ref);
-        return Object.assign(Object.assign({}, result), { feedback: range(start, start + length) });
+        return { ...result, feedback: range(start, start + length) };
     }
     drop(data, targetNode, targetIndex, originalEvent) {
         this.autoExpandDisposable.dispose();
@@ -115,8 +111,7 @@
         this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
     }
     onDragEnd(originalEvent) {
-        var _a, _b;
-        (_b = (_a = this.dnd).onDragEnd) === null || _b === void 0 ? void 0 : _b.call(_a, originalEvent);
+        this.dnd.onDragEnd?.(originalEvent);
     }
     dispose() {
         this.disposables.dispose();
@@ -124,18 +119,25 @@
     }
 }
 function asListOptions(modelProvider, options) {
-    return options && Object.assign(Object.assign({}, options), { identityProvider: options.identityProvider && {
+    return options && {
+        ...options,
+        identityProvider: options.identityProvider && {
             getId(el) {
                 return options.identityProvider.getId(el.element);
             }
-        }, dnd: options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd), multipleSelectionController: options.multipleSelectionController && {
+        },
+        dnd: options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd),
+        multipleSelectionController: options.multipleSelectionController && {
             isSelectionSingleChangeEvent(e) {
-                return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
+                return options.multipleSelectionController.isSelectionSingleChangeEvent({ ...e, element: e.element });
             },
             isSelectionRangeChangeEvent(e) {
-                return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
+                return options.multipleSelectionController.isSelectionRangeChangeEvent({ ...e, element: e.element });
             }
-        }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), { getSetSize(node) {
+        },
+        accessibilityProvider: options.accessibilityProvider && {
+            ...options.accessibilityProvider,
+            getSetSize(node) {
                 const model = modelProvider();
                 const ref = model.getNodeLocation(node);
                 const parentRef = model.getParentNodeLocation(ref);
@@ -144,22 +146,34 @@
             },
             getPosInSet(node) {
                 return node.visibleChildIndex + 1;
-            }, isChecked: options.accessibilityProvider && options.accessibilityProvider.isChecked ? (node) => {
+            },
+            isChecked: options.accessibilityProvider && options.accessibilityProvider.isChecked ? (node) => {
                 return options.accessibilityProvider.isChecked(node.element);
-            } : undefined, getRole: options.accessibilityProvider && options.accessibilityProvider.getRole ? (node) => {
+            } : undefined,
+            getRole: options.accessibilityProvider && options.accessibilityProvider.getRole ? (node) => {
                 return options.accessibilityProvider.getRole(node.element);
-            } : () => 'treeitem', getAriaLabel(e) {
+            } : () => 'treeitem',
+            getAriaLabel(e) {
                 return options.accessibilityProvider.getAriaLabel(e.element);
             },
             getWidgetAriaLabel() {
                 return options.accessibilityProvider.getWidgetAriaLabel();
-            }, getWidgetRole: options.accessibilityProvider && options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree', getAriaLevel: options.accessibilityProvider && options.accessibilityProvider.getAriaLevel ? (node) => options.accessibilityProvider.getAriaLevel(node.element) : (node) => {
+            },
+            getWidgetRole: options.accessibilityProvider && options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree',
+            getAriaLevel: options.accessibilityProvider && options.accessibilityProvider.getAriaLevel ? (node) => options.accessibilityProvider.getAriaLevel(node.element) : (node) => {
                 return node.depth;
-            }, getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {
+            },
+            getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {
                 return options.accessibilityProvider.getActiveDescendantId(node.element);
-            }) }), keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(node) {
+            })
+        },
+        keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {
+            ...options.keyboardNavigationLabelProvider,
+            getKeyboardNavigationLabel(node) {
                 return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);
-            } }) });
+            }
+        }
+    };
 }
 export class ComposedTreeDelegate {
     constructor(delegate) {
@@ -175,8 +189,43 @@
         return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);
     }
     setDynamicHeight(element, height) {
-        var _a, _b;
-        (_b = (_a = this.delegate).setDynamicHeight) === null || _b === void 0 ? void 0 : _b.call(_a, element.element, height);
+        this.delegate.setDynamicHeight?.(element.element, height);
+    }
+}
+export class AbstractTreeViewState {
+    static lift(state) {
+        return state instanceof AbstractTreeViewState ? state : new AbstractTreeViewState(state);
+    }
+    static empty(scrollTop = 0) {
+        return new AbstractTreeViewState({
+            focus: [],
+            selection: [],
+            expanded: Object.create(null),
+            scrollTop,
+        });
+    }
+    constructor(state) {
+        this.focus = new Set(state.focus);
+        this.selection = new Set(state.selection);
+        if (state.expanded instanceof Array) { // old format
+            this.expanded = Object.create(null);
+            for (const id of state.expanded) {
+                this.expanded[id] = 1;
+            }
+        }
+        else {
+            this.expanded = state.expanded;
+        }
+        this.expanded = state.expanded;
+        this.scrollTop = state.scrollTop;
+    }
+    toJSON() {
+        return {
+            focus: Array.from(this.focus),
+            selection: Array.from(this.selection),
+            expanded: this.expanded,
+            scrollTop: this.scrollTop,
+        };
     }
 }
 export var RenderIndentGuides;
@@ -200,7 +249,6 @@
 }
 class TreeRenderer {
     constructor(renderer, modelProvider, onDidChangeCollapseState, activeNodes, renderedIndentGuides, options = {}) {
-        var _a;
         this.renderer = renderer;
         this.modelProvider = modelProvider;
         this.activeNodes = activeNodes;
@@ -216,7 +264,7 @@
         this.templateId = renderer.templateId;
         this.updateOptions(options);
         Event.map(onDidChangeCollapseState, e => e.node)(this.onDidChangeNodeTwistieState, this, this.disposables);
-        (_a = renderer.onDidChangeTwistieState) === null || _a === void 0 ? void 0 : _a.call(renderer, this.onDidChangeTwistieState, this, this.disposables);
+        renderer.onDidChangeTwistieState?.(this.onDidChangeTwistieState, this, this.disposables);
     }
     updateOptions(options = {}) {
         if (typeof options.indent !== 'undefined') {
@@ -263,9 +311,8 @@
         this.renderer.renderElement(node, index, templateData.templateData, height);
     }
     disposeElement(node, index, templateData, height) {
-        var _a, _b;
         templateData.indentGuidesDisposable.dispose();
-        (_b = (_a = this.renderer).disposeElement) === null || _b === void 0 ? void 0 : _b.call(_a, node, index, templateData.templateData, height);
+        this.renderer.disposeElement?.(node, index, templateData.templateData, height);
         if (typeof height === 'number') {
             this.renderedNodes.delete(node);
             this.renderedElements.delete(node.element);
@@ -364,7 +411,7 @@
                     set.add(model.getNode(parentRef));
                 }
             }
-            catch (_a) {
+            catch {
                 // noop
             }
         });
@@ -391,6 +438,10 @@
 class FindFilter {
     get totalCount() { return this._totalCount; }
     get matchCount() { return this._matchCount; }
+    set pattern(pattern) {
+        this._pattern = pattern;
+        this._lowercasePattern = pattern.toLowerCase();
+    }
     constructor(tree, keyboardNavigationLabelProvider, _filter) {
         this.tree = tree;
         this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;
@@ -476,11 +527,10 @@
 }
 export class ModeToggle extends Toggle {
     constructor(opts) {
-        var _a;
         super({
             icon: Codicon.listFilter,
-            title: localize('filter', "Filter"),
-            isChecked: (_a = opts.isChecked) !== null && _a !== void 0 ? _a : false,
+            title: localizeWithPath('vs/base/browser/ui/tree/abstractTree', 'filter', "Filter"),
+            isChecked: opts.isChecked ?? false,
             inputActiveOptionBorder: opts.inputActiveOptionBorder,
             inputActiveOptionForeground: opts.inputActiveOptionForeground,
             inputActiveOptionBackground: opts.inputActiveOptionBackground
@@ -489,11 +539,10 @@
 }
 export class FuzzyToggle extends Toggle {
     constructor(opts) {
-        var _a;
         super({
             icon: Codicon.searchFuzzy,
-            title: localize('fuzzySearch', "Fuzzy Match"),
-            isChecked: (_a = opts.isChecked) !== null && _a !== void 0 ? _a : false,
+            title: localizeWithPath('vs/base/browser/ui/tree/abstractTree', 'fuzzySearch', "Fuzzy Match"),
+            isChecked: opts.isChecked ?? false,
             inputActiveOptionBorder: opts.inputActiveOptionBorder,
             inputActiveOptionForeground: opts.inputActiveOptionForeground,
             inputActiveOptionBackground: opts.inputActiveOptionBackground
@@ -521,13 +570,18 @@
 class FindWidget extends Disposable {
     set mode(mode) {
         this.modeToggle.checked = mode === TreeFindMode.Filter;
-        this.findInput.inputBox.setPlaceHolder(mode === TreeFindMode.Filter ? localize('type to filter', "Type to filter") : localize('type to search', "Type to search"));
+        this.findInput.inputBox.setPlaceHolder(mode === TreeFindMode.Filter ? localizeWithPath('vs/base/browser/ui/tree/abstractTree', 'type to filter', "Type to filter") : localizeWithPath('vs/base/browser/ui/tree/abstractTree', 'type to search', "Type to search"));
     }
     set matchType(matchType) {
         this.matchTypeToggle.checked = matchType === TreeFindMatchType.Fuzzy;
     }
+    get value() {
+        return this.findInput.inputBox.value;
+    }
+    set value(value) {
+        this.findInput.inputBox.value = value;
+    }
     constructor(container, tree, contextViewProvider, mode, matchType, options) {
-        var _a;
         super();
         this.tree = tree;
         this.elements = h('.monaco-tree-type-filter', [
@@ -539,26 +593,27 @@
         this.right = 0;
         this.top = 0;
         this._onDidDisable = new Emitter();
+        this.onDidDisable = this._onDidDisable.event;
         container.appendChild(this.elements.root);
         this._register(toDisposable(() => container.removeChild(this.elements.root)));
-        const styles = (_a = options === null || options === void 0 ? void 0 : options.styles) !== null && _a !== void 0 ? _a : unthemedFindWidgetStyles;
+        const styles = options?.styles ?? unthemedFindWidgetStyles;
         if (styles.listFilterWidgetBackground) {
             this.elements.root.style.backgroundColor = styles.listFilterWidgetBackground;
         }
         if (styles.listFilterWidgetShadow) {
             this.elements.root.style.boxShadow = `0 0 8px 2px ${styles.listFilterWidgetShadow}`;
         }
-        this.modeToggle = this._register(new ModeToggle(Object.assign(Object.assign({}, styles.toggleStyles), { isChecked: mode === TreeFindMode.Filter })));
-        this.matchTypeToggle = this._register(new FuzzyToggle(Object.assign(Object.assign({}, styles.toggleStyles), { isChecked: matchType === TreeFindMatchType.Fuzzy })));
+        this.modeToggle = this._register(new ModeToggle({ ...styles.toggleStyles, isChecked: mode === TreeFindMode.Filter }));
+        this.matchTypeToggle = this._register(new FuzzyToggle({ ...styles.toggleStyles, isChecked: matchType === TreeFindMatchType.Fuzzy }));
         this.onDidChangeMode = Event.map(this.modeToggle.onChange, () => this.modeToggle.checked ? TreeFindMode.Filter : TreeFindMode.Highlight, this._store);
         this.onDidChangeMatchType = Event.map(this.matchTypeToggle.onChange, () => this.matchTypeToggle.checked ? TreeFindMatchType.Fuzzy : TreeFindMatchType.Contiguous, this._store);
         this.findInput = this._register(new FindInput(this.elements.findInput, contextViewProvider, {
-            label: localize('type to search', "Type to search"),
+            label: localizeWithPath('vs/base/browser/ui/tree/abstractTree', 'type to search', "Type to search"),
             additionalToggles: [this.modeToggle, this.matchTypeToggle],
             showCommonFindToggles: false,
             inputBoxStyles: styles.inputBoxStyles,
             toggleStyles: styles.toggleStyles,
-            history: options === null || options === void 0 ? void 0 : options.history
+            history: options?.history
         }));
         this.actionbar = this._register(new ActionBar(this.elements.actionbar));
         this.mode = mode;
@@ -596,7 +651,7 @@
                 return;
             }
         }));
-        const closeAction = this._register(new Action('close', localize('close', "Close"), 'codicon codicon-close', true, () => this.dispose()));
+        const closeAction = this._register(new Action('close', localizeWithPath('vs/base/browser/ui/tree/abstractTree', 'close', "Close"), 'codicon codicon-close', true, () => this.dispose()));
         this.actionbar.push(closeAction, { icon: true, label: false });
         const onGrabMouseDown = this._register(new DomEmitter(this.elements.grab, 'mousedown'));
         this._register(onGrabMouseDown.event(e => {
@@ -664,6 +719,17 @@
         }));
         this.onDidChangeValue = this.findInput.onDidChange;
     }
+    getHistory() {
+        return this.findInput.inputBox.getHistory();
+    }
+    focus() {
+        this.findInput.focus();
+    }
+    select() {
+        this.findInput.select();
+        // Reposition to last in history
+        this.findInput.inputBox.addToHistory(true);
+    }
     layout(width = this.width) {
         this.width = width;
         this.right = clamp(this.right, 0, Math.max(0, width - 212));
@@ -677,16 +743,11 @@
     clearMessage() {
         this.findInput.clearMessage();
     }
-    dispose() {
-        const _super = Object.create(null, {
-            dispose: { get: () => super.dispose }
-        });
-        return __awaiter(this, void 0, void 0, function* () {
-            this._onDidDisable.fire();
-            this.elements.root.classList.add('disabled');
-            yield timeout(300);
-            _super.dispose.call(this);
-        });
+    async dispose() {
+        this._onDidDisable.fire();
+        this.elements.root.classList.add('disabled');
+        await timeout(300);
+        super.dispose();
     }
 }
 class FindController {
@@ -718,25 +779,26 @@
         this._onDidChangeMatchType.fire(matchType);
     }
     constructor(tree, model, view, filter, contextViewProvider, options = {}) {
-        var _a, _b;
         this.tree = tree;
         this.view = view;
         this.filter = filter;
         this.contextViewProvider = contextViewProvider;
         this.options = options;
         this._pattern = '';
+        this.previousPattern = '';
         this.width = 0;
         this._onDidChangeMode = new Emitter();
         this.onDidChangeMode = this._onDidChangeMode.event;
         this._onDidChangeMatchType = new Emitter();
         this.onDidChangeMatchType = this._onDidChangeMatchType.event;
         this._onDidChangePattern = new Emitter();
+        this.onDidChangePattern = this._onDidChangePattern.event;
         this._onDidChangeOpenState = new Emitter();
         this.onDidChangeOpenState = this._onDidChangeOpenState.event;
         this.enabledDisposables = new DisposableStore();
         this.disposables = new DisposableStore();
-        this._mode = (_a = tree.options.defaultFindMode) !== null && _a !== void 0 ? _a : TreeFindMode.Highlight;
-        this._matchType = (_b = tree.options.defaultFindMatchType) !== null && _b !== void 0 ? _b : TreeFindMatchType.Fuzzy;
+        this._mode = tree.options.defaultFindMode ?? TreeFindMode.Highlight;
+        this._matchType = tree.options.defaultFindMatchType ?? TreeFindMatchType.Fuzzy;
         model.onDidSplice(this.onDidSpliceModel, this, this.disposables);
     }
     updateOptions(optionsUpdate = {}) {
@@ -747,6 +809,53 @@
             this.matchType = optionsUpdate.defaultFindMatchType;
         }
     }
+    open() {
+        if (this.widget) {
+            this.widget.focus();
+            this.widget.select();
+            return;
+        }
+        this.widget = new FindWidget(this.view.getHTMLElement(), this.tree, this.contextViewProvider, this.mode, this.matchType, { ...this.options, history: this._history });
+        this.enabledDisposables.add(this.widget);
+        this.widget.onDidChangeValue(this.onDidChangeValue, this, this.enabledDisposables);
+        this.widget.onDidChangeMode(mode => this.mode = mode, undefined, this.enabledDisposables);
+        this.widget.onDidChangeMatchType(matchType => this.matchType = matchType, undefined, this.enabledDisposables);
+        this.widget.onDidDisable(this.close, this, this.enabledDisposables);
+        this.widget.layout(this.width);
+        this.widget.focus();
+        this.widget.value = this.previousPattern;
+        this.widget.select();
+        this._onDidChangeOpenState.fire(true);
+    }
+    close() {
+        if (!this.widget) {
+            return;
+        }
+        this._history = this.widget.getHistory();
+        this.widget = undefined;
+        this.enabledDisposables.clear();
+        this.previousPattern = this.pattern;
+        this.onDidChangeValue('');
+        this.tree.domFocus();
+        this._onDidChangeOpenState.fire(false);
+    }
+    onDidChangeValue(pattern) {
+        this._pattern = pattern;
+        this._onDidChangePattern.fire(pattern);
+        this.filter.pattern = pattern;
+        this.tree.refilter();
+        if (pattern) {
+            this.tree.focusNext(0, true, undefined, node => !FuzzyScore.isDefault(node.filterData));
+        }
+        const focus = this.tree.getFocus();
+        if (focus.length > 0) {
+            const element = focus[0];
+            if (this.tree.getRelativeTop(element) === null) {
+                this.tree.reveal(element, 0.5);
+            }
+        }
+        this.render();
+    }
     onDidSpliceModel() {
         if (!this.widget || this.pattern.length === 0) {
             return;
@@ -755,18 +864,17 @@
         this.render();
     }
     render() {
-        var _a, _b, _c, _d;
         const noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;
         if (this.pattern && noMatches) {
-            if ((_a = this.tree.options.showNotFoundMessage) !== null && _a !== void 0 ? _a : true) {
-                (_b = this.widget) === null || _b === void 0 ? void 0 : _b.showMessage({ type: 2 /* MessageType.WARNING */, content: localize('not found', "No elements found.") });
+            if (this.tree.options.showNotFoundMessage ?? true) {
+                this.widget?.showMessage({ type: 2 /* MessageType.WARNING */, content: localizeWithPath('vs/base/browser/ui/tree/abstractTree', 'not found', "No elements found.") });
             }
             else {
-                (_c = this.widget) === null || _c === void 0 ? void 0 : _c.showMessage({ type: 2 /* MessageType.WARNING */ });
+                this.widget?.showMessage({ type: 2 /* MessageType.WARNING */ });
             }
         }
         else {
-            (_d = this.widget) === null || _d === void 0 ? void 0 : _d.clearMessage();
+            this.widget?.clearMessage();
         }
     }
     shouldAllowFocus(node) {
@@ -779,9 +887,8 @@
         return !FuzzyScore.isDefault(node.filterData);
     }
     layout(width) {
-        var _a;
         this.width = width;
-        (_a = this.widget) === null || _a === void 0 ? void 0 : _a.layout(width);
+        this.widget?.layout(width);
     }
     dispose() {
         this._history = undefined;
@@ -807,6 +914,13 @@
         target
     };
 }
+function asTreeContextMenuEvent(event) {
+    return {
+        element: event.element ? event.element.element : null,
+        browserEvent: event.browserEvent,
+        anchor: event.anchor
+    };
+}
 function dfs(node, fn) {
     fn(node);
     node.children.forEach(child => dfs(child, fn));
@@ -830,7 +944,7 @@
         this.onDidChange = this._onDidChange.event;
     }
     set(nodes, browserEvent) {
-        if (!(browserEvent === null || browserEvent === void 0 ? void 0 : browserEvent.__forceEvent) && equals(this.nodes, nodes)) {
+        if (!browserEvent?.__forceEvent && equals(this.nodes, nodes)) {
             return;
         }
         this._set(nodes, false, browserEvent);
@@ -1032,24 +1146,32 @@
     get onDidScroll() { return this.view.onDidScroll; }
     get onDidChangeFocus() { return this.eventBufferer.wrapEvent(this.focus.onDidChange); }
     get onDidChangeSelection() { return this.eventBufferer.wrapEvent(this.selection.onDidChange); }
+    get onMouseClick() { return Event.map(this.view.onMouseClick, asTreeMouseEvent); }
     get onMouseDblClick() { return Event.filter(Event.map(this.view.onMouseDblClick, asTreeMouseEvent), e => e.target !== TreeMouseEventTarget.Filter); }
+    get onContextMenu() { return Event.map(this.view.onContextMenu, asTreeContextMenuEvent); }
+    get onTap() { return Event.map(this.view.onTap, asTreeMouseEvent); }
     get onPointer() { return Event.map(this.view.onPointer, asTreeMouseEvent); }
+    get onKeyDown() { return this.view.onKeyDown; }
+    get onKeyUp() { return this.view.onKeyUp; }
+    get onKeyPress() { return this.view.onKeyPress; }
     get onDidFocus() { return this.view.onDidFocus; }
+    get onDidBlur() { return this.view.onDidBlur; }
     get onDidChangeModel() { return Event.signal(this.model.onDidSplice); }
     get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }
-    get findMode() { var _a, _b; return (_b = (_a = this.findController) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : TreeFindMode.Highlight; }
+    get onDidChangeRenderNodeCount() { return this.model.onDidChangeRenderNodeCount; }
+    get findMode() { return this.findController?.mode ?? TreeFindMode.Highlight; }
     set findMode(findMode) { if (this.findController) {
         this.findController.mode = findMode;
     } }
-    get findMatchType() { var _a, _b; return (_b = (_a = this.findController) === null || _a === void 0 ? void 0 : _a.matchType) !== null && _b !== void 0 ? _b : TreeFindMatchType.Fuzzy; }
+    get findMatchType() { return this.findController?.matchType ?? TreeFindMatchType.Fuzzy; }
     set findMatchType(findFuzzy) { if (this.findController) {
         this.findController.matchType = findFuzzy;
     } }
+    get onDidChangeFindPattern() { return this.findController ? this.findController.onDidChangePattern : Event.None; }
     get expandOnDoubleClick() { return typeof this._options.expandOnDoubleClick === 'undefined' ? true : this._options.expandOnDoubleClick; }
     get expandOnlyOnTwistieClick() { return typeof this._options.expandOnlyOnTwistieClick === 'undefined' ? true : this._options.expandOnlyOnTwistieClick; }
     get onDidDispose() { return this.view.onDidDispose; }
     constructor(_user, container, delegate, renderers, _options = {}) {
-        var _a;
         this._user = _user;
         this._options = _options;
         this.eventBufferer = new EventBufferer();
@@ -1058,6 +1180,7 @@
         this._onWillRefilter = new Emitter();
         this.onWillRefilter = this._onWillRefilter.event;
         this._onDidUpdateOptions = new Emitter();
+        this.onDidUpdateOptions = this._onDidUpdateOptions.event;
         const treeDelegate = new ComposedTreeDelegate(delegate);
         const onDidChangeCollapseStateRelay = new Relay();
         const onDidChangeActiveNodes = new Relay();
@@ -1070,13 +1193,13 @@
         let filter;
         if (_options.keyboardNavigationLabelProvider) {
             filter = new FindFilter(this, _options.keyboardNavigationLabelProvider, _options.filter);
-            _options = Object.assign(Object.assign({}, _options), { filter: filter }); // TODO need typescript help here
+            _options = { ..._options, filter: filter }; // TODO need typescript help here
             this.disposables.add(filter);
         }
         this.focus = new Trait(() => this.view.getFocusedElements()[0], _options.identityProvider);
         this.selection = new Trait(() => this.view.getSelectedElements()[0], _options.identityProvider);
         this.anchor = new Trait(() => this.view.getAnchorElement(), _options.identityProvider);
-        this.view = new TreeNodeList(_user, container, treeDelegate, this.renderers, this.focus, this.selection, this.anchor, Object.assign(Object.assign({}, asListOptions(() => this.model, _options)), { tree: this }));
+        this.view = new TreeNodeList(_user, container, treeDelegate, this.renderers, this.focus, this.selection, this.anchor, { ...asListOptions(() => this.model, _options), tree: this });
         this.model = this.createModel(_user, this.view, _options);
         onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;
         const onDidModelSplice = Event.forEach(this.model.onDidSplice, e => {
@@ -1113,7 +1236,7 @@
             Event.chain(onKeyDown, $ => $.filter(e => e.keyCode === 17 /* KeyCode.RightArrow */))(this.onRightArrow, this, this.disposables);
             Event.chain(onKeyDown, $ => $.filter(e => e.keyCode === 10 /* KeyCode.Space */))(this.onSpace, this, this.disposables);
         }
-        if (((_a = _options.findWidgetEnabled) !== null && _a !== void 0 ? _a : true) && _options.keyboardNavigationLabelProvider && _options.contextViewProvider) {
+        if ((_options.findWidgetEnabled ?? true) && _options.keyboardNavigationLabelProvider && _options.contextViewProvider) {
             const opts = this.options.findWidgetStyles ? { styles: this.options.findWidgetStyles } : undefined;
             this.findController = new FindController(this, this.model, this.view, filter, _options.contextViewProvider, opts);
             this.focusNavigationFilter = node => this.findController.shouldAllowFocus(node);
@@ -1130,43 +1253,91 @@
         this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);
     }
     updateOptions(optionsUpdate = {}) {
-        var _a;
-        this._options = Object.assign(Object.assign({}, this._options), optionsUpdate);
+        this._options = { ...this._options, ...optionsUpdate };
         for (const renderer of this.renderers) {
             renderer.updateOptions(optionsUpdate);
         }
         this.view.updateOptions(this._options);
-        (_a = this.findController) === null || _a === void 0 ? void 0 : _a.updateOptions(optionsUpdate);
+        this.findController?.updateOptions(optionsUpdate);
         this._onDidUpdateOptions.fire(this._options);
         this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);
     }
     get options() {
         return this._options;
     }
+    updateWidth(element) {
+        const index = this.model.getListIndex(element);
+        if (index === -1) {
+            return;
+        }
+        this.view.updateWidth(index);
+    }
     // Widget
     getHTMLElement() {
         return this.view.getHTMLElement();
     }
+    get contentHeight() {
+        return this.view.contentHeight;
+    }
+    get contentWidth() {
+        return this.view.contentWidth;
+    }
+    get onDidChangeContentHeight() {
+        return this.view.onDidChangeContentHeight;
+    }
+    get onDidChangeContentWidth() {
+        return this.view.onDidChangeContentWidth;
+    }
     get scrollTop() {
         return this.view.scrollTop;
     }
     set scrollTop(scrollTop) {
         this.view.scrollTop = scrollTop;
     }
+    get scrollLeft() {
+        return this.view.scrollLeft;
+    }
+    set scrollLeft(scrollLeft) {
+        this.view.scrollLeft = scrollLeft;
+    }
     get scrollHeight() {
         return this.view.scrollHeight;
     }
     get renderHeight() {
         return this.view.renderHeight;
     }
+    get firstVisibleElement() {
+        const index = this.view.firstVisibleIndex;
+        if (index < 0 || index >= this.view.length) {
+            return undefined;
+        }
+        const node = this.view.element(index);
+        return node.element;
+    }
+    get lastVisibleElement() {
+        const index = this.view.lastVisibleIndex;
+        const node = this.view.element(index);
+        return node.element;
+    }
+    get ariaLabel() {
+        return this.view.ariaLabel;
+    }
+    set ariaLabel(value) {
+        this.view.ariaLabel = value;
+    }
+    get selectionSize() {
+        return this.selection.getNodes().length;
+    }
     domFocus() {
         this.view.domFocus();
     }
+    isDOMFocused() {
+        return this.getHTMLElement() === document.activeElement;
+    }
     layout(height, width) {
-        var _a;
         this.view.layout(height, width);
         if (isNumber(width)) {
-            (_a = this.findController) === null || _a === void 0 ? void 0 : _a.layout(width);
+            this.findController?.layout(width);
         }
     }
     style(styles) {
@@ -1204,6 +1375,12 @@
     toggleCollapsed(location, recursive = false) {
         return this.model.setCollapsed(location, undefined, recursive);
     }
+    expandAll() {
+        this.model.setCollapsed(this.model.rootRef, false, true);
+    }
+    collapseAll() {
+        this.model.setCollapsed(this.model.rootRef, true, true);
+    }
     isCollapsible(location) {
         return this.model.isCollapsible(location);
     }
@@ -1213,10 +1390,33 @@
     isCollapsed(location) {
         return this.model.isCollapsed(location);
     }
+    triggerTypeNavigation() {
+        this.view.triggerTypeNavigation();
+    }
+    openFind() {
+        this.findController?.open();
+    }
+    closeFind() {
+        this.findController?.close();
+    }
     refilter() {
         this._onWillRefilter.fire(undefined);
         this.model.refilter();
     }
+    setAnchor(element) {
+        if (typeof element === 'undefined') {
+            return this.view.setAnchor(undefined);
+        }
+        const node = this.model.getNode(element);
+        this.anchor.set([node]);
+        const index = this.model.getListIndex(element);
+        if (index > -1) {
+            this.view.setAnchor(index, true);
+        }
+    }
+    getAnchor() {
+        return firstOrDefault(this.anchor.get(), undefined);
+    }
     setSelection(elements, browserEvent) {
         const nodes = elements.map(e => this.model.getNode(e));
         this.selection.set(nodes, browserEvent);
@@ -1232,6 +1432,24 @@
         const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);
         this.view.setFocus(indexes, browserEvent, true);
     }
+    focusNext(n = 1, loop = false, browserEvent, filter = this.focusNavigationFilter) {
+        this.view.focusNext(n, loop, browserEvent, filter);
+    }
+    focusPrevious(n = 1, loop = false, browserEvent, filter = this.focusNavigationFilter) {
+        this.view.focusPrevious(n, loop, browserEvent, filter);
+    }
+    focusNextPage(browserEvent, filter = this.focusNavigationFilter) {
+        return this.view.focusNextPage(browserEvent, filter);
+    }
+    focusPreviousPage(browserEvent, filter = this.focusNavigationFilter) {
+        return this.view.focusPreviousPage(browserEvent, filter);
+    }
+    focusLast(browserEvent, filter = this.focusNavigationFilter) {
+        this.view.focusLast(browserEvent, filter);
+    }
+    focusFirst(browserEvent, filter = this.focusNavigationFilter) {
+        this.view.focusFirst(browserEvent, filter);
+    }
     getFocus() {
         return this.focus.get();
     }
@@ -1243,6 +1461,40 @@
         }
         this.view.reveal(index, relativeTop);
     }
+    /**
+     * Returns the relative position of an element rendered in the list.
+     * Returns `null` if the element isn't *entirely* in the visible viewport.
+     */
+    getRelativeTop(location) {
+        const index = this.model.getListIndex(location);
+        if (index === -1) {
+            return null;
+        }
+        return this.view.getRelativeTop(index);
+    }
+    getViewState(identityProvider = this.options.identityProvider) {
+        if (!identityProvider) {
+            throw new TreeError(this._user, 'Can\'t get tree view state without an identity provider');
+        }
+        const getId = (element) => identityProvider.getId(element).toString();
+        const state = AbstractTreeViewState.empty(this.scrollTop);
+        for (const focus of this.getFocus()) {
+            state.focus.add(getId(focus));
+        }
+        for (const selection of this.getSelection()) {
+            state.selection.add(getId(selection));
+        }
+        const root = this.model.getNode();
+        const queue = [root];
+        while (queue.length > 0) {
+            const node = queue.shift();
+            if (node !== root && node.collapsible) {
+                state.expanded[getId(node.element)] = node.collapsed ? 0 : 1;
+            }
+            queue.push(...node.children);
+        }
+        return state;
+    }
     // List
     onLeftArrow(e) {
         e.preventDefault();
@@ -1296,8 +1548,45 @@
         const recursive = e.browserEvent.altKey;
         this.model.setCollapsed(location, undefined, recursive);
     }
+    navigate(start) {
+        return new TreeNavigator(this.view, this.model, start);
+    }
     dispose() {
         dispose(this.disposables);
         this.view.dispose();
     }
 }
+class TreeNavigator {
+    constructor(view, model, start) {
+        this.view = view;
+        this.model = model;
+        if (start) {
+            this.index = this.model.getListIndex(start);
+        }
+        else {
+            this.index = -1;
+        }
+    }
+    current() {
+        if (this.index < 0 || this.index >= this.view.length) {
+            return null;
+        }
+        return this.view.element(this.index).element;
+    }
+    previous() {
+        this.index--;
+        return this.current();
+    }
+    next() {
+        this.index++;
+        return this.current();
+    }
+    first() {
+        this.index = 0;
+        return this.current();
+    }
+    last() {
+        this.index = this.view.length - 1;
+        return this.current();
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/ui/tree/asyncDataTree.js b/vs/base/browser/ui/tree/asyncDataTree.js
--- a/vs/base/browser/ui/tree/asyncDataTree.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/ui/tree/asyncDataTree.js	2023-12-06 14:23:14.347854727 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { ElementsDragAndDropData } from '../list/listView.js';
 import { ComposedTreeDelegate } from './abstractTree.js';
 import { getVisibleState, isFilterResult } from './indexTreeModel.js';
@@ -25,7 +16,14 @@
 import { DisposableStore, dispose } from '../../../common/lifecycle.js';
 import { isIterable } from '../../../common/types.js';
 function createAsyncDataTreeNode(props) {
-    return Object.assign(Object.assign({}, props), { children: [], refreshPromise: undefined, stale: true, slow: false, collapsedByDefault: undefined });
+    return {
+        ...props,
+        children: [],
+        refreshPromise: undefined,
+        stale: true,
+        slow: false,
+        collapsedByDefault: undefined
+    };
 }
 function isAncestor(ancestor, descendant) {
     if (!descendant.parent) {
@@ -81,8 +79,7 @@
         }
     }
     disposeElement(node, index, templateData, height) {
-        var _a, _b;
-        (_b = (_a = this.renderer).disposeElement) === null || _b === void 0 ? void 0 : _b.call(_a, this.nodeMapper.map(node), index, templateData.templateData, height);
+        this.renderer.disposeElement?.(this.nodeMapper.map(node), index, templateData.templateData, height);
     }
     disposeTemplate(templateData) {
         this.renderer.disposeTemplate(templateData.templateData);
@@ -104,7 +101,20 @@
         target: e.target
     };
 }
+function asTreeContextMenuEvent(e) {
+    return {
+        browserEvent: e.browserEvent,
+        element: e.element && e.element.element,
+        anchor: e.anchor
+    };
+}
 class AsyncDataTreeElementsDragAndDropData extends ElementsDragAndDropData {
+    set context(context) {
+        this.data.context = context;
+    }
+    get context() {
+        return this.data.context;
+    }
     constructor(data) {
         super(data.elements.map(node => node.element));
         this.data = data;
@@ -130,8 +140,7 @@
         return undefined;
     }
     onDragStart(data, originalEvent) {
-        var _a, _b;
-        (_b = (_a = this.dnd).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, asAsyncDataTreeDragAndDropData(data), originalEvent);
+        this.dnd.onDragStart?.(asAsyncDataTreeDragAndDropData(data), originalEvent);
     }
     onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {
         return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
@@ -140,46 +149,68 @@
         this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
     }
     onDragEnd(originalEvent) {
-        var _a, _b;
-        (_b = (_a = this.dnd).onDragEnd) === null || _b === void 0 ? void 0 : _b.call(_a, originalEvent);
+        this.dnd.onDragEnd?.(originalEvent);
     }
     dispose() {
         this.dnd.dispose();
     }
 }
 function asObjectTreeOptions(options) {
-    return options && Object.assign(Object.assign({}, options), { collapseByDefault: true, identityProvider: options.identityProvider && {
+    return options && {
+        ...options,
+        collapseByDefault: true,
+        identityProvider: options.identityProvider && {
             getId(el) {
                 return options.identityProvider.getId(el.element);
             }
-        }, dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd), multipleSelectionController: options.multipleSelectionController && {
+        },
+        dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd),
+        multipleSelectionController: options.multipleSelectionController && {
             isSelectionSingleChangeEvent(e) {
-                return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
+                return options.multipleSelectionController.isSelectionSingleChangeEvent({ ...e, element: e.element });
             },
             isSelectionRangeChangeEvent(e) {
-                return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
+                return options.multipleSelectionController.isSelectionRangeChangeEvent({ ...e, element: e.element });
             }
-        }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), { getPosInSet: undefined, getSetSize: undefined, getRole: options.accessibilityProvider.getRole ? (el) => {
+        },
+        accessibilityProvider: options.accessibilityProvider && {
+            ...options.accessibilityProvider,
+            getPosInSet: undefined,
+            getSetSize: undefined,
+            getRole: options.accessibilityProvider.getRole ? (el) => {
                 return options.accessibilityProvider.getRole(el.element);
-            } : () => 'treeitem', isChecked: options.accessibilityProvider.isChecked ? (e) => {
-                var _a;
-                return !!((_a = options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.isChecked(e.element));
-            } : undefined, getAriaLabel(e) {
+            } : () => 'treeitem',
+            isChecked: options.accessibilityProvider.isChecked ? (e) => {
+                return !!(options.accessibilityProvider?.isChecked(e.element));
+            } : undefined,
+            getAriaLabel(e) {
                 return options.accessibilityProvider.getAriaLabel(e.element);
             },
             getWidgetAriaLabel() {
                 return options.accessibilityProvider.getWidgetAriaLabel();
-            }, getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree', getAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {
+            },
+            getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree',
+            getAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {
                 return options.accessibilityProvider.getAriaLevel(node.element);
-            }), getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {
+            }),
+            getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {
                 return options.accessibilityProvider.getActiveDescendantId(node.element);
-            }) }), filter: options.filter && {
+            })
+        },
+        filter: options.filter && {
             filter(e, parentVisibility) {
                 return options.filter.filter(e.element, parentVisibility);
             }
-        }, keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(e) {
+        },
+        keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {
+            ...options.keyboardNavigationLabelProvider,
+            getKeyboardNavigationLabel(e) {
                 return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
-            } }), sorter: undefined, expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (e => options.expandOnlyOnTwistieClick(e.element))), defaultFindVisibility: e => {
+            }
+        },
+        sorter: undefined,
+        expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (e => options.expandOnlyOnTwistieClick(e.element))),
+        defaultFindVisibility: e => {
             if (e.hasChildren && e.stale) {
                 return 1 /* TreeVisibility.Visible */;
             }
@@ -192,7 +223,8 @@
             else {
                 return options.defaultFindVisibility(e.element);
             }
-        } });
+        }
+    };
 }
 function dfs(node, fn) {
     fn(node);
@@ -202,16 +234,31 @@
     get onDidScroll() { return this.tree.onDidScroll; }
     get onDidChangeFocus() { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }
     get onDidChangeSelection() { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }
+    get onKeyDown() { return this.tree.onKeyDown; }
+    get onMouseClick() { return Event.map(this.tree.onMouseClick, asTreeMouseEvent); }
     get onMouseDblClick() { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }
+    get onContextMenu() { return Event.map(this.tree.onContextMenu, asTreeContextMenuEvent); }
+    get onTap() { return Event.map(this.tree.onTap, asTreeMouseEvent); }
     get onPointer() { return Event.map(this.tree.onPointer, asTreeMouseEvent); }
     get onDidFocus() { return this.tree.onDidFocus; }
+    get onDidBlur() { return this.tree.onDidBlur; }
     /**
      * To be used internally only!
      * @deprecated
      */
     get onDidChangeModel() { return this.tree.onDidChangeModel; }
     get onDidChangeCollapseState() { return this.tree.onDidChangeCollapseState; }
+    get onDidUpdateOptions() { return this.tree.onDidUpdateOptions; }
     get onDidChangeFindOpenState() { return this.tree.onDidChangeFindOpenState; }
+    get findMode() { return this.tree.findMode; }
+    set findMode(mode) { this.tree.findMode = mode; }
+    get expandOnlyOnTwistieClick() {
+        if (typeof this.tree.expandOnlyOnTwistieClick === 'boolean') {
+            return this.tree.expandOnlyOnTwistieClick;
+        }
+        const fn = this.tree.expandOnlyOnTwistieClick;
+        return element => fn(this.nodes.get((element === this.root.element ? null : element)) || null);
+    }
     get onDidDispose() { return this.tree.onDidDispose; }
     constructor(user, container, delegate, renderers, dataSource, options = {}) {
         this.user = user;
@@ -235,7 +282,10 @@
             hasChildren: true
         });
         if (this.identityProvider) {
-            this.root = Object.assign(Object.assign({}, this.root), { id: null });
+            this.root = {
+                ...this.root,
+                id: null
+            };
         }
         this.nodes.set(null, this.root);
         this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
@@ -249,22 +299,52 @@
     updateOptions(options = {}) {
         this.tree.updateOptions(options);
     }
+    get options() {
+        return this.tree.options;
+    }
     // Widget
     getHTMLElement() {
         return this.tree.getHTMLElement();
     }
+    get contentHeight() {
+        return this.tree.contentHeight;
+    }
+    get contentWidth() {
+        return this.tree.contentWidth;
+    }
+    get onDidChangeContentHeight() {
+        return this.tree.onDidChangeContentHeight;
+    }
+    get onDidChangeContentWidth() {
+        return this.tree.onDidChangeContentWidth;
+    }
     get scrollTop() {
         return this.tree.scrollTop;
     }
     set scrollTop(scrollTop) {
         this.tree.scrollTop = scrollTop;
     }
+    get scrollLeft() {
+        return this.tree.scrollLeft;
+    }
+    set scrollLeft(scrollLeft) {
+        this.tree.scrollLeft = scrollLeft;
+    }
     get scrollHeight() {
         return this.tree.scrollHeight;
     }
     get renderHeight() {
         return this.tree.renderHeight;
     }
+    get lastVisibleElement() {
+        return this.tree.lastVisibleElement.element;
+    }
+    get ariaLabel() {
+        return this.tree.ariaLabel;
+    }
+    set ariaLabel(value) {
+        this.tree.ariaLabel = value;
+    }
     domFocus() {
         this.tree.domFocus();
     }
@@ -278,43 +358,48 @@
     getInput() {
         return this.root.element;
     }
-    setInput(input, viewState) {
-        return __awaiter(this, void 0, void 0, function* () {
-            this.refreshPromises.forEach(promise => promise.cancel());
-            this.refreshPromises.clear();
-            this.root.element = input;
-            const viewStateContext = viewState && { viewState, focus: [], selection: [] };
-            yield this._updateChildren(input, true, false, viewStateContext);
-            if (viewStateContext) {
-                this.tree.setFocus(viewStateContext.focus);
-                this.tree.setSelection(viewStateContext.selection);
+    async setInput(input, viewState) {
+        this.refreshPromises.forEach(promise => promise.cancel());
+        this.refreshPromises.clear();
+        this.root.element = input;
+        const viewStateContext = viewState && { viewState, focus: [], selection: [] };
+        await this._updateChildren(input, true, false, viewStateContext);
+        if (viewStateContext) {
+            this.tree.setFocus(viewStateContext.focus);
+            this.tree.setSelection(viewStateContext.selection);
+        }
+        if (viewState && typeof viewState.scrollTop === 'number') {
+            this.scrollTop = viewState.scrollTop;
+        }
+    }
+    async updateChildren(element = this.root.element, recursive = true, rerender = false, options) {
+        await this._updateChildren(element, recursive, rerender, undefined, options);
+    }
+    async _updateChildren(element = this.root.element, recursive = true, rerender = false, viewStateContext, options) {
+        if (typeof this.root.element === 'undefined') {
+            throw new TreeError(this.user, 'Tree input not set');
+        }
+        if (this.root.refreshPromise) {
+            await this.root.refreshPromise;
+            await Event.toPromise(this._onDidRender.event);
+        }
+        const node = this.getDataNode(element);
+        await this.refreshAndRenderNode(node, recursive, viewStateContext, options);
+        if (rerender) {
+            try {
+                this.tree.rerender(node);
             }
-            if (viewState && typeof viewState.scrollTop === 'number') {
-                this.scrollTop = viewState.scrollTop;
+            catch {
+                // missing nodes are fine, this could've resulted from
+                // parallel refresh calls, removing `node` altogether
             }
-        });
+        }
     }
-    _updateChildren(element = this.root.element, recursive = true, rerender = false, viewStateContext, options) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (typeof this.root.element === 'undefined') {
-                throw new TreeError(this.user, 'Tree input not set');
-            }
-            if (this.root.refreshPromise) {
-                yield this.root.refreshPromise;
-                yield Event.toPromise(this._onDidRender.event);
-            }
-            const node = this.getDataNode(element);
-            yield this.refreshAndRenderNode(node, recursive, viewStateContext, options);
-            if (rerender) {
-                try {
-                    this.tree.rerender(node);
-                }
-                catch (_a) {
-                    // missing nodes are fine, this could've resulted from
-                    // parallel refresh calls, removing `node` altogether
-                }
-            }
-        });
+    resort(element = this.root.element, recursive = true) {
+        this.tree.resort(this.getDataNode(element), recursive);
+    }
+    hasNode(element) {
+        return element === this.root.element || this.nodes.has(element);
     }
     // View
     rerender(element) {
@@ -325,6 +410,10 @@
         const node = this.getDataNode(element);
         this.tree.rerender(node);
     }
+    updateWidth(element) {
+        const node = this.getDataNode(element);
+        this.tree.updateWidth(node);
+    }
     // Tree
     getNode(element = this.root.element) {
         const dataNode = this.getDataNode(element);
@@ -335,33 +424,65 @@
         const node = this.getDataNode(element);
         return this.tree.collapse(node === this.root ? null : node, recursive);
     }
-    expand(element, recursive = false) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (typeof this.root.element === 'undefined') {
-                throw new TreeError(this.user, 'Tree input not set');
-            }
-            if (this.root.refreshPromise) {
-                yield this.root.refreshPromise;
-                yield Event.toPromise(this._onDidRender.event);
-            }
-            const node = this.getDataNode(element);
-            if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {
-                return false;
-            }
-            if (node.refreshPromise) {
-                yield this.root.refreshPromise;
-                yield Event.toPromise(this._onDidRender.event);
-            }
-            if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {
-                return false;
-            }
-            const result = this.tree.expand(node === this.root ? null : node, recursive);
-            if (node.refreshPromise) {
-                yield this.root.refreshPromise;
-                yield Event.toPromise(this._onDidRender.event);
-            }
-            return result;
-        });
+    async expand(element, recursive = false) {
+        if (typeof this.root.element === 'undefined') {
+            throw new TreeError(this.user, 'Tree input not set');
+        }
+        if (this.root.refreshPromise) {
+            await this.root.refreshPromise;
+            await Event.toPromise(this._onDidRender.event);
+        }
+        const node = this.getDataNode(element);
+        if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {
+            return false;
+        }
+        if (node.refreshPromise) {
+            await this.root.refreshPromise;
+            await Event.toPromise(this._onDidRender.event);
+        }
+        if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {
+            return false;
+        }
+        const result = this.tree.expand(node === this.root ? null : node, recursive);
+        if (node.refreshPromise) {
+            await this.root.refreshPromise;
+            await Event.toPromise(this._onDidRender.event);
+        }
+        return result;
+    }
+    toggleCollapsed(element, recursive = false) {
+        return this.tree.toggleCollapsed(this.getDataNode(element), recursive);
+    }
+    expandAll() {
+        this.tree.expandAll();
+    }
+    collapseAll() {
+        this.tree.collapseAll();
+    }
+    isCollapsible(element) {
+        return this.tree.isCollapsible(this.getDataNode(element));
+    }
+    isCollapsed(element) {
+        return this.tree.isCollapsed(this.getDataNode(element));
+    }
+    triggerTypeNavigation() {
+        this.tree.triggerTypeNavigation();
+    }
+    openFind() {
+        this.tree.openFind();
+    }
+    closeFind() {
+        this.tree.closeFind();
+    }
+    refilter() {
+        this.tree.refilter();
+    }
+    setAnchor(element) {
+        this.tree.setAnchor(typeof element === 'undefined' ? undefined : this.getDataNode(element));
+    }
+    getAnchor() {
+        const node = this.tree.getAnchor();
+        return node?.element;
     }
     setSelection(elements, browserEvent) {
         const nodes = elements.map(e => this.getDataNode(e));
@@ -375,6 +496,24 @@
         const nodes = elements.map(e => this.getDataNode(e));
         this.tree.setFocus(nodes, browserEvent);
     }
+    focusNext(n = 1, loop = false, browserEvent) {
+        this.tree.focusNext(n, loop, browserEvent);
+    }
+    focusPrevious(n = 1, loop = false, browserEvent) {
+        this.tree.focusPrevious(n, loop, browserEvent);
+    }
+    focusNextPage(browserEvent) {
+        return this.tree.focusNextPage(browserEvent);
+    }
+    focusPreviousPage(browserEvent) {
+        return this.tree.focusPreviousPage(browserEvent);
+    }
+    focusLast(browserEvent) {
+        this.tree.focusLast(browserEvent);
+    }
+    focusFirst(browserEvent) {
+        this.tree.focusFirst(browserEvent);
+    }
     getFocus() {
         const nodes = this.tree.getFocus();
         return nodes.map(n => n.element);
@@ -382,6 +521,9 @@
     reveal(element, relativeTop) {
         this.tree.reveal(this.getDataNode(element), relativeTop);
     }
+    getRelativeTop(element) {
+        return this.tree.getRelativeTop(this.getDataNode(element));
+    }
     // Tree navigation
     getParentElement(element) {
         const node = this.tree.getParentElement(this.getDataNode(element));
@@ -400,94 +542,86 @@
         }
         return node;
     }
-    refreshAndRenderNode(node, recursive, viewStateContext, options) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield this.refreshNode(node, recursive, viewStateContext);
-            this.render(node, viewStateContext, options);
-        });
-    }
-    refreshNode(node, recursive, viewStateContext) {
-        return __awaiter(this, void 0, void 0, function* () {
-            let result;
-            this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {
-                if (!result && intersects(refreshNode, node)) {
-                    result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));
-                }
-            });
-            if (result) {
-                return result;
-            }
-            if (node !== this.root) {
-                const treeNode = this.tree.getNode(node);
-                if (treeNode.collapsed) {
-                    node.hasChildren = !!this.dataSource.hasChildren(node.element);
-                    node.stale = true;
-                    return;
-                }
+    async refreshAndRenderNode(node, recursive, viewStateContext, options) {
+        await this.refreshNode(node, recursive, viewStateContext);
+        this.render(node, viewStateContext, options);
+    }
+    async refreshNode(node, recursive, viewStateContext) {
+        let result;
+        this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {
+            if (!result && intersects(refreshNode, node)) {
+                result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));
             }
-            return this.doRefreshSubTree(node, recursive, viewStateContext);
         });
-    }
-    doRefreshSubTree(node, recursive, viewStateContext) {
-        return __awaiter(this, void 0, void 0, function* () {
-            let done;
-            node.refreshPromise = new Promise(c => done = c);
-            this.subTreeRefreshPromises.set(node, node.refreshPromise);
-            node.refreshPromise.finally(() => {
-                node.refreshPromise = undefined;
-                this.subTreeRefreshPromises.delete(node);
-            });
-            try {
-                const childrenToRefresh = yield this.doRefreshNode(node, recursive, viewStateContext);
-                node.stale = false;
-                yield Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));
-            }
-            finally {
-                done();
-            }
+        if (result) {
+            return result;
+        }
+        if (node !== this.root) {
+            const treeNode = this.tree.getNode(node);
+            if (treeNode.collapsed) {
+                node.hasChildren = !!this.dataSource.hasChildren(node.element);
+                node.stale = true;
+                return;
+            }
+        }
+        return this.doRefreshSubTree(node, recursive, viewStateContext);
+    }
+    async doRefreshSubTree(node, recursive, viewStateContext) {
+        let done;
+        node.refreshPromise = new Promise(c => done = c);
+        this.subTreeRefreshPromises.set(node, node.refreshPromise);
+        node.refreshPromise.finally(() => {
+            node.refreshPromise = undefined;
+            this.subTreeRefreshPromises.delete(node);
         });
+        try {
+            const childrenToRefresh = await this.doRefreshNode(node, recursive, viewStateContext);
+            node.stale = false;
+            await Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));
+        }
+        finally {
+            done();
+        }
     }
-    doRefreshNode(node, recursive, viewStateContext) {
-        return __awaiter(this, void 0, void 0, function* () {
-            node.hasChildren = !!this.dataSource.hasChildren(node.element);
-            let childrenPromise;
-            if (!node.hasChildren) {
-                childrenPromise = Promise.resolve(Iterable.empty());
+    async doRefreshNode(node, recursive, viewStateContext) {
+        node.hasChildren = !!this.dataSource.hasChildren(node.element);
+        let childrenPromise;
+        if (!node.hasChildren) {
+            childrenPromise = Promise.resolve(Iterable.empty());
+        }
+        else {
+            const children = this.doGetChildren(node);
+            if (isIterable(children)) {
+                childrenPromise = Promise.resolve(children);
             }
             else {
-                const children = this.doGetChildren(node);
-                if (isIterable(children)) {
-                    childrenPromise = Promise.resolve(children);
-                }
-                else {
-                    const slowTimeout = timeout(800);
-                    slowTimeout.then(() => {
-                        node.slow = true;
-                        this._onDidChangeNodeSlowState.fire(node);
-                    }, _ => null);
-                    childrenPromise = children.finally(() => slowTimeout.cancel());
-                }
+                const slowTimeout = timeout(800);
+                slowTimeout.then(() => {
+                    node.slow = true;
+                    this._onDidChangeNodeSlowState.fire(node);
+                }, _ => null);
+                childrenPromise = children.finally(() => slowTimeout.cancel());
             }
-            try {
-                const children = yield childrenPromise;
-                return this.setChildren(node, children, recursive, viewStateContext);
+        }
+        try {
+            const children = await childrenPromise;
+            return this.setChildren(node, children, recursive, viewStateContext);
+        }
+        catch (err) {
+            if (node !== this.root && this.tree.hasElement(node)) {
+                this.tree.collapse(node);
             }
-            catch (err) {
-                if (node !== this.root && this.tree.hasElement(node)) {
-                    this.tree.collapse(node);
-                }
-                if (isCancellationError(err)) {
-                    return [];
-                }
-                throw err;
+            if (isCancellationError(err)) {
+                return [];
             }
-            finally {
-                if (node.slow) {
-                    node.slow = false;
-                    this._onDidChangeNodeSlowState.fire(node);
-                }
+            throw err;
+        }
+        finally {
+            if (node.slow) {
+                node.slow = false;
+                this._onDidChangeNodeSlowState.fire(node);
             }
-        });
+        }
     }
     doGetChildren(node) {
         let result = this.refreshPromises.get(node);
@@ -499,7 +633,7 @@
             return this.processChildren(children);
         }
         else {
-            result = createCancelablePromise(() => __awaiter(this, void 0, void 0, function* () { return this.processChildren(yield children); }));
+            result = createCancelablePromise(async () => this.processChildren(await children));
             this.refreshPromises.set(node, result);
             return result.finally(() => { this.refreshPromises.delete(node); });
         }
@@ -601,11 +735,14 @@
     }
     render(node, viewStateContext, options) {
         const children = node.children.map(node => this.asTreeElement(node, viewStateContext));
-        const objectTreeOptions = options && Object.assign(Object.assign({}, options), { diffIdentityProvider: options.diffIdentityProvider && {
+        const objectTreeOptions = options && {
+            ...options,
+            diffIdentityProvider: options.diffIdentityProvider && {
                 getId(node) {
                     return options.diffIdentityProvider.getId(node.element);
                 }
-            } });
+            }
+        };
         this.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);
         if (node !== this.root) {
             this.tree.setCollapsible(node, node.hasChildren);
@@ -641,6 +778,26 @@
         }
         return children;
     }
+    // view state
+    getViewState() {
+        if (!this.identityProvider) {
+            throw new TreeError(this.user, 'Can\'t get tree view state without an identity provider');
+        }
+        const getId = (element) => this.identityProvider.getId(element).toString();
+        const focus = this.getFocus().map(getId);
+        const selection = this.getSelection().map(getId);
+        const expanded = [];
+        const root = this.tree.getNode();
+        const stack = [root];
+        while (stack.length > 0) {
+            const node = stack.pop();
+            if (node !== root && node.collapsible && !node.collapsed) {
+                expanded.push(getId(node.element.element));
+            }
+            stack.push(...node.children);
+        }
+        return { focus, selection, expanded, scrollTop: this.scrollTop };
+    }
     dispose() {
         this.disposables.dispose();
         this.tree.dispose();
@@ -696,12 +853,10 @@
         }
     }
     disposeElement(node, index, templateData, height) {
-        var _a, _b;
-        (_b = (_a = this.renderer).disposeElement) === null || _b === void 0 ? void 0 : _b.call(_a, this.nodeMapper.map(node), index, templateData.templateData, height);
+        this.renderer.disposeElement?.(this.nodeMapper.map(node), index, templateData.templateData, height);
     }
     disposeCompressedElements(node, index, templateData, height) {
-        var _a, _b;
-        (_b = (_a = this.renderer).disposeCompressedElements) === null || _b === void 0 ? void 0 : _b.call(_a, this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);
+        this.renderer.disposeCompressedElements?.(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);
     }
     disposeTemplate(templateData) {
         this.renderer.disposeTemplate(templateData.templateData);
@@ -713,9 +868,15 @@
 }
 function asCompressibleObjectTreeOptions(options) {
     const objectTreeOptions = options && asObjectTreeOptions(options);
-    return objectTreeOptions && Object.assign(Object.assign({}, objectTreeOptions), { keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, objectTreeOptions.keyboardNavigationLabelProvider), { getCompressedNodeKeyboardNavigationLabel(els) {
+    return objectTreeOptions && {
+        ...objectTreeOptions,
+        keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && {
+            ...objectTreeOptions.keyboardNavigationLabelProvider,
+            getCompressedNodeKeyboardNavigationLabel(els) {
                 return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element));
-            } }) });
+            }
+        }
+    };
 }
 export class CompressibleAsyncDataTree extends AsyncDataTree {
     constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options = {}) {
@@ -731,11 +892,35 @@
         return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);
     }
     asTreeElement(node, viewStateContext) {
-        return Object.assign({ incompressible: this.compressionDelegate.isIncompressible(node.element) }, super.asTreeElement(node, viewStateContext));
+        return {
+            incompressible: this.compressionDelegate.isIncompressible(node.element),
+            ...super.asTreeElement(node, viewStateContext)
+        };
     }
     updateOptions(options = {}) {
         this.tree.updateOptions(options);
     }
+    getViewState() {
+        if (!this.identityProvider) {
+            throw new TreeError(this.user, 'Can\'t get tree view state without an identity provider');
+        }
+        const getId = (element) => this.identityProvider.getId(element).toString();
+        const focus = this.getFocus().map(getId);
+        const selection = this.getSelection().map(getId);
+        const expanded = [];
+        const root = this.tree.getCompressedTreeNode();
+        const stack = [root];
+        while (stack.length > 0) {
+            const node = stack.pop();
+            if (node !== root && node.collapsible && !node.collapsed) {
+                for (const asyncNode of node.element.elements) {
+                    expanded.push(getId(asyncNode.element));
+                }
+            }
+            stack.push(...node.children);
+        }
+        return { focus, selection, expanded, scrollTop: this.scrollTop };
+    }
     render(node, viewStateContext) {
         if (!this.identityProvider) {
             return super.render(node, viewStateContext);
diff -urN -x '*.map' a/vs/base/browser/ui/tree/compressedObjectTreeModel.js b/vs/base/browser/ui/tree/compressedObjectTreeModel.js
--- a/vs/base/browser/ui/tree/compressedObjectTreeModel.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/ui/tree/compressedObjectTreeModel.js	2023-12-06 14:23:14.347854727 +0000
@@ -71,9 +71,9 @@
 }
 function splice(treeElement, element, children) {
     if (treeElement.element === element) {
-        return Object.assign(Object.assign({}, treeElement), { children });
+        return { ...treeElement, children };
     }
-    return Object.assign(Object.assign({}, treeElement), { children: Iterable.map(Iterable.from(treeElement.children), e => splice(e, element, children)) });
+    return { ...treeElement, children: Iterable.map(Iterable.from(treeElement.children), e => splice(e, element, children)) };
 }
 const wrapIdentityProvider = (base) => ({
     getId(node) {
@@ -85,6 +85,7 @@
     get onDidSplice() { return this.model.onDidSplice; }
     get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }
     get onDidChangeRenderNodeCount() { return this.model.onDidChangeRenderNodeCount; }
+    get size() { return this.nodes.size; }
     constructor(user, list, options = {}) {
         this.user = user;
         this.rootRef = null;
@@ -128,6 +129,9 @@
             diffDepth: node.depth - parent.depth,
         });
     }
+    isCompressionEnabled() {
+        return this.enabled;
+    }
     setCompressionEnabled(enabled) {
         if (enabled === this.enabled) {
             return;
@@ -159,7 +163,7 @@
                 }
             }
         };
-        this.model.setChildren(node, children, Object.assign(Object.assign({}, options), { onDidCreateNode, onDidDeleteNode }));
+        this.model.setChildren(node, children, { ...options, onDidCreateNode, onDidDeleteNode });
     }
     has(element) {
         return this.nodes.has(element);
@@ -200,6 +204,10 @@
         const compressedNode = this.getCompressedNode(location);
         return this.model.getFirstElementChild(compressedNode);
     }
+    getLastElementAncestor(location) {
+        const compressedNode = typeof location === 'undefined' ? undefined : this.getCompressedNode(location);
+        return this.model.getLastElementAncestor(compressedNode);
+    }
     isCollapsible(location) {
         const compressedNode = this.getCompressedNode(location);
         return this.model.isCollapsible(compressedNode);
@@ -224,9 +232,20 @@
         const compressedNode = this.getCompressedNode(location);
         this.model.rerender(compressedNode);
     }
+    updateElementHeight(element, height) {
+        const compressedNode = this.getCompressedNode(element);
+        if (!compressedNode) {
+            return;
+        }
+        this.model.updateElementHeight(compressedNode, height);
+    }
     refilter() {
         this.model.refilter();
     }
+    resort(location = null, recursive = true) {
+        const compressedNode = this.getCompressedNode(location);
+        this.model.resort(compressedNode, recursive);
+    }
     getCompressedNode(element) {
         if (element === null) {
             return null;
@@ -265,19 +284,24 @@
     };
 }
 function mapOptions(compressedNodeUnwrapper, options) {
-    return Object.assign(Object.assign({}, options), { identityProvider: options.identityProvider && {
+    return {
+        ...options,
+        identityProvider: options.identityProvider && {
             getId(node) {
                 return options.identityProvider.getId(compressedNodeUnwrapper(node));
             }
-        }, sorter: options.sorter && {
+        },
+        sorter: options.sorter && {
             compare(node, otherNode) {
                 return options.sorter.compare(node.elements[0], otherNode.elements[0]);
             }
-        }, filter: options.filter && {
+        },
+        filter: options.filter && {
             filter(node, parentVisibility) {
                 return options.filter.filter(compressedNodeUnwrapper(node), parentVisibility);
             }
-        } });
+        }
+    };
 }
 export class CompressibleObjectTreeModel {
     get onDidSplice() {
@@ -305,6 +329,9 @@
     setChildren(element, children = Iterable.empty(), options = {}) {
         this.model.setChildren(element, children, options);
     }
+    isCompressionEnabled() {
+        return this.model.isCompressionEnabled();
+    }
     setCompressionEnabled(enabled) {
         this.model.setCompressionEnabled(enabled);
     }
@@ -333,6 +360,13 @@
         }
         return this.elementMapper(result.elements);
     }
+    getLastElementAncestor(location) {
+        const result = this.model.getLastElementAncestor(location);
+        if (result === null || typeof result === 'undefined') {
+            return result;
+        }
+        return this.elementMapper(result.elements);
+    }
     isCollapsible(location) {
         return this.model.isCollapsible(location);
     }
@@ -351,9 +385,15 @@
     rerender(location) {
         return this.model.rerender(location);
     }
+    updateElementHeight(element, height) {
+        this.model.updateElementHeight(element, height);
+    }
     refilter() {
         return this.model.refilter();
     }
+    resort(element = null, recursive = true) {
+        return this.model.resort(element, recursive);
+    }
     getCompressedTreeNode(location = null) {
         return this.model.getNode(location);
     }
diff -urN -x '*.map' a/vs/base/browser/ui/tree/dataTree.js b/vs/base/browser/ui/tree/dataTree.js
--- a/vs/base/browser/ui/tree/dataTree.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/ui/tree/dataTree.js	2023-12-06 14:23:14.347854727 +0000
@@ -4,13 +4,115 @@
  *--------------------------------------------------------------------------------------------*/
 import { AbstractTree } from './abstractTree.js';
 import { ObjectTreeModel } from './objectTreeModel.js';
+import { TreeError } from './tree.js';
+import { Iterable } from '../../../common/iterator.js';
 export class DataTree extends AbstractTree {
     constructor(user, container, delegate, renderers, dataSource, options = {}) {
         super(user, container, delegate, renderers, options);
         this.user = user;
         this.dataSource = dataSource;
+        this.nodesByIdentity = new Map();
         this.identityProvider = options.identityProvider;
     }
+    // Model
+    getInput() {
+        return this.input;
+    }
+    setInput(input, viewState) {
+        if (viewState && !this.identityProvider) {
+            throw new TreeError(this.user, 'Can\'t restore tree view state without an identity provider');
+        }
+        this.input = input;
+        if (!input) {
+            this.nodesByIdentity.clear();
+            this.model.setChildren(null, Iterable.empty());
+            return;
+        }
+        if (!viewState) {
+            this._refresh(input);
+            return;
+        }
+        const focus = [];
+        const selection = [];
+        const isCollapsed = (element) => {
+            const id = this.identityProvider.getId(element).toString();
+            return !viewState.expanded[id];
+        };
+        const onDidCreateNode = (node) => {
+            const id = this.identityProvider.getId(node.element).toString();
+            if (viewState.focus.has(id)) {
+                focus.push(node.element);
+            }
+            if (viewState.selection.has(id)) {
+                selection.push(node.element);
+            }
+        };
+        this._refresh(input, isCollapsed, onDidCreateNode);
+        this.setFocus(focus);
+        this.setSelection(selection);
+        if (viewState && typeof viewState.scrollTop === 'number') {
+            this.scrollTop = viewState.scrollTop;
+        }
+    }
+    updateChildren(element = this.input) {
+        if (typeof this.input === 'undefined') {
+            throw new TreeError(this.user, 'Tree input not set');
+        }
+        let isCollapsed;
+        if (this.identityProvider) {
+            isCollapsed = element => {
+                const id = this.identityProvider.getId(element).toString();
+                const node = this.nodesByIdentity.get(id);
+                if (!node) {
+                    return undefined;
+                }
+                return node.collapsed;
+            };
+        }
+        this._refresh(element, isCollapsed);
+    }
+    resort(element = this.input, recursive = true) {
+        this.model.resort((element === this.input ? null : element), recursive);
+    }
+    // View
+    refresh(element) {
+        if (element === undefined) {
+            this.view.rerender();
+            return;
+        }
+        this.model.rerender(element);
+    }
+    // Implementation
+    _refresh(element, isCollapsed, onDidCreateNode) {
+        let onDidDeleteNode;
+        if (this.identityProvider) {
+            const insertedElements = new Set();
+            const outerOnDidCreateNode = onDidCreateNode;
+            onDidCreateNode = (node) => {
+                const id = this.identityProvider.getId(node.element).toString();
+                insertedElements.add(id);
+                this.nodesByIdentity.set(id, node);
+                outerOnDidCreateNode?.(node);
+            };
+            onDidDeleteNode = (node) => {
+                const id = this.identityProvider.getId(node.element).toString();
+                if (!insertedElements.has(id)) {
+                    this.nodesByIdentity.delete(id);
+                }
+            };
+        }
+        this.model.setChildren((element === this.input ? null : element), this.iterate(element, isCollapsed).elements, { onDidCreateNode, onDidDeleteNode });
+    }
+    iterate(element, isCollapsed) {
+        const children = [...this.dataSource.getChildren(element)];
+        const elements = Iterable.map(children, element => {
+            const { elements: children, size } = this.iterate(element, isCollapsed);
+            const collapsible = this.dataSource.hasChildren ? this.dataSource.hasChildren(element) : undefined;
+            const collapsed = size === 0 ? undefined : (isCollapsed && isCollapsed(element));
+            return { element, children, collapsible, collapsed };
+        });
+        return { elements, size: children.length };
+    }
     createModel(user, view, options) {
         return new ObjectTreeModel(user, view, options);
     }
diff -urN -x '*.map' a/vs/base/browser/ui/tree/indexTreeModel.js b/vs/base/browser/ui/tree/indexTreeModel.js
--- a/vs/base/browser/ui/tree/indexTreeModel.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/ui/tree/indexTreeModel.js	2023-12-06 14:23:14.347854727 +0000
@@ -64,10 +64,7 @@
             this.spliceSimple(location, deleteCount, toInsert, options);
         }
     }
-    spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {
-        var _a;
-        if (toInsertIterable === void 0) { toInsertIterable = Iterable.empty(); }
-        if (recurseLevels === void 0) { recurseLevels = (_a = options.diffDepth) !== null && _a !== void 0 ? _a : 0; }
+    spliceSmart(identity, location, deleteCount, toInsertIterable = Iterable.empty(), options, recurseLevels = options.diffDepth ?? 0) {
         const { parentNode } = this.getParentNodeWithListIndex(location);
         if (!parentNode.lastDiffIds) {
             return this.spliceSimple(location, deleteCount, toInsertIterable, options);
@@ -197,6 +194,13 @@
             this.list.splice(listIndex, 1, [node]);
         }
     }
+    updateElementHeight(location, height) {
+        if (location.length === 0) {
+            throw new TreeError(this.user, 'Invalid tree location');
+        }
+        const { listIndex } = this.getTreeNodeWithListIndex(location);
+        this.list.updateElementHeight(listIndex, height);
+    }
     has(location) {
         return this.hasTreeNode(location);
     }
@@ -353,7 +357,7 @@
         else if (!node.collapsed) {
             node.renderNodeCount = renderNodeCount;
         }
-        onDidCreateNode === null || onDidCreateNode === void 0 ? void 0 : onDidCreateNode(node);
+        onDidCreateNode?.(node);
         return node;
     }
     updateNodeAfterCollapseChange(node) {
@@ -536,4 +540,17 @@
         }
         return node.children[0].element;
     }
+    getLastElementAncestor(location = []) {
+        const node = this.getTreeNode(location);
+        if (node.children.length === 0) {
+            return undefined;
+        }
+        return this._getLastElementAncestor(node);
+    }
+    _getLastElementAncestor(node) {
+        if (node.children.length === 0) {
+            return node.element;
+        }
+        return this._getLastElementAncestor(node.children[node.children.length - 1]);
+    }
 }
diff -urN -x '*.map' a/vs/base/browser/ui/tree/objectTree.js b/vs/base/browser/ui/tree/objectTree.js
--- a/vs/base/browser/ui/tree/objectTree.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/ui/tree/objectTree.js	2023-12-06 14:23:14.347854727 +0000
@@ -29,6 +29,12 @@
         }
         this.model.rerender(element);
     }
+    updateElementHeight(element, height) {
+        this.model.updateElementHeight(element, height);
+    }
+    resort(element, recursive = true) {
+        this.model.resort(element, recursive);
+    }
     hasElement(element) {
         return this.model.has(element);
     }
@@ -64,12 +70,11 @@
         }
     }
     disposeElement(node, index, templateData, height) {
-        var _a, _b, _c, _d;
         if (templateData.compressedTreeNode) {
-            (_b = (_a = this.renderer).disposeCompressedElements) === null || _b === void 0 ? void 0 : _b.call(_a, templateData.compressedTreeNode, index, templateData.data, height);
+            this.renderer.disposeCompressedElements?.(templateData.compressedTreeNode, index, templateData.data, height);
         }
         else {
-            (_d = (_c = this.renderer).disposeElement) === null || _d === void 0 ? void 0 : _d.call(_c, node, index, templateData.data, height);
+            this.renderer.disposeElement?.(node, index, templateData.data, height);
         }
     }
     disposeTemplate(templateData) {
@@ -86,13 +91,15 @@
     memoize
 ], CompressibleRenderer.prototype, "compressedTreeNodeProvider", null);
 function asObjectTreeOptions(compressedTreeNodeProvider, options) {
-    return options && Object.assign(Object.assign({}, options), { keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {
+    return options && {
+        ...options,
+        keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {
             getKeyboardNavigationLabel(e) {
                 let compressedTreeNode;
                 try {
                     compressedTreeNode = compressedTreeNodeProvider().getCompressedTreeNode(e);
                 }
-                catch (_a) {
+                catch {
                     return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e);
                 }
                 if (compressedTreeNode.element.elements.length === 1) {
@@ -102,7 +109,8 @@
                     return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(compressedTreeNode.element.elements);
                 }
             }
-        } });
+        }
+    };
 }
 export class CompressibleObjectTree extends ObjectTree {
     constructor(user, container, delegate, renderers, options = {}) {
diff -urN -x '*.map' a/vs/base/browser/ui/tree/objectTreeModel.js b/vs/base/browser/ui/tree/objectTreeModel.js
--- a/vs/base/browser/ui/tree/objectTreeModel.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/ui/tree/objectTreeModel.js	2023-12-06 14:23:14.347854727 +0000
@@ -6,6 +6,7 @@
 import { ObjectTreeElementCollapseState, TreeError } from './tree.js';
 import { Iterable } from '../../../common/iterator.js';
 export class ObjectTreeModel {
+    get size() { return this.nodes.size; }
     constructor(user, list, options = {}) {
         this.user = user;
         this.rootRef = null;
@@ -32,7 +33,6 @@
         const insertedElements = new Set();
         const insertedElementIds = new Set();
         const onDidCreateNode = (node) => {
-            var _a;
             if (node.element === null) {
                 return;
             }
@@ -44,10 +44,9 @@
                 insertedElementIds.add(id);
                 this.nodesByIdentity.set(id, tnode);
             }
-            (_a = options.onDidCreateNode) === null || _a === void 0 ? void 0 : _a.call(options, tnode);
+            options.onDidCreateNode?.(tnode);
         };
         const onDidDeleteNode = (node) => {
-            var _a;
             if (node.element === null) {
                 return;
             }
@@ -61,9 +60,9 @@
                     this.nodesByIdentity.delete(id);
                 }
             }
-            (_a = options.onDidDeleteNode) === null || _a === void 0 ? void 0 : _a.call(options, tnode);
+            options.onDidDeleteNode?.(tnode);
         };
-        this.model.splice([...location, 0], Number.MAX_VALUE, children, Object.assign(Object.assign({}, options), { onDidCreateNode, onDidDeleteNode }));
+        this.model.splice([...location, 0], Number.MAX_VALUE, children, { ...options, onDidCreateNode, onDidDeleteNode });
     }
     preserveCollapseState(elements = Iterable.empty()) {
         if (this.sorter) {
@@ -89,7 +88,11 @@
                 else {
                     collapsed = Boolean(treeElement.collapsed);
                 }
-                return Object.assign(Object.assign({}, treeElement), { children: this.preserveCollapseState(treeElement.children), collapsed });
+                return {
+                    ...treeElement,
+                    children: this.preserveCollapseState(treeElement.children),
+                    collapsed
+                };
             }
             const collapsible = typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : node.collapsible;
             let collapsed;
@@ -105,18 +108,50 @@
             else {
                 collapsed = Boolean(treeElement.collapsed);
             }
-            return Object.assign(Object.assign({}, treeElement), { collapsible,
-                collapsed, children: this.preserveCollapseState(treeElement.children) });
+            return {
+                ...treeElement,
+                collapsible,
+                collapsed,
+                children: this.preserveCollapseState(treeElement.children)
+            };
         });
     }
     rerender(element) {
         const location = this.getElementLocation(element);
         this.model.rerender(location);
     }
+    updateElementHeight(element, height) {
+        const location = this.getElementLocation(element);
+        this.model.updateElementHeight(location, height);
+    }
+    resort(element = null, recursive = true) {
+        if (!this.sorter) {
+            return;
+        }
+        const location = this.getElementLocation(element);
+        const node = this.model.getNode(location);
+        this._setChildren(location, this.resortChildren(node, recursive), {});
+    }
+    resortChildren(node, recursive, first = true) {
+        let childrenNodes = [...node.children];
+        if (recursive || first) {
+            childrenNodes = childrenNodes.sort(this.sorter.compare.bind(this.sorter));
+        }
+        return Iterable.map(childrenNodes, node => ({
+            element: node.element,
+            collapsible: node.collapsible,
+            collapsed: node.collapsed,
+            children: this.resortChildren(node, recursive, false)
+        }));
+    }
     getFirstElementChild(ref = null) {
         const location = this.getElementLocation(ref);
         return this.model.getFirstElementChild(location);
     }
+    getLastElementAncestor(ref = null) {
+        const location = this.getElementLocation(ref);
+        return this.model.getLastElementAncestor(location);
+    }
     has(element) {
         return this.nodes.has(element);
     }
diff -urN -x '*.map' a/vs/base/browser/ui/tree/tree.js b/vs/base/browser/ui/tree/tree.js
--- a/vs/base/browser/ui/tree/tree.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/browser/ui/tree/tree.js	2023-12-06 14:23:14.347854727 +0000
@@ -22,6 +22,12 @@
     TreeMouseEventTarget[TreeMouseEventTarget["Element"] = 2] = "Element";
     TreeMouseEventTarget[TreeMouseEventTarget["Filter"] = 3] = "Filter";
 })(TreeMouseEventTarget || (TreeMouseEventTarget = {}));
+export const TreeDragOverReactions = {
+    acceptBubbleUp() { return { accept: true, bubble: 1 /* TreeDragOverBubble.Up */ }; },
+    acceptBubbleDown(autoExpand = false) { return { accept: true, bubble: 0 /* TreeDragOverBubble.Down */, autoExpand }; },
+    acceptCopyBubbleUp() { return { accept: true, bubble: 1 /* TreeDragOverBubble.Up */, effect: 0 /* ListDragOverEffect.Copy */ }; },
+    acceptCopyBubbleDown(autoExpand = false) { return { accept: true, bubble: 0 /* TreeDragOverBubble.Down */, effect: 0 /* ListDragOverEffect.Copy */, autoExpand }; }
+};
 export class TreeError extends Error {
     constructor(user, message) {
         super(`TreeError [${user}] ${message}`);
diff -urN -x '*.map' a/vs/base/browser/ui/widget.js b/vs/base/browser/ui/widget.js
--- a/vs/base/browser/ui/widget.js	2023-12-06 14:22:33.827782458 +0000
+++ b/vs/base/browser/ui/widget.js	2023-12-06 14:23:14.343854719 +0000
@@ -35,6 +35,9 @@
     onfocus(domNode, listener) {
         this._register(dom.addDisposableListener(domNode, dom.EventType.FOCUS, listener));
     }
+    onchange(domNode, listener) {
+        this._register(dom.addDisposableListener(domNode, dom.EventType.CHANGE, listener));
+    }
     ignoreGesture(domNode) {
         return Gesture.ignoreTarget(domNode);
     }
diff -urN -x '*.map' a/vs/base/common/actions.js b/vs/base/common/actions.js
--- a/vs/base/common/actions.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/actions.js	2023-12-06 14:23:14.347854727 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { Emitter } from './event.js';
 import { Disposable } from './lifecycle.js';
 import * as nls from '../../nls.js';
@@ -89,12 +80,10 @@
             this._onDidChange.fire({ checked: value });
         }
     }
-    run(event, data) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (this._actionCallback) {
-                yield this._actionCallback(event);
-            }
-        });
+    async run(event, data) {
+        if (this._actionCallback) {
+            await this._actionCallback(event);
+        }
     }
 }
 export class ActionRunner extends Disposable {
@@ -105,26 +94,22 @@
         this._onDidRun = this._register(new Emitter());
         this.onDidRun = this._onDidRun.event;
     }
-    run(action, context) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!action.enabled) {
-                return;
-            }
-            this._onWillRun.fire({ action });
-            let error = undefined;
-            try {
-                yield this.runAction(action, context);
-            }
-            catch (e) {
-                error = e;
-            }
-            this._onDidRun.fire({ action, error });
-        });
+    async run(action, context) {
+        if (!action.enabled) {
+            return;
+        }
+        this._onWillRun.fire({ action });
+        let error = undefined;
+        try {
+            await this.runAction(action, context);
+        }
+        catch (e) {
+            error = e;
+        }
+        this._onDidRun.fire({ action, error });
     }
-    runAction(action, context) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield action.run(context);
-        });
+    async runAction(action, context) {
+        await action.run(context);
     }
 }
 export class Separator {
@@ -154,9 +139,7 @@
         }
         return out;
     }
-    run() {
-        return __awaiter(this, void 0, void 0, function* () { });
-    }
+    async run() { }
 }
 Separator.ID = 'vs.actions.separator';
 export class SubmenuAction {
@@ -170,25 +153,22 @@
         this.class = cssClass;
         this._actions = actions;
     }
-    run() {
-        return __awaiter(this, void 0, void 0, function* () { });
-    }
+    async run() { }
 }
 export class EmptySubmenuAction extends Action {
     constructor() {
-        super(EmptySubmenuAction.ID, nls.localize('submenu.empty', '(empty)'), undefined, false);
+        super(EmptySubmenuAction.ID, nls.localizeWithPath('vs/base/common/actions', 'submenu.empty', '(empty)'), undefined, false);
     }
 }
 EmptySubmenuAction.ID = 'vs.actions.empty';
 export function toAction(props) {
-    var _a, _b;
     return {
         id: props.id,
         label: props.label,
         class: undefined,
-        enabled: (_a = props.enabled) !== null && _a !== void 0 ? _a : true,
-        checked: (_b = props.checked) !== null && _b !== void 0 ? _b : false,
-        run: (...args) => __awaiter(this, void 0, void 0, function* () { return props.run(...args); }),
+        enabled: props.enabled ?? true,
+        checked: props.checked ?? false,
+        run: async (...args) => props.run(...args),
         tooltip: props.label
     };
 }
diff -urN -x '*.map' a/vs/base/common/arrays.js b/vs/base/common/arrays.js
--- a/vs/base/common/arrays.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/arrays.js	2023-12-06 14:23:14.347854727 +0000
@@ -1,3 +1,9 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { CancellationError } from './errors.js';
+import { findFirstIdxMonotonousOrArrLen } from './arraysFind.js';
 /**
  * Returns the last element of an array.
  * @param array The array.
@@ -166,6 +172,133 @@
     }
 }
 /**
+ * Diffs two *sorted* arrays and computes the splices which apply the diff.
+ */
+export function sortedDiff(before, after, compare) {
+    const result = [];
+    function pushSplice(start, deleteCount, toInsert) {
+        if (deleteCount === 0 && toInsert.length === 0) {
+            return;
+        }
+        const latest = result[result.length - 1];
+        if (latest && latest.start + latest.deleteCount === start) {
+            latest.deleteCount += deleteCount;
+            latest.toInsert.push(...toInsert);
+        }
+        else {
+            result.push({ start, deleteCount, toInsert });
+        }
+    }
+    let beforeIdx = 0;
+    let afterIdx = 0;
+    while (true) {
+        if (beforeIdx === before.length) {
+            pushSplice(beforeIdx, 0, after.slice(afterIdx));
+            break;
+        }
+        if (afterIdx === after.length) {
+            pushSplice(beforeIdx, before.length - beforeIdx, []);
+            break;
+        }
+        const beforeElement = before[beforeIdx];
+        const afterElement = after[afterIdx];
+        const n = compare(beforeElement, afterElement);
+        if (n === 0) {
+            // equal
+            beforeIdx += 1;
+            afterIdx += 1;
+        }
+        else if (n < 0) {
+            // beforeElement is smaller -> before element removed
+            pushSplice(beforeIdx, 1, []);
+            beforeIdx += 1;
+        }
+        else if (n > 0) {
+            // beforeElement is greater -> after element added
+            pushSplice(beforeIdx, 0, [afterElement]);
+            afterIdx += 1;
+        }
+    }
+    return result;
+}
+/**
+ * Takes two *sorted* arrays and computes their delta (removed, added elements).
+ * Finishes in `Math.min(before.length, after.length)` steps.
+ */
+export function delta(before, after, compare) {
+    const splices = sortedDiff(before, after, compare);
+    const removed = [];
+    const added = [];
+    for (const splice of splices) {
+        removed.push(...before.slice(splice.start, splice.start + splice.deleteCount));
+        added.push(...splice.toInsert);
+    }
+    return { removed, added };
+}
+/**
+ * Returns the top N elements from the array.
+ *
+ * Faster than sorting the entire array when the array is a lot larger than N.
+ *
+ * @param array The unsorted array.
+ * @param compare A sort function for the elements.
+ * @param n The number of elements to return.
+ * @return The first n elements from array when sorted with compare.
+ */
+export function top(array, compare, n) {
+    if (n === 0) {
+        return [];
+    }
+    const result = array.slice(0, n).sort(compare);
+    topStep(array, compare, result, n, array.length);
+    return result;
+}
+/**
+ * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.
+ *
+ * Returns the top N elements from the array.
+ *
+ * Faster than sorting the entire array when the array is a lot larger than N.
+ *
+ * @param array The unsorted array.
+ * @param compare A sort function for the elements.
+ * @param n The number of elements to return.
+ * @param batch The number of elements to examine before yielding to the event loop.
+ * @return The first n elements from array when sorted with compare.
+ */
+export function topAsync(array, compare, n, batch, token) {
+    if (n === 0) {
+        return Promise.resolve([]);
+    }
+    return new Promise((resolve, reject) => {
+        (async () => {
+            const o = array.length;
+            const result = array.slice(0, n).sort(compare);
+            for (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {
+                if (i > n) {
+                    await new Promise(resolve => setTimeout(resolve)); // any other delay function would starve I/O
+                }
+                if (token && token.isCancellationRequested) {
+                    throw new CancellationError();
+                }
+                topStep(array, compare, result, i, m);
+            }
+            return result;
+        })()
+            .then(resolve, reject);
+    });
+}
+function topStep(array, compare, result, i, m) {
+    for (const n = result.length; i < m; i++) {
+        const element = array[i];
+        if (compare(element, result[n - 1]) < 0) {
+            result.pop();
+            const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
+            result.splice(j, 0, element);
+        }
+    }
+}
+/**
  * @returns New array with all falsy values removed. The original array IS NOT modified.
  */
 export function coalesce(array) {
@@ -185,6 +318,12 @@
     array.length = to;
 }
 /**
+ * @deprecated Use `Array.copyWithin` instead
+ */
+export function move(array, from, to) {
+    array.splice(to, 0, array.splice(from, 1)[0]);
+}
+/**
  * @returns false if the provided object is an array and not empty.
  */
 export function isFalsyOrEmpty(obj) {
@@ -208,9 +347,36 @@
         return true;
     });
 }
+export function uniqueFilter(keyFn) {
+    const seen = new Set();
+    return element => {
+        const key = keyFn(element);
+        if (seen.has(key)) {
+            return false;
+        }
+        seen.add(key);
+        return true;
+    };
+}
 export function firstOrDefault(array, notFoundValue) {
     return array.length > 0 ? array[0] : notFoundValue;
 }
+export function lastOrDefault(array, notFoundValue) {
+    return array.length > 0 ? array[array.length - 1] : notFoundValue;
+}
+export function commonPrefixLength(one, other, equals = (a, b) => a === b) {
+    let result = 0;
+    for (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {
+        result++;
+    }
+    return result;
+}
+/**
+ * @deprecated Use `[].flat()`
+ */
+export function flatten(arr) {
+    return [].concat(...arr);
+}
 export function range(arg, to) {
     let from = typeof to === 'number' ? arg : 0;
     if (typeof to === 'number') {
@@ -233,6 +399,35 @@
     }
     return result;
 }
+export function index(array, indexer, mapper) {
+    return array.reduce((r, t) => {
+        r[indexer(t)] = mapper ? mapper(t) : t;
+        return r;
+    }, Object.create(null));
+}
+/**
+ * Inserts an element into an array. Returns a function which, when
+ * called, will remove that element from the array.
+ *
+ * @deprecated In almost all cases, use a `Set<T>` instead.
+ */
+export function insert(array, element) {
+    array.push(element);
+    return () => remove(array, element);
+}
+/**
+ * Removes an element from an array if it can be found.
+ *
+ * @deprecated In almost all cases, use a `Set<T>` instead.
+ */
+export function remove(array, element) {
+    const index = array.indexOf(element);
+    if (index > -1) {
+        array.splice(index, 1);
+        return element;
+    }
+    return undefined;
+}
 /**
  * Insert `insertArr` inside `target` at `insertIndex`.
  * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array
@@ -243,6 +438,30 @@
     return before.concat(insertArr, after);
 }
 /**
+ * Uses Fisher-Yates shuffle to shuffle the given array
+ */
+export function shuffle(array, _seed) {
+    let rand;
+    if (typeof _seed === 'number') {
+        let seed = _seed;
+        // Seeded random number generator in JS. Modified from:
+        // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
+        rand = () => {
+            const x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias
+            return x - Math.floor(x);
+        };
+    }
+    else {
+        rand = Math.random;
+    }
+    for (let i = array.length - 1; i > 0; i -= 1) {
+        const j = Math.floor(rand() * (i + 1));
+        const temp = array[i];
+        array[i] = array[j];
+        array[j] = temp;
+    }
+}
+/**
  * Pushes an element to the start of the array, if found.
  */
 export function pushToStart(arr, value) {
@@ -267,9 +486,17 @@
         arr.push(item);
     }
 }
+export function mapArrayOrNot(items, fn) {
+    return Array.isArray(items) ?
+        items.map(fn) :
+        fn(items);
+}
 export function asArray(x) {
     return Array.isArray(x) ? x : [x];
 }
+export function getRandomElement(arr) {
+    return arr[Math.floor(Math.random() * arr.length)];
+}
 /**
  * Insert the new items in the array.
  * @param array The original array.
@@ -410,11 +637,22 @@
         }
         return this.items[this.firstIdx];
     }
+    peekLast() {
+        if (this.length === 0) {
+            return undefined;
+        }
+        return this.items[this.lastIdx];
+    }
     dequeue() {
         const result = this.items[this.firstIdx];
         this.firstIdx++;
         return result;
     }
+    removeLast() {
+        const result = this.items[this.lastIdx];
+        this.lastIdx--;
+        return result;
+    }
     takeCount(count) {
         const result = this.items.slice(this.firstIdx, this.firstIdx + count);
         this.firstIdx += count;
@@ -433,6 +671,9 @@
     iterate) {
         this.iterate = iterate;
     }
+    forEach(handler) {
+        this.iterate(item => { handler(item); return true; });
+    }
     toArray() {
         const result = [];
         this.iterate(item => { result.push(item); return true; });
@@ -444,6 +685,22 @@
     map(mapFn) {
         return new CallbackIterable(cb => this.iterate(item => cb(mapFn(item))));
     }
+    some(predicate) {
+        let result = false;
+        this.iterate(item => { result = predicate(item); return !result; });
+        return result;
+    }
+    findFirst(predicate) {
+        let result;
+        this.iterate(item => {
+            if (predicate(item)) {
+                result = item;
+                return false;
+            }
+            return true;
+        });
+        return result;
+    }
     findLast(predicate) {
         let result;
         this.iterate(item => {
diff -urN -x '*.map' a/vs/base/common/arraysFind.js b/vs/base/common/arraysFind.js
--- a/vs/base/common/arraysFind.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/arraysFind.js	2023-12-06 14:23:14.347854727 +0000
@@ -78,6 +78,10 @@
     }
     return i;
 }
+export function findFirstIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {
+    const idx = findFirstIdxMonotonousOrArrLen(array, predicate, startIdx, endIdxEx);
+    return idx === array.length ? -1 : idx;
+}
 /**
  * Use this when
  * * You have a sorted array
diff -urN -x '*.map' a/vs/base/common/assert.js b/vs/base/common/assert.js
--- a/vs/base/common/assert.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/assert.js	2023-12-06 14:23:14.347854727 +0000
@@ -25,6 +25,11 @@
 export function assertNever(value, message = 'Unreachable') {
     throw new Error(message);
 }
+export function assert(condition) {
+    if (!condition) {
+        throw new BugIndicatingError('Assertion Failed');
+    }
+}
 /**
  * condition must be side-effect free!
  */
diff -urN -x '*.map' a/vs/base/common/async.js b/vs/base/common/async.js
--- a/vs/base/common/async.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/async.js	2023-12-06 14:23:14.347854727 +0000
@@ -2,26 +2,11 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __asyncValues = (this && this.__asyncValues) || function (o) {
-    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
-    var m = o[Symbol.asyncIterator], i;
-    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
-    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
-    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
-};
 import { CancellationTokenSource } from './cancellation.js';
 import { CancellationError } from './errors.js';
 import { Emitter, Event } from './event.js';
-import { toDisposable } from './lifecycle.js';
+import { Disposable, DisposableMap, MutableDisposable, toDisposable } from './lifecycle.js';
+import { extUri as defaultExtUri } from './resources.js';
 import { setTimeout0 } from './platform.js';
 import { MicrotaskDelay } from './symbols.js';
 export function isThenable(obj) {
@@ -71,6 +56,59 @@
     });
 }
 /**
+ * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.
+ * @see {@link raceCancellation}
+ */
+export function raceCancellationError(promise, token) {
+    return new Promise((resolve, reject) => {
+        const ref = token.onCancellationRequested(() => {
+            ref.dispose();
+            reject(new CancellationError());
+        });
+        promise.then(resolve, reject).finally(() => ref.dispose());
+    });
+}
+/**
+ * Returns as soon as one of the promises resolves or rejects and cancels remaining promises
+ */
+export async function raceCancellablePromises(cancellablePromises) {
+    let resolvedPromiseIndex = -1;
+    const promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));
+    try {
+        const result = await Promise.race(promises);
+        return result;
+    }
+    finally {
+        cancellablePromises.forEach((cancellablePromise, index) => {
+            if (index !== resolvedPromiseIndex) {
+                cancellablePromise.cancel();
+            }
+        });
+    }
+}
+export function raceTimeout(promise, timeout, onTimeout) {
+    let promiseResolve = undefined;
+    const timer = setTimeout(() => {
+        promiseResolve?.(undefined);
+        onTimeout?.();
+    }, timeout);
+    return Promise.race([
+        promise.finally(() => clearTimeout(timer)),
+        new Promise(resolve => promiseResolve = resolve)
+    ]);
+}
+export function asPromise(callback) {
+    return new Promise((resolve, reject) => {
+        const item = callback();
+        if (isThenable(item)) {
+            item.then(resolve, reject);
+        }
+        else {
+            resolve(item);
+        }
+    });
+}
+/**
  * A helper to prevent accumulation of sequential async tasks.
  *
  * Imagine a mail man with the sole task of delivering letters. As soon as
@@ -142,6 +180,32 @@
         this.isDisposed = true;
     }
 }
+export class Sequencer {
+    constructor() {
+        this.current = Promise.resolve(null);
+    }
+    queue(promiseTask) {
+        return this.current = this.current.then(() => promiseTask(), () => promiseTask());
+    }
+}
+export class SequencerByKey {
+    constructor() {
+        this.promiseMap = new Map();
+    }
+    queue(key, promiseTask) {
+        const runningPromise = this.promiseMap.get(key) ?? Promise.resolve();
+        const newPromise = runningPromise
+            .catch(() => { })
+            .then(promiseTask)
+            .finally(() => {
+            if (this.promiseMap.get(key) === newPromise) {
+                this.promiseMap.delete(key);
+            }
+        });
+        this.promiseMap.set(key, newPromise);
+        return newPromise;
+    }
+}
 const timeoutDeferred = (timeout, fn) => {
     let scheduled = true;
     const handle = setTimeout(() => {
@@ -220,28 +284,24 @@
             });
         }
         const fn = () => {
-            var _a;
             this.deferred = null;
-            (_a = this.doResolve) === null || _a === void 0 ? void 0 : _a.call(this, null);
+            this.doResolve?.(null);
         };
         this.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);
         return this.completionPromise;
     }
     isTriggered() {
-        var _a;
-        return !!((_a = this.deferred) === null || _a === void 0 ? void 0 : _a.isTriggered());
+        return !!this.deferred?.isTriggered();
     }
     cancel() {
-        var _a;
         this.cancelTimeout();
         if (this.completionPromise) {
-            (_a = this.doReject) === null || _a === void 0 ? void 0 : _a.call(this, new CancellationError());
+            this.doReject?.(new CancellationError());
             this.completionPromise = null;
         }
     }
     cancelTimeout() {
-        var _a;
-        (_a = this.deferred) === null || _a === void 0 ? void 0 : _a.dispose();
+        this.deferred?.dispose();
         this.deferred = null;
     }
     dispose() {
@@ -265,6 +325,9 @@
     trigger(promiseFactory, delay) {
         return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);
     }
+    isTriggered() {
+        return this.delayer.isTriggered();
+    }
     cancel() {
         this.delayer.cancel();
     }
@@ -273,6 +336,41 @@
         this.throttler.dispose();
     }
 }
+/**
+ * A barrier that is initially closed and then becomes opened permanently.
+ */
+export class Barrier {
+    constructor() {
+        this._isOpen = false;
+        this._promise = new Promise((c, e) => {
+            this._completePromise = c;
+        });
+    }
+    isOpen() {
+        return this._isOpen;
+    }
+    open() {
+        this._isOpen = true;
+        this._completePromise(true);
+    }
+    wait() {
+        return this._promise;
+    }
+}
+/**
+ * A barrier that is initially closed and then becomes opened permanently after a certain period of
+ * time or when open is called explicitly
+ */
+export class AutoOpenBarrier extends Barrier {
+    constructor(autoOpenTimeMs) {
+        super();
+        this._timeout = setTimeout(() => this.open(), autoOpenTimeMs);
+    }
+    open() {
+        clearTimeout(this._timeout);
+        super.open();
+    }
+}
 export function timeout(millis, token) {
     if (!token) {
         return createCancelablePromise(token => timeout(millis, token));
@@ -315,11 +413,34 @@
     }, timeout);
     const disposable = toDisposable(() => {
         clearTimeout(timer);
-        store === null || store === void 0 ? void 0 : store.deleteAndLeak(disposable);
+        store?.deleteAndLeak(disposable);
     });
-    store === null || store === void 0 ? void 0 : store.add(disposable);
+    store?.add(disposable);
     return disposable;
 }
+/**
+ * Runs the provided list of promise factories in sequential order. The returned
+ * promise will complete to an array of results from each promise.
+ */
+export function sequence(promiseFactories) {
+    const results = [];
+    let index = 0;
+    const len = promiseFactories.length;
+    function next() {
+        return index < len ? promiseFactories[index++]() : null;
+    }
+    function thenHandler(result) {
+        if (result !== undefined && result !== null) {
+            results.push(result);
+        }
+        const n = next();
+        if (n) {
+            return n.then(thenHandler);
+        }
+        return Promise.resolve(results);
+    }
+    return Promise.resolve(null).then(thenHandler);
+}
 export function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {
     let index = 0;
     const len = promiseFactories.length;
@@ -338,6 +459,201 @@
     };
     return loop();
 }
+export function firstParallel(promiseList, shouldStop = t => !!t, defaultValue = null) {
+    if (promiseList.length === 0) {
+        return Promise.resolve(defaultValue);
+    }
+    let todo = promiseList.length;
+    const finish = () => {
+        todo = -1;
+        for (const promise of promiseList) {
+            promise.cancel?.();
+        }
+    };
+    return new Promise((resolve, reject) => {
+        for (const promise of promiseList) {
+            promise.then(result => {
+                if (--todo >= 0 && shouldStop(result)) {
+                    finish();
+                    resolve(result);
+                }
+                else if (todo === 0) {
+                    resolve(defaultValue);
+                }
+            })
+                .catch(err => {
+                if (--todo >= 0) {
+                    finish();
+                    reject(err);
+                }
+            });
+        }
+    });
+}
+/**
+ * A helper to queue N promises and run them all with a max degree of parallelism. The helper
+ * ensures that at any time no more than M promises are running at the same time.
+ */
+export class Limiter {
+    constructor(maxDegreeOfParalellism) {
+        this._size = 0;
+        this.maxDegreeOfParalellism = maxDegreeOfParalellism;
+        this.outstandingPromises = [];
+        this.runningPromises = 0;
+        this._onDrained = new Emitter();
+    }
+    /**
+     * An event that fires when every promise in the queue
+     * has started to execute. In other words: no work is
+     * pending to be scheduled.
+     *
+     * This is NOT an event that signals when all promises
+     * have finished though.
+     */
+    get onDrained() {
+        return this._onDrained.event;
+    }
+    get size() {
+        return this._size;
+    }
+    queue(factory) {
+        this._size++;
+        return new Promise((c, e) => {
+            this.outstandingPromises.push({ factory, c, e });
+            this.consume();
+        });
+    }
+    consume() {
+        while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {
+            const iLimitedTask = this.outstandingPromises.shift();
+            this.runningPromises++;
+            const promise = iLimitedTask.factory();
+            promise.then(iLimitedTask.c, iLimitedTask.e);
+            promise.then(() => this.consumed(), () => this.consumed());
+        }
+    }
+    consumed() {
+        this._size--;
+        this.runningPromises--;
+        if (this.outstandingPromises.length > 0) {
+            this.consume();
+        }
+        else {
+            this._onDrained.fire();
+        }
+    }
+    dispose() {
+        this._onDrained.dispose();
+    }
+}
+/**
+ * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.
+ */
+export class Queue extends Limiter {
+    constructor() {
+        super(1);
+    }
+}
+/**
+ * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that
+ * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will
+ * replace the currently queued task until it executes.
+ *
+ * As such, the returned promise may not be from the factory that is passed in but from the next factory that
+ * is running after having called `queue`.
+ */
+export class LimitedQueue {
+    constructor() {
+        this.sequentializer = new TaskSequentializer();
+        this.tasks = 0;
+    }
+    queue(factory) {
+        if (!this.sequentializer.isRunning()) {
+            return this.sequentializer.run(this.tasks++, factory());
+        }
+        return this.sequentializer.queue(() => {
+            return this.sequentializer.run(this.tasks++, factory());
+        });
+    }
+}
+/**
+ * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource
+ * by disposing them once the queue is empty.
+ */
+export class ResourceQueue {
+    constructor() {
+        this.queues = new Map();
+        this.drainers = new Set();
+        this.drainListeners = undefined;
+        this.drainListenerCount = 0;
+    }
+    async whenDrained() {
+        if (this.isDrained()) {
+            return;
+        }
+        const promise = new DeferredPromise();
+        this.drainers.add(promise);
+        return promise.p;
+    }
+    isDrained() {
+        for (const [, queue] of this.queues) {
+            if (queue.size > 0) {
+                return false;
+            }
+        }
+        return true;
+    }
+    queueFor(resource, extUri = defaultExtUri) {
+        const key = extUri.getComparisonKey(resource);
+        let queue = this.queues.get(key);
+        if (!queue) {
+            queue = new Queue();
+            const drainListenerId = this.drainListenerCount++;
+            const drainListener = Event.once(queue.onDrained)(() => {
+                queue?.dispose();
+                this.queues.delete(key);
+                this.onDidQueueDrain();
+                this.drainListeners?.deleteAndDispose(drainListenerId);
+                if (this.drainListeners?.size === 0) {
+                    this.drainListeners.dispose();
+                    this.drainListeners = undefined;
+                }
+            });
+            if (!this.drainListeners) {
+                this.drainListeners = new DisposableMap();
+            }
+            this.drainListeners.set(drainListenerId, drainListener);
+            this.queues.set(key, queue);
+        }
+        return queue;
+    }
+    onDidQueueDrain() {
+        if (!this.isDrained()) {
+            return; // not done yet
+        }
+        this.releaseDrainers();
+    }
+    releaseDrainers() {
+        for (const drainer of this.drainers) {
+            drainer.complete();
+        }
+        this.drainers.clear();
+    }
+    dispose() {
+        for (const [, queue] of this.queues) {
+            queue.dispose();
+        }
+        this.queues.clear();
+        // Even though we might still have pending
+        // tasks queued, after the queues have been
+        // disposed, we can no longer track them, so
+        // we release drainers to prevent hanging
+        // promises when the resource queue is being
+        // disposed.
+        this.releaseDrainers();
+        this.drainListeners?.dispose();
+    }
+}
 export class TimeoutTimer {
     constructor(runner, timeout) {
         this._token = -1;
@@ -434,6 +750,12 @@
     isScheduled() {
         return this.timeoutToken !== -1;
     }
+    flush() {
+        if (this.isScheduled()) {
+            this.cancel();
+            this.doRun();
+        }
+    }
     onTimeout() {
         this.timeoutToken = -1;
         if (this.runner) {
@@ -441,8 +763,165 @@
         }
     }
     doRun() {
-        var _a;
-        (_a = this.runner) === null || _a === void 0 ? void 0 : _a.call(this);
+        this.runner?.();
+    }
+}
+/**
+ * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.
+ * > **NOTE**: Only offers 1s resolution.
+ *
+ * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep
+ * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But
+ * this scheduler will execute 3hrs **after waking the computer from sleep**.
+ */
+export class ProcessTimeRunOnceScheduler {
+    constructor(runner, delay) {
+        if (delay % 1000 !== 0) {
+            console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);
+        }
+        this.runner = runner;
+        this.timeout = delay;
+        this.counter = 0;
+        this.intervalToken = -1;
+        this.intervalHandler = this.onInterval.bind(this);
+    }
+    dispose() {
+        this.cancel();
+        this.runner = null;
+    }
+    cancel() {
+        if (this.isScheduled()) {
+            clearInterval(this.intervalToken);
+            this.intervalToken = -1;
+        }
+    }
+    /**
+     * Cancel previous runner (if any) & schedule a new runner.
+     */
+    schedule(delay = this.timeout) {
+        if (delay % 1000 !== 0) {
+            console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);
+        }
+        this.cancel();
+        this.counter = Math.ceil(delay / 1000);
+        this.intervalToken = setInterval(this.intervalHandler, 1000);
+    }
+    /**
+     * Returns true if scheduled.
+     */
+    isScheduled() {
+        return this.intervalToken !== -1;
+    }
+    onInterval() {
+        this.counter--;
+        if (this.counter > 0) {
+            // still need to wait
+            return;
+        }
+        // time elapsed
+        clearInterval(this.intervalToken);
+        this.intervalToken = -1;
+        this.runner?.();
+    }
+}
+export class RunOnceWorker extends RunOnceScheduler {
+    constructor(runner, timeout) {
+        super(runner, timeout);
+        this.units = [];
+    }
+    work(unit) {
+        this.units.push(unit);
+        if (!this.isScheduled()) {
+            this.schedule();
+        }
+    }
+    doRun() {
+        const units = this.units;
+        this.units = [];
+        this.runner?.(units);
+    }
+    dispose() {
+        this.units = [];
+        super.dispose();
+    }
+}
+/**
+ * The `ThrottledWorker` will accept units of work `T`
+ * to handle. The contract is:
+ * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)
+ * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)
+ * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)
+ */
+export class ThrottledWorker extends Disposable {
+    constructor(options, handler) {
+        super();
+        this.options = options;
+        this.handler = handler;
+        this.pendingWork = [];
+        this.throttler = this._register(new MutableDisposable());
+        this.disposed = false;
+    }
+    /**
+     * The number of work units that are pending to be processed.
+     */
+    get pending() { return this.pendingWork.length; }
+    /**
+     * Add units to be worked on. Use `pending` to figure out
+     * how many units are not yet processed after this method
+     * was called.
+     *
+     * @returns whether the work was accepted or not. If the
+     * worker is disposed, it will not accept any more work.
+     * If the number of pending units would become larger
+     * than `maxPendingWork`, more work will also not be accepted.
+     */
+    work(units) {
+        if (this.disposed) {
+            return false; // work not accepted: disposed
+        }
+        // Check for reaching maximum of pending work
+        if (typeof this.options.maxBufferedWork === 'number') {
+            // Throttled: simple check if pending + units exceeds max pending
+            if (this.throttler.value) {
+                if (this.pending + units.length > this.options.maxBufferedWork) {
+                    return false; // work not accepted: too much pending work
+                }
+            }
+            // Unthrottled: same as throttled, but account for max chunk getting
+            // worked on directly without being pending
+            else {
+                if (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {
+                    return false; // work not accepted: too much pending work
+                }
+            }
+        }
+        // Add to pending units first
+        for (const unit of units) {
+            this.pendingWork.push(unit);
+        }
+        // If not throttled, start working directly
+        // Otherwise, when the throttle delay has
+        // past, pending work will be worked again.
+        if (!this.throttler.value) {
+            this.doWork();
+        }
+        return true; // work accepted
+    }
+    doWork() {
+        // Extract chunk to handle and handle it
+        this.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));
+        // If we have remaining work, schedule it after a delay
+        if (this.pendingWork.length > 0) {
+            this.throttler.value = new RunOnceScheduler(() => {
+                this.throttler.clear();
+                this.doWork();
+            }, this.options.throttleDelay);
+            this.throttler.value.schedule();
+        }
+    }
+    dispose() {
+        super.dispose();
+        this.disposed = true;
     }
 }
 /**
@@ -543,17 +1022,138 @@
         return this._didRun;
     }
 }
+//#endregion
+export async function retry(task, delay, retries) {
+    let lastError;
+    for (let i = 0; i < retries; i++) {
+        try {
+            return await task();
+        }
+        catch (error) {
+            lastError = error;
+            await timeout(delay);
+        }
+    }
+    throw lastError;
+}
+/**
+ * @deprecated use `LimitedQueue` instead for an easier to use API
+ */
+export class TaskSequentializer {
+    isRunning(taskId) {
+        if (typeof taskId === 'number') {
+            return this._running?.taskId === taskId;
+        }
+        return !!this._running;
+    }
+    get running() {
+        return this._running?.promise;
+    }
+    cancelRunning() {
+        this._running?.cancel();
+    }
+    run(taskId, promise, onCancel) {
+        this._running = { taskId, cancel: () => onCancel?.(), promise };
+        promise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));
+        return promise;
+    }
+    doneRunning(taskId) {
+        if (this._running && taskId === this._running.taskId) {
+            // only set running to done if the promise finished that is associated with that taskId
+            this._running = undefined;
+            // schedule the queued task now that we are free if we have any
+            this.runQueued();
+        }
+    }
+    runQueued() {
+        if (this._queued) {
+            const queued = this._queued;
+            this._queued = undefined;
+            // Run queued task and complete on the associated promise
+            queued.run().then(queued.promiseResolve, queued.promiseReject);
+        }
+    }
+    /**
+     * Note: the promise to schedule as next run MUST itself call `run`.
+     *       Otherwise, this sequentializer will report `false` for `isRunning`
+     *       even when this task is running. Missing this detail means that
+     *       suddenly multiple tasks will run in parallel.
+     */
+    queue(run) {
+        // this is our first queued task, so we create associated promise with it
+        // so that we can return a promise that completes when the task has
+        // completed.
+        if (!this._queued) {
+            let promiseResolve;
+            let promiseReject;
+            const promise = new Promise((resolve, reject) => {
+                promiseResolve = resolve;
+                promiseReject = reject;
+            });
+            this._queued = {
+                run,
+                promise,
+                promiseResolve: promiseResolve,
+                promiseReject: promiseReject
+            };
+        }
+        // we have a previous queued task, just overwrite it
+        else {
+            this._queued.run = run;
+        }
+        return this._queued.promise;
+    }
+    hasQueued() {
+        return !!this._queued;
+    }
+    async join() {
+        return this._queued?.promise ?? this._running?.promise;
+    }
+}
+//#endregion
+//#region
+/**
+ * The `IntervalCounter` allows to count the number
+ * of calls to `increment()` over a duration of
+ * `interval`. This utility can be used to conditionally
+ * throttle a frequent task when a certain threshold
+ * is reached.
+ */
+export class IntervalCounter {
+    constructor(interval, nowFn = () => Date.now()) {
+        this.interval = interval;
+        this.nowFn = nowFn;
+        this.lastIncrementTime = 0;
+        this.value = 0;
+    }
+    increment() {
+        const now = this.nowFn();
+        // We are outside of the range of `interval` and as such
+        // start counting from 0 and remember the time
+        if (now - this.lastIncrementTime > this.interval) {
+            this.lastIncrementTime = now;
+            this.value = 0;
+        }
+        this.value++;
+        return this.value;
+    }
+}
 /**
  * Creates a promise whose resolution or rejection can be controlled imperatively.
  */
 export class DeferredPromise {
     get isRejected() {
-        var _a;
-        return ((_a = this.outcome) === null || _a === void 0 ? void 0 : _a.outcome) === 1 /* DeferredOutcome.Rejected */;
+        return this.outcome?.outcome === 1 /* DeferredOutcome.Rejected */;
+    }
+    get isResolved() {
+        return this.outcome?.outcome === 0 /* DeferredOutcome.Resolved */;
     }
     get isSettled() {
         return !!this.outcome;
     }
+    get value() {
+        return this.outcome?.outcome === 0 /* DeferredOutcome.Resolved */ ? this.outcome?.value : undefined;
+    }
     constructor() {
         this.p = new Promise((c, e) => {
             this.completeCallback = c;
@@ -589,20 +1189,18 @@
      * Similar to `Promise.all`, only the first error will be returned
      * if any.
      */
-    function settled(promises) {
-        return __awaiter(this, void 0, void 0, function* () {
-            let firstError = undefined;
-            const result = yield Promise.all(promises.map(promise => promise.then(value => value, error => {
-                if (!firstError) {
-                    firstError = error;
-                }
-                return undefined; // do not rethrow so that other promises can settle
-            })));
-            if (typeof firstError !== 'undefined') {
-                throw firstError;
+    async function settled(promises) {
+        let firstError = undefined;
+        const result = await Promise.all(promises.map(promise => promise.then(value => value, error => {
+            if (!firstError) {
+                firstError = error;
             }
-            return result; // cast is needed and protected by the `throw` above
-        });
+            return undefined; // do not rethrow so that other promises can settle
+        })));
+        if (typeof firstError !== 'undefined') {
+            throw firstError;
+        }
+        return result; // cast is needed and protected by the `throw` above
     }
     Promises.settled = settled;
     /**
@@ -617,14 +1215,14 @@
      */
     function withAsyncBody(bodyFn) {
         // eslint-disable-next-line no-async-promise-executor
-        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
+        return new Promise(async (resolve, reject) => {
             try {
-                yield bodyFn(resolve, reject);
+                await bodyFn(resolve, reject);
             }
             catch (error) {
                 reject(error);
             }
-        }));
+        });
     }
     Promises.withAsyncBody = withAsyncBody;
 })(Promises || (Promises = {}));
@@ -638,50 +1236,37 @@
         });
     }
     static fromPromise(promise) {
-        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {
-            emitter.emitMany(yield promise);
-        }));
+        return new AsyncIterableObject(async (emitter) => {
+            emitter.emitMany(await promise);
+        });
     }
     static fromPromises(promises) {
-        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {
-            yield Promise.all(promises.map((p) => __awaiter(this, void 0, void 0, function* () { return emitter.emitOne(yield p); })));
-        }));
+        return new AsyncIterableObject(async (emitter) => {
+            await Promise.all(promises.map(async (p) => emitter.emitOne(await p)));
+        });
     }
     static merge(iterables) {
-        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {
-            yield Promise.all(iterables.map((iterable) => { var _a, iterable_1, iterable_1_1; return __awaiter(this, void 0, void 0, function* () {
-                var _b, e_1, _c, _d;
-                try {
-                    for (_a = true, iterable_1 = __asyncValues(iterable); iterable_1_1 = yield iterable_1.next(), _b = iterable_1_1.done, !_b; _a = true) {
-                        _d = iterable_1_1.value;
-                        _a = false;
-                        const item = _d;
-                        emitter.emitOne(item);
-                    }
-                }
-                catch (e_1_1) { e_1 = { error: e_1_1 }; }
-                finally {
-                    try {
-                        if (!_a && !_b && (_c = iterable_1.return)) yield _c.call(iterable_1);
-                    }
-                    finally { if (e_1) throw e_1.error; }
+        return new AsyncIterableObject(async (emitter) => {
+            await Promise.all(iterables.map(async (iterable) => {
+                for await (const item of iterable) {
+                    emitter.emitOne(item);
                 }
-            }); }));
-        }));
+            }));
+        });
     }
     constructor(executor) {
         this._state = 0 /* AsyncIterableSourceState.Initial */;
         this._results = [];
         this._error = null;
         this._onStateChanged = new Emitter();
-        queueMicrotask(() => __awaiter(this, void 0, void 0, function* () {
+        queueMicrotask(async () => {
             const writer = {
                 emitOne: (item) => this.emitOne(item),
                 emitMany: (items) => this.emitMany(items),
                 reject: (error) => this.reject(error)
             };
             try {
-                yield Promise.resolve(executor(writer));
+                await Promise.resolve(executor(writer));
                 this.resolve();
             }
             catch (err) {
@@ -692,12 +1277,12 @@
                 writer.emitMany = undefined;
                 writer.reject = undefined;
             }
-        }));
+        });
     }
     [Symbol.asyncIterator]() {
         let i = 0;
         return {
-            next: () => __awaiter(this, void 0, void 0, function* () {
+            next: async () => {
                 do {
                     if (this._state === 2 /* AsyncIterableSourceState.DoneError */) {
                         throw this._error;
@@ -708,55 +1293,29 @@
                     if (this._state === 1 /* AsyncIterableSourceState.DoneOK */) {
                         return { done: true, value: undefined };
                     }
-                    yield Event.toPromise(this._onStateChanged.event);
+                    await Event.toPromise(this._onStateChanged.event);
                 } while (true);
-            })
+            }
         };
     }
     static map(iterable, mapFn) {
-        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {
-            var _a, e_2, _b, _c;
-            try {
-                for (var _d = true, iterable_2 = __asyncValues(iterable), iterable_2_1; iterable_2_1 = yield iterable_2.next(), _a = iterable_2_1.done, !_a; _d = true) {
-                    _c = iterable_2_1.value;
-                    _d = false;
-                    const item = _c;
-                    emitter.emitOne(mapFn(item));
-                }
+        return new AsyncIterableObject(async (emitter) => {
+            for await (const item of iterable) {
+                emitter.emitOne(mapFn(item));
             }
-            catch (e_2_1) { e_2 = { error: e_2_1 }; }
-            finally {
-                try {
-                    if (!_d && !_a && (_b = iterable_2.return)) yield _b.call(iterable_2);
-                }
-                finally { if (e_2) throw e_2.error; }
-            }
-        }));
+        });
     }
     map(mapFn) {
         return AsyncIterableObject.map(this, mapFn);
     }
     static filter(iterable, filterFn) {
-        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {
-            var _a, e_3, _b, _c;
-            try {
-                for (var _d = true, iterable_3 = __asyncValues(iterable), iterable_3_1; iterable_3_1 = yield iterable_3.next(), _a = iterable_3_1.done, !_a; _d = true) {
-                    _c = iterable_3_1.value;
-                    _d = false;
-                    const item = _c;
-                    if (filterFn(item)) {
-                        emitter.emitOne(item);
-                    }
-                }
-            }
-            catch (e_3_1) { e_3 = { error: e_3_1 }; }
-            finally {
-                try {
-                    if (!_d && !_a && (_b = iterable_3.return)) yield _b.call(iterable_3);
+        return new AsyncIterableObject(async (emitter) => {
+            for await (const item of iterable) {
+                if (filterFn(item)) {
+                    emitter.emitOne(item);
                 }
-                finally { if (e_3) throw e_3.error; }
             }
-        }));
+        });
     }
     filter(filterFn) {
         return AsyncIterableObject.filter(this, filterFn);
@@ -767,28 +1326,12 @@
     coalesce() {
         return AsyncIterableObject.coalesce(this);
     }
-    static toPromise(iterable) {
-        var _a, iterable_4, iterable_4_1;
-        var _b, e_4, _c, _d;
-        return __awaiter(this, void 0, void 0, function* () {
-            const result = [];
-            try {
-                for (_a = true, iterable_4 = __asyncValues(iterable); iterable_4_1 = yield iterable_4.next(), _b = iterable_4_1.done, !_b; _a = true) {
-                    _d = iterable_4_1.value;
-                    _a = false;
-                    const item = _d;
-                    result.push(item);
-                }
-            }
-            catch (e_4_1) { e_4 = { error: e_4_1 }; }
-            finally {
-                try {
-                    if (!_a && !_b && (_c = iterable_4.return)) yield _c.call(iterable_4);
-                }
-                finally { if (e_4) throw e_4.error; }
-            }
-            return result;
-        });
+    static async toPromise(iterable) {
+        const result = [];
+        for await (const item of iterable) {
+            result.push(item);
+        }
+        return result;
     }
     toPromise() {
         return AsyncIterableObject.toPromise(this);
@@ -862,32 +1405,19 @@
 export function createCancelableAsyncIterable(callback) {
     const source = new CancellationTokenSource();
     const innerIterable = callback(source.token);
-    return new CancelableAsyncIterableObject(source, (emitter) => __awaiter(this, void 0, void 0, function* () {
-        var _a, e_5, _b, _c;
+    return new CancelableAsyncIterableObject(source, async (emitter) => {
         const subscription = source.token.onCancellationRequested(() => {
             subscription.dispose();
             source.dispose();
             emitter.reject(new CancellationError());
         });
         try {
-            try {
-                for (var _d = true, innerIterable_1 = __asyncValues(innerIterable), innerIterable_1_1; innerIterable_1_1 = yield innerIterable_1.next(), _a = innerIterable_1_1.done, !_a; _d = true) {
-                    _c = innerIterable_1_1.value;
-                    _d = false;
-                    const item = _c;
-                    if (source.token.isCancellationRequested) {
-                        // canceled in the meantime
-                        return;
-                    }
-                    emitter.emitOne(item);
-                }
-            }
-            catch (e_5_1) { e_5 = { error: e_5_1 }; }
-            finally {
-                try {
-                    if (!_d && !_a && (_b = innerIterable_1.return)) yield _b.call(innerIterable_1);
+            for await (const item of innerIterable) {
+                if (source.token.isCancellationRequested) {
+                    // canceled in the meantime
+                    return;
                 }
-                finally { if (e_5) throw e_5.error; }
+                emitter.emitOne(item);
             }
             subscription.dispose();
             source.dispose();
@@ -897,6 +1427,6 @@
             source.dispose();
             emitter.reject(err);
         }
-    }));
+    });
 }
 //#endregion
diff -urN -x '*.map' a/vs/base/common/buffer.js b/vs/base/common/buffer.js
--- a/vs/base/common/buffer.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/buffer.js	2023-12-06 14:23:14.347854727 +0000
@@ -3,11 +3,25 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { Lazy } from './lazy.js';
+import * as streams from './stream.js';
 const hasBuffer = (typeof Buffer !== 'undefined');
 const indexOfTable = new Lazy(() => new Uint8Array(256));
+let textEncoder;
 let textDecoder;
 export class VSBuffer {
     /**
+     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
+     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
+     */
+    static alloc(byteLength) {
+        if (hasBuffer) {
+            return new VSBuffer(Buffer.allocUnsafe(byteLength));
+        }
+        else {
+            return new VSBuffer(new Uint8Array(byteLength));
+        }
+    }
+    /**
      * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
      * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
      * which is not transferrable.
@@ -20,10 +34,66 @@
         }
         return new VSBuffer(actual);
     }
+    /**
+     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
+     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
+     */
+    static fromString(source, options) {
+        const dontUseNodeBuffer = options?.dontUseNodeBuffer || false;
+        if (!dontUseNodeBuffer && hasBuffer) {
+            return new VSBuffer(Buffer.from(source));
+        }
+        else {
+            if (!textEncoder) {
+                textEncoder = new TextEncoder();
+            }
+            return new VSBuffer(textEncoder.encode(source));
+        }
+    }
+    /**
+     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
+     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
+     */
+    static fromByteArray(source) {
+        const result = VSBuffer.alloc(source.length);
+        for (let i = 0, len = source.length; i < len; i++) {
+            result.buffer[i] = source[i];
+        }
+        return result;
+    }
+    /**
+     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
+     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
+     */
+    static concat(buffers, totalLength) {
+        if (typeof totalLength === 'undefined') {
+            totalLength = 0;
+            for (let i = 0, len = buffers.length; i < len; i++) {
+                totalLength += buffers[i].byteLength;
+            }
+        }
+        const ret = VSBuffer.alloc(totalLength);
+        let offset = 0;
+        for (let i = 0, len = buffers.length; i < len; i++) {
+            const element = buffers[i];
+            ret.set(element, offset);
+            offset += element.byteLength;
+        }
+        return ret;
+    }
     constructor(buffer) {
         this.buffer = buffer;
         this.byteLength = this.buffer.byteLength;
     }
+    /**
+     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
+     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
+     */
+    clone() {
+        const result = VSBuffer.alloc(this.byteLength);
+        result.set(this);
+        return result;
+    }
     toString() {
         if (hasBuffer) {
             return this.buffer.toString();
@@ -35,6 +105,91 @@
             return textDecoder.decode(this.buffer);
         }
     }
+    slice(start, end) {
+        // IMPORTANT: use subarray instead of slice because TypedArray#slice
+        // creates shallow copy and NodeBuffer#slice doesn't. The use of subarray
+        // ensures the same, performance, behaviour.
+        return new VSBuffer(this.buffer.subarray(start, end));
+    }
+    set(array, offset) {
+        if (array instanceof VSBuffer) {
+            this.buffer.set(array.buffer, offset);
+        }
+        else if (array instanceof Uint8Array) {
+            this.buffer.set(array, offset);
+        }
+        else if (array instanceof ArrayBuffer) {
+            this.buffer.set(new Uint8Array(array), offset);
+        }
+        else if (ArrayBuffer.isView(array)) {
+            this.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);
+        }
+        else {
+            throw new Error(`Unknown argument 'array'`);
+        }
+    }
+    readUInt32BE(offset) {
+        return readUInt32BE(this.buffer, offset);
+    }
+    writeUInt32BE(value, offset) {
+        writeUInt32BE(this.buffer, value, offset);
+    }
+    readUInt32LE(offset) {
+        return readUInt32LE(this.buffer, offset);
+    }
+    writeUInt32LE(value, offset) {
+        writeUInt32LE(this.buffer, value, offset);
+    }
+    readUInt8(offset) {
+        return readUInt8(this.buffer, offset);
+    }
+    writeUInt8(value, offset) {
+        writeUInt8(this.buffer, value, offset);
+    }
+    indexOf(subarray, offset = 0) {
+        return binaryIndexOf(this.buffer, subarray instanceof VSBuffer ? subarray.buffer : subarray, offset);
+    }
+}
+/**
+ * Like String.indexOf, but works on Uint8Arrays.
+ * Uses the boyer-moore-horspool algorithm to be reasonably speedy.
+ */
+export function binaryIndexOf(haystack, needle, offset = 0) {
+    const needleLen = needle.byteLength;
+    const haystackLen = haystack.byteLength;
+    if (needleLen === 0) {
+        return 0;
+    }
+    if (needleLen === 1) {
+        return haystack.indexOf(needle[0]);
+    }
+    if (needleLen > haystackLen - offset) {
+        return -1;
+    }
+    // find index of the subarray using boyer-moore-horspool algorithm
+    const table = indexOfTable.value;
+    table.fill(needle.length);
+    for (let i = 0; i < needle.length; i++) {
+        table[needle[i]] = needle.length - i - 1;
+    }
+    let i = offset + needle.length - 1;
+    let j = i;
+    let result = -1;
+    while (i < haystackLen) {
+        if (haystack[i] === needle[j]) {
+            if (j === 0) {
+                result = i;
+                break;
+            }
+            i--;
+            j--;
+        }
+        else {
+            i += Math.max(needle.length - j, table[haystack[i]]);
+            j = needle.length - 1;
+        }
+    }
+    return result;
 }
 export function readUInt16LE(source, offset) {
     return (((source[offset + 0] << 0) >>> 0) |
@@ -46,9 +201,9 @@
     destination[offset + 1] = (value & 0b11111111);
 }
 export function readUInt32BE(source, offset) {
-    return (source[offset] * Math.pow(2, 24)
-        + source[offset + 1] * Math.pow(2, 16)
-        + source[offset + 2] * Math.pow(2, 8)
+    return (source[offset] * 2 ** 24
+        + source[offset + 1] * 2 ** 16
+        + source[offset + 2] * 2 ** 8
         + source[offset + 3]);
 }
 export function writeUInt32BE(destination, value, offset) {
@@ -60,9 +215,158 @@
     value = value >>> 8;
     destination[offset] = value;
 }
+export function readUInt32LE(source, offset) {
+    return (((source[offset + 0] << 0) >>> 0) |
+        ((source[offset + 1] << 8) >>> 0) |
+        ((source[offset + 2] << 16) >>> 0) |
+        ((source[offset + 3] << 24) >>> 0));
+}
+export function writeUInt32LE(destination, value, offset) {
+    destination[offset + 0] = (value & 0b11111111);
+    value = value >>> 8;
+    destination[offset + 1] = (value & 0b11111111);
+    value = value >>> 8;
+    destination[offset + 2] = (value & 0b11111111);
+    value = value >>> 8;
+    destination[offset + 3] = (value & 0b11111111);
+}
 export function readUInt8(source, offset) {
     return source[offset];
 }
 export function writeUInt8(destination, value, offset) {
     destination[offset] = value;
 }
+export function readableToBuffer(readable) {
+    return streams.consumeReadable(readable, chunks => VSBuffer.concat(chunks));
+}
+export function bufferToReadable(buffer) {
+    return streams.toReadable(buffer);
+}
+export function streamToBuffer(stream) {
+    return streams.consumeStream(stream, chunks => VSBuffer.concat(chunks));
+}
+export async function bufferedStreamToBuffer(bufferedStream) {
+    if (bufferedStream.ended) {
+        return VSBuffer.concat(bufferedStream.buffer);
+    }
+    return VSBuffer.concat([
+        // Include already read chunks...
+        ...bufferedStream.buffer,
+        // ...and all additional chunks
+        await streamToBuffer(bufferedStream.stream)
+    ]);
+}
+export function bufferToStream(buffer) {
+    return streams.toStream(buffer, chunks => VSBuffer.concat(chunks));
+}
+export function streamToBufferReadableStream(stream) {
+    return streams.transform(stream, { data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data) }, chunks => VSBuffer.concat(chunks));
+}
+export function newWriteableBufferStream(options) {
+    return streams.newWriteableStream(chunks => VSBuffer.concat(chunks), options);
+}
+export function prefixedBufferReadable(prefix, readable) {
+    return streams.prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));
+}
+export function prefixedBufferStream(prefix, stream) {
+    return streams.prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));
+}
+/** Decodes base64 to a uint8 array. URL-encoded and unpadded base64 is allowed. */
+export function decodeBase64(encoded) {
+    let building = 0;
+    let remainder = 0;
+    let bufi = 0;
+    // The simpler way to do this is `Uint8Array.from(atob(str), c => c.charCodeAt(0))`,
+    // but that's about 10-20x slower than this function in current Chromium versions.
+    const buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));
+    const append = (value) => {
+        switch (remainder) {
+            case 3:
+                buffer[bufi++] = building | value;
+                remainder = 0;
+                break;
+            case 2:
+                buffer[bufi++] = building | (value >>> 2);
+                building = value << 6;
+                remainder = 3;
+                break;
+            case 1:
+                buffer[bufi++] = building | (value >>> 4);
+                building = value << 4;
+                remainder = 2;
+                break;
+            default:
+                building = value << 2;
+                remainder = 1;
+        }
+    };
+    for (let i = 0; i < encoded.length; i++) {
+        const code = encoded.charCodeAt(i);
+        // See https://datatracker.ietf.org/doc/html/rfc4648#section-4
+        // This branchy code is about 3x faster than an indexOf on a base64 char string.
+        if (code >= 65 && code <= 90) {
+            append(code - 65); // A-Z starts ranges from char code 65 to 90
+        }
+        else if (code >= 97 && code <= 122) {
+            append(code - 97 + 26); // a-z starts ranges from char code 97 to 122, starting at byte 26
+        }
+        else if (code >= 48 && code <= 57) {
+            append(code - 48 + 52); // 0-9 starts ranges from char code 48 to 58, starting at byte 52
+        }
+        else if (code === 43 || code === 45) {
+            append(62); // "+" or "-" for URLS
+        }
+        else if (code === 47 || code === 95) {
+            append(63); // "/" or "_" for URLS
+        }
+        else if (code === 61) {
+            break; // "="
+        }
+        else {
+            throw new SyntaxError(`Unexpected base64 character ${encoded[i]}`);
+        }
+    }
+    const unpadded = bufi;
+    while (remainder > 0) {
+        append(0);
+    }
+    // slice is needed to account for overestimation due to padding
+    return VSBuffer.wrap(buffer).slice(0, unpadded);
+}
+const base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
+const base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
+/** Encodes a buffer to a base64 string. */
+export function encodeBase64({ buffer }, padded = true, urlSafe = false) {
+    const dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;
+    let output = '';
+    const remainder = buffer.byteLength % 3;
+    let i = 0;
+    for (; i < buffer.byteLength - remainder; i += 3) {
+        const a = buffer[i + 0];
+        const b = buffer[i + 1];
+        const c = buffer[i + 2];
+        output += dictionary[a >>> 2];
+        output += dictionary[(a << 4 | b >>> 4) & 0b111111];
+        output += dictionary[(b << 2 | c >>> 6) & 0b111111];
+        output += dictionary[c & 0b111111];
+    }
+    if (remainder === 1) {
+        const a = buffer[i + 0];
+        output += dictionary[a >>> 2];
+        output += dictionary[(a << 4) & 0b111111];
+        if (padded) {
+            output += '==';
+        }
+    }
+    else if (remainder === 2) {
+        const a = buffer[i + 0];
+        const b = buffer[i + 1];
+        output += dictionary[a >>> 2];
+        output += dictionary[(a << 4 | b >>> 4) & 0b111111];
+        output += dictionary[(b << 2) & 0b111111];
+        if (padded) {
+            output += '=';
+        }
+    }
+    return output;
+}
diff -urN -x '*.map' a/vs/base/common/cache.js b/vs/base/common/cache.js
--- a/vs/base/common/cache.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/cache.js	2023-12-06 14:23:14.347854727 +0000
@@ -1,3 +1,30 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { CancellationTokenSource } from './cancellation.js';
+export class Cache {
+    constructor(task) {
+        this.task = task;
+        this.result = null;
+    }
+    get() {
+        if (this.result) {
+            return this.result;
+        }
+        const cts = new CancellationTokenSource();
+        const promise = this.task(cts.token);
+        this.result = {
+            promise,
+            dispose: () => {
+                this.result = null;
+                cts.cancel();
+                cts.dispose();
+            }
+        };
+        return this.result;
+    }
+}
 /**
  * Uses a LRU cache to make a given parametrized function cached.
  * Caches just the last value.
diff -urN -x '*.map' a/vs/base/common/cancellation.js b/vs/base/common/cancellation.js
--- a/vs/base/common/cancellation.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/cancellation.js	2023-12-06 14:23:14.347854727 +0000
@@ -92,11 +92,10 @@
         }
     }
     dispose(cancel = false) {
-        var _a;
         if (cancel) {
             this.cancel();
         }
-        (_a = this._parentListener) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._parentListener?.dispose();
         if (!this._token) {
             // ensure to initialize with an empty token if we had none
             this._token = CancellationToken.None;
diff -urN -x '*.map' a/vs/base/common/codicons.js b/vs/base/common/codicons.js
--- a/vs/base/common/codicons.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/codicons.js	2023-12-06 14:23:14.347854727 +0000
@@ -18,6 +18,12 @@
     return _codiconFontCharacters;
 }
 /**
+ * Only to be used by the iconRegistry.
+ */
+export function getAllCodicons() {
+    return Object.values(Codicon);
+}
+/**
  * The Codicon library is a set of default icons that are built-in in VS Code.
  *
  * In the product (outside of base) Codicons should only be used as defaults. In order to have all icons in VS Code
diff -urN -x '*.map' a/vs/base/common/collections.js b/vs/base/common/collections.js
--- a/vs/base/common/collections.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/collections.js	2023-12-06 14:23:14.347854727 +0000
@@ -2,6 +2,22 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+/**
+ * Groups the collection into a dictionary based on the provided
+ * group function.
+ */
+export function groupBy(data, groupFn) {
+    const result = Object.create(null);
+    for (const element of data) {
+        const key = groupFn(element);
+        let target = result[key];
+        if (!target) {
+            target = result[key] = [];
+        }
+        target.push(element);
+    }
+    return result;
+}
 export function diffSets(before, after) {
     const removed = [];
     const added = [];
@@ -16,6 +32,21 @@
         }
     }
     return { removed, added };
+}
+export function diffMaps(before, after) {
+    const removed = [];
+    const added = [];
+    for (const [index, value] of before) {
+        if (!after.has(index)) {
+            removed.push(value);
+        }
+    }
+    for (const [index, value] of after) {
+        if (!before.has(index)) {
+            added.push(value);
+        }
+    }
+    return { removed, added };
 }
 /**
  * Computes the intersection of two sets.
diff -urN -x '*.map' a/vs/base/common/color.js b/vs/base/common/color.js
--- a/vs/base/common/color.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/color.js	2023-12-06 14:23:14.347854727 +0000
@@ -242,6 +242,23 @@
         return (c <= 0.03928) ? c / 12.92 : Math.pow(((c + 0.055) / 1.055), 2.4);
     }
     /**
+     * http://www.w3.org/TR/WCAG20/#contrast-ratiodef
+     * Returns the contrast ration number in the set [1, 21].
+     */
+    getContrastRatio(another) {
+        const lum1 = this.getRelativeLuminance();
+        const lum2 = another.getRelativeLuminance();
+        return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);
+    }
+    /**
+     *	http://24ways.org/2010/calculating-color-contrast
+     *  Return 'true' if darker color otherwise 'false'
+     */
+    isDarker() {
+        const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;
+        return yiq < 128;
+    }
+    /**
      *	http://24ways.org/2010/calculating-color-contrast
      *  Return 'true' if lighter color otherwise 'false'
      */
@@ -278,6 +295,20 @@
     opposite() {
         return new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
     }
+    blend(c) {
+        const rgba = c.rgba;
+        // Convert to 0..1 opacity
+        const thisA = this.rgba.a;
+        const colorA = rgba.a;
+        const a = thisA + colorA * (1 - thisA);
+        if (a < 1e-6) {
+            return Color.transparent;
+        }
+        const r = this.rgba.r * thisA / a + rgba.r * colorA * (1 - thisA) / a;
+        const g = this.rgba.g * thisA / a + rgba.g * colorA * (1 - thisA) / a;
+        const b = this.rgba.b * thisA / a + rgba.b * colorA * (1 - thisA) / a;
+        return new Color(new RGBA(r, g, b, a));
+    }
     makeOpaque(opaqueBackground) {
         if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {
             // only allow to blend onto a non-opaque color onto a opaque color
@@ -287,6 +318,16 @@
         // https://stackoverflow.com/questions/12228548/finding-equivalent-color-with-opacity
         return new Color(new RGBA(opaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b), 1));
     }
+    flatten(...backgrounds) {
+        const background = backgrounds.reduceRight((accumulator, color) => {
+            return Color._flatten(color, accumulator);
+        });
+        return Color._flatten(this, background);
+    }
+    static _flatten(foreground, background) {
+        const backgroundAlpha = 1 - foreground.rgba.a;
+        return new Color(new RGBA(backgroundAlpha * background.rgba.r + foreground.rgba.a * foreground.rgba.r, backgroundAlpha * background.rgba.g + foreground.rgba.a * foreground.rgba.g, backgroundAlpha * background.rgba.b + foreground.rgba.a * foreground.rgba.b));
+    }
     toString() {
         if (!this._toString) {
             this._toString = Color.Format.CSS.format(this);
diff -urN -x '*.map' a/vs/base/common/comparers.js b/vs/base/common/comparers.js
--- a/vs/base/common/comparers.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/comparers.js	2023-12-06 14:23:14.351854734 +0000
@@ -3,6 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { Lazy } from './lazy.js';
+import { sep } from './path.js';
 // When comparing large numbers of strings it's better for performance to create an
 // Intl.Collator object and use the function provided by its compare property
 // than it is to use String.prototype.localeCompare()
@@ -39,6 +40,211 @@
     }
     return result;
 }
+/** Compares full filenames without grouping by case. */
+export function compareFileNamesDefault(one, other) {
+    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
+    one = one || '';
+    other = other || '';
+    return compareAndDisambiguateByLength(collatorNumeric, one, other);
+}
+/** Compares full filenames grouping uppercase names before lowercase. */
+export function compareFileNamesUpper(one, other) {
+    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
+    one = one || '';
+    other = other || '';
+    return compareCaseUpperFirst(one, other) || compareAndDisambiguateByLength(collatorNumeric, one, other);
+}
+/** Compares full filenames grouping lowercase names before uppercase. */
+export function compareFileNamesLower(one, other) {
+    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
+    one = one || '';
+    other = other || '';
+    return compareCaseLowerFirst(one, other) || compareAndDisambiguateByLength(collatorNumeric, one, other);
+}
+/** Compares full filenames by unicode value. */
+export function compareFileNamesUnicode(one, other) {
+    one = one || '';
+    other = other || '';
+    if (one === other) {
+        return 0;
+    }
+    return one < other ? -1 : 1;
+}
+/** Compares filenames by extension, then by name. Disambiguates by unicode comparison. */
+export function compareFileExtensions(one, other) {
+    const [oneName, oneExtension] = extractNameAndExtension(one);
+    const [otherName, otherExtension] = extractNameAndExtension(other);
+    let result = intlFileNameCollatorBaseNumeric.value.collator.compare(oneExtension, otherExtension);
+    if (result === 0) {
+        // Using the numeric option will  make compare(`foo1`, `foo01`) === 0. Disambiguate.
+        if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && oneExtension !== otherExtension) {
+            return oneExtension < otherExtension ? -1 : 1;
+        }
+        // Extensions are equal, compare filenames
+        result = intlFileNameCollatorBaseNumeric.value.collator.compare(oneName, otherName);
+        if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && oneName !== otherName) {
+            return oneName < otherName ? -1 : 1;
+        }
+    }
+    return result;
+}
+/** Compares filenames by extension, then by full filename. Mixes uppercase and lowercase names together. */
+export function compareFileExtensionsDefault(one, other) {
+    one = one || '';
+    other = other || '';
+    const oneExtension = extractExtension(one);
+    const otherExtension = extractExtension(other);
+    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
+    const collatorNumericCaseInsensitive = intlFileNameCollatorNumericCaseInsensitive.value.collator;
+    return compareAndDisambiguateByLength(collatorNumericCaseInsensitive, oneExtension, otherExtension) ||
+        compareAndDisambiguateByLength(collatorNumeric, one, other);
+}
+/** Compares filenames by extension, then case, then full filename. Groups uppercase names before lowercase. */
+export function compareFileExtensionsUpper(one, other) {
+    one = one || '';
+    other = other || '';
+    const oneExtension = extractExtension(one);
+    const otherExtension = extractExtension(other);
+    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
+    const collatorNumericCaseInsensitive = intlFileNameCollatorNumericCaseInsensitive.value.collator;
+    return compareAndDisambiguateByLength(collatorNumericCaseInsensitive, oneExtension, otherExtension) ||
+        compareCaseUpperFirst(one, other) ||
+        compareAndDisambiguateByLength(collatorNumeric, one, other);
+}
+/** Compares filenames by extension, then case, then full filename. Groups lowercase names before uppercase. */
+export function compareFileExtensionsLower(one, other) {
+    one = one || '';
+    other = other || '';
+    const oneExtension = extractExtension(one);
+    const otherExtension = extractExtension(other);
+    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
+    const collatorNumericCaseInsensitive = intlFileNameCollatorNumericCaseInsensitive.value.collator;
+    return compareAndDisambiguateByLength(collatorNumericCaseInsensitive, oneExtension, otherExtension) ||
+        compareCaseLowerFirst(one, other) ||
+        compareAndDisambiguateByLength(collatorNumeric, one, other);
+}
+/** Compares filenames by case-insensitive extension unicode value, then by full filename unicode value. */
+export function compareFileExtensionsUnicode(one, other) {
+    one = one || '';
+    other = other || '';
+    const oneExtension = extractExtension(one).toLowerCase();
+    const otherExtension = extractExtension(other).toLowerCase();
+    // Check for extension differences
+    if (oneExtension !== otherExtension) {
+        return oneExtension < otherExtension ? -1 : 1;
+    }
+    // Check for full filename differences.
+    if (one !== other) {
+        return one < other ? -1 : 1;
+    }
+    return 0;
+}
+const FileNameMatch = /^(.*?)(\.([^.]*))?$/;
+/** Extracts the name and extension from a full filename, with optional special handling for dotfiles */
+function extractNameAndExtension(str, dotfilesAsNames = false) {
+    const match = str ? FileNameMatch.exec(str) : [];
+    let result = [(match && match[1]) || '', (match && match[3]) || ''];
+    // if the dotfilesAsNames option is selected, treat an empty filename with an extension
+    // or a filename that starts with a dot, as a dotfile name
+    if (dotfilesAsNames && (!result[0] && result[1] || result[0] && result[0].charAt(0) === '.')) {
+        result = [result[0] + '.' + result[1], ''];
+    }
+    return result;
+}
+/** Extracts the extension from a full filename. Treats dotfiles as names, not extensions. */
+function extractExtension(str) {
+    const match = str ? FileNameMatch.exec(str) : [];
+    return (match && match[1] && match[1].charAt(0) !== '.' && match[3]) || '';
+}
+function compareAndDisambiguateByLength(collator, one, other) {
+    // Check for differences
+    const result = collator.compare(one, other);
+    if (result !== 0) {
+        return result;
+    }
+    // In a numeric comparison, `foo1` and `foo01` will compare as equivalent.
+    // Disambiguate by sorting the shorter string first.
+    if (one.length !== other.length) {
+        return one.length < other.length ? -1 : 1;
+    }
+    return 0;
+}
+/** @returns `true` if the string is starts with a lowercase letter. Otherwise, `false`. */
+function startsWithLower(string) {
+    const character = string.charAt(0);
+    return (character.toLocaleUpperCase() !== character) ? true : false;
+}
+/** @returns `true` if the string starts with an uppercase letter. Otherwise, `false`. */
+function startsWithUpper(string) {
+    const character = string.charAt(0);
+    return (character.toLocaleLowerCase() !== character) ? true : false;
+}
+/**
+ * Compares the case of the provided strings - lowercase before uppercase
+ *
+ * @returns
+ * ```text
+ *   -1 if one is lowercase and other is uppercase
+ *    1 if one is uppercase and other is lowercase
+ *    0 otherwise
+ * ```
+ */
+function compareCaseLowerFirst(one, other) {
+    if (startsWithLower(one) && startsWithUpper(other)) {
+        return -1;
+    }
+    return (startsWithUpper(one) && startsWithLower(other)) ? 1 : 0;
+}
+/**
+ * Compares the case of the provided strings - uppercase before lowercase
+ *
+ * @returns
+ * ```text
+ *   -1 if one is uppercase and other is lowercase
+ *    1 if one is lowercase and other is uppercase
+ *    0 otherwise
+ * ```
+ */
+function compareCaseUpperFirst(one, other) {
+    if (startsWithUpper(one) && startsWithLower(other)) {
+        return -1;
+    }
+    return (startsWithLower(one) && startsWithUpper(other)) ? 1 : 0;
+}
+function comparePathComponents(one, other, caseSensitive = false) {
+    if (!caseSensitive) {
+        one = one && one.toLowerCase();
+        other = other && other.toLowerCase();
+    }
+    if (one === other) {
+        return 0;
+    }
+    return one < other ? -1 : 1;
+}
+export function comparePaths(one, other, caseSensitive = false) {
+    const oneParts = one.split(sep);
+    const otherParts = other.split(sep);
+    const lastOne = oneParts.length - 1;
+    const lastOther = otherParts.length - 1;
+    let endOne, endOther;
+    for (let i = 0;; i++) {
+        endOne = lastOne === i;
+        endOther = lastOther === i;
+        if (endOne && endOther) {
+            return compareFileNames(oneParts[i], otherParts[i], caseSensitive);
+        }
+        else if (endOne) {
+            return -1;
+        }
+        else if (endOther) {
+            return 1;
+        }
+        const result = comparePathComponents(oneParts[i], otherParts[i], caseSensitive);
+        if (result !== 0) {
+            return result;
+        }
+    }
+}
 export function compareAnything(one, other, lookFor) {
     const elementAName = one.toLowerCase();
     const elementBName = other.toLowerCase();
diff -urN -x '*.map' a/vs/base/common/dataTransfer.js b/vs/base/common/dataTransfer.js
--- a/vs/base/common/dataTransfer.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/dataTransfer.js	2023-12-06 14:23:14.351854734 +0000
@@ -2,21 +2,12 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { distinct } from './arrays.js';
 import { Iterable } from './iterator.js';
 import { generateUuid } from './uuid.js';
 export function createStringDataTransferItem(stringOrPromise) {
     return {
-        asString: () => __awaiter(this, void 0, void 0, function* () { return stringOrPromise; }),
+        asString: async () => stringOrPromise,
         asFile: () => undefined,
         value: typeof stringOrPromise === 'string' ? stringOrPromise : undefined,
     };
@@ -24,7 +15,7 @@
 export function createFileDataTransferItem(fileName, uri, data) {
     const file = { id: generateUuid(), name: fileName, uri, data };
     return {
-        asString: () => __awaiter(this, void 0, void 0, function* () { return ''; }),
+        asString: async () => '',
         asFile: () => file,
         value: undefined,
     };
@@ -51,8 +42,7 @@
         return matchesMimeType_normalized(normalizeMimeType(pattern), mimes);
     }
     get(mimeType) {
-        var _a;
-        return (_a = this._entries.get(this.toKey(mimeType))) === null || _a === void 0 ? void 0 : _a[0];
+        return this._entries.get(this.toKey(mimeType))?.[0];
     }
     /**
      * Add a new entry to this data transfer.
diff -urN -x '*.map' a/vs/base/common/decorators.js b/vs/base/common/decorators.js
--- a/vs/base/common/decorators.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/decorators.js	2023-12-06 14:23:14.351854734 +0000
@@ -1,3 +1,25 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+function createDecorator(mapFn) {
+    return (target, key, descriptor) => {
+        let fnKey = null;
+        let fn = null;
+        if (typeof descriptor.value === 'function') {
+            fnKey = 'value';
+            fn = descriptor.value;
+        }
+        else if (typeof descriptor.get === 'function') {
+            fnKey = 'get';
+            fn = descriptor.get;
+        }
+        if (!fn) {
+            throw new Error('not supported');
+        }
+        descriptor[fnKey] = mapFn(fn, key);
+    };
+}
 export function memoize(_target, key, descriptor) {
     let fnKey = null;
     let fn = null;
@@ -28,3 +50,60 @@
         return this[memoizeKey];
     };
 }
+export function debounce(delay, reducer, initialValueProvider) {
+    return createDecorator((fn, key) => {
+        const timerKey = `$debounce$${key}`;
+        const resultKey = `$debounce$result$${key}`;
+        return function (...args) {
+            if (!this[resultKey]) {
+                this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
+            }
+            clearTimeout(this[timerKey]);
+            if (reducer) {
+                this[resultKey] = reducer(this[resultKey], ...args);
+                args = [this[resultKey]];
+            }
+            this[timerKey] = setTimeout(() => {
+                fn.apply(this, args);
+                this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
+            }, delay);
+        };
+    });
+}
+export function throttle(delay, reducer, initialValueProvider) {
+    return createDecorator((fn, key) => {
+        const timerKey = `$throttle$timer$${key}`;
+        const resultKey = `$throttle$result$${key}`;
+        const lastRunKey = `$throttle$lastRun$${key}`;
+        const pendingKey = `$throttle$pending$${key}`;
+        return function (...args) {
+            if (!this[resultKey]) {
+                this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
+            }
+            if (this[lastRunKey] === null || this[lastRunKey] === undefined) {
+                this[lastRunKey] = -Number.MAX_VALUE;
+            }
+            if (reducer) {
+                this[resultKey] = reducer(this[resultKey], ...args);
+            }
+            if (this[pendingKey]) {
+                return;
+            }
+            const nextTime = this[lastRunKey] + delay;
+            if (nextTime <= Date.now()) {
+                this[lastRunKey] = Date.now();
+                fn.apply(this, [this[resultKey]]);
+                this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
+            }
+            else {
+                this[pendingKey] = true;
+                this[timerKey] = setTimeout(() => {
+                    this[pendingKey] = false;
+                    this[lastRunKey] = Date.now();
+                    fn.apply(this, [this[resultKey]]);
+                    this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
+                }, nextTime - Date.now());
+            }
+        };
+    });
+}
diff -urN -x '*.map' a/vs/base/common/errorMessage.js b/vs/base/common/errorMessage.js
--- a/vs/base/common/errorMessage.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/errorMessage.js	2023-12-06 14:23:14.351854734 +0000
@@ -7,7 +7,7 @@
 import * as nls from '../../nls.js';
 function exceptionToErrorMessage(exception, verbose) {
     if (verbose && (exception.stack || exception.stacktrace)) {
-        return nls.localize('stackTrace.format', "{0}: {1}", detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));
+        return nls.localizeWithPath('vs/base/common/errorMessage', 'stackTrace.format', "{0}: {1}", detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));
     }
     return detectSystemErrorMessage(exception);
 }
@@ -24,9 +24,9 @@
     }
     // See https://nodejs.org/api/errors.html#errors_class_system_error
     if (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {
-        return nls.localize('nodeExceptionMessage', "A system error occurred ({0})", exception.message);
+        return nls.localizeWithPath('vs/base/common/errorMessage', 'nodeExceptionMessage', "A system error occurred ({0})", exception.message);
     }
-    return exception.message || nls.localize('error.defaultMessage', "An unknown error occurred. Please consult the log for more details.");
+    return exception.message || nls.localizeWithPath('vs/base/common/errorMessage', 'error.defaultMessage', "An unknown error occurred. Please consult the log for more details.");
 }
 /**
  * Tries to generate a human readable error message out of the error. If the verbose parameter
@@ -36,13 +36,13 @@
  */
 export function toErrorMessage(error = null, verbose = false) {
     if (!error) {
-        return nls.localize('error.defaultMessage', "An unknown error occurred. Please consult the log for more details.");
+        return nls.localizeWithPath('vs/base/common/errorMessage', 'error.defaultMessage', "An unknown error occurred. Please consult the log for more details.");
     }
     if (Array.isArray(error)) {
         const errors = arrays.coalesce(error);
         const msg = toErrorMessage(errors[0], verbose);
         if (errors.length > 1) {
-            return nls.localize('error.moreErrors', "{0} ({1} errors in total)", msg, errors.length);
+            return nls.localizeWithPath('vs/base/common/errorMessage', 'error.moreErrors', "{0} ({1} errors in total)", msg, errors.length);
         }
         return msg;
     }
@@ -64,5 +64,20 @@
     if (error.message) {
         return error.message;
     }
-    return nls.localize('error.defaultMessage', "An unknown error occurred. Please consult the log for more details.");
+    return nls.localizeWithPath('vs/base/common/errorMessage', 'error.defaultMessage', "An unknown error occurred. Please consult the log for more details.");
+}
+export function isErrorWithActions(obj) {
+    const candidate = obj;
+    return candidate instanceof Error && Array.isArray(candidate.actions);
+}
+export function createErrorWithActions(messageOrError, actions) {
+    let error;
+    if (typeof messageOrError === 'string') {
+        error = new Error(messageOrError);
+    }
+    else {
+        error = messageOrError;
+    }
+    error.actions = actions;
+    return error;
 }
diff -urN -x '*.map' a/vs/base/common/errors.js b/vs/base/common/errors.js
--- a/vs/base/common/errors.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/errors.js	2023-12-06 14:23:14.351854734 +0000
@@ -18,11 +18,26 @@
             }, 0);
         };
     }
+    addListener(listener) {
+        this.listeners.push(listener);
+        return () => {
+            this._removeListener(listener);
+        };
+    }
     emit(e) {
         this.listeners.forEach((listener) => {
             listener(e);
         });
     }
+    _removeListener(listener) {
+        this.listeners.splice(this.listeners.indexOf(listener), 1);
+    }
+    setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
+        this.unexpectedErrorHandler = newUnexpectedErrorHandler;
+    }
+    getUnexpectedErrorHandler() {
+        return this.unexpectedErrorHandler;
+    }
     onUnexpectedError(e) {
         this.unexpectedErrorHandler(e);
         this.emit(e);
@@ -33,6 +48,23 @@
     }
 }
 export const errorHandler = new ErrorHandler();
+/** @skipMangle */
+export function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
+    errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
+}
+/**
+ * Returns if the error is a SIGPIPE error. SIGPIPE errors should generally be
+ * logged at most once, to avoid a loop.
+ *
+ * @see https://github.com/microsoft/vscode-remote-release/issues/6481
+ */
+export function isSigPipeError(e) {
+    if (!e || typeof e !== 'object') {
+        return false;
+    }
+    const cast = e;
+    return cast.code === 'EPIPE' && cast.syscall?.toUpperCase() === 'WRITE';
+}
 export function onUnexpectedError(e) {
     // ignore errors from cancelled promises
     if (!isCancellationError(e)) {
@@ -104,6 +136,31 @@
         return new Error('Illegal state');
     }
 }
+export class ReadonlyError extends TypeError {
+    constructor(name) {
+        super(name ? `${name} is read-only and cannot be changed` : 'Cannot change read-only property');
+    }
+}
+export function getErrorMessage(err) {
+    if (!err) {
+        return 'Error';
+    }
+    if (err.message) {
+        return err.message;
+    }
+    if (err.stack) {
+        return err.stack.split('\n')[0];
+    }
+    return String(err);
+}
+export class NotImplementedError extends Error {
+    constructor(message) {
+        super('NotImplemented');
+        if (message) {
+            this.message = message;
+        }
+    }
+}
 export class NotSupportedError extends Error {
     constructor(message) {
         super('NotSupported');
@@ -112,6 +169,12 @@
         }
     }
 }
+export class ExpectedError extends Error {
+    constructor() {
+        super(...arguments);
+        this.isExpected = true;
+    }
+}
 /**
  * Error that when thrown won't be logged in telemetry as an unhandled error.
  */
diff -urN -x '*.map' a/vs/base/common/event.js b/vs/base/common/event.js
--- a/vs/base/common/event.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/event.js	2023-12-06 14:23:14.351854734 +0000
@@ -1,6 +1,10 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 import { onUnexpectedError } from './errors.js';
 import { createSingleCallFunction } from './functional.js';
-import { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';
+import { combinedDisposable, Disposable, DisposableMap, DisposableStore, toDisposable } from './lifecycle.js';
 import { LinkedList } from './linkedList.js';
 import { StopWatch } from './stopwatch.js';
 // -----------------------------------------------------------------------------------------------------------------------
@@ -26,7 +30,7 @@
                     console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');
                     stack.print();
                 }
-                origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();
+                origListenerDidAdd?.();
             };
         }
     }
@@ -148,14 +152,14 @@
                 listener = event(emitter.fire, emitter);
             },
             onDidRemoveLastListener() {
-                listener === null || listener === void 0 ? void 0 : listener.dispose();
+                listener?.dispose();
             }
         };
         if (!disposable) {
             _addLeakageTraceLogic(options);
         }
         const emitter = new Emitter(options);
-        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
+        disposable?.add(emitter);
         return emitter.event;
     }
     /**
@@ -210,7 +214,7 @@
             },
             onWillRemoveListener() {
                 if (flushOnListenerRemove && numDebouncedCalls > 0) {
-                    doFire === null || doFire === void 0 ? void 0 : doFire();
+                    doFire?.();
                 }
             },
             onDidRemoveLastListener() {
@@ -222,7 +226,7 @@
             _addLeakageTraceLogic(options);
         }
         const emitter = new Emitter(options);
-        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
+        disposable?.add(emitter);
         return emitter.event;
     }
     Event.debounce = debounce;
@@ -330,7 +334,7 @@
             disposable.add(listener);
         }
         const flush = () => {
-            buffer === null || buffer === void 0 ? void 0 : buffer.forEach(e => emitter.fire(e));
+            buffer?.forEach(e => emitter.fire(e));
             buffer = null;
         };
         const emitter = new Emitter({
@@ -511,7 +515,7 @@
     function runAndSubscribeWithStore(event, handler) {
         let store = null;
         function run(e) {
-            store === null || store === void 0 ? void 0 : store.dispose();
+            store?.dispose();
             store = new DisposableStore();
             handler(e, store);
         }
@@ -519,7 +523,7 @@
         const disposable = event(e => run(e));
         return toDisposable(() => {
             disposable.dispose();
-            store === null || store === void 0 ? void 0 : store.dispose();
+            store?.dispose();
         });
     }
     Event.runAndSubscribeWithStore = runAndSubscribeWithStore;
@@ -641,6 +645,15 @@
 EventProfiling.all = new Set();
 EventProfiling._idPool = 0;
 let _globalLeakWarningThreshold = -1;
+export function setGlobalLeakWarningThreshold(n) {
+    const oldValue = _globalLeakWarningThreshold;
+    _globalLeakWarningThreshold = n;
+    return {
+        dispose() {
+            _globalLeakWarningThreshold = oldValue;
+        }
+    };
+}
 class LeakageMonitor {
     constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {
         this.threshold = threshold;
@@ -648,8 +661,7 @@
         this._warnCountdown = 0;
     }
     dispose() {
-        var _a;
-        (_a = this._stacks) === null || _a === void 0 ? void 0 : _a.clear();
+        this._stacks?.clear();
     }
     check(stack, listenerCount) {
         const threshold = this.threshold;
@@ -686,8 +698,7 @@
 }
 class Stacktrace {
     static create() {
-        var _a;
-        return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');
+        return new Stacktrace(new Error().stack ?? '');
     }
     constructor(value) {
         this.value = value;
@@ -696,9 +707,11 @@
         console.warn(this.value.split('\n').slice(2).join('\n'));
     }
 }
+let id = 0;
 class UniqueContainer {
     constructor(value) {
         this.value = value;
+        this.id = id++;
     }
 }
 const compactionThreshold = 2;
@@ -738,15 +751,13 @@
  */
 export class Emitter {
     constructor(options) {
-        var _a, _b, _c, _d, _e;
         this._size = 0;
         this._options = options;
-        this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a = this._options) === null || _a === void 0 ? void 0 : _a.leakWarningThreshold) ? new LeakageMonitor((_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.leakWarningThreshold) !== null && _c !== void 0 ? _c : _globalLeakWarningThreshold) : undefined;
-        this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : undefined;
-        this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;
+        this._leakageMon = _globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold ? new LeakageMonitor(this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) : undefined;
+        this._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;
+        this._deliveryQueue = this._options?.deliveryQueue;
     }
     dispose() {
-        var _a, _b, _c, _d;
         if (!this._disposed) {
             this._disposed = true;
             // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter
@@ -758,21 +769,21 @@
             // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener
             // ...later...
             // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the "overall dispose" is done
-            if (((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) === this) {
+            if (this._deliveryQueue?.current === this) {
                 this._deliveryQueue.reset();
             }
             if (this._listeners) {
                 if (_enableDisposeWithListenerWarning) {
                     const listeners = this._listeners;
                     queueMicrotask(() => {
-                        forEachListener(listeners, l => { var _a; return (_a = l.stack) === null || _a === void 0 ? void 0 : _a.print(); });
+                        forEachListener(listeners, l => l.stack?.print());
                     });
                 }
                 this._listeners = undefined;
                 this._size = 0;
             }
-            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b);
-            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();
+            this._options?.onDidRemoveLastListener?.();
+            this._leakageMon?.dispose();
         }
     }
     /**
@@ -780,9 +791,7 @@
      * to events from this Emitter
      */
     get event() {
-        var _a;
-        (_a = this._event) !== null && _a !== void 0 ? _a : (this._event = (callback, thisArgs, disposables) => {
-            var _a, _b, _c, _d, _e;
+        this._event ?? (this._event = (callback, thisArgs, disposables) => {
             if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {
                 console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);
                 return Disposable.None;
@@ -803,22 +812,22 @@
                 removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);
             }
             if (_enableDisposeWithListenerWarning) {
-                contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();
+                contained.stack = stack ?? Stacktrace.create();
             }
             if (!this._listeners) {
-                (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillAddFirstListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);
+                this._options?.onWillAddFirstListener?.(this);
                 this._listeners = contained;
-                (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);
+                this._options?.onDidAddFirstListener?.(this);
             }
             else if (this._listeners instanceof UniqueContainer) {
-                (_e = this._deliveryQueue) !== null && _e !== void 0 ? _e : (this._deliveryQueue = new EventDeliveryQueuePrivate());
+                this._deliveryQueue ?? (this._deliveryQueue = new EventDeliveryQueuePrivate());
                 this._listeners = [this._listeners, contained];
             }
             else {
                 this._listeners.push(contained);
             }
             this._size++;
-            const result = toDisposable(() => { removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor(); this._removeListener(contained); });
+            const result = toDisposable(() => { removeMonitor?.(); this._removeListener(contained); });
             if (disposables instanceof DisposableStore) {
                 disposables.add(result);
             }
@@ -830,14 +839,13 @@
         return this._event;
     }
     _removeListener(listener) {
-        var _a, _b, _c, _d;
-        (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillRemoveListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);
+        this._options?.onWillRemoveListener?.(this);
         if (!this._listeners) {
             return; // expected if a listener gets disposed
         }
         if (this._size === 1) {
             this._listeners = undefined;
-            (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);
+            this._options?.onDidRemoveLastListener?.(this);
             this._size = 0;
             return;
         }
@@ -870,11 +878,10 @@
         }
     }
     _deliver(listener, value) {
-        var _a;
         if (!listener) {
             return;
         }
-        const errorHandler = ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onListenerError) || onUnexpectedError;
+        const errorHandler = this._options?.onListenerError || onUnexpectedError;
         if (!errorHandler) {
             listener.value(value);
             return;
@@ -900,12 +907,11 @@
      * subscribers
      */
     fire(event) {
-        var _a, _b, _c, _d;
-        if ((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) {
+        if (this._deliveryQueue?.current) {
             this._deliverQueue(this._deliveryQueue);
-            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch
+            this._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch
         }
-        (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);
+        this._perfMon?.start(this._size);
         if (!this._listeners) {
             // no-op
         }
@@ -917,7 +923,7 @@
             dq.enqueue(this, event, this._listeners.length);
             this._deliverQueue(dq);
         }
-        (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();
+        this._perfMon?.stop();
     }
     hasListeners() {
         return this._size > 0;
@@ -947,12 +953,60 @@
         this.value = undefined;
     }
 }
+export class AsyncEmitter extends Emitter {
+    async fireAsync(data, token, promiseJoin) {
+        if (!this._listeners) {
+            return;
+        }
+        if (!this._asyncDeliveryQueue) {
+            this._asyncDeliveryQueue = new LinkedList();
+        }
+        forEachListener(this._listeners, listener => this._asyncDeliveryQueue.push([listener.value, data]));
+        while (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {
+            const [listener, data] = this._asyncDeliveryQueue.shift();
+            const thenables = [];
+            const event = {
+                ...data,
+                token,
+                waitUntil: (p) => {
+                    if (Object.isFrozen(thenables)) {
+                        throw new Error('waitUntil can NOT be called asynchronous');
+                    }
+                    if (promiseJoin) {
+                        p = promiseJoin(p, listener);
+                    }
+                    thenables.push(p);
+                }
+            };
+            try {
+                listener(event);
+            }
+            catch (e) {
+                onUnexpectedError(e);
+                continue;
+            }
+            // freeze thenables-collection to enforce sync-calls to
+            // wait until and then wait for all thenables to resolve
+            Object.freeze(thenables);
+            await Promise.allSettled(thenables).then(values => {
+                for (const value of values) {
+                    if (value.status === 'rejected') {
+                        onUnexpectedError(value.reason);
+                    }
+                }
+            });
+        }
+    }
+}
 export class PauseableEmitter extends Emitter {
+    get isPaused() {
+        return this._isPaused !== 0;
+    }
     constructor(options) {
         super(options);
         this._isPaused = 0;
         this._eventQueue = new LinkedList();
-        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;
+        this._mergeFn = options?.merge;
     }
     pause() {
         this._isPaused++;
@@ -990,9 +1044,8 @@
 }
 export class DebounceEmitter extends PauseableEmitter {
     constructor(options) {
-        var _a;
         super(options);
-        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;
+        this._delay = options.delay ?? 100;
     }
     fire(event) {
         if (!this._handle) {
@@ -1013,7 +1066,7 @@
     constructor(options) {
         super(options);
         this._queuedEvents = [];
-        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;
+        this._mergeFn = options?.merge;
     }
     fire(event) {
         if (!this.hasListeners()) {
@@ -1104,6 +1157,32 @@
         this.emitter.dispose();
     }
 }
+export class DynamicListEventMultiplexer {
+    constructor(items, onAddItem, onRemoveItem, getEvent) {
+        this._store = new DisposableStore();
+        const multiplexer = this._store.add(new EventMultiplexer());
+        const itemListeners = this._store.add(new DisposableMap());
+        function addItem(instance) {
+            itemListeners.set(instance, multiplexer.add(getEvent(instance)));
+        }
+        // Existing items
+        for (const instance of items) {
+            addItem(instance);
+        }
+        // Added items
+        this._store.add(onAddItem(instance => {
+            addItem(instance);
+        }));
+        // Removed items
+        this._store.add(onRemoveItem(instance => {
+            itemListeners.deleteAndDispose(instance);
+        }));
+        this.event = multiplexer.event;
+    }
+    dispose() {
+        this._store.dispose();
+    }
+}
 /**
  * The EventBufferer is useful in situations in which you want
  * to delay firing your events during some code.
diff -urN -x '*.map' a/vs/base/common/extpath.js b/vs/base/common/extpath.js
--- a/vs/base/common/extpath.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/extpath.js	2023-12-06 14:23:14.351854734 +0000
@@ -2,9 +2,10 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-import { posix, sep } from './path.js';
+import { isAbsolute, join, normalize, posix, sep } from './path.js';
 import { isWindows } from './platform.js';
-import { startsWithIgnoreCase } from './strings.js';
+import { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from './strings.js';
+import { isNumber } from './types.js';
 export function isPathSeparator(code) {
     return code === 47 /* CharCode.Slash */ || code === 92 /* CharCode.Backslash */;
 }
@@ -100,6 +101,92 @@
     return '';
 }
 /**
+ * Check if the path follows this pattern: `\\hostname\sharename`.
+ *
+ * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx
+ * @return A boolean indication if the path is a UNC path, on none-windows
+ * always false.
+ */
+export function isUNC(path) {
+    if (!isWindows) {
+        // UNC is a windows concept
+        return false;
+    }
+    if (!path || path.length < 5) {
+        // at least \\a\b
+        return false;
+    }
+    let code = path.charCodeAt(0);
+    if (code !== 92 /* CharCode.Backslash */) {
+        return false;
+    }
+    code = path.charCodeAt(1);
+    if (code !== 92 /* CharCode.Backslash */) {
+        return false;
+    }
+    let pos = 2;
+    const start = pos;
+    for (; pos < path.length; pos++) {
+        code = path.charCodeAt(pos);
+        if (code === 92 /* CharCode.Backslash */) {
+            break;
+        }
+    }
+    if (start === pos) {
+        return false;
+    }
+    code = path.charCodeAt(pos + 1);
+    if (isNaN(code) || code === 92 /* CharCode.Backslash */) {
+        return false;
+    }
+    return true;
+}
+// Reference: https://en.wikipedia.org/wiki/Filename
+const WINDOWS_INVALID_FILE_CHARS = /[\\/:\*\?"<>\|]/g;
+const UNIX_INVALID_FILE_CHARS = /[\\/]/g;
+const WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])(\.(.*?))?$/i;
+export function isValidBasename(name, isWindowsOS = isWindows) {
+    const invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;
+    if (!name || name.length === 0 || /^\s+$/.test(name)) {
+        return false; // require a name that is not just whitespace
+    }
+    invalidFileChars.lastIndex = 0; // the holy grail of software development
+    if (invalidFileChars.test(name)) {
+        return false; // check for certain invalid file characters
+    }
+    if (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {
+        return false; // check for certain invalid file names
+    }
+    if (name === '.' || name === '..') {
+        return false; // check for reserved values
+    }
+    if (isWindowsOS && name[name.length - 1] === '.') {
+        return false; // Windows: file cannot end with a "."
+    }
+    if (isWindowsOS && name.length !== name.trim().length) {
+        return false; // Windows: file cannot end with a whitespace
+    }
+    if (name.length > 255) {
+        return false; // most file systems do not allow files > 255 length
+    }
+    return true;
+}
+/**
+ * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are
+ * in a context without services, consider to pass down the `extUri` from the outside
+ * or use `extUriBiasedIgnorePathCase` if you know what you are doing.
+ */
+export function isEqual(pathA, pathB, ignoreCase) {
+    const identityEquals = (pathA === pathB);
+    if (!ignoreCase || identityEquals) {
+        return identityEquals;
+    }
+    if (!pathA || !pathB) {
+        return false;
+    }
+    return equalsIgnoreCase(pathA, pathB);
+}
+/**
  * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If
  * you are in a context without services, consider to pass down the `extUri` from the
  * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.
@@ -136,9 +223,121 @@
 export function isWindowsDriveLetter(char0) {
     return char0 >= 65 /* CharCode.A */ && char0 <= 90 /* CharCode.Z */ || char0 >= 97 /* CharCode.a */ && char0 <= 122 /* CharCode.z */;
 }
+export function sanitizeFilePath(candidate, cwd) {
+    // Special case: allow to open a drive letter without trailing backslash
+    if (isWindows && candidate.endsWith(':')) {
+        candidate += sep;
+    }
+    // Ensure absolute
+    if (!isAbsolute(candidate)) {
+        candidate = join(cwd, candidate);
+    }
+    // Ensure normalized
+    candidate = normalize(candidate);
+    // Ensure no trailing slash/backslash
+    if (isWindows) {
+        candidate = rtrim(candidate, sep);
+        // Special case: allow to open drive root ('C:\')
+        if (candidate.endsWith(':')) {
+            candidate += sep;
+        }
+    }
+    else {
+        candidate = rtrim(candidate, sep);
+        // Special case: allow to open root ('/')
+        if (!candidate) {
+            candidate = sep;
+        }
+    }
+    return candidate;
+}
+export function isRootOrDriveLetter(path) {
+    const pathNormalized = normalize(path);
+    if (isWindows) {
+        if (path.length > 3) {
+            return false;
+        }
+        return hasDriveLetter(pathNormalized) &&
+            (path.length === 2 || pathNormalized.charCodeAt(2) === 92 /* CharCode.Backslash */);
+    }
+    return pathNormalized === posix.sep;
+}
 export function hasDriveLetter(path, isWindowsOS = isWindows) {
     if (isWindowsOS) {
         return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58 /* CharCode.Colon */;
     }
     return false;
 }
+export function getDriveLetter(path, isWindowsOS = isWindows) {
+    return hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;
+}
+export function indexOfPath(path, candidate, ignoreCase) {
+    if (candidate.length > path.length) {
+        return -1;
+    }
+    if (path === candidate) {
+        return 0;
+    }
+    if (ignoreCase) {
+        path = path.toLowerCase();
+        candidate = candidate.toLowerCase();
+    }
+    return path.indexOf(candidate);
+}
+export function parseLineAndColumnAware(rawPath) {
+    const segments = rawPath.split(':'); // C:\file.txt:<line>:<column>
+    let path = undefined;
+    let line = undefined;
+    let column = undefined;
+    for (const segment of segments) {
+        const segmentAsNumber = Number(segment);
+        if (!isNumber(segmentAsNumber)) {
+            path = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\...)
+        }
+        else if (line === undefined) {
+            line = segmentAsNumber;
+        }
+        else if (column === undefined) {
+            column = segmentAsNumber;
+        }
+    }
+    if (!path) {
+        throw new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');
+    }
+    return {
+        path,
+        line: line !== undefined ? line : undefined,
+        column: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set
+    };
+}
+const pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
+const windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';
+export function randomPath(parent, prefix, randomLength = 8) {
+    let suffix = '';
+    for (let i = 0; i < randomLength; i++) {
+        let pathCharsTouse;
+        if (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {
+            // Windows has certain reserved file names that cannot be used, such
+            // as AUX, CON, PRN, etc. We want to avoid generating a random name
+            // that matches that pattern, so we use a different set of characters
+            // for the first character of the name that does not include any of
+            // the reserved names first characters.
+            pathCharsTouse = windowsSafePathFirstChars;
+        }
+        else {
+            pathCharsTouse = pathChars;
+        }
+        suffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));
+    }
+    let randomFileName;
+    if (prefix) {
+        randomFileName = `${prefix}-${suffix}`;
+    }
+    else {
+        randomFileName = suffix;
+    }
+    if (parent) {
+        return join(parent, randomFileName);
+    }
+    return randomFileName;
+}
diff -urN -x '*.map' a/vs/base/common/filters.js b/vs/base/common/filters.js
--- a/vs/base/common/filters.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/filters.js	2023-12-06 14:23:14.351854734 +0000
@@ -675,6 +675,9 @@
 export function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {
     return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);
 }
+export function fuzzyScoreGraceful(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {
+    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, false, options);
+}
 function fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options) {
     let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);
     if (top && !aggressive) {
diff -urN -x '*.map' a/vs/base/common/fuzzyScorer.js b/vs/base/common/fuzzyScorer.js
--- a/vs/base/common/fuzzyScorer.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/fuzzyScorer.js	2023-12-06 14:23:14.351854734 +0000
@@ -1,7 +1,216 @@
-import { createMatches as createFuzzyMatches, fuzzyScore } from './filters.js';
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { compareAnything } from './comparers.js';
+import { createMatches as createFuzzyMatches, fuzzyScore, isUpper, matchesPrefix } from './filters.js';
+import { hash } from './hash.js';
 import { sep } from './path.js';
-import { isWindows } from './platform.js';
-import { stripWildcards } from './strings.js';
+import { isLinux, isWindows } from './platform.js';
+import { equalsIgnoreCase, stripWildcards } from './strings.js';
+const NO_MATCH = 0;
+const NO_SCORE = [NO_MATCH, []];
+// const DEBUG = true;
+// const DEBUG_MATRIX = false;
+export function scoreFuzzy(target, query, queryLower, allowNonContiguousMatches) {
+    if (!target || !query) {
+        return NO_SCORE; // return early if target or query are undefined
+    }
+    const targetLength = target.length;
+    const queryLength = query.length;
+    if (targetLength < queryLength) {
+        return NO_SCORE; // impossible for query to be contained in target
+    }
+    // if (DEBUG) {
+    // 	console.group(`Target: ${target}, Query: ${query}`);
+    // }
+    const targetLower = target.toLowerCase();
+    const res = doScoreFuzzy(query, queryLower, queryLength, target, targetLower, targetLength, allowNonContiguousMatches);
+    // if (DEBUG) {
+    // 	console.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');
+    // 	console.groupEnd();
+    // }
+    return res;
+}
+function doScoreFuzzy(query, queryLower, queryLength, target, targetLower, targetLength, allowNonContiguousMatches) {
+    const scores = [];
+    const matches = [];
+    //
+    // Build Scorer Matrix:
+    //
+    // The matrix is composed of query q and target t. For each index we score
+    // q[i] with t[i] and compare that with the previous score. If the score is
+    // equal or larger, we keep the match. In addition to the score, we also keep
+    // the length of the consecutive matches to use as boost for the score.
+    //
+    //      t   a   r   g   e   t
+    //  q
+    //  u
+    //  e
+    //  r
+    //  y
+    //
+    for (let queryIndex = 0; queryIndex < queryLength; queryIndex++) {
+        const queryIndexOffset = queryIndex * targetLength;
+        const queryIndexPreviousOffset = queryIndexOffset - targetLength;
+        const queryIndexGtNull = queryIndex > 0;
+        const queryCharAtIndex = query[queryIndex];
+        const queryLowerCharAtIndex = queryLower[queryIndex];
+        for (let targetIndex = 0; targetIndex < targetLength; targetIndex++) {
+            const targetIndexGtNull = targetIndex > 0;
+            const currentIndex = queryIndexOffset + targetIndex;
+            const leftIndex = currentIndex - 1;
+            const diagIndex = queryIndexPreviousOffset + targetIndex - 1;
+            const leftScore = targetIndexGtNull ? scores[leftIndex] : 0;
+            const diagScore = queryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;
+            const matchesSequenceLength = queryIndexGtNull && targetIndexGtNull ? matches[diagIndex] : 0;
+            // If we are not matching on the first query character any more, we only produce a
+            // score if we had a score previously for the last query index (by looking at the diagScore).
+            // This makes sure that the query always matches in sequence on the target. For example
+            // given a target of "ede" and a query of "de", we would otherwise produce a wrong high score
+            // for query[1] ("e") matching on target[0] ("e") because of the "beginning of word" boost.
+            let score;
+            if (!diagScore && queryIndexGtNull) {
+                score = 0;
+            }
+            else {
+                score = computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength);
+            }
+            // We have a score and its equal or larger than the left score
+            // Match: sequence continues growing from previous diag value
+            // Score: increases by diag score value
+            const isValidScore = score && diagScore + score >= leftScore;
+            if (isValidScore && (
+            // We don't need to check if it's contiguous if we allow non-contiguous matches
+            allowNonContiguousMatches ||
+                // We must be looking for a contiguous match.
+                // Looking at an index higher than 0 in the query means we must have already
+                // found out this is contiguous otherwise there wouldn't have been a score
+                queryIndexGtNull ||
+                // lastly check if the query is completely contiguous at this index in the target
+                targetLower.startsWith(queryLower, targetIndex))) {
+                matches[currentIndex] = matchesSequenceLength + 1;
+                scores[currentIndex] = diagScore + score;
+            }
+            // We either have no score or the score is lower than the left score
+            // Match: reset to 0
+            // Score: pick up from left hand side
+            else {
+                matches[currentIndex] = NO_MATCH;
+                scores[currentIndex] = leftScore;
+            }
+        }
+    }
+    // Restore Positions (starting from bottom right of matrix)
+    const positions = [];
+    let queryIndex = queryLength - 1;
+    let targetIndex = targetLength - 1;
+    while (queryIndex >= 0 && targetIndex >= 0) {
+        const currentIndex = queryIndex * targetLength + targetIndex;
+        const match = matches[currentIndex];
+        if (match === NO_MATCH) {
+            targetIndex--; // go left
+        }
+        else {
+            positions.push(targetIndex);
+            // go up and left
+            queryIndex--;
+            targetIndex--;
+        }
+    }
+    // Print matrix
+    // if (DEBUG_MATRIX) {
+    // 	printMatrix(query, target, matches, scores);
+    // }
+    return [scores[queryLength * targetLength - 1], positions.reverse()];
+}
+function computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength) {
+    let score = 0;
+    if (!considerAsEqual(queryLowerCharAtIndex, targetLower[targetIndex])) {
+        return score; // no match of characters
+    }
+    // if (DEBUG) {
+    // 	console.groupCollapsed(`%cFound a match of char: ${queryLowerCharAtIndex} at index ${targetIndex}`, 'font-weight: normal');
+    // }
+    // Character match bonus
+    score += 1;
+    // if (DEBUG) {
+    // 	console.log(`%cCharacter match bonus: +1`, 'font-weight: normal');
+    // }
+    // Consecutive match bonus
+    if (matchesSequenceLength > 0) {
+        score += (matchesSequenceLength * 5);
+        // if (DEBUG) {
+        // 	console.log(`Consecutive match bonus: +${matchesSequenceLength * 5}`);
+        // }
+    }
+    // Same case bonus
+    if (queryCharAtIndex === target[targetIndex]) {
+        score += 1;
+        // if (DEBUG) {
+        // 	console.log('Same case bonus: +1');
+        // }
+    }
+    // Start of word bonus
+    if (targetIndex === 0) {
+        score += 8;
+        // if (DEBUG) {
+        // 	console.log('Start of word bonus: +8');
+        // }
+    }
+    else {
+        // After separator bonus
+        const separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));
+        if (separatorBonus) {
+            score += separatorBonus;
+            // if (DEBUG) {
+            // 	console.log(`After separator bonus: +${separatorBonus}`);
+            // }
+        }
+        // Inside word upper case bonus (camel case). We only give this bonus if we're not in a contiguous sequence.
+        // For example:
+        // NPE => NullPointerException = boost
+        // HTTP => HTTP = not boost
+        else if (isUpper(target.charCodeAt(targetIndex)) && matchesSequenceLength === 0) {
+            score += 2;
+            // if (DEBUG) {
+            // 	console.log('Inside word upper case bonus: +2');
+            // }
+        }
+    }
+    // if (DEBUG) {
+    // 	console.log(`Total score: ${score}`);
+    // 	console.groupEnd();
+    // }
+    return score;
+}
+function considerAsEqual(a, b) {
+    if (a === b) {
+        return true;
+    }
+    // Special case path separators: ignore platform differences
+    if (a === '/' || a === '\\') {
+        return b === '/' || b === '\\';
+    }
+    return false;
+}
+function scoreSeparatorAtPos(charCode) {
+    switch (charCode) {
+        case 47 /* CharCode.Slash */:
+        case 92 /* CharCode.Backslash */:
+            return 5; // prefer path separators...
+        case 95 /* CharCode.Underline */:
+        case 45 /* CharCode.Dash */:
+        case 46 /* CharCode.Period */:
+        case 32 /* CharCode.Space */:
+        case 39 /* CharCode.SingleQuote */:
+        case 34 /* CharCode.DoubleQuote */:
+        case 58 /* CharCode.Colon */:
+            return 4; // ...over other separators
+        default:
+            return 0;
+    }
+}
 const NO_SCORE2 = [undefined, []];
 export function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {
     // Score: multiple inputs
@@ -37,6 +246,163 @@
     return [score[0], createFuzzyMatches(score)];
 }
 const NO_ITEM_SCORE = Object.freeze({ score: 0 });
+const PATH_IDENTITY_SCORE = 1 << 18;
+const LABEL_PREFIX_SCORE_THRESHOLD = 1 << 17;
+const LABEL_SCORE_THRESHOLD = 1 << 16;
+function getCacheHash(label, description, allowNonContiguousMatches, query) {
+    const values = query.values ? query.values : [query];
+    const cacheHash = hash({
+        [query.normalized]: {
+            values: values.map(v => ({ value: v.normalized, expectContiguousMatch: v.expectContiguousMatch })),
+            label,
+            description,
+            allowNonContiguousMatches
+        }
+    });
+    return cacheHash;
+}
+export function scoreItemFuzzy(item, query, allowNonContiguousMatches, accessor, cache) {
+    if (!item || !query.normalized) {
+        return NO_ITEM_SCORE; // we need an item and query to score on at least
+    }
+    const label = accessor.getItemLabel(item);
+    if (!label) {
+        return NO_ITEM_SCORE; // we need a label at least
+    }
+    const description = accessor.getItemDescription(item);
+    // in order to speed up scoring, we cache the score with a unique hash based on:
+    // - label
+    // - description (if provided)
+    // - whether non-contiguous matching is enabled or not
+    // - hash of the query (normalized) values
+    const cacheHash = getCacheHash(label, description, allowNonContiguousMatches, query);
+    const cached = cache[cacheHash];
+    if (cached) {
+        return cached;
+    }
+    const itemScore = doScoreItemFuzzy(label, description, accessor.getItemPath(item), query, allowNonContiguousMatches);
+    cache[cacheHash] = itemScore;
+    return itemScore;
+}
+function doScoreItemFuzzy(label, description, path, query, allowNonContiguousMatches) {
+    const preferLabelMatches = !path || !query.containsPathSeparator;
+    // Treat identity matches on full path highest
+    if (path && (isLinux ? query.pathNormalized === path : equalsIgnoreCase(query.pathNormalized, path))) {
+        return { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : undefined };
+    }
+    // Score: multiple inputs
+    if (query.values && query.values.length > 1) {
+        return doScoreItemFuzzyMultiple(label, description, path, query.values, preferLabelMatches, allowNonContiguousMatches);
+    }
+    // Score: single input
+    return doScoreItemFuzzySingle(label, description, path, query, preferLabelMatches, allowNonContiguousMatches);
+}
+function doScoreItemFuzzyMultiple(label, description, path, query, preferLabelMatches, allowNonContiguousMatches) {
+    let totalScore = 0;
+    const totalLabelMatches = [];
+    const totalDescriptionMatches = [];
+    for (const queryPiece of query) {
+        const { score, labelMatch, descriptionMatch } = doScoreItemFuzzySingle(label, description, path, queryPiece, preferLabelMatches, allowNonContiguousMatches);
+        if (score === NO_MATCH) {
+            // if a single query value does not match, return with
+            // no score entirely, we require all queries to match
+            return NO_ITEM_SCORE;
+        }
+        totalScore += score;
+        if (labelMatch) {
+            totalLabelMatches.push(...labelMatch);
+        }
+        if (descriptionMatch) {
+            totalDescriptionMatches.push(...descriptionMatch);
+        }
+    }
+    // if we have a score, ensure that the positions are
+    // sorted in ascending order and distinct
+    return {
+        score: totalScore,
+        labelMatch: normalizeMatches(totalLabelMatches),
+        descriptionMatch: normalizeMatches(totalDescriptionMatches)
+    };
+}
+function doScoreItemFuzzySingle(label, description, path, query, preferLabelMatches, allowNonContiguousMatches) {
+    // Prefer label matches if told so or we have no description
+    if (preferLabelMatches || !description) {
+        const [labelScore, labelPositions] = scoreFuzzy(label, query.normalized, query.normalizedLowercase, allowNonContiguousMatches && !query.expectContiguousMatch);
+        if (labelScore) {
+            // If we have a prefix match on the label, we give a much
+            // higher baseScore to elevate these matches over others
+            // This ensures that typing a file name wins over results
+            // that are present somewhere in the label, but not the
+            // beginning.
+            const labelPrefixMatch = matchesPrefix(query.normalized, label);
+            let baseScore;
+            if (labelPrefixMatch) {
+                baseScore = LABEL_PREFIX_SCORE_THRESHOLD;
+                // We give another boost to labels that are short, e.g. given
+                // files "window.ts" and "windowActions.ts" and a query of
+                // "window", we want "window.ts" to receive a higher score.
+                // As such we compute the percentage the query has within the
+                // label and add that to the baseScore.
+                const prefixLengthBoost = Math.round((query.normalized.length / label.length) * 100);
+                baseScore += prefixLengthBoost;
+            }
+            else {
+                baseScore = LABEL_SCORE_THRESHOLD;
+            }
+            return { score: baseScore + labelScore, labelMatch: labelPrefixMatch || createMatches(labelPositions) };
+        }
+    }
+    // Finally compute description + label scores if we have a description
+    if (description) {
+        let descriptionPrefix = description;
+        if (!!path) {
+            descriptionPrefix = `${description}${sep}`; // assume this is a file path
+        }
+        const descriptionPrefixLength = descriptionPrefix.length;
+        const descriptionAndLabel = `${descriptionPrefix}${label}`;
+        const [labelDescriptionScore, labelDescriptionPositions] = scoreFuzzy(descriptionAndLabel, query.normalized, query.normalizedLowercase, allowNonContiguousMatches && !query.expectContiguousMatch);
+        if (labelDescriptionScore) {
+            const labelDescriptionMatches = createMatches(labelDescriptionPositions);
+            const labelMatch = [];
+            const descriptionMatch = [];
+            // We have to split the matches back onto the label and description portions
+            labelDescriptionMatches.forEach(h => {
+                // Match overlaps label and description part, we need to split it up
+                if (h.start < descriptionPrefixLength && h.end > descriptionPrefixLength) {
+                    labelMatch.push({ start: 0, end: h.end - descriptionPrefixLength });
+                    descriptionMatch.push({ start: h.start, end: descriptionPrefixLength });
+                }
+                // Match on label part
+                else if (h.start >= descriptionPrefixLength) {
+                    labelMatch.push({ start: h.start - descriptionPrefixLength, end: h.end - descriptionPrefixLength });
+                }
+                // Match on description part
+                else {
+                    descriptionMatch.push(h);
+                }
+            });
+            return { score: labelDescriptionScore, labelMatch, descriptionMatch };
+        }
+    }
+    return NO_ITEM_SCORE;
+}
+function createMatches(offsets) {
+    const ret = [];
+    if (!offsets) {
+        return ret;
+    }
+    let last;
+    for (const pos of offsets) {
+        if (last && last.end === pos) {
+            last.end += 1;
+        }
+        else {
+            last = { start: pos, end: pos + 1 };
+            ret.push(last);
+        }
+    }
+    return ret;
+}
 function normalizeMatches(matches) {
     // sort matches by start to be able to normalize
     const sortedMatches = matches.sort((matchA, matchB) => {
@@ -70,6 +436,144 @@
     }
     return true;
 }
+//#endregion
+//#region Comparers
+export function compareItemsByFuzzyScore(itemA, itemB, query, allowNonContiguousMatches, accessor, cache) {
+    const itemScoreA = scoreItemFuzzy(itemA, query, allowNonContiguousMatches, accessor, cache);
+    const itemScoreB = scoreItemFuzzy(itemB, query, allowNonContiguousMatches, accessor, cache);
+    const scoreA = itemScoreA.score;
+    const scoreB = itemScoreB.score;
+    // 1.) identity matches have highest score
+    if (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {
+        if (scoreA !== scoreB) {
+            return scoreA === PATH_IDENTITY_SCORE ? -1 : 1;
+        }
+    }
+    // 2.) matches on label are considered higher compared to label+description matches
+    if (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {
+        if (scoreA !== scoreB) {
+            return scoreA > scoreB ? -1 : 1;
+        }
+        // prefer more compact matches over longer in label (unless this is a prefix match where
+        // longer prefix matches are actually preferred)
+        if (scoreA < LABEL_PREFIX_SCORE_THRESHOLD && scoreB < LABEL_PREFIX_SCORE_THRESHOLD) {
+            const comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);
+            if (comparedByMatchLength !== 0) {
+                return comparedByMatchLength;
+            }
+        }
+        // prefer shorter labels over longer labels
+        const labelA = accessor.getItemLabel(itemA) || '';
+        const labelB = accessor.getItemLabel(itemB) || '';
+        if (labelA.length !== labelB.length) {
+            return labelA.length - labelB.length;
+        }
+    }
+    // 3.) compare by score in label+description
+    if (scoreA !== scoreB) {
+        return scoreA > scoreB ? -1 : 1;
+    }
+    // 4.) scores are identical: prefer matches in label over non-label matches
+    const itemAHasLabelMatches = Array.isArray(itemScoreA.labelMatch) && itemScoreA.labelMatch.length > 0;
+    const itemBHasLabelMatches = Array.isArray(itemScoreB.labelMatch) && itemScoreB.labelMatch.length > 0;
+    if (itemAHasLabelMatches && !itemBHasLabelMatches) {
+        return -1;
+    }
+    else if (itemBHasLabelMatches && !itemAHasLabelMatches) {
+        return 1;
+    }
+    // 5.) scores are identical: prefer more compact matches (label and description)
+    const itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);
+    const itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);
+    if (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {
+        return itemBMatchDistance > itemAMatchDistance ? -1 : 1;
+    }
+    // 6.) scores are identical: start to use the fallback compare
+    return fallbackCompare(itemA, itemB, query, accessor);
+}
+function computeLabelAndDescriptionMatchDistance(item, score, accessor) {
+    let matchStart = -1;
+    let matchEnd = -1;
+    // If we have description matches, the start is first of description match
+    if (score.descriptionMatch && score.descriptionMatch.length) {
+        matchStart = score.descriptionMatch[0].start;
+    }
+    // Otherwise, the start is the first label match
+    else if (score.labelMatch && score.labelMatch.length) {
+        matchStart = score.labelMatch[0].start;
+    }
+    // If we have label match, the end is the last label match
+    // If we had a description match, we add the length of the description
+    // as offset to the end to indicate this.
+    if (score.labelMatch && score.labelMatch.length) {
+        matchEnd = score.labelMatch[score.labelMatch.length - 1].end;
+        if (score.descriptionMatch && score.descriptionMatch.length) {
+            const itemDescription = accessor.getItemDescription(item);
+            if (itemDescription) {
+                matchEnd += itemDescription.length;
+            }
+        }
+    }
+    // If we have just a description match, the end is the last description match
+    else if (score.descriptionMatch && score.descriptionMatch.length) {
+        matchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;
+    }
+    return matchEnd - matchStart;
+}
+function compareByMatchLength(matchesA, matchesB) {
+    if ((!matchesA && !matchesB) || ((!matchesA || !matchesA.length) && (!matchesB || !matchesB.length))) {
+        return 0; // make sure to not cause bad comparing when matches are not provided
+    }
+    if (!matchesB || !matchesB.length) {
+        return -1;
+    }
+    if (!matchesA || !matchesA.length) {
+        return 1;
+    }
+    // Compute match length of A (first to last match)
+    const matchStartA = matchesA[0].start;
+    const matchEndA = matchesA[matchesA.length - 1].end;
+    const matchLengthA = matchEndA - matchStartA;
+    // Compute match length of B (first to last match)
+    const matchStartB = matchesB[0].start;
+    const matchEndB = matchesB[matchesB.length - 1].end;
+    const matchLengthB = matchEndB - matchStartB;
+    // Prefer shorter match length
+    return matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;
+}
+function fallbackCompare(itemA, itemB, query, accessor) {
+    // check for label + description length and prefer shorter
+    const labelA = accessor.getItemLabel(itemA) || '';
+    const labelB = accessor.getItemLabel(itemB) || '';
+    const descriptionA = accessor.getItemDescription(itemA);
+    const descriptionB = accessor.getItemDescription(itemB);
+    const labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);
+    const labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);
+    if (labelDescriptionALength !== labelDescriptionBLength) {
+        return labelDescriptionALength - labelDescriptionBLength;
+    }
+    // check for path length and prefer shorter
+    const pathA = accessor.getItemPath(itemA);
+    const pathB = accessor.getItemPath(itemB);
+    if (pathA && pathB && pathA.length !== pathB.length) {
+        return pathA.length - pathB.length;
+    }
+    // 7.) finally we have equal scores and equal length, we fallback to comparer
+    // compare by label
+    if (labelA !== labelB) {
+        return compareAnything(labelA, labelB, query.normalized);
+    }
+    // compare by description
+    if (descriptionA && descriptionB && descriptionA !== descriptionB) {
+        return compareAnything(descriptionA, descriptionB, query.normalized);
+    }
+    // compare by path
+    if (pathA && pathB && pathA !== pathB) {
+        return compareAnything(pathA, pathB, query.normalized);
+    }
+    // equal
+    return 0;
+}
 /*
  * If a query is wrapped in quotes, the user does not want to
  * use fuzzy search for this query.
diff -urN -x '*.map' a/vs/base/common/glob.js b/vs/base/common/glob.js
--- a/vs/base/common/glob.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/glob.js	2023-12-06 14:23:14.351854734 +0000
@@ -1,18 +1,17 @@
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { equals } from './arrays.js';
 import { isThenable } from './async.js';
 import { isEqualOrParent } from './extpath.js';
 import { LRUCache } from './map.js';
 import { basename, extname, posix, sep } from './path.js';
 import { isLinux } from './platform.js';
 import { escapeRegExpCharacters, ltrim } from './strings.js';
+export function getEmptyExpression() {
+    return Object.create(null);
+}
 export const GLOBSTAR = '**';
 export const GLOB_SPLIT = '/';
 const PATH_REGEX = '[/\\\\]'; // any slash or backslash
@@ -391,6 +390,12 @@
     }
     return typeof rp.base === 'string' && typeof rp.pattern === 'string';
 }
+export function getBasenameTerms(patternOrExpression) {
+    return patternOrExpression.allBasenames || [];
+}
+export function getPathTerms(patternOrExpression) {
+    return patternOrExpression.allPaths || [];
+}
 function parsedExpression(expression, options) {
     const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)
         .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))
@@ -422,15 +427,15 @@
             // With result promises, we have to loop over each and
             // await the result before we can return any result.
             if (resultPromises) {
-                return (() => __awaiter(this, void 0, void 0, function* () {
+                return (async () => {
                     for (const resultPromise of resultPromises) {
-                        const result = yield resultPromise;
+                        const result = await resultPromise;
                         if (typeof result === 'string') {
                             return result;
                         }
                     }
                     return null;
-                }))();
+                })();
             }
             return null;
         };
@@ -474,15 +479,15 @@
         // With result promises, we have to loop over each and
         // await the result before we can return any result.
         if (resultPromises) {
-            return (() => __awaiter(this, void 0, void 0, function* () {
+            return (async () => {
                 for (const resultPromise of resultPromises) {
-                    const result = yield resultPromise;
+                    const result = await resultPromise;
                     if (typeof result === 'string') {
                         return result;
                     }
                 }
                 return null;
-            }))();
+            })();
         }
         return null;
     };
@@ -575,3 +580,14 @@
     aggregatedPatterns.push(aggregate);
     return aggregatedPatterns;
 }
+export function patternsEquals(patternsA, patternsB) {
+    return equals(patternsA, patternsB, (a, b) => {
+        if (typeof a === 'string' && typeof b === 'string') {
+            return a === b;
+        }
+        if (typeof a !== 'string' && typeof b !== 'string') {
+            return a.base === b.base && a.pattern === b.pattern;
+        }
+        return false;
+    });
+}
diff -urN -x '*.map' a/vs/base/common/hash.js b/vs/base/common/hash.js
--- a/vs/base/common/hash.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/hash.js	2023-12-06 14:23:14.351854734 +0000
@@ -55,6 +55,18 @@
         return doHash(obj[key], hashVal);
     }, initialHashVal);
 }
+export class Hasher {
+    constructor() {
+        this._value = 0;
+    }
+    get value() {
+        return this._value;
+    }
+    hash(obj) {
+        this._value = doHash(obj, this._value);
+        return this._value;
+    }
+}
 function leftRotate(value, bits, totalBits = 32) {
     // delta + bits = totalBits
     const delta = totalBits - bits;
diff -urN -x '*.map' a/vs/base/common/history.js b/vs/base/common/history.js
--- a/vs/base/common/history.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/history.js	2023-12-06 14:23:14.351854734 +0000
@@ -36,6 +36,9 @@
     last() {
         return this._navigator.last();
     }
+    isFirst() {
+        return this._currentPosition() === 0;
+    }
     isLast() {
         return this._currentPosition() >= this._elements.length - 1;
     }
@@ -45,6 +48,10 @@
     has(t) {
         return this._history.has(t);
     }
+    clear() {
+        this._initialize([]);
+        this._onChange();
+    }
     _onChange() {
         this._reduceToLimit();
         const elements = this._elements;
@@ -75,3 +82,126 @@
         return elements;
     }
 }
+export class HistoryNavigator2 {
+    get size() { return this._size; }
+    constructor(history, capacity = 10) {
+        this.capacity = capacity;
+        if (history.length < 1) {
+            throw new Error('not supported');
+        }
+        this._size = 1;
+        this.head = this.tail = this.cursor = {
+            value: history[0],
+            previous: undefined,
+            next: undefined
+        };
+        this.valueSet = new Set([history[0]]);
+        for (let i = 1; i < history.length; i++) {
+            this.add(history[i]);
+        }
+    }
+    add(value) {
+        const node = {
+            value,
+            previous: this.tail,
+            next: undefined
+        };
+        this.tail.next = node;
+        this.tail = node;
+        this.cursor = this.tail;
+        this._size++;
+        if (this.valueSet.has(value)) {
+            this._deleteFromList(value);
+        }
+        else {
+            this.valueSet.add(value);
+        }
+        while (this._size > this.capacity) {
+            this.valueSet.delete(this.head.value);
+            this.head = this.head.next;
+            this.head.previous = undefined;
+            this._size--;
+        }
+    }
+    /**
+     * @returns old last value
+     */
+    replaceLast(value) {
+        if (this.tail.value === value) {
+            return value;
+        }
+        const oldValue = this.tail.value;
+        this.valueSet.delete(oldValue);
+        this.tail.value = value;
+        if (this.valueSet.has(value)) {
+            this._deleteFromList(value);
+        }
+        else {
+            this.valueSet.add(value);
+        }
+        return oldValue;
+    }
+    prepend(value) {
+        if (this._size === this.capacity || this.valueSet.has(value)) {
+            return;
+        }
+        const node = {
+            value,
+            previous: undefined,
+            next: this.head
+        };
+        this.head.previous = node;
+        this.head = node;
+        this._size++;
+        this.valueSet.add(value);
+    }
+    isAtEnd() {
+        return this.cursor === this.tail;
+    }
+    current() {
+        return this.cursor.value;
+    }
+    previous() {
+        if (this.cursor.previous) {
+            this.cursor = this.cursor.previous;
+        }
+        return this.cursor.value;
+    }
+    next() {
+        if (this.cursor.next) {
+            this.cursor = this.cursor.next;
+        }
+        return this.cursor.value;
+    }
+    has(t) {
+        return this.valueSet.has(t);
+    }
+    resetCursor() {
+        this.cursor = this.tail;
+        return this.cursor.value;
+    }
+    *[Symbol.iterator]() {
+        let node = this.head;
+        while (node) {
+            yield node.value;
+            node = node.next;
+        }
+    }
+    _deleteFromList(value) {
+        let temp = this.head;
+        while (temp !== this.tail) {
+            if (temp.value === value) {
+                if (temp === this.head) {
+                    this.head = this.head.next;
+                    this.head.previous = undefined;
+                }
+                else {
+                    temp.previous.next = temp.next;
+                    temp.next.previous = temp.previous;
+                }
+                this._size--;
+            }
+            temp = temp.next;
+        }
+    }
+}
diff -urN -x '*.map' a/vs/base/common/htmlContent.js b/vs/base/common/htmlContent.js
--- a/vs/base/common/htmlContent.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/htmlContent.js	2023-12-06 14:23:14.351854734 +0000
@@ -9,7 +9,6 @@
 import { URI } from './uri.js';
 export class MarkdownString {
     constructor(value = '', isTrustedOrOptions = false) {
-        var _a, _b, _c;
         this.value = value;
         if (typeof this.value !== 'string') {
             throw illegalArgument('value');
@@ -20,9 +19,9 @@
             this.supportHtml = false;
         }
         else {
-            this.isTrusted = (_a = isTrustedOrOptions.isTrusted) !== null && _a !== void 0 ? _a : undefined;
-            this.supportThemeIcons = (_b = isTrustedOrOptions.supportThemeIcons) !== null && _b !== void 0 ? _b : false;
-            this.supportHtml = (_c = isTrustedOrOptions.supportHtml) !== null && _c !== void 0 ? _c : false;
+            this.isTrusted = isTrustedOrOptions.isTrusted ?? undefined;
+            this.supportThemeIcons = isTrustedOrOptions.supportThemeIcons ?? false;
+            this.supportHtml = isTrustedOrOptions.supportHtml ?? false;
         }
     }
     appendText(value, newlineStyle = 0 /* MarkdownStringTextNewlineStyle.Paragraph */) {
diff -urN -x '*.map' a/vs/base/common/iconLabels.js b/vs/base/common/iconLabels.js
--- a/vs/base/common/iconLabels.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/iconLabels.js	2023-12-06 14:23:14.351854734 +0000
@@ -47,7 +47,7 @@
     while (true) {
         const pos = _parseIconsRegex.lastIndex;
         const match = _parseIconsRegex.exec(input);
-        const chars = input.substring(pos, match === null || match === void 0 ? void 0 : match.index);
+        const chars = input.substring(pos, match?.index);
         if (chars.length > 0) {
             text += chars;
             for (let i = 0; i < chars.length; i++) {
diff -urN -x '*.map' a/vs/base/common/json.js b/vs/base/common/json.js
--- a/vs/base/common/json.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/base/common/json.js	2023-12-06 14:23:14.351854734 +0000
@@ -0,0 +1,967 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+export var ParseOptions;
+(function (ParseOptions) {
+    ParseOptions.DEFAULT = {
+        allowTrailingComma: true
+    };
+})(ParseOptions || (ParseOptions = {}));
+/**
+ * Creates a JSON scanner on the given text.
+ * If ignoreTrivia is set, whitespaces or comments are ignored.
+ */
+export function createScanner(text, ignoreTrivia = false) {
+    let pos = 0;
+    const len = text.length;
+    let value = '';
+    let tokenOffset = 0;
+    let token = 16 /* SyntaxKind.Unknown */;
+    let scanError = 0 /* ScanError.None */;
+    function scanHexDigits(count) {
+        let digits = 0;
+        let hexValue = 0;
+        while (digits < count) {
+            const ch = text.charCodeAt(pos);
+            if (ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */) {
+                hexValue = hexValue * 16 + ch - 48 /* CharacterCodes._0 */;
+            }
+            else if (ch >= 65 /* CharacterCodes.A */ && ch <= 70 /* CharacterCodes.F */) {
+                hexValue = hexValue * 16 + ch - 65 /* CharacterCodes.A */ + 10;
+            }
+            else if (ch >= 97 /* CharacterCodes.a */ && ch <= 102 /* CharacterCodes.f */) {
+                hexValue = hexValue * 16 + ch - 97 /* CharacterCodes.a */ + 10;
+            }
+            else {
+                break;
+            }
+            pos++;
+            digits++;
+        }
+        if (digits < count) {
+            hexValue = -1;
+        }
+        return hexValue;
+    }
+    function setPosition(newPosition) {
+        pos = newPosition;
+        value = '';
+        tokenOffset = 0;
+        token = 16 /* SyntaxKind.Unknown */;
+        scanError = 0 /* ScanError.None */;
+    }
+    function scanNumber() {
+        const start = pos;
+        if (text.charCodeAt(pos) === 48 /* CharacterCodes._0 */) {
+            pos++;
+        }
+        else {
+            pos++;
+            while (pos < text.length && isDigit(text.charCodeAt(pos))) {
+                pos++;
+            }
+        }
+        if (pos < text.length && text.charCodeAt(pos) === 46 /* CharacterCodes.dot */) {
+            pos++;
+            if (pos < text.length && isDigit(text.charCodeAt(pos))) {
+                pos++;
+                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
+                    pos++;
+                }
+            }
+            else {
+                scanError = 3 /* ScanError.UnexpectedEndOfNumber */;
+                return text.substring(start, pos);
+            }
+        }
+        let end = pos;
+        if (pos < text.length && (text.charCodeAt(pos) === 69 /* CharacterCodes.E */ || text.charCodeAt(pos) === 101 /* CharacterCodes.e */)) {
+            pos++;
+            if (pos < text.length && text.charCodeAt(pos) === 43 /* CharacterCodes.plus */ || text.charCodeAt(pos) === 45 /* CharacterCodes.minus */) {
+                pos++;
+            }
+            if (pos < text.length && isDigit(text.charCodeAt(pos))) {
+                pos++;
+                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
+                    pos++;
+                }
+                end = pos;
+            }
+            else {
+                scanError = 3 /* ScanError.UnexpectedEndOfNumber */;
+            }
+        }
+        return text.substring(start, end);
+    }
+    function scanString() {
+        let result = '', start = pos;
+        while (true) {
+            if (pos >= len) {
+                result += text.substring(start, pos);
+                scanError = 2 /* ScanError.UnexpectedEndOfString */;
+                break;
+            }
+            const ch = text.charCodeAt(pos);
+            if (ch === 34 /* CharacterCodes.doubleQuote */) {
+                result += text.substring(start, pos);
+                pos++;
+                break;
+            }
+            if (ch === 92 /* CharacterCodes.backslash */) {
+                result += text.substring(start, pos);
+                pos++;
+                if (pos >= len) {
+                    scanError = 2 /* ScanError.UnexpectedEndOfString */;
+                    break;
+                }
+                const ch2 = text.charCodeAt(pos++);
+                switch (ch2) {
+                    case 34 /* CharacterCodes.doubleQuote */:
+                        result += '\"';
+                        break;
+                    case 92 /* CharacterCodes.backslash */:
+                        result += '\\';
+                        break;
+                    case 47 /* CharacterCodes.slash */:
+                        result += '/';
+                        break;
+                    case 98 /* CharacterCodes.b */:
+                        result += '\b';
+                        break;
+                    case 102 /* CharacterCodes.f */:
+                        result += '\f';
+                        break;
+                    case 110 /* CharacterCodes.n */:
+                        result += '\n';
+                        break;
+                    case 114 /* CharacterCodes.r */:
+                        result += '\r';
+                        break;
+                    case 116 /* CharacterCodes.t */:
+                        result += '\t';
+                        break;
+                    case 117 /* CharacterCodes.u */: {
+                        const ch3 = scanHexDigits(4);
+                        if (ch3 >= 0) {
+                            result += String.fromCharCode(ch3);
+                        }
+                        else {
+                            scanError = 4 /* ScanError.InvalidUnicode */;
+                        }
+                        break;
+                    }
+                    default:
+                        scanError = 5 /* ScanError.InvalidEscapeCharacter */;
+                }
+                start = pos;
+                continue;
+            }
+            if (ch >= 0 && ch <= 0x1F) {
+                if (isLineBreak(ch)) {
+                    result += text.substring(start, pos);
+                    scanError = 2 /* ScanError.UnexpectedEndOfString */;
+                    break;
+                }
+                else {
+                    scanError = 6 /* ScanError.InvalidCharacter */;
+                    // mark as error but continue with string
+                }
+            }
+            pos++;
+        }
+        return result;
+    }
+    function scanNext() {
+        value = '';
+        scanError = 0 /* ScanError.None */;
+        tokenOffset = pos;
+        if (pos >= len) {
+            // at the end
+            tokenOffset = len;
+            return token = 17 /* SyntaxKind.EOF */;
+        }
+        let code = text.charCodeAt(pos);
+        // trivia: whitespace
+        if (isWhitespace(code)) {
+            do {
+                pos++;
+                value += String.fromCharCode(code);
+                code = text.charCodeAt(pos);
+            } while (isWhitespace(code));
+            return token = 15 /* SyntaxKind.Trivia */;
+        }
+        // trivia: newlines
+        if (isLineBreak(code)) {
+            pos++;
+            value += String.fromCharCode(code);
+            if (code === 13 /* CharacterCodes.carriageReturn */ && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */) {
+                pos++;
+                value += '\n';
+            }
+            return token = 14 /* SyntaxKind.LineBreakTrivia */;
+        }
+        switch (code) {
+            // tokens: []{}:,
+            case 123 /* CharacterCodes.openBrace */:
+                pos++;
+                return token = 1 /* SyntaxKind.OpenBraceToken */;
+            case 125 /* CharacterCodes.closeBrace */:
+                pos++;
+                return token = 2 /* SyntaxKind.CloseBraceToken */;
+            case 91 /* CharacterCodes.openBracket */:
+                pos++;
+                return token = 3 /* SyntaxKind.OpenBracketToken */;
+            case 93 /* CharacterCodes.closeBracket */:
+                pos++;
+                return token = 4 /* SyntaxKind.CloseBracketToken */;
+            case 58 /* CharacterCodes.colon */:
+                pos++;
+                return token = 6 /* SyntaxKind.ColonToken */;
+            case 44 /* CharacterCodes.comma */:
+                pos++;
+                return token = 5 /* SyntaxKind.CommaToken */;
+            // strings
+            case 34 /* CharacterCodes.doubleQuote */:
+                pos++;
+                value = scanString();
+                return token = 10 /* SyntaxKind.StringLiteral */;
+            // comments
+            case 47 /* CharacterCodes.slash */: {
+                const start = pos - 1;
+                // Single-line comment
+                if (text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {
+                    pos += 2;
+                    while (pos < len) {
+                        if (isLineBreak(text.charCodeAt(pos))) {
+                            break;
+                        }
+                        pos++;
+                    }
+                    value = text.substring(start, pos);
+                    return token = 12 /* SyntaxKind.LineCommentTrivia */;
+                }
+                // Multi-line comment
+                if (text.charCodeAt(pos + 1) === 42 /* CharacterCodes.asterisk */) {
+                    pos += 2;
+                    const safeLength = len - 1; // For lookahead.
+                    let commentClosed = false;
+                    while (pos < safeLength) {
+                        const ch = text.charCodeAt(pos);
+                        if (ch === 42 /* CharacterCodes.asterisk */ && text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {
+                            pos += 2;
+                            commentClosed = true;
+                            break;
+                        }
+                        pos++;
+                    }
+                    if (!commentClosed) {
+                        pos++;
+                        scanError = 1 /* ScanError.UnexpectedEndOfComment */;
+                    }
+                    value = text.substring(start, pos);
+                    return token = 13 /* SyntaxKind.BlockCommentTrivia */;
+                }
+                // just a single slash
+                value += String.fromCharCode(code);
+                pos++;
+                return token = 16 /* SyntaxKind.Unknown */;
+            }
+            // numbers
+            case 45 /* CharacterCodes.minus */:
+                value += String.fromCharCode(code);
+                pos++;
+                if (pos === len || !isDigit(text.charCodeAt(pos))) {
+                    return token = 16 /* SyntaxKind.Unknown */;
+                }
+            // found a minus, followed by a number so
+            // we fall through to proceed with scanning
+            // numbers
+            case 48 /* CharacterCodes._0 */:
+            case 49 /* CharacterCodes._1 */:
+            case 50 /* CharacterCodes._2 */:
+            case 51 /* CharacterCodes._3 */:
+            case 52 /* CharacterCodes._4 */:
+            case 53 /* CharacterCodes._5 */:
+            case 54 /* CharacterCodes._6 */:
+            case 55 /* CharacterCodes._7 */:
+            case 56 /* CharacterCodes._8 */:
+            case 57 /* CharacterCodes._9 */:
+                value += scanNumber();
+                return token = 11 /* SyntaxKind.NumericLiteral */;
+            // literals and unknown symbols
+            default:
+                // is a literal? Read the full word.
+                while (pos < len && isUnknownContentCharacter(code)) {
+                    pos++;
+                    code = text.charCodeAt(pos);
+                }
+                if (tokenOffset !== pos) {
+                    value = text.substring(tokenOffset, pos);
+                    // keywords: true, false, null
+                    switch (value) {
+                        case 'true': return token = 8 /* SyntaxKind.TrueKeyword */;
+                        case 'false': return token = 9 /* SyntaxKind.FalseKeyword */;
+                        case 'null': return token = 7 /* SyntaxKind.NullKeyword */;
+                    }
+                    return token = 16 /* SyntaxKind.Unknown */;
+                }
+                // some
+                value += String.fromCharCode(code);
+                pos++;
+                return token = 16 /* SyntaxKind.Unknown */;
+        }
+    }
+    function isUnknownContentCharacter(code) {
+        if (isWhitespace(code) || isLineBreak(code)) {
+            return false;
+        }
+        switch (code) {
+            case 125 /* CharacterCodes.closeBrace */:
+            case 93 /* CharacterCodes.closeBracket */:
+            case 123 /* CharacterCodes.openBrace */:
+            case 91 /* CharacterCodes.openBracket */:
+            case 34 /* CharacterCodes.doubleQuote */:
+            case 58 /* CharacterCodes.colon */:
+            case 44 /* CharacterCodes.comma */:
+            case 47 /* CharacterCodes.slash */:
+                return false;
+        }
+        return true;
+    }
+    function scanNextNonTrivia() {
+        let result;
+        do {
+            result = scanNext();
+        } while (result >= 12 /* SyntaxKind.LineCommentTrivia */ && result <= 15 /* SyntaxKind.Trivia */);
+        return result;
+    }
+    return {
+        setPosition: setPosition,
+        getPosition: () => pos,
+        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
+        getToken: () => token,
+        getTokenValue: () => value,
+        getTokenOffset: () => tokenOffset,
+        getTokenLength: () => pos - tokenOffset,
+        getTokenError: () => scanError
+    };
+}
+function isWhitespace(ch) {
+    return ch === 32 /* CharacterCodes.space */ || ch === 9 /* CharacterCodes.tab */ || ch === 11 /* CharacterCodes.verticalTab */ || ch === 12 /* CharacterCodes.formFeed */ ||
+        ch === 160 /* CharacterCodes.nonBreakingSpace */ || ch === 5760 /* CharacterCodes.ogham */ || ch >= 8192 /* CharacterCodes.enQuad */ && ch <= 8203 /* CharacterCodes.zeroWidthSpace */ ||
+        ch === 8239 /* CharacterCodes.narrowNoBreakSpace */ || ch === 8287 /* CharacterCodes.mathematicalSpace */ || ch === 12288 /* CharacterCodes.ideographicSpace */ || ch === 65279 /* CharacterCodes.byteOrderMark */;
+}
+function isLineBreak(ch) {
+    return ch === 10 /* CharacterCodes.lineFeed */ || ch === 13 /* CharacterCodes.carriageReturn */ || ch === 8232 /* CharacterCodes.lineSeparator */ || ch === 8233 /* CharacterCodes.paragraphSeparator */;
+}
+function isDigit(ch) {
+    return ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */;
+}
+/**
+ * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
+ */
+export function getLocation(text, position) {
+    const segments = []; // strings or numbers
+    const earlyReturnException = new Object();
+    let previousNode = undefined;
+    const previousNodeInst = {
+        value: {},
+        offset: 0,
+        length: 0,
+        type: 'object',
+        parent: undefined
+    };
+    let isAtPropertyKey = false;
+    function setPreviousNode(value, offset, length, type) {
+        previousNodeInst.value = value;
+        previousNodeInst.offset = offset;
+        previousNodeInst.length = length;
+        previousNodeInst.type = type;
+        previousNodeInst.colonOffset = undefined;
+        previousNode = previousNodeInst;
+    }
+    try {
+        visit(text, {
+            onObjectBegin: (offset, length) => {
+                if (position <= offset) {
+                    throw earlyReturnException;
+                }
+                previousNode = undefined;
+                isAtPropertyKey = position > offset;
+                segments.push(''); // push a placeholder (will be replaced)
+            },
+            onObjectProperty: (name, offset, length) => {
+                if (position < offset) {
+                    throw earlyReturnException;
+                }
+                setPreviousNode(name, offset, length, 'property');
+                segments[segments.length - 1] = name;
+                if (position <= offset + length) {
+                    throw earlyReturnException;
+                }
+            },
+            onObjectEnd: (offset, length) => {
+                if (position <= offset) {
+                    throw earlyReturnException;
+                }
+                previousNode = undefined;
+                segments.pop();
+            },
+            onArrayBegin: (offset, length) => {
+                if (position <= offset) {
+                    throw earlyReturnException;
+                }
+                previousNode = undefined;
+                segments.push(0);
+            },
+            onArrayEnd: (offset, length) => {
+                if (position <= offset) {
+                    throw earlyReturnException;
+                }
+                previousNode = undefined;
+                segments.pop();
+            },
+            onLiteralValue: (value, offset, length) => {
+                if (position < offset) {
+                    throw earlyReturnException;
+                }
+                setPreviousNode(value, offset, length, getNodeType(value));
+                if (position <= offset + length) {
+                    throw earlyReturnException;
+                }
+            },
+            onSeparator: (sep, offset, length) => {
+                if (position <= offset) {
+                    throw earlyReturnException;
+                }
+                if (sep === ':' && previousNode && previousNode.type === 'property') {
+                    previousNode.colonOffset = offset;
+                    isAtPropertyKey = false;
+                    previousNode = undefined;
+                }
+                else if (sep === ',') {
+                    const last = segments[segments.length - 1];
+                    if (typeof last === 'number') {
+                        segments[segments.length - 1] = last + 1;
+                    }
+                    else {
+                        isAtPropertyKey = true;
+                        segments[segments.length - 1] = '';
+                    }
+                    previousNode = undefined;
+                }
+            }
+        });
+    }
+    catch (e) {
+        if (e !== earlyReturnException) {
+            throw e;
+        }
+    }
+    return {
+        path: segments,
+        previousNode,
+        isAtPropertyKey,
+        matches: (pattern) => {
+            let k = 0;
+            for (let i = 0; k < pattern.length && i < segments.length; i++) {
+                if (pattern[k] === segments[i] || pattern[k] === '*') {
+                    k++;
+                }
+                else if (pattern[k] !== '**') {
+                    return false;
+                }
+            }
+            return k === pattern.length;
+        }
+    };
+}
+/**
+ * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
+ * Therefore always check the errors list to find out if the input was valid.
+ */
+export function parse(text, errors = [], options = ParseOptions.DEFAULT) {
+    let currentProperty = null;
+    let currentParent = [];
+    const previousParents = [];
+    function onValue(value) {
+        if (Array.isArray(currentParent)) {
+            currentParent.push(value);
+        }
+        else if (currentProperty !== null) {
+            currentParent[currentProperty] = value;
+        }
+    }
+    const visitor = {
+        onObjectBegin: () => {
+            const object = {};
+            onValue(object);
+            previousParents.push(currentParent);
+            currentParent = object;
+            currentProperty = null;
+        },
+        onObjectProperty: (name) => {
+            currentProperty = name;
+        },
+        onObjectEnd: () => {
+            currentParent = previousParents.pop();
+        },
+        onArrayBegin: () => {
+            const array = [];
+            onValue(array);
+            previousParents.push(currentParent);
+            currentParent = array;
+            currentProperty = null;
+        },
+        onArrayEnd: () => {
+            currentParent = previousParents.pop();
+        },
+        onLiteralValue: onValue,
+        onError: (error, offset, length) => {
+            errors.push({ error, offset, length });
+        }
+    };
+    visit(text, visitor, options);
+    return currentParent[0];
+}
+/**
+ * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
+ */
+export function parseTree(text, errors = [], options = ParseOptions.DEFAULT) {
+    let currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root
+    function ensurePropertyComplete(endOffset) {
+        if (currentParent.type === 'property') {
+            currentParent.length = endOffset - currentParent.offset;
+            currentParent = currentParent.parent;
+        }
+    }
+    function onValue(valueNode) {
+        currentParent.children.push(valueNode);
+        return valueNode;
+    }
+    const visitor = {
+        onObjectBegin: (offset) => {
+            currentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });
+        },
+        onObjectProperty: (name, offset, length) => {
+            currentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });
+            currentParent.children.push({ type: 'string', value: name, offset, length, parent: currentParent });
+        },
+        onObjectEnd: (offset, length) => {
+            currentParent.length = offset + length - currentParent.offset;
+            currentParent = currentParent.parent;
+            ensurePropertyComplete(offset + length);
+        },
+        onArrayBegin: (offset, length) => {
+            currentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });
+        },
+        onArrayEnd: (offset, length) => {
+            currentParent.length = offset + length - currentParent.offset;
+            currentParent = currentParent.parent;
+            ensurePropertyComplete(offset + length);
+        },
+        onLiteralValue: (value, offset, length) => {
+            onValue({ type: getNodeType(value), offset, length, parent: currentParent, value });
+            ensurePropertyComplete(offset + length);
+        },
+        onSeparator: (sep, offset, length) => {
+            if (currentParent.type === 'property') {
+                if (sep === ':') {
+                    currentParent.colonOffset = offset;
+                }
+                else if (sep === ',') {
+                    ensurePropertyComplete(offset);
+                }
+            }
+        },
+        onError: (error, offset, length) => {
+            errors.push({ error, offset, length });
+        }
+    };
+    visit(text, visitor, options);
+    const result = currentParent.children[0];
+    if (result) {
+        delete result.parent;
+    }
+    return result;
+}
+/**
+ * Finds the node at the given path in a JSON DOM.
+ */
+export function findNodeAtLocation(root, path) {
+    if (!root) {
+        return undefined;
+    }
+    let node = root;
+    for (const segment of path) {
+        if (typeof segment === 'string') {
+            if (node.type !== 'object' || !Array.isArray(node.children)) {
+                return undefined;
+            }
+            let found = false;
+            for (const propertyNode of node.children) {
+                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {
+                    node = propertyNode.children[1];
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                return undefined;
+            }
+        }
+        else {
+            const index = segment;
+            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
+                return undefined;
+            }
+            node = node.children[index];
+        }
+    }
+    return node;
+}
+/**
+ * Gets the JSON path of the given JSON DOM node
+ */
+export function getNodePath(node) {
+    if (!node.parent || !node.parent.children) {
+        return [];
+    }
+    const path = getNodePath(node.parent);
+    if (node.parent.type === 'property') {
+        const key = node.parent.children[0].value;
+        path.push(key);
+    }
+    else if (node.parent.type === 'array') {
+        const index = node.parent.children.indexOf(node);
+        if (index !== -1) {
+            path.push(index);
+        }
+    }
+    return path;
+}
+/**
+ * Evaluates the JavaScript object of the given JSON DOM node
+ */
+export function getNodeValue(node) {
+    switch (node.type) {
+        case 'array':
+            return node.children.map(getNodeValue);
+        case 'object': {
+            const obj = Object.create(null);
+            for (const prop of node.children) {
+                const valueNode = prop.children[1];
+                if (valueNode) {
+                    obj[prop.children[0].value] = getNodeValue(valueNode);
+                }
+            }
+            return obj;
+        }
+        case 'null':
+        case 'string':
+        case 'number':
+        case 'boolean':
+            return node.value;
+        default:
+            return undefined;
+    }
+}
+export function contains(node, offset, includeRightBound = false) {
+    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));
+}
+/**
+ * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
+ */
+export function findNodeAtOffset(node, offset, includeRightBound = false) {
+    if (contains(node, offset, includeRightBound)) {
+        const children = node.children;
+        if (Array.isArray(children)) {
+            for (let i = 0; i < children.length && children[i].offset <= offset; i++) {
+                const item = findNodeAtOffset(children[i], offset, includeRightBound);
+                if (item) {
+                    return item;
+                }
+            }
+        }
+        return node;
+    }
+    return undefined;
+}
+/**
+ * Parses the given text and invokes the visitor functions for each object, array and literal reached.
+ */
+export function visit(text, visitor, options = ParseOptions.DEFAULT) {
+    const _scanner = createScanner(text, false);
+    function toNoArgVisit(visitFunction) {
+        return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;
+    }
+    function toOneArgVisit(visitFunction) {
+        return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;
+    }
+    const onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
+    const disallowComments = options && options.disallowComments;
+    const allowTrailingComma = options && options.allowTrailingComma;
+    function scanNext() {
+        while (true) {
+            const token = _scanner.scan();
+            switch (_scanner.getTokenError()) {
+                case 4 /* ScanError.InvalidUnicode */:
+                    handleError(14 /* ParseErrorCode.InvalidUnicode */);
+                    break;
+                case 5 /* ScanError.InvalidEscapeCharacter */:
+                    handleError(15 /* ParseErrorCode.InvalidEscapeCharacter */);
+                    break;
+                case 3 /* ScanError.UnexpectedEndOfNumber */:
+                    handleError(13 /* ParseErrorCode.UnexpectedEndOfNumber */);
+                    break;
+                case 1 /* ScanError.UnexpectedEndOfComment */:
+                    if (!disallowComments) {
+                        handleError(11 /* ParseErrorCode.UnexpectedEndOfComment */);
+                    }
+                    break;
+                case 2 /* ScanError.UnexpectedEndOfString */:
+                    handleError(12 /* ParseErrorCode.UnexpectedEndOfString */);
+                    break;
+                case 6 /* ScanError.InvalidCharacter */:
+                    handleError(16 /* ParseErrorCode.InvalidCharacter */);
+                    break;
+            }
+            switch (token) {
+                case 12 /* SyntaxKind.LineCommentTrivia */:
+                case 13 /* SyntaxKind.BlockCommentTrivia */:
+                    if (disallowComments) {
+                        handleError(10 /* ParseErrorCode.InvalidCommentToken */);
+                    }
+                    else {
+                        onComment();
+                    }
+                    break;
+                case 16 /* SyntaxKind.Unknown */:
+                    handleError(1 /* ParseErrorCode.InvalidSymbol */);
+                    break;
+                case 15 /* SyntaxKind.Trivia */:
+                case 14 /* SyntaxKind.LineBreakTrivia */:
+                    break;
+                default:
+                    return token;
+            }
+        }
+    }
+    function handleError(error, skipUntilAfter = [], skipUntil = []) {
+        onError(error);
+        if (skipUntilAfter.length + skipUntil.length > 0) {
+            let token = _scanner.getToken();
+            while (token !== 17 /* SyntaxKind.EOF */) {
+                if (skipUntilAfter.indexOf(token) !== -1) {
+                    scanNext();
+                    break;
+                }
+                else if (skipUntil.indexOf(token) !== -1) {
+                    break;
+                }
+                token = scanNext();
+            }
+        }
+    }
+    function parseString(isValue) {
+        const value = _scanner.getTokenValue();
+        if (isValue) {
+            onLiteralValue(value);
+        }
+        else {
+            onObjectProperty(value);
+        }
+        scanNext();
+        return true;
+    }
+    function parseLiteral() {
+        switch (_scanner.getToken()) {
+            case 11 /* SyntaxKind.NumericLiteral */: {
+                let value = 0;
+                try {
+                    value = JSON.parse(_scanner.getTokenValue());
+                    if (typeof value !== 'number') {
+                        handleError(2 /* ParseErrorCode.InvalidNumberFormat */);
+                        value = 0;
+                    }
+                }
+                catch (e) {
+                    handleError(2 /* ParseErrorCode.InvalidNumberFormat */);
+                }
+                onLiteralValue(value);
+                break;
+            }
+            case 7 /* SyntaxKind.NullKeyword */:
+                onLiteralValue(null);
+                break;
+            case 8 /* SyntaxKind.TrueKeyword */:
+                onLiteralValue(true);
+                break;
+            case 9 /* SyntaxKind.FalseKeyword */:
+                onLiteralValue(false);
+                break;
+            default:
+                return false;
+        }
+        scanNext();
+        return true;
+    }
+    function parseProperty() {
+        if (_scanner.getToken() !== 10 /* SyntaxKind.StringLiteral */) {
+            handleError(3 /* ParseErrorCode.PropertyNameExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);
+            return false;
+        }
+        parseString(false);
+        if (_scanner.getToken() === 6 /* SyntaxKind.ColonToken */) {
+            onSeparator(':');
+            scanNext(); // consume colon
+            if (!parseValue()) {
+                handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);
+            }
+        }
+        else {
+            handleError(5 /* ParseErrorCode.ColonExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);
+        }
+        return true;
+    }
+    function parseObject() {
+        onObjectBegin();
+        scanNext(); // consume open brace
+        let needsComma = false;
+        while (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {
+            if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {
+                if (!needsComma) {
+                    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);
+                }
+                onSeparator(',');
+                scanNext(); // consume comma
+                if (_scanner.getToken() === 2 /* SyntaxKind.CloseBraceToken */ && allowTrailingComma) {
+                    break;
+                }
+            }
+            else if (needsComma) {
+                handleError(6 /* ParseErrorCode.CommaExpected */, [], []);
+            }
+            if (!parseProperty()) {
+                handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);
+            }
+            needsComma = true;
+        }
+        onObjectEnd();
+        if (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */) {
+            handleError(7 /* ParseErrorCode.CloseBraceExpected */, [2 /* SyntaxKind.CloseBraceToken */], []);
+        }
+        else {
+            scanNext(); // consume close brace
+        }
+        return true;
+    }
+    function parseArray() {
+        onArrayBegin();
+        scanNext(); // consume open bracket
+        let needsComma = false;
+        while (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {
+            if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {
+                if (!needsComma) {
+                    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);
+                }
+                onSeparator(',');
+                scanNext(); // consume comma
+                if (_scanner.getToken() === 4 /* SyntaxKind.CloseBracketToken */ && allowTrailingComma) {
+                    break;
+                }
+            }
+            else if (needsComma) {
+                handleError(6 /* ParseErrorCode.CommaExpected */, [], []);
+            }
+            if (!parseValue()) {
+                handleError(4 /* ParseErrorCode.ValueExpected */, [], [4 /* SyntaxKind.CloseBracketToken */, 5 /* SyntaxKind.CommaToken */]);
+            }
+            needsComma = true;
+        }
+        onArrayEnd();
+        if (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */) {
+            handleError(8 /* ParseErrorCode.CloseBracketExpected */, [4 /* SyntaxKind.CloseBracketToken */], []);
+        }
+        else {
+            scanNext(); // consume close bracket
+        }
+        return true;
+    }
+    function parseValue() {
+        switch (_scanner.getToken()) {
+            case 3 /* SyntaxKind.OpenBracketToken */:
+                return parseArray();
+            case 1 /* SyntaxKind.OpenBraceToken */:
+                return parseObject();
+            case 10 /* SyntaxKind.StringLiteral */:
+                return parseString(true);
+            default:
+                return parseLiteral();
+        }
+    }
+    scanNext();
+    if (_scanner.getToken() === 17 /* SyntaxKind.EOF */) {
+        if (options.allowEmptyContent) {
+            return true;
+        }
+        handleError(4 /* ParseErrorCode.ValueExpected */, [], []);
+        return false;
+    }
+    if (!parseValue()) {
+        handleError(4 /* ParseErrorCode.ValueExpected */, [], []);
+        return false;
+    }
+    if (_scanner.getToken() !== 17 /* SyntaxKind.EOF */) {
+        handleError(9 /* ParseErrorCode.EndOfFileExpected */, [], []);
+    }
+    return true;
+}
+/**
+ * Takes JSON with JavaScript-style comments and remove
+ * them. Optionally replaces every none-newline character
+ * of comments with a replaceCharacter
+ */
+export function stripComments(text, replaceCh) {
+    const _scanner = createScanner(text);
+    const parts = [];
+    let kind;
+    let offset = 0;
+    let pos;
+    do {
+        pos = _scanner.getPosition();
+        kind = _scanner.scan();
+        switch (kind) {
+            case 12 /* SyntaxKind.LineCommentTrivia */:
+            case 13 /* SyntaxKind.BlockCommentTrivia */:
+            case 17 /* SyntaxKind.EOF */:
+                if (offset !== pos) {
+                    parts.push(text.substring(offset, pos));
+                }
+                if (replaceCh !== undefined) {
+                    parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
+                }
+                offset = _scanner.getPosition();
+                break;
+        }
+    } while (kind !== 17 /* SyntaxKind.EOF */);
+    return parts.join('');
+}
+export function getNodeType(value) {
+    switch (typeof value) {
+        case 'boolean': return 'boolean';
+        case 'number': return 'number';
+        case 'string': return 'string';
+        case 'object': {
+            if (!value) {
+                return 'null';
+            }
+            else if (Array.isArray(value)) {
+                return 'array';
+            }
+            return 'object';
+        }
+        default: return 'null';
+    }
+}
diff -urN -x '*.map' a/vs/base/common/keyCodes.js b/vs/base/common/keyCodes.js
--- a/vs/base/common/keyCodes.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/keyCodes.js	2023-12-06 14:23:14.351854734 +0000
@@ -26,6 +26,11 @@
 const scanCodeIntToStr = [];
 const scanCodeStrToInt = Object.create(null);
 const scanCodeLowerCaseStrToInt = Object.create(null);
+export const ScanCodeUtils = {
+    lowerCaseToEnum: (scanCode) => scanCodeLowerCaseStrToInt[scanCode] || 0 /* ScanCode.None */,
+    toEnum: (scanCode) => scanCodeStrToInt[scanCode] || 0 /* ScanCode.None */,
+    toString: (scanCode) => scanCodeIntToStr[scanCode] || 'None'
+};
 /**
  * -1 if a ScanCode => KeyCode mapping depends on kb layout.
  */
diff -urN -x '*.map' a/vs/base/common/keybindingLabels.js b/vs/base/common/keybindingLabels.js
--- a/vs/base/common/keybindingLabels.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/keybindingLabels.js	2023-12-06 14:23:14.351854734 +0000
@@ -37,38 +37,38 @@
     metaKey: '⌘',
     separator: '',
 }, {
-    ctrlKey: nls.localize({ key: 'ctrlKey', comment: ['This is the short form for the Control key on the keyboard'] }, "Ctrl"),
-    shiftKey: nls.localize({ key: 'shiftKey', comment: ['This is the short form for the Shift key on the keyboard'] }, "Shift"),
-    altKey: nls.localize({ key: 'altKey', comment: ['This is the short form for the Alt key on the keyboard'] }, "Alt"),
-    metaKey: nls.localize({ key: 'windowsKey', comment: ['This is the short form for the Windows key on the keyboard'] }, "Windows"),
+    ctrlKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'ctrlKey', comment: ['This is the short form for the Control key on the keyboard'] }, "Ctrl"),
+    shiftKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'shiftKey', comment: ['This is the short form for the Shift key on the keyboard'] }, "Shift"),
+    altKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'altKey', comment: ['This is the short form for the Alt key on the keyboard'] }, "Alt"),
+    metaKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'windowsKey', comment: ['This is the short form for the Windows key on the keyboard'] }, "Windows"),
     separator: '+',
 }, {
-    ctrlKey: nls.localize({ key: 'ctrlKey', comment: ['This is the short form for the Control key on the keyboard'] }, "Ctrl"),
-    shiftKey: nls.localize({ key: 'shiftKey', comment: ['This is the short form for the Shift key on the keyboard'] }, "Shift"),
-    altKey: nls.localize({ key: 'altKey', comment: ['This is the short form for the Alt key on the keyboard'] }, "Alt"),
-    metaKey: nls.localize({ key: 'superKey', comment: ['This is the short form for the Super key on the keyboard'] }, "Super"),
+    ctrlKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'ctrlKey', comment: ['This is the short form for the Control key on the keyboard'] }, "Ctrl"),
+    shiftKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'shiftKey', comment: ['This is the short form for the Shift key on the keyboard'] }, "Shift"),
+    altKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'altKey', comment: ['This is the short form for the Alt key on the keyboard'] }, "Alt"),
+    metaKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'superKey', comment: ['This is the short form for the Super key on the keyboard'] }, "Super"),
     separator: '+',
 });
 /**
  * A label provider that prints modifiers in a suitable format for ARIA.
  */
 export const AriaLabelProvider = new ModifierLabelProvider({
-    ctrlKey: nls.localize({ key: 'ctrlKey.long', comment: ['This is the long form for the Control key on the keyboard'] }, "Control"),
-    shiftKey: nls.localize({ key: 'shiftKey.long', comment: ['This is the long form for the Shift key on the keyboard'] }, "Shift"),
-    altKey: nls.localize({ key: 'optKey.long', comment: ['This is the long form for the Alt/Option key on the keyboard'] }, "Option"),
-    metaKey: nls.localize({ key: 'cmdKey.long', comment: ['This is the long form for the Command key on the keyboard'] }, "Command"),
+    ctrlKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'ctrlKey.long', comment: ['This is the long form for the Control key on the keyboard'] }, "Control"),
+    shiftKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'shiftKey.long', comment: ['This is the long form for the Shift key on the keyboard'] }, "Shift"),
+    altKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'optKey.long', comment: ['This is the long form for the Alt/Option key on the keyboard'] }, "Option"),
+    metaKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'cmdKey.long', comment: ['This is the long form for the Command key on the keyboard'] }, "Command"),
     separator: '+',
 }, {
-    ctrlKey: nls.localize({ key: 'ctrlKey.long', comment: ['This is the long form for the Control key on the keyboard'] }, "Control"),
-    shiftKey: nls.localize({ key: 'shiftKey.long', comment: ['This is the long form for the Shift key on the keyboard'] }, "Shift"),
-    altKey: nls.localize({ key: 'altKey.long', comment: ['This is the long form for the Alt key on the keyboard'] }, "Alt"),
-    metaKey: nls.localize({ key: 'windowsKey.long', comment: ['This is the long form for the Windows key on the keyboard'] }, "Windows"),
+    ctrlKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'ctrlKey.long', comment: ['This is the long form for the Control key on the keyboard'] }, "Control"),
+    shiftKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'shiftKey.long', comment: ['This is the long form for the Shift key on the keyboard'] }, "Shift"),
+    altKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'altKey.long', comment: ['This is the long form for the Alt key on the keyboard'] }, "Alt"),
+    metaKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'windowsKey.long', comment: ['This is the long form for the Windows key on the keyboard'] }, "Windows"),
     separator: '+',
 }, {
-    ctrlKey: nls.localize({ key: 'ctrlKey.long', comment: ['This is the long form for the Control key on the keyboard'] }, "Control"),
-    shiftKey: nls.localize({ key: 'shiftKey.long', comment: ['This is the long form for the Shift key on the keyboard'] }, "Shift"),
-    altKey: nls.localize({ key: 'altKey.long', comment: ['This is the long form for the Alt key on the keyboard'] }, "Alt"),
-    metaKey: nls.localize({ key: 'superKey.long', comment: ['This is the long form for the Super key on the keyboard'] }, "Super"),
+    ctrlKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'ctrlKey.long', comment: ['This is the long form for the Control key on the keyboard'] }, "Control"),
+    shiftKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'shiftKey.long', comment: ['This is the long form for the Shift key on the keyboard'] }, "Shift"),
+    altKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'altKey.long', comment: ['This is the long form for the Alt key on the keyboard'] }, "Alt"),
+    metaKey: nls.localizeWithPath('vs/base/common/keybindingLabels', { key: 'superKey.long', comment: ['This is the long form for the Super key on the keyboard'] }, "Super"),
     separator: '+',
 });
 /**
diff -urN -x '*.map' a/vs/base/common/keybindings.js b/vs/base/common/keybindings.js
--- a/vs/base/common/keybindings.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/keybindings.js	2023-12-06 14:23:14.351854734 +0000
@@ -56,6 +56,13 @@
             && this.metaKey === other.metaKey
             && this.keyCode === other.keyCode);
     }
+    getHashCode() {
+        const ctrl = this.ctrlKey ? '1' : '0';
+        const shift = this.shiftKey ? '1' : '0';
+        const alt = this.altKey ? '1' : '0';
+        const meta = this.metaKey ? '1' : '0';
+        return `K${ctrl}${shift}${alt}${meta}${this.keyCode}`;
+    }
     isModifierKey() {
         return (this.keyCode === 0 /* KeyCode.Unknown */
             || this.keyCode === 5 /* KeyCode.Ctrl */
@@ -63,6 +70,9 @@
             || this.keyCode === 6 /* KeyCode.Alt */
             || this.keyCode === 4 /* KeyCode.Shift */);
     }
+    toKeybinding() {
+        return new Keybinding([this]);
+    }
     /**
      * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
      */
@@ -85,6 +95,21 @@
         this.metaKey = metaKey;
         this.scanCode = scanCode;
     }
+    equals(other) {
+        return (other instanceof ScanCodeChord
+            && this.ctrlKey === other.ctrlKey
+            && this.shiftKey === other.shiftKey
+            && this.altKey === other.altKey
+            && this.metaKey === other.metaKey
+            && this.scanCode === other.scanCode);
+    }
+    getHashCode() {
+        const ctrl = this.ctrlKey ? '1' : '0';
+        const shift = this.shiftKey ? '1' : '0';
+        const alt = this.altKey ? '1' : '0';
+        const meta = this.metaKey ? '1' : '0';
+        return `S${ctrl}${shift}${alt}${meta}${this.scanCode}`;
+    }
     /**
      * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
      */
@@ -105,6 +130,30 @@
         }
         this.chords = chords;
     }
+    getHashCode() {
+        let result = '';
+        for (let i = 0, len = this.chords.length; i < len; i++) {
+            if (i !== 0) {
+                result += ';';
+            }
+            result += this.chords[i].getHashCode();
+        }
+        return result;
+    }
+    equals(other) {
+        if (other === null) {
+            return false;
+        }
+        if (this.chords.length !== other.chords.length) {
+            return false;
+        }
+        for (let i = 0; i < this.chords.length; i++) {
+            if (!this.chords[i].equals(other.chords[i])) {
+                return false;
+            }
+        }
+        return true;
+    }
 }
 export class ResolvedChord {
     constructor(ctrlKey, shiftKey, altKey, metaKey, keyLabel, keyAriaLabel) {
diff -urN -x '*.map' a/vs/base/common/labels.js b/vs/base/common/labels.js
--- a/vs/base/common/labels.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/labels.js	2023-12-06 14:23:14.351854734 +0000
@@ -1,5 +1,89 @@
-import { hasDriveLetter } from './extpath.js';
-import { isWindows } from './platform.js';
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { firstOrDefault } from './arrays.js';
+import { hasDriveLetter, toSlashes } from './extpath.js';
+import { posix, sep, win32 } from './path.js';
+import { isMacintosh, isWindows, OS } from './platform.js';
+import { extUri, extUriIgnorePathCase } from './resources.js';
+import { rtrim, startsWithIgnoreCase } from './strings.js';
+export function getPathLabel(resource, formatting) {
+    const { os, tildify: tildifier, relative: relatifier } = formatting;
+    // return early with a relative path if we can resolve one
+    if (relatifier) {
+        const relativePath = getRelativePathLabel(resource, relatifier, os);
+        if (typeof relativePath === 'string') {
+            return relativePath;
+        }
+    }
+    // otherwise try to resolve a absolute path label and
+    // apply target OS standard path separators if target
+    // OS differs from actual OS we are running in
+    let absolutePath = resource.fsPath;
+    if (os === 1 /* OperatingSystem.Windows */ && !isWindows) {
+        absolutePath = absolutePath.replace(/\//g, '\\');
+    }
+    else if (os !== 1 /* OperatingSystem.Windows */ && isWindows) {
+        absolutePath = absolutePath.replace(/\\/g, '/');
+    }
+    // macOS/Linux: tildify with provided user home directory
+    if (os !== 1 /* OperatingSystem.Windows */ && tildifier?.userHome) {
+        const userHome = tildifier.userHome.fsPath;
+        // This is a bit of a hack, but in order to figure out if the
+        // resource is in the user home, we need to make sure to convert it
+        // to a user home resource. We cannot assume that the resource is
+        // already a user home resource.
+        let userHomeCandidate;
+        if (resource.scheme !== tildifier.userHome.scheme && resource.path.startsWith(posix.sep)) {
+            userHomeCandidate = tildifier.userHome.with({ path: resource.path }).fsPath;
+        }
+        else {
+            userHomeCandidate = resource.fsPath;
+        }
+        absolutePath = tildify(userHomeCandidate, userHome, os);
+    }
+    // normalize
+    const pathLib = os === 1 /* OperatingSystem.Windows */ ? win32 : posix;
+    return pathLib.normalize(normalizeDriveLetter(absolutePath, os === 1 /* OperatingSystem.Windows */));
+}
+function getRelativePathLabel(resource, relativePathProvider, os) {
+    const pathLib = os === 1 /* OperatingSystem.Windows */ ? win32 : posix;
+    const extUriLib = os === 3 /* OperatingSystem.Linux */ ? extUri : extUriIgnorePathCase;
+    const workspace = relativePathProvider.getWorkspace();
+    const firstFolder = firstOrDefault(workspace.folders);
+    if (!firstFolder) {
+        return undefined;
+    }
+    // This is a bit of a hack, but in order to figure out the folder
+    // the resource belongs to, we need to make sure to convert it
+    // to a workspace resource. We cannot assume that the resource is
+    // already matching the workspace.
+    if (resource.scheme !== firstFolder.uri.scheme && resource.path.startsWith(posix.sep)) {
+        resource = firstFolder.uri.with({ path: resource.path });
+    }
+    const folder = relativePathProvider.getWorkspaceFolder(resource);
+    if (!folder) {
+        return undefined;
+    }
+    let relativePathLabel = undefined;
+    if (extUriLib.isEqual(folder.uri, resource)) {
+        relativePathLabel = ''; // no label if paths are identical
+    }
+    else {
+        relativePathLabel = extUriLib.relativePath(folder.uri, resource) ?? '';
+    }
+    // normalize
+    if (relativePathLabel) {
+        relativePathLabel = pathLib.normalize(relativePathLabel);
+    }
+    // always show root basename if there are multiple folders
+    if (workspace.folders.length > 1 && !relativePathProvider.noPrefix) {
+        const rootName = folder.name ? folder.name : extUriLib.basenameOrAuthority(folder.uri);
+        relativePathLabel = relativePathLabel ? `${rootName} • ${relativePathLabel}` : rootName;
+    }
+    return relativePathLabel;
+}
 export function normalizeDriveLetter(path, isWindowsOS = isWindows) {
     if (hasDriveLetter(path, isWindowsOS)) {
         return path.charAt(0).toUpperCase() + path.slice(1);
@@ -7,3 +91,262 @@
     return path;
 }
 let normalizedUserHomeCached = Object.create(null);
+export function tildify(path, userHome, os = OS) {
+    if (os === 1 /* OperatingSystem.Windows */ || !path || !userHome) {
+        return path; // unsupported on Windows
+    }
+    let normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;
+    if (!normalizedUserHome) {
+        normalizedUserHome = userHome;
+        if (isWindows) {
+            normalizedUserHome = toSlashes(normalizedUserHome); // make sure that the path is POSIX normalized on Windows
+        }
+        normalizedUserHome = `${rtrim(normalizedUserHome, posix.sep)}${posix.sep}`;
+        normalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };
+    }
+    let normalizedPath = path;
+    if (isWindows) {
+        normalizedPath = toSlashes(normalizedPath); // make sure that the path is POSIX normalized on Windows
+    }
+    // Linux: case sensitive, macOS: case insensitive
+    if (os === 3 /* OperatingSystem.Linux */ ? normalizedPath.startsWith(normalizedUserHome) : startsWithIgnoreCase(normalizedPath, normalizedUserHome)) {
+        return `~/${normalizedPath.substr(normalizedUserHome.length)}`;
+    }
+    return path;
+}
+export function untildify(path, userHome) {
+    return path.replace(/^~($|\/|\\)/, `${userHome}$1`);
+}
+/**
+ * Shortens the paths but keeps them easy to distinguish.
+ * Replaces not important parts with ellipsis.
+ * Every shorten path matches only one original path and vice versa.
+ *
+ * Algorithm for shortening paths is as follows:
+ * 1. For every path in list, find unique substring of that path.
+ * 2. Unique substring along with ellipsis is shortened path of that path.
+ * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string
+ *    and if present segment is not substring to any other paths then present segment is unique path,
+ *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,
+ *    if it is true take present segment as unique path.
+ * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.
+ *
+ * Example 1
+ * 1. consider 2 paths i.e. ['a\\b\\c\\d', 'a\\f\\b\\c\\d']
+ * 2. find unique path of first path,
+ * 	a. 'd' is present in path2 and is suffix of path2, hence not unique of present path.
+ * 	b. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.
+ * 	c. 'd\\c' is suffix of path2.
+ *  d. 'b\\c' is not suffix of present path.
+ *  e. 'a\\b' is not present in path2, hence unique path is 'a\\b...'.
+ * 3. for path2, 'f' is not present in path1 hence unique is '...\\f\\...'.
+ *
+ * Example 2
+ * 1. consider 2 paths i.e. ['a\\b', 'a\\b\\c'].
+ * 	a. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\b'.
+ * 2. for path2, 'c' is not present in path1 hence unique path is '..\\c'.
+ */
+const ellipsis = '\u2026';
+const unc = '\\\\';
+const home = '~';
+export function shorten(paths, pathSeparator = sep) {
+    const shortenedPaths = new Array(paths.length);
+    // for every path
+    let match = false;
+    for (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {
+        const originalPath = paths[pathIndex];
+        if (originalPath === '') {
+            shortenedPaths[pathIndex] = `.${pathSeparator}`;
+            continue;
+        }
+        if (!originalPath) {
+            shortenedPaths[pathIndex] = originalPath;
+            continue;
+        }
+        match = true;
+        // trim for now and concatenate unc path (e.g. \\network) or root path (/etc, ~/etc) later
+        let prefix = '';
+        let trimmedPath = originalPath;
+        if (trimmedPath.indexOf(unc) === 0) {
+            prefix = trimmedPath.substr(0, trimmedPath.indexOf(unc) + unc.length);
+            trimmedPath = trimmedPath.substr(trimmedPath.indexOf(unc) + unc.length);
+        }
+        else if (trimmedPath.indexOf(pathSeparator) === 0) {
+            prefix = trimmedPath.substr(0, trimmedPath.indexOf(pathSeparator) + pathSeparator.length);
+            trimmedPath = trimmedPath.substr(trimmedPath.indexOf(pathSeparator) + pathSeparator.length);
+        }
+        else if (trimmedPath.indexOf(home) === 0) {
+            prefix = trimmedPath.substr(0, trimmedPath.indexOf(home) + home.length);
+            trimmedPath = trimmedPath.substr(trimmedPath.indexOf(home) + home.length);
+        }
+        // pick the first shortest subpath found
+        const segments = trimmedPath.split(pathSeparator);
+        for (let subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {
+            for (let start = segments.length - subpathLength; match && start >= 0; start--) {
+                match = false;
+                let subpath = segments.slice(start, start + subpathLength).join(pathSeparator);
+                // that is unique to any other path
+                for (let otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {
+                    // suffix subpath treated specially as we consider no match 'x' and 'x/...'
+                    if (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {
+                        const isSubpathEnding = (start + subpathLength === segments.length);
+                        // Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.
+                        // prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.
+                        const subpathWithSep = (start > 0 && paths[otherPathIndex].indexOf(pathSeparator) > -1) ? pathSeparator + subpath : subpath;
+                        const isOtherPathEnding = paths[otherPathIndex].endsWith(subpathWithSep);
+                        match = !isSubpathEnding || isOtherPathEnding;
+                    }
+                }
+                // found unique subpath
+                if (!match) {
+                    let result = '';
+                    // preserve disk drive or root prefix
+                    if (segments[0].endsWith(':') || prefix !== '') {
+                        if (start === 1) {
+                            // extend subpath to include disk drive prefix
+                            start = 0;
+                            subpathLength++;
+                            subpath = segments[0] + pathSeparator + subpath;
+                        }
+                        if (start > 0) {
+                            result = segments[0] + pathSeparator;
+                        }
+                        result = prefix + result;
+                    }
+                    // add ellipsis at the beginning if needed
+                    if (start > 0) {
+                        result = result + ellipsis + pathSeparator;
+                    }
+                    result = result + subpath;
+                    // add ellipsis at the end if needed
+                    if (start + subpathLength < segments.length) {
+                        result = result + pathSeparator + ellipsis;
+                    }
+                    shortenedPaths[pathIndex] = result;
+                }
+            }
+        }
+        if (match) {
+            shortenedPaths[pathIndex] = originalPath; // use original path if no unique subpaths found
+        }
+    }
+    return shortenedPaths;
+}
+var Type;
+(function (Type) {
+    Type[Type["TEXT"] = 0] = "TEXT";
+    Type[Type["VARIABLE"] = 1] = "VARIABLE";
+    Type[Type["SEPARATOR"] = 2] = "SEPARATOR";
+})(Type || (Type = {}));
+/**
+ * Helper to insert values for specific template variables into the string. E.g. "this $(is) a $(template)" can be
+ * passed to this function together with an object that maps "is" and "template" to strings to have them replaced.
+ * @param value string to which template is applied
+ * @param values the values of the templates to use
+ */
+export function template(template, values = Object.create(null)) {
+    const segments = [];
+    let inVariable = false;
+    let curVal = '';
+    for (const char of template) {
+        // Beginning of variable
+        if (char === '$' || (inVariable && char === '{')) {
+            if (curVal) {
+                segments.push({ value: curVal, type: Type.TEXT });
+            }
+            curVal = '';
+            inVariable = true;
+        }
+        // End of variable
+        else if (char === '}' && inVariable) {
+            const resolved = values[curVal];
+            // Variable
+            if (typeof resolved === 'string') {
+                if (resolved.length) {
+                    segments.push({ value: resolved, type: Type.VARIABLE });
+                }
+            }
+            // Separator
+            else if (resolved) {
+                const prevSegment = segments[segments.length - 1];
+                if (!prevSegment || prevSegment.type !== Type.SEPARATOR) {
+                    segments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators
+                }
+            }
+            curVal = '';
+            inVariable = false;
+        }
+        // Text or Variable Name
+        else {
+            curVal += char;
+        }
+    }
+    // Tail
+    if (curVal && !inVariable) {
+        segments.push({ value: curVal, type: Type.TEXT });
+    }
+    return segments.filter((segment, index) => {
+        // Only keep separator if we have values to the left and right
+        if (segment.type === Type.SEPARATOR) {
+            const left = segments[index - 1];
+            const right = segments[index + 1];
+            return [left, right].every(segment => segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0);
+        }
+        // accept any TEXT and VARIABLE
+        return true;
+    }).map(segment => segment.value).join('');
+}
+/**
+ * Handles mnemonics for menu items. Depending on OS:
+ * - Windows: Supported via & character (replace && with &)
+ * -   Linux: Supported via & character (replace && with &)
+ * -   macOS: Unsupported (replace && with empty string)
+ */
+export function mnemonicMenuLabel(label, forceDisableMnemonics) {
+    if (isMacintosh || forceDisableMnemonics) {
+        return label.replace(/\(&&\w\)|&&/g, '').replace(/&/g, isMacintosh ? '&' : '&&');
+    }
+    return label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');
+}
+/**
+ * Handles mnemonics for buttons. Depending on OS:
+ * - Windows: Supported via & character (replace && with & and & with && for escaping)
+ * -   Linux: Supported via _ character (replace && with _)
+ * -   macOS: Unsupported (replace && with empty string)
+ */
+export function mnemonicButtonLabel(label, forceDisableMnemonics) {
+    if (isMacintosh || forceDisableMnemonics) {
+        return label.replace(/\(&&\w\)|&&/g, '');
+    }
+    if (isWindows) {
+        return label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');
+    }
+    return label.replace(/&&/g, '_');
+}
+export function unmnemonicLabel(label) {
+    return label.replace(/&/g, '&&');
+}
+/**
+ * Splits a recent label in name and parent path, supporting both '/' and '\' and workspace suffixes
+ */
+export function splitRecentLabel(recentLabel) {
+    if (recentLabel.endsWith(']')) {
+        // label with workspace suffix
+        const lastIndexOfSquareBracket = recentLabel.lastIndexOf(' [', recentLabel.length - 2);
+        if (lastIndexOfSquareBracket !== -1) {
+            const split = splitName(recentLabel.substring(0, lastIndexOfSquareBracket));
+            return { name: split.name, parentPath: split.parentPath + recentLabel.substring(lastIndexOfSquareBracket) };
+        }
+    }
+    return splitName(recentLabel);
+}
+function splitName(fullPath) {
+    const p = fullPath.indexOf('/') !== -1 ? posix : win32;
+    const name = p.basename(fullPath);
+    const parentPath = p.dirname(fullPath);
+    if (name.length) {
+        return { name, parentPath };
+    }
+    // only the root segment
+    return { name: parentPath, parentPath: '' };
+}
diff -urN -x '*.map' a/vs/base/common/lazy.js b/vs/base/common/lazy.js
--- a/vs/base/common/lazy.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/lazy.js	2023-12-06 14:23:14.351854734 +0000
@@ -8,6 +8,10 @@
         this._didRun = false;
     }
     /**
+     * True if the lazy value has been resolved.
+     */
+    get hasValue() { return this._didRun; }
+    /**
      * Get the wrapped value.
      *
      * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
diff -urN -x '*.map' a/vs/base/common/lifecycle.js b/vs/base/common/lifecycle.js
--- a/vs/base/common/lifecycle.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/lifecycle.js	2023-12-06 14:23:14.351854734 +0000
@@ -1,3 +1,10 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { compareBy, numberComparator } from './arrays.js';
+import { groupBy } from './collections.js';
+import { SetMap } from './map.js';
 import { createSingleCallFunction } from './functional.js';
 import { Iterable } from './iterator.js';
 // #region Disposable Tracking
@@ -10,6 +17,122 @@
  */
 const TRACK_DISPOSABLES = false;
 let disposableTracker = null;
+export class DisposableTracker {
+    constructor() {
+        this.livingDisposables = new Map();
+    }
+    getDisposableData(d) {
+        let val = this.livingDisposables.get(d);
+        if (!val) {
+            val = { parent: null, source: null, isSingleton: false, value: d, idx: DisposableTracker.idx++ };
+            this.livingDisposables.set(d, val);
+        }
+        return val;
+    }
+    trackDisposable(d) {
+        const data = this.getDisposableData(d);
+        if (!data.source) {
+            data.source =
+                new Error().stack;
+        }
+    }
+    setParent(child, parent) {
+        const data = this.getDisposableData(child);
+        data.parent = parent;
+    }
+    markAsDisposed(x) {
+        this.livingDisposables.delete(x);
+    }
+    markAsSingleton(disposable) {
+        this.getDisposableData(disposable).isSingleton = true;
+    }
+    getRootParent(data, cache) {
+        const cacheValue = cache.get(data);
+        if (cacheValue) {
+            return cacheValue;
+        }
+        const result = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;
+        cache.set(data, result);
+        return result;
+    }
+    getTrackedDisposables() {
+        const rootParentCache = new Map();
+        const leaking = [...this.livingDisposables.entries()]
+            .filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton)
+            .map(([k]) => k)
+            .flat();
+        return leaking;
+    }
+    computeLeakingDisposables(maxReported = 10, preComputedLeaks) {
+        let uncoveredLeakingObjs;
+        if (preComputedLeaks) {
+            uncoveredLeakingObjs = preComputedLeaks;
+        }
+        else {
+            const rootParentCache = new Map();
+            const leakingObjects = [...this.livingDisposables.values()]
+                .filter((info) => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);
+            if (leakingObjects.length === 0) {
+                return;
+            }
+            const leakingObjsSet = new Set(leakingObjects.map(o => o.value));
+            // Remove all objects that are a child of other leaking objects. Assumes there are no cycles.
+            uncoveredLeakingObjs = leakingObjects.filter(l => {
+                return !(l.parent && leakingObjsSet.has(l.parent));
+            });
+            if (uncoveredLeakingObjs.length === 0) {
+                throw new Error('There are cyclic diposable chains!');
+            }
+        }
+        if (!uncoveredLeakingObjs) {
+            return undefined;
+        }
+        function getStackTracePath(leaking) {
+            function removePrefix(array, linesToRemove) {
+                while (array.length > 0 && linesToRemove.some(regexp => typeof regexp === 'string' ? regexp === array[0] : array[0].match(regexp))) {
+                    array.shift();
+                }
+            }
+            const lines = leaking.source.split('\n').map(p => p.trim().replace('at ', '')).filter(l => l !== '');
+            removePrefix(lines, ['Error', /^trackDisposable \(.*\)$/, /^DisposableTracker.trackDisposable \(.*\)$/]);
+            return lines.reverse();
+        }
+        const stackTraceStarts = new SetMap();
+        for (const leaking of uncoveredLeakingObjs) {
+            const stackTracePath = getStackTracePath(leaking);
+            for (let i = 0; i <= stackTracePath.length; i++) {
+                stackTraceStarts.add(stackTracePath.slice(0, i).join('\n'), leaking);
+            }
+        }
+        // Put earlier leaks first
+        uncoveredLeakingObjs.sort(compareBy(l => l.idx, numberComparator));
+        let message = '';
+        let i = 0;
+        for (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {
+            i++;
+            const stackTracePath = getStackTracePath(leaking);
+            const stackTraceFormattedLines = [];
+            for (let i = 0; i < stackTracePath.length; i++) {
+                let line = stackTracePath[i];
+                const starts = stackTraceStarts.get(stackTracePath.slice(0, i + 1).join('\n'));
+                line = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;
+                const prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i).join('\n'));
+                const continuations = groupBy([...prevStarts].map(d => getStackTracePath(d)[i]), v => v);
+                delete continuations[stackTracePath[i]];
+                for (const [cont, set] of Object.entries(continuations)) {
+                    stackTraceFormattedLines.unshift(`    - stacktraces of ${set.length} other leaks continue with ${cont}`);
+                }
+                stackTraceFormattedLines.unshift(line);
+            }
+            message += `\n\n\n==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================\n${stackTraceFormattedLines.join('\n')}\n============================================================\n\n`;
+        }
+        if (uncoveredLeakingObjs.length > maxReported) {
+            message += `\n\n\n... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables\n\n`;
+        }
+        return { leaks: uncoveredLeakingObjs, details: message };
+    }
+}
+DisposableTracker.idx = 0;
 export function setDisposableTracker(tracker) {
     disposableTracker = tracker;
 }
@@ -29,7 +152,7 @@
                 try {
                     child[__is_disposable_tracked__] = true;
                 }
-                catch (_a) {
+                catch {
                     // noop
                 }
             }
@@ -39,7 +162,7 @@
                 try {
                     disposable[__is_disposable_tracked__] = true;
                 }
-                catch (_a) {
+                catch {
                     // noop
                 }
             }
@@ -48,14 +171,14 @@
     });
 }
 export function trackDisposable(x) {
-    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);
+    disposableTracker?.trackDisposable(x);
     return x;
 }
 export function markAsDisposed(disposable) {
-    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);
+    disposableTracker?.markAsDisposed(disposable);
 }
 function setParentOfDisposable(child, parent) {
-    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);
+    disposableTracker?.setParent(child, parent);
 }
 function setParentOfDisposables(children, parent) {
     if (!disposableTracker) {
@@ -69,7 +192,7 @@
  * Indicates that the given object is a singleton which does not need to be disposed.
 */
 export function markAsSingleton(singleton) {
-    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);
+    disposableTracker?.markAsSingleton(singleton);
     return singleton;
 }
 /**
@@ -104,6 +227,14 @@
         return arg;
     }
 }
+export function disposeIfDisposable(disposables) {
+    for (const d of disposables) {
+        if (isDisposable(d)) {
+            d.dispose();
+        }
+    }
+    return [];
+}
 /**
  * Combine multiple disposable values into a single {@link IDisposable}.
  */
@@ -194,6 +325,20 @@
         return o;
     }
     /**
+     * Deletes a disposable from store and disposes of it. This will not throw or warn and proceed to dispose the
+     * disposable even when the disposable is not part in the store.
+     */
+    delete(o) {
+        if (!o) {
+            return;
+        }
+        if (o === this) {
+            throw new Error('Cannot dispose a disposable on itself!');
+        }
+        this._toDispose.delete(o);
+        o.dispose();
+    }
+    /**
      * Deletes the value from the store, but does not dispose it.
      */
     deleteAndLeak(o) {
@@ -253,11 +398,10 @@
         return this._isDisposed ? undefined : this._value;
     }
     set value(value) {
-        var _a;
         if (this._isDisposed || value === this._value) {
             return;
         }
-        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._value?.dispose();
         if (value) {
             setParentOfDisposable(value, this);
         }
@@ -270,12 +414,23 @@
         this.value = undefined;
     }
     dispose() {
-        var _a;
         this._isDisposed = true;
         markAsDisposed(this);
-        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._value?.dispose();
         this._value = undefined;
     }
+    /**
+     * Clears the value, but does not dispose it.
+     * The old value is returned.
+    */
+    clearAndLeak() {
+        const oldValue = this._value;
+        this._value = undefined;
+        if (oldValue) {
+            setParentOfDisposable(oldValue, null);
+        }
+        return oldValue;
+    }
 }
 export class RefCountedDisposable {
     constructor(_disposable) {
@@ -293,12 +448,90 @@
         return this;
     }
 }
+/**
+ * A safe disposable can be `unset` so that a leaked reference (listener)
+ * can be cut-off.
+ */
+export class SafeDisposable {
+    constructor() {
+        this.dispose = () => { };
+        this.unset = () => { };
+        this.isset = () => false;
+        trackDisposable(this);
+    }
+    set(fn) {
+        let callback = fn;
+        this.unset = () => callback = undefined;
+        this.isset = () => callback !== undefined;
+        this.dispose = () => {
+            if (callback) {
+                callback();
+                callback = undefined;
+                markAsDisposed(this);
+            }
+        };
+        return this;
+    }
+}
+export class ReferenceCollection {
+    constructor() {
+        this.references = new Map();
+    }
+    acquire(key, ...args) {
+        let reference = this.references.get(key);
+        if (!reference) {
+            reference = { counter: 0, object: this.createReferencedObject(key, ...args) };
+            this.references.set(key, reference);
+        }
+        const { object } = reference;
+        const dispose = createSingleCallFunction(() => {
+            if (--reference.counter === 0) {
+                this.destroyReferencedObject(key, reference.object);
+                this.references.delete(key);
+            }
+        });
+        reference.counter++;
+        return { object, dispose };
+    }
+}
+/**
+ * Unwraps a reference collection of promised values. Makes sure
+ * references are disposed whenever promises get rejected.
+ */
+export class AsyncReferenceCollection {
+    constructor(referenceCollection) {
+        this.referenceCollection = referenceCollection;
+    }
+    async acquire(key, ...args) {
+        const ref = this.referenceCollection.acquire(key, ...args);
+        try {
+            const object = await ref.object;
+            return {
+                object,
+                dispose: () => ref.dispose()
+            };
+        }
+        catch (error) {
+            ref.dispose();
+            throw error;
+        }
+    }
+}
 export class ImmortalReference {
     constructor(object) {
         this.object = object;
     }
     dispose() { }
 }
+export function disposeOnReturn(fn) {
+    const store = new DisposableStore();
+    try {
+        fn(store);
+    }
+    finally {
+        store.dispose();
+    }
+}
 /**
  * A map the manages the lifecycle of the values that it stores.
  */
@@ -332,16 +565,21 @@
             this._store.clear();
         }
     }
+    has(key) {
+        return this._store.has(key);
+    }
+    get size() {
+        return this._store.size;
+    }
     get(key) {
         return this._store.get(key);
     }
     set(key, value, skipDisposeOnOverwrite = false) {
-        var _a;
         if (this._isDisposed) {
             console.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);
         }
         if (!skipDisposeOnOverwrite) {
-            (_a = this._store.get(key)) === null || _a === void 0 ? void 0 : _a.dispose();
+            this._store.get(key)?.dispose();
         }
         this._store.set(key, value);
     }
@@ -349,8 +587,7 @@
      * Delete the value stored for `key` from this map and also dispose of it.
      */
     deleteAndDispose(key) {
-        var _a;
-        (_a = this._store.get(key)) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._store.get(key)?.dispose();
         this._store.delete(key);
     }
     [Symbol.iterator]() {
diff -urN -x '*.map' a/vs/base/common/map.js b/vs/base/common/map.js
--- a/vs/base/common/map.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/map.js	2023-12-06 14:23:14.351854734 +0000
@@ -2,7 +2,29 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var _a, _b;
+var _a, _b, _c;
+export function getOrSet(map, key, value) {
+    let result = map.get(key);
+    if (result === undefined) {
+        result = value;
+        map.set(key, result);
+    }
+    return result;
+}
+export function mapToString(map) {
+    const entries = [];
+    map.forEach((value, key) => {
+        entries.push(`${key} => ${value}`);
+    });
+    return `Map(${map.size}) {${entries.join(', ')}}`;
+}
+export function setToString(set) {
+    const entries = [];
+    set.forEach(value => {
+        entries.push(value);
+    });
+    return `Set(${set.size}) {${entries.join(', ')}}`;
+}
 class ResourceMapEntry {
     constructor(uri, value) {
         this.uri = uri;
@@ -17,18 +39,18 @@
         this[_a] = 'ResourceMap';
         if (arg instanceof ResourceMap) {
             this.map = new Map(arg.map);
-            this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;
+            this.toKey = toKey ?? ResourceMap.defaultToKey;
         }
         else if (isEntries(arg)) {
             this.map = new Map();
-            this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;
+            this.toKey = toKey ?? ResourceMap.defaultToKey;
             for (const [resource, value] of arg) {
                 this.set(resource, value);
             }
         }
         else {
             this.map = new Map();
-            this.toKey = arg !== null && arg !== void 0 ? arg : ResourceMap.defaultToKey;
+            this.toKey = arg ?? ResourceMap.defaultToKey;
         }
     }
     set(resource, value) {
@@ -36,8 +58,7 @@
         return this;
     }
     get(resource) {
-        var _c;
-        return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;
+        return this.map.get(this.toKey(resource))?.value;
     }
     has(resource) {
         return this.map.has(this.toKey(resource));
@@ -81,9 +102,52 @@
     }
 }
 ResourceMap.defaultToKey = (resource) => resource.toString();
+export class ResourceSet {
+    constructor(entriesOrKey, toKey) {
+        this[_b] = 'ResourceSet';
+        if (!entriesOrKey || typeof entriesOrKey === 'function') {
+            this._map = new ResourceMap(entriesOrKey);
+        }
+        else {
+            this._map = new ResourceMap(toKey);
+            entriesOrKey.forEach(this.add, this);
+        }
+    }
+    get size() {
+        return this._map.size;
+    }
+    add(value) {
+        this._map.set(value, value);
+        return this;
+    }
+    clear() {
+        this._map.clear();
+    }
+    delete(value) {
+        return this._map.delete(value);
+    }
+    forEach(callbackfn, thisArg) {
+        this._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));
+    }
+    has(value) {
+        return this._map.has(value);
+    }
+    entries() {
+        return this._map.entries();
+    }
+    keys() {
+        return this._map.keys();
+    }
+    values() {
+        return this._map.keys();
+    }
+    [(_b = Symbol.toStringTag, Symbol.iterator)]() {
+        return this.keys();
+    }
+}
 export class LinkedMap {
     constructor() {
-        this[_b] = 'LinkedMap';
+        this[_c] = 'LinkedMap';
         this._map = new Map();
         this._head = undefined;
         this._tail = undefined;
@@ -104,12 +168,10 @@
         return this._size;
     }
     get first() {
-        var _c;
-        return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;
+        return this._head?.value;
     }
     get last() {
-        var _c;
-        return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;
+        return this._tail?.value;
     }
     has(key) {
         return this._map.has(key);
@@ -267,7 +329,7 @@
         };
         return iterator;
     }
-    [(_b = Symbol.toStringTag, Symbol.iterator)]() {
+    [(_c = Symbol.toStringTag, Symbol.iterator)]() {
         return this.entries();
     }
     trimOld(newSize) {
@@ -442,6 +504,13 @@
         this._limit = limit;
         this.checkTrim();
     }
+    get ratio() {
+        return this._ratio;
+    }
+    set ratio(ratio) {
+        this._ratio = Math.min(Math.max(0, ratio), 1);
+        this.checkTrim();
+    }
     get(key, touch = 2 /* Touch.AsNew */) {
         return super.get(key, touch);
     }
@@ -459,6 +528,32 @@
         }
     }
 }
+export class CounterSet {
+    constructor() {
+        this.map = new Map();
+    }
+    add(value) {
+        this.map.set(value, (this.map.get(value) || 0) + 1);
+        return this;
+    }
+    delete(value) {
+        let counter = this.map.get(value) || 0;
+        if (counter === 0) {
+            return false;
+        }
+        counter--;
+        if (counter === 0) {
+            this.map.delete(value);
+        }
+        else {
+            this.map.set(value, counter);
+        }
+        return true;
+    }
+    has(value) {
+        return this.map.has(value);
+    }
+}
 /**
  * A map that allows access both by keys and values.
  * **NOTE**: values need to be unique.
@@ -496,6 +591,11 @@
         this._m2.delete(value);
         return true;
     }
+    forEach(callbackfn, thisArg) {
+        this._m1.forEach((value, key) => {
+            callbackfn.call(thisArg, value, key, this);
+        });
+    }
     keys() {
         return this._m1.keys();
     }
diff -urN -x '*.map' a/vs/base/common/mime.js b/vs/base/common/mime.js
--- a/vs/base/common/mime.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/mime.js	2023-12-06 14:23:14.351854734 +0000
@@ -1,3 +1,8 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { extname } from './path.js';
 export const Mimes = Object.freeze({
     text: 'text/plain',
     binary: 'application/octet-stream',
@@ -6,3 +11,100 @@
     latex: 'text/latex',
     uriList: 'text/uri-list',
 });
+const mapExtToTextMimes = {
+    '.css': 'text/css',
+    '.csv': 'text/csv',
+    '.htm': 'text/html',
+    '.html': 'text/html',
+    '.ics': 'text/calendar',
+    '.js': 'text/javascript',
+    '.mjs': 'text/javascript',
+    '.txt': 'text/plain',
+    '.xml': 'text/xml'
+};
+// Known media mimes that we can handle
+const mapExtToMediaMimes = {
+    '.aac': 'audio/x-aac',
+    '.avi': 'video/x-msvideo',
+    '.bmp': 'image/bmp',
+    '.flv': 'video/x-flv',
+    '.gif': 'image/gif',
+    '.ico': 'image/x-icon',
+    '.jpe': 'image/jpg',
+    '.jpeg': 'image/jpg',
+    '.jpg': 'image/jpg',
+    '.m1v': 'video/mpeg',
+    '.m2a': 'audio/mpeg',
+    '.m2v': 'video/mpeg',
+    '.m3a': 'audio/mpeg',
+    '.mid': 'audio/midi',
+    '.midi': 'audio/midi',
+    '.mk3d': 'video/x-matroska',
+    '.mks': 'video/x-matroska',
+    '.mkv': 'video/x-matroska',
+    '.mov': 'video/quicktime',
+    '.movie': 'video/x-sgi-movie',
+    '.mp2': 'audio/mpeg',
+    '.mp2a': 'audio/mpeg',
+    '.mp3': 'audio/mpeg',
+    '.mp4': 'video/mp4',
+    '.mp4a': 'audio/mp4',
+    '.mp4v': 'video/mp4',
+    '.mpe': 'video/mpeg',
+    '.mpeg': 'video/mpeg',
+    '.mpg': 'video/mpeg',
+    '.mpg4': 'video/mp4',
+    '.mpga': 'audio/mpeg',
+    '.oga': 'audio/ogg',
+    '.ogg': 'audio/ogg',
+    '.opus': 'audio/opus',
+    '.ogv': 'video/ogg',
+    '.png': 'image/png',
+    '.psd': 'image/vnd.adobe.photoshop',
+    '.qt': 'video/quicktime',
+    '.spx': 'audio/ogg',
+    '.svg': 'image/svg+xml',
+    '.tga': 'image/x-tga',
+    '.tif': 'image/tiff',
+    '.tiff': 'image/tiff',
+    '.wav': 'audio/x-wav',
+    '.webm': 'video/webm',
+    '.webp': 'image/webp',
+    '.wma': 'audio/x-ms-wma',
+    '.wmv': 'video/x-ms-wmv',
+    '.woff': 'application/font-woff',
+};
+export function getMediaOrTextMime(path) {
+    const ext = extname(path);
+    const textMime = mapExtToTextMimes[ext.toLowerCase()];
+    if (textMime !== undefined) {
+        return textMime;
+    }
+    else {
+        return getMediaMime(path);
+    }
+}
+export function getMediaMime(path) {
+    const ext = extname(path);
+    return mapExtToMediaMimes[ext.toLowerCase()];
+}
+export function getExtensionForMimeType(mimeType) {
+    for (const extension in mapExtToMediaMimes) {
+        if (mapExtToMediaMimes[extension] === mimeType) {
+            return extension;
+        }
+    }
+    return undefined;
+}
+const _simplePattern = /^(.+)\/(.+?)(;.+)?$/;
+export function normalizeMimeType(mimeType, strict) {
+    const match = _simplePattern.exec(mimeType);
+    if (!match) {
+        return strict
+            ? undefined
+            : mimeType;
+    }
+    // https://datatracker.ietf.org/doc/html/rfc2045#section-5.1
+    // media and subtype must ALWAYS be lowercase, parameter not
+    return `${match[1].toLowerCase()}/${match[2].toLowerCase()}${match[3] ?? ''}`;
+}
diff -urN -x '*.map' a/vs/base/common/network.js b/vs/base/common/network.js
--- a/vs/base/common/network.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/network.js	2023-12-06 14:23:14.351854734 +0000
@@ -3,6 +3,8 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import * as errors from './errors.js';
+import { toDisposable } from './lifecycle.js';
+import { ResourceMap } from './map.js';
 import * as platform from './platform.js';
 import { URI } from './uri.js';
 export var Schemas;
@@ -78,6 +80,7 @@
      */
     Schemas.vscodeSourceControl = 'vscode-scm';
 })(Schemas || (Schemas = {}));
+export const connectionTokenCookieName = 'vscode-tkn';
 export const connectionTokenQueryName = 'tkn';
 class RemoteAuthoritiesImpl {
     constructor() {
@@ -91,6 +94,22 @@
     setPreferredWebSchema(schema) {
         this._preferredWebSchema = schema;
     }
+    setDelegate(delegate) {
+        this._delegate = delegate;
+    }
+    setServerRootPath(serverRootPath) {
+        this._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;
+    }
+    set(authority, host, port) {
+        this._hosts[authority] = host;
+        this._ports[authority] = port;
+    }
+    setConnectionToken(authority, connectionToken) {
+        this._connectionTokens[authority] = connectionToken;
+    }
+    getPreferredWebSchema() {
+        return this._preferredWebSchema;
+    }
     rewrite(uri) {
         if (this._delegate) {
             try {
@@ -121,7 +140,35 @@
     }
 }
 export const RemoteAuthorities = new RemoteAuthoritiesImpl();
+export const builtinExtensionsPath = 'vs/../../extensions';
+export const nodeModulesPath = 'vs/../../node_modules';
+export const nodeModulesAsarPath = 'vs/../../node_modules.asar';
+export const nodeModulesAsarUnpackedPath = 'vs/../../node_modules.asar.unpacked';
 class FileAccessImpl {
+    constructor() {
+        this.staticBrowserUris = new ResourceMap();
+        this.appResourcePathUrls = new Map();
+    }
+    registerAppResourcePathUrl(moduleId, url) {
+        this.appResourcePathUrls.set(moduleId, url);
+    }
+    toUrl(moduleId) {
+        let url = this.appResourcePathUrls.get(moduleId);
+        if (typeof url === 'function') {
+            url = url();
+        }
+        return new URL(url ?? '', globalThis.location?.href ?? import.meta.url).toString();
+    }
+    /**
+     * Returns a URI to use in contexts where the browser is responsible
+     * for loading (e.g. fetch()) or when used within the DOM.
+     *
+     * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
+     */
+    asBrowserUri(resourcePath) {
+        const uri = this.toUri(resourcePath, { toUrl: this.toUrl.bind(this) });
+        return this.uriToBrowserUri(uri);
+    }
     /**
      * Returns a URI to use in contexts where the browser is responsible
      * for loading (e.g. fetch()) or when used within the DOM.
@@ -153,8 +200,52 @@
                 fragment: null
             });
         }
+        return this.staticBrowserUris.get(uri) ?? uri;
+    }
+    /**
+     * Returns the `file` URI to use in contexts where node.js
+     * is responsible for loading.
+     */
+    asFileUri(resourcePath) {
+        const uri = this.toUri(resourcePath, { toUrl: this.toUrl.bind(this) });
+        return this.uriToFileUri(uri);
+    }
+    /**
+     * Returns the `file` URI to use in contexts where node.js
+     * is responsible for loading.
+     */
+    uriToFileUri(uri) {
+        // Only convert the URI if it is `vscode-file:` scheme
+        if (uri.scheme === Schemas.vscodeFileResource) {
+            return uri.with({
+                scheme: Schemas.file,
+                // Only preserve the `authority` if it is different from
+                // our fallback authority. This ensures we properly preserve
+                // Windows UNC paths that come with their own authority.
+                authority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,
+                query: null,
+                fragment: null
+            });
+        }
         return uri;
     }
+    toUri(uriOrModule, moduleIdToUrl) {
+        if (URI.isUri(uriOrModule)) {
+            return uriOrModule;
+        }
+        return URI.parse(moduleIdToUrl.toUrl(uriOrModule));
+    }
+    registerStaticBrowserUri(uri, browserUri) {
+        this.staticBrowserUris.set(uri, browserUri);
+        return toDisposable(() => {
+            if (this.staticBrowserUris.get(uri) === browserUri) {
+                this.staticBrowserUris.delete(uri);
+            }
+        });
+    }
+    getRegisteredBrowserUris() {
+        return this.staticBrowserUris.keys();
+    }
 }
 FileAccessImpl.FALLBACK_AUTHORITY = 'vscode-app';
 export const FileAccess = new FileAccessImpl();
@@ -181,7 +272,7 @@
         else if (URI.isUri(url)) {
             params = new URL(url.toString(true)).searchParams;
         }
-        const value = params === null || params === void 0 ? void 0 : params.get(coiSearchParamName);
+        const value = params?.get(coiSearchParamName);
         if (!value) {
             return undefined;
         }
diff -urN -x '*.map' a/vs/base/common/numbers.js b/vs/base/common/numbers.js
--- a/vs/base/common/numbers.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/numbers.js	2023-12-06 14:23:14.351854734 +0000
@@ -5,6 +5,17 @@
 export function clamp(value, min, max) {
     return Math.min(Math.max(value, min), max);
 }
+export function rot(index, modulo) {
+    return (modulo + (index % modulo)) % modulo;
+}
+export class Counter {
+    constructor() {
+        this._next = 0;
+    }
+    getNext() {
+        return this._next++;
+    }
+}
 export class MovingAverage {
     constructor() {
         this._n = 1;
diff -urN -x '*.map' a/vs/base/common/objects.js b/vs/base/common/objects.js
--- a/vs/base/common/objects.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/objects.js	2023-12-06 14:23:14.351854734 +0000
@@ -147,6 +147,64 @@
     }
     return true;
 }
+/**
+ * Calls `JSON.Stringify` with a replacer to break apart any circular references.
+ * This prevents `JSON`.stringify` from throwing the exception
+ *  "Uncaught TypeError: Converting circular structure to JSON"
+ */
+export function safeStringify(obj) {
+    const seen = new Set();
+    return JSON.stringify(obj, (key, value) => {
+        if (isObject(value) || Array.isArray(value)) {
+            if (seen.has(value)) {
+                return '[Circular]';
+            }
+            else {
+                seen.add(value);
+            }
+        }
+        return value;
+    });
+}
+/**
+ * Returns an object that has keys for each value that is different in the base object. Keys
+ * that do not exist in the target but in the base object are not considered.
+ *
+ * Note: This is not a deep-diffing method, so the values are strictly taken into the resulting
+ * object if they differ.
+ *
+ * @param base the object to diff against
+ * @param obj the object to use for diffing
+ */
+export function distinct(base, target) {
+    const result = Object.create(null);
+    if (!base || !target) {
+        return result;
+    }
+    const targetKeys = Object.keys(target);
+    targetKeys.forEach(k => {
+        const baseValue = base[k];
+        const targetValue = target[k];
+        if (!equals(baseValue, targetValue)) {
+            result[k] = targetValue;
+        }
+    });
+    return result;
+}
+export function getCaseInsensitive(target, key) {
+    const lowercaseKey = key.toLowerCase();
+    const equivalentKey = Object.keys(target).find(k => k.toLowerCase() === lowercaseKey);
+    return equivalentKey ? target[equivalentKey] : target[key];
+}
+export function filter(obj, predicate) {
+    const result = Object.create(null);
+    for (const [key, value] of Object.entries(obj)) {
+        if (predicate(key, value)) {
+            result[key] = value;
+        }
+    }
+    return result;
+}
 export function getAllPropertyNames(obj) {
     let res = [];
     while (Object.prototype !== obj) {
diff -urN -x '*.map' a/vs/base/common/observable.js b/vs/base/common/observable.js
--- a/vs/base/common/observable.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/observable.js	2023-12-06 14:23:14.351854734 +0000
@@ -2,10 +2,10 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-export { observableValue, disposableObservableValue, transaction, subtransaction } from './observableInternal/base.js';
-export { derived, derivedOpts, derivedHandleChanges, derivedWithStore } from './observableInternal/derived.js';
-export { autorun, autorunHandleChanges, autorunWithStore, autorunOpts } from './observableInternal/autorun.js';
-export { constObservable, recomputeInitiallyAndOnChange, observableFromEvent, observableSignal, observableSignalFromEvent, waitForState } from './observableInternal/utils.js';
+export { observableValue, disposableObservableValue, transaction, subtransaction, } from './observableInternal/base';
+export { derived, derivedOpts, derivedHandleChanges, derivedWithStore, } from './observableInternal/derived';
+export { autorun, autorunDelta, autorunHandleChanges, autorunWithStore, autorunOpts, autorunWithStoreHandleChanges, } from './observableInternal/autorun';
+export { constObservable, debouncedObservable, derivedObservableWithCache, derivedObservableWithWritableCache, keepObserved, recomputeInitiallyAndOnChange, observableFromEvent, observableFromPromise, observableSignal, observableSignalFromEvent, waitForState, wasEventTriggeredRecently, } from './observableInternal/utils';
 import { ConsoleObservableLogger, setLogger } from './observableInternal/logging.js';
 const enableLogging = false;
 if (enableLogging) {
diff -urN -x '*.map' a/vs/base/common/observableInternal/autorun.js b/vs/base/common/observableInternal/autorun.js
--- a/vs/base/common/observableInternal/autorun.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/observableInternal/autorun.js	2023-12-06 14:23:14.355854741 +0000
@@ -15,6 +15,21 @@
 export function autorunHandleChanges(options, fn) {
     return new AutorunObserver(options.debugName, fn, options.createEmptyChangeSummary, options.handleChange);
 }
+export function autorunWithStoreHandleChanges(options, fn) {
+    const store = new DisposableStore();
+    const disposable = autorunHandleChanges({
+        debugName: options.debugName ?? (() => getFunctionName(fn)),
+        createEmptyChangeSummary: options.createEmptyChangeSummary,
+        handleChange: options.handleChange,
+    }, (reader, changeSummary) => {
+        store.clear();
+        fn(reader, changeSummary, store);
+    });
+    return toDisposable(() => {
+        disposable.dispose();
+        store.dispose();
+    });
+}
 export function autorunWithStore(fn) {
     const store = new DisposableStore();
     const disposable = autorunOpts({
@@ -46,7 +61,6 @@
         return '(anonymous)';
     }
     constructor(_debugName, _runFn, createChangeSummary, _handleChange) {
-        var _a, _b;
         this._debugName = _debugName;
         this._runFn = _runFn;
         this.createChangeSummary = createChangeSummary;
@@ -56,8 +70,8 @@
         this.disposed = false;
         this.dependencies = new Set();
         this.dependenciesToBeRemoved = new Set();
-        this.changeSummary = (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this);
-        (_b = getLogger()) === null || _b === void 0 ? void 0 : _b.handleAutorunCreated(this);
+        this.changeSummary = this.createChangeSummary?.();
+        getLogger()?.handleAutorunCreated(this);
         this._runIfNeeded();
         trackDisposable(this);
     }
@@ -70,7 +84,6 @@
         markAsDisposed(this);
     }
     _runIfNeeded() {
-        var _a, _b, _c;
         if (this.state === 3 /* AutorunState.upToDate */) {
             return;
         }
@@ -80,14 +93,14 @@
         this.state = 3 /* AutorunState.upToDate */;
         try {
             if (!this.disposed) {
-                (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleAutorunTriggered(this);
+                getLogger()?.handleAutorunTriggered(this);
                 const changeSummary = this.changeSummary;
-                this.changeSummary = (_b = this.createChangeSummary) === null || _b === void 0 ? void 0 : _b.call(this);
+                this.changeSummary = this.createChangeSummary?.();
                 this._runFn(this, changeSummary);
             }
         }
         finally {
-            (_c = getLogger()) === null || _c === void 0 ? void 0 : _c.handleAutorunFinished(this);
+            getLogger()?.handleAutorunFinished(this);
             // We don't want our observed observables to think that they are (not even temporarily) not being observed.
             // Thus, we only unsubscribe from observables that are definitely not read anymore.
             for (const o of this.dependenciesToBeRemoved) {
@@ -158,3 +171,12 @@
 (function (autorun) {
     autorun.Observer = AutorunObserver;
 })(autorun || (autorun = {}));
+export function autorunDelta(observable, handler) {
+    let _lastValue;
+    return autorunOpts({ debugName: () => getFunctionName(handler) }, (reader) => {
+        const newValue = observable.read(reader);
+        const lastValue = _lastValue;
+        _lastValue = newValue;
+        handler({ lastValue, newValue });
+    });
+}
diff -urN -x '*.map' a/vs/base/common/observableInternal/base.js b/vs/base/common/observableInternal/base.js
--- a/vs/base/common/observableInternal/base.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/observableInternal/base.js	2023-12-06 14:23:14.355854741 +0000
@@ -89,11 +89,10 @@
 }
 export class TransactionImpl {
     constructor(_fn, _getDebugName) {
-        var _a;
         this._fn = _fn;
         this._getDebugName = _getDebugName;
         this.updatingObservers = [];
-        (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleBeginTransaction(this);
+        getLogger()?.handleBeginTransaction(this);
     }
     getDebugName() {
         if (this._getDebugName) {
@@ -106,14 +105,13 @@
         observer.beginUpdate(observable);
     }
     finish() {
-        var _a;
         const updatingObservers = this.updatingObservers;
         // Prevent anyone from updating observers from now on.
         this.updatingObservers = null;
         for (const { observer, observable } of updatingObservers) {
             observer.endUpdate(observable);
         }
-        (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleEndTransaction();
+        getLogger()?.handleEndTransaction();
     }
 }
 export function getDebugName(debugNameFn, fn, owner, self) {
@@ -150,7 +148,7 @@
     const regexp = /\/\*\*\s*@description\s*([^*]*)\*\//;
     const match = regexp.exec(fnSrc);
     const result = match ? match[1] : undefined;
-    return result === null || result === void 0 ? void 0 : result.trim();
+    return result?.trim();
 }
 export function observableValue(nameOrOwner, initialValue) {
     if (typeof nameOrOwner === 'string') {
@@ -162,8 +160,7 @@
 }
 export class ObservableValue extends BaseObservable {
     get debugName() {
-        var _a;
-        return (_a = getDebugName(this._debugName, undefined, this._owner, this)) !== null && _a !== void 0 ? _a : 'ObservableValue';
+        return getDebugName(this._debugName, undefined, this._owner, this) ?? 'ObservableValue';
     }
     constructor(_owner, _debugName, initialValue) {
         super();
@@ -175,7 +172,6 @@
         return this._value;
     }
     set(value, tx, change) {
-        var _a;
         if (this._value === value) {
             return;
         }
@@ -186,7 +182,7 @@
         try {
             const oldValue = this._value;
             this._setValue(value);
-            (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });
+            getLogger()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });
             for (const observer of this.observers) {
                 tx.updateObserver(observer, this);
                 observer.handleChange(this, change);
@@ -224,7 +220,6 @@
         this._value = newValue;
     }
     dispose() {
-        var _a;
-        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._value?.dispose();
     }
 }
diff -urN -x '*.map' a/vs/base/common/observableInternal/derived.js b/vs/base/common/observableInternal/derived.js
--- a/vs/base/common/observableInternal/derived.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/observableInternal/derived.js	2023-12-06 14:23:14.355854741 +0000
@@ -14,12 +14,10 @@
     return new Derived(undefined, undefined, computeFnOrOwner, undefined, undefined, undefined, defaultEqualityComparer);
 }
 export function derivedOpts(options, computeFn) {
-    var _a;
-    return new Derived(options.owner, options.debugName, computeFn, undefined, undefined, undefined, (_a = options.equalityComparer) !== null && _a !== void 0 ? _a : defaultEqualityComparer);
+    return new Derived(options.owner, options.debugName, computeFn, undefined, undefined, undefined, options.equalityComparer ?? defaultEqualityComparer);
 }
 export function derivedHandleChanges(options, computeFn) {
-    var _a;
-    return new Derived(options.owner, options.debugName, computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, (_a = options.equalityComparer) !== null && _a !== void 0 ? _a : defaultEqualityComparer);
+    return new Derived(options.owner, options.debugName, computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, options.equalityComparer ?? defaultEqualityComparer);
 }
 export function derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {
     let computeFn;
@@ -33,7 +31,7 @@
         computeFn = computeFnOrUndefined;
     }
     const store = new DisposableStore();
-    return new Derived(owner, (() => { var _a; return (_a = getFunctionName(computeFn)) !== null && _a !== void 0 ? _a : '(anonymous)'; }), r => {
+    return new Derived(owner, (() => getFunctionName(computeFn) ?? '(anonymous)'), r => {
         store.clear();
         return computeFn(r, store);
     }, undefined, undefined, () => store.dispose(), defaultEqualityComparer);
@@ -41,11 +39,9 @@
 _setDerivedOpts(derived);
 export class Derived extends BaseObservable {
     get debugName() {
-        var _a;
-        return (_a = getDebugName(this._debugName, this._computeFn, this._owner, this)) !== null && _a !== void 0 ? _a : '(anonymous)';
+        return getDebugName(this._debugName, this._computeFn, this._owner, this) ?? '(anonymous)';
     }
     constructor(_owner, _debugName, _computeFn, createChangeSummary, _handleChange, _handleLastObserverRemoved = undefined, _equalityComparator) {
-        var _a, _b;
         super();
         this._owner = _owner;
         this._debugName = _debugName;
@@ -60,11 +56,10 @@
         this.dependencies = new Set();
         this.dependenciesToBeRemoved = new Set();
         this.changeSummary = undefined;
-        this.changeSummary = (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this);
-        (_b = getLogger()) === null || _b === void 0 ? void 0 : _b.handleDerivedCreated(this);
+        this.changeSummary = this.createChangeSummary?.();
+        getLogger()?.handleDerivedCreated(this);
     }
     onLastObserverRemoved() {
-        var _a;
         /**
          * We are not tracking changes anymore, thus we have to assume
          * that our cache is invalid.
@@ -75,14 +70,13 @@
             d.removeObserver(this);
         }
         this.dependencies.clear();
-        (_a = this._handleLastObserverRemoved) === null || _a === void 0 ? void 0 : _a.call(this);
+        this._handleLastObserverRemoved?.();
     }
     get() {
-        var _a;
         if (this.observers.size === 0) {
             // Without observers, we don't know when to clean up stuff.
             // Thus, we don't cache anything to prevent memory leaks.
-            const result = this._computeFn(this, (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this));
+            const result = this._computeFn(this, this.createChangeSummary?.());
             // Clear new dependencies
             this.onLastObserverRemoved();
             return result;
@@ -113,7 +107,6 @@
         }
     }
     _recomputeIfNeeded() {
-        var _a, _b;
         if (this.state === 3 /* DerivedState.upToDate */) {
             return;
         }
@@ -124,7 +117,7 @@
         const oldValue = this.value;
         this.state = 3 /* DerivedState.upToDate */;
         const changeSummary = this.changeSummary;
-        this.changeSummary = (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this);
+        this.changeSummary = this.createChangeSummary?.();
         try {
             /** might call {@link handleChange} indirectly, which could invalidate us */
             this.value = this._computeFn(this, changeSummary);
@@ -138,7 +131,7 @@
             this.dependenciesToBeRemoved.clear();
         }
         const didChange = hadValue && !(this._equalityComparator(oldValue, this.value));
-        (_b = getLogger()) === null || _b === void 0 ? void 0 : _b.handleDerivedRecomputed(this, {
+        getLogger()?.handleDerivedRecomputed(this, {
             oldValue,
             newValue: this.value,
             change: undefined,
diff -urN -x '*.map' a/vs/base/common/observableInternal/utils.js b/vs/base/common/observableInternal/utils.js
--- a/vs/base/common/observableInternal/utils.js	2023-12-06 14:22:33.831782465 +0000
+++ b/vs/base/common/observableInternal/utils.js	2023-12-06 14:23:14.355854741 +0000
@@ -4,7 +4,8 @@
  *--------------------------------------------------------------------------------------------*/
 import { toDisposable } from '../lifecycle.js';
 import { autorun } from './autorun.js';
-import { BaseObservable, ConvenientObservable, getDebugName, getFunctionName, transaction } from './base.js';
+import { BaseObservable, ConvenientObservable, getDebugName, getFunctionName, observableValue, transaction } from './base.js';
+import { derived } from './derived.js';
 import { getLogger } from './logging.js';
 /**
  * Represents an efficient observable whose value never changes.
@@ -33,6 +34,13 @@
         return `Const: ${this.value}`;
     }
 }
+export function observableFromPromise(promise) {
+    const observable = observableValue('promiseValue', {});
+    promise.then((value) => {
+        observable.set({ value }, undefined);
+    });
+    return observable;
+}
 export function waitForState(observable, predicate) {
     return new Promise(resolve => {
         let didRun = false;
@@ -66,10 +74,9 @@
         this._getValue = _getValue;
         this.hasValue = false;
         this.handleEvent = (args) => {
-            var _a;
             const newValue = this._getValue(args);
             const didChange = !this.hasValue || this.value !== newValue;
-            (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, { oldValue: this.value, newValue, change: undefined, didChange, hadValue: this.hasValue });
+            getLogger()?.handleFromEventObservableTriggered(this, { oldValue: this.value, newValue, change: undefined, didChange, hadValue: this.hasValue });
             if (didChange) {
                 this.value = newValue;
                 if (this.hasValue) {
@@ -157,8 +164,7 @@
 }
 class ObservableSignal extends BaseObservable {
     get debugName() {
-        var _a;
-        return (_a = getDebugName(this._debugName, undefined, this._owner, this)) !== null && _a !== void 0 ? _a : 'Observable Signal';
+        return getDebugName(this._debugName, undefined, this._owner, this) ?? 'Observable Signal';
     }
     constructor(_debugName, _owner) {
         super();
@@ -181,6 +187,47 @@
         // NO OP
     }
 }
+export function debouncedObservable(observable, debounceMs, disposableStore) {
+    const debouncedObservable = observableValue('debounced', undefined);
+    let timeout = undefined;
+    disposableStore.add(autorun(reader => {
+        /** @description debounce */
+        const value = observable.read(reader);
+        if (timeout) {
+            clearTimeout(timeout);
+        }
+        timeout = setTimeout(() => {
+            transaction(tx => {
+                debouncedObservable.set(value, tx);
+            });
+        }, debounceMs);
+    }));
+    return debouncedObservable;
+}
+export function wasEventTriggeredRecently(event, timeoutMs, disposableStore) {
+    const observable = observableValue('triggeredRecently', false);
+    let timeout = undefined;
+    disposableStore.add(event(() => {
+        observable.set(true, undefined);
+        if (timeout) {
+            clearTimeout(timeout);
+        }
+        timeout = setTimeout(() => {
+            observable.set(false, undefined);
+        }, timeoutMs);
+    }));
+    return observable;
+}
+/**
+ * This makes sure the observable is being observed and keeps its cache alive.
+ */
+export function keepObserved(observable) {
+    const o = new KeepAliveObserver(false);
+    observable.addObserver(o);
+    return toDisposable(() => {
+        observable.removeObserver(o);
+    });
+}
 /**
  * This converts the given observable into an autorun.
  */
@@ -213,3 +260,26 @@
         // NO OP
     }
 }
+export function derivedObservableWithCache(computeFn) {
+    let lastValue = undefined;
+    const observable = derived(reader => {
+        lastValue = computeFn(reader, lastValue);
+        return lastValue;
+    });
+    return observable;
+}
+export function derivedObservableWithWritableCache(owner, computeFn) {
+    let lastValue = undefined;
+    const counter = observableValue('derivedObservableWithWritableCache.counter', 0);
+    const observable = derived(owner, reader => {
+        counter.read(reader);
+        lastValue = computeFn(reader, lastValue);
+        return lastValue;
+    });
+    return Object.assign(observable, {
+        clearCache: (transaction) => {
+            lastValue = undefined;
+            counter.set(counter.get() + 1, transaction);
+        },
+    });
+}
diff -urN -x '*.map' a/vs/base/common/paging.js b/vs/base/common/paging.js
--- a/vs/base/common/paging.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/paging.js	2023-12-06 14:23:14.351854734 +0000
@@ -1 +1,131 @@
-export {};
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { range } from './arrays.js';
+import { CancellationTokenSource } from './cancellation.js';
+import { canceled } from './errors.js';
+function createPage(elements) {
+    return {
+        isResolved: !!elements,
+        promise: null,
+        cts: null,
+        promiseIndexes: new Set(),
+        elements: elements || []
+    };
+}
+export function singlePagePager(elements) {
+    return {
+        firstPage: elements,
+        total: elements.length,
+        pageSize: elements.length,
+        getPage: (pageIndex, cancellationToken) => {
+            return Promise.resolve(elements);
+        }
+    };
+}
+export class PagedModel {
+    get length() { return this.pager.total; }
+    constructor(arg) {
+        this.pages = [];
+        this.pager = Array.isArray(arg) ? singlePagePager(arg) : arg;
+        const totalPages = Math.ceil(this.pager.total / this.pager.pageSize);
+        this.pages = [
+            createPage(this.pager.firstPage.slice()),
+            ...range(totalPages - 1).map(() => createPage())
+        ];
+    }
+    isResolved(index) {
+        const pageIndex = Math.floor(index / this.pager.pageSize);
+        const page = this.pages[pageIndex];
+        return !!page.isResolved;
+    }
+    get(index) {
+        const pageIndex = Math.floor(index / this.pager.pageSize);
+        const indexInPage = index % this.pager.pageSize;
+        const page = this.pages[pageIndex];
+        return page.elements[indexInPage];
+    }
+    resolve(index, cancellationToken) {
+        if (cancellationToken.isCancellationRequested) {
+            return Promise.reject(canceled());
+        }
+        const pageIndex = Math.floor(index / this.pager.pageSize);
+        const indexInPage = index % this.pager.pageSize;
+        const page = this.pages[pageIndex];
+        if (page.isResolved) {
+            return Promise.resolve(page.elements[indexInPage]);
+        }
+        if (!page.promise) {
+            page.cts = new CancellationTokenSource();
+            page.promise = this.pager.getPage(pageIndex, page.cts.token)
+                .then(elements => {
+                page.elements = elements;
+                page.isResolved = true;
+                page.promise = null;
+                page.cts = null;
+            }, err => {
+                page.isResolved = false;
+                page.promise = null;
+                page.cts = null;
+                return Promise.reject(err);
+            });
+        }
+        const listener = cancellationToken.onCancellationRequested(() => {
+            if (!page.cts) {
+                return;
+            }
+            page.promiseIndexes.delete(index);
+            if (page.promiseIndexes.size === 0) {
+                page.cts.cancel();
+            }
+        });
+        page.promiseIndexes.add(index);
+        return page.promise.then(() => page.elements[indexInPage])
+            .finally(() => listener.dispose());
+    }
+}
+export class DelayedPagedModel {
+    get length() { return this.model.length; }
+    constructor(model, timeout = 500) {
+        this.model = model;
+        this.timeout = timeout;
+    }
+    isResolved(index) {
+        return this.model.isResolved(index);
+    }
+    get(index) {
+        return this.model.get(index);
+    }
+    resolve(index, cancellationToken) {
+        return new Promise((c, e) => {
+            if (cancellationToken.isCancellationRequested) {
+                return e(canceled());
+            }
+            const timer = setTimeout(() => {
+                if (cancellationToken.isCancellationRequested) {
+                    return e(canceled());
+                }
+                timeoutCancellation.dispose();
+                this.model.resolve(index, cancellationToken).then(c, e);
+            }, this.timeout);
+            const timeoutCancellation = cancellationToken.onCancellationRequested(() => {
+                clearTimeout(timer);
+                timeoutCancellation.dispose();
+                e(canceled());
+            });
+        });
+    }
+}
+/**
+ * Similar to array.map, `mapPager` lets you map the elements of an
+ * abstract paged collection to another type.
+ */
+export function mapPager(pager, fn) {
+    return {
+        firstPage: pager.firstPage.map(fn),
+        total: pager.total,
+        pageSize: pager.pageSize,
+        getPage: (pageIndex, token) => pager.getPage(pageIndex, token).then(r => r.map(fn))
+    };
+}
diff -urN -x '*.map' a/vs/base/common/path.js b/vs/base/common/path.js
--- a/vs/base/common/path.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/path.js	2023-12-06 14:23:14.351854734 +0000
@@ -1385,9 +1385,15 @@
 posix.win32 = win32.win32 = win32;
 posix.posix = win32.posix = posix;
 export const normalize = (platformIsWin32 ? win32.normalize : posix.normalize);
+export const isAbsolute = (platformIsWin32 ? win32.isAbsolute : posix.isAbsolute);
+export const join = (platformIsWin32 ? win32.join : posix.join);
 export const resolve = (platformIsWin32 ? win32.resolve : posix.resolve);
 export const relative = (platformIsWin32 ? win32.relative : posix.relative);
 export const dirname = (platformIsWin32 ? win32.dirname : posix.dirname);
 export const basename = (platformIsWin32 ? win32.basename : posix.basename);
 export const extname = (platformIsWin32 ? win32.extname : posix.extname);
+export const format = (platformIsWin32 ? win32.format : posix.format);
+export const parse = (platformIsWin32 ? win32.parse : posix.parse);
+export const toNamespacedPath = (platformIsWin32 ? win32.toNamespacedPath : posix.toNamespacedPath);
 export const sep = (platformIsWin32 ? win32.sep : posix.sep);
+export const delimiter = (platformIsWin32 ? win32.delimiter : posix.delimiter);
diff -urN -x '*.map' a/vs/base/common/performance.js b/vs/base/common/performance.js
--- a/vs/base/common/performance.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/base/common/performance.js	2023-12-06 14:23:14.351854734 +0000
@@ -0,0 +1,149 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+
+'use strict';
+
+//@ts-check
+// ESM-comment-begin
+// (function () {
+// 
+// 	/**
+// 	 * @returns {{mark(name:string):void, getMarks():{name:string, startTime:number}[]}}
+// 	 */
+// 	function _definePolyfillMarks(timeOrigin) {
+// 
+// 		const _data = [];
+// 		if (typeof timeOrigin === 'number') {
+// 			_data.push('code/timeOrigin', timeOrigin);
+// 		}
+// 
+// 		function mark(name) {
+// 			_data.push(name, Date.now());
+// 		}
+// 		function getMarks() {
+// 			const result = [];
+// 			for (let i = 0; i < _data.length; i += 2) {
+// 				result.push({
+// 					name: _data[i],
+// 					startTime: _data[i + 1],
+// 				});
+// 			}
+// 			return result;
+// 		}
+// 		return { mark, getMarks };
+// 	}
+// 
+// 	/**
+// 	 * @returns {{mark(name:string):void, getMarks():{name:string, startTime:number}[]}}
+// 	 */
+// 	function _define() {
+// 
+// 		// Identify browser environment when following property is not present
+// 		// https://nodejs.org/dist/latest-v16.x/docs/api/perf_hooks.html#performancenodetiming
+// 		if (typeof performance === 'object' && typeof performance.mark === 'function' && !performance.nodeTiming) {
+// 			// in a browser context, reuse performance-util
+// 
+// 			if (typeof performance.timeOrigin !== 'number' && !performance.timing) {
+// 				// safari & webworker: because there is no timeOrigin and no workaround
+// 				// we use the `Date.now`-based polyfill.
+// 				return _definePolyfillMarks();
+// 
+// 			} else {
+// 				// use "native" performance for mark and getMarks
+// 				return {
+// 					mark(name) {
+// 						performance.mark(name);
+// 					},
+// 					getMarks() {
+// 						let timeOrigin = performance.timeOrigin;
+// 						if (typeof timeOrigin !== 'number') {
+// 							// safari: there is no timerOrigin but in renderers there is the timing-property
+// 							// see https://bugs.webkit.org/show_bug.cgi?id=174862
+// 							timeOrigin = performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart;
+// 						}
+// 						const result = [{ name: 'code/timeOrigin', startTime: Math.round(timeOrigin) }];
+// 						for (const entry of performance.getEntriesByType('mark')) {
+// 							result.push({
+// 								name: entry.name,
+// 								startTime: Math.round(timeOrigin + entry.startTime)
+// 							});
+// 						}
+// 						return result;
+// 					}
+// 				};
+// 			}
+// 
+// 		} else if (typeof process === 'object') {
+// 			// node.js: use the normal polyfill but add the timeOrigin
+// 			// from the node perf_hooks API as very first mark
+// 			const timeOrigin = performance?.timeOrigin ?? Math.round((require.__$__nodeRequire || require)('perf_hooks').performance.timeOrigin);
+// 			return _definePolyfillMarks(timeOrigin);
+// 
+// 		} else {
+// 			// unknown environment
+// 			console.trace('perf-util loaded in UNKNOWN environment');
+// 			return _definePolyfillMarks();
+// 		}
+// 	}
+// 
+// 	function _factory(sharedObj) {
+// 		if (!sharedObj.MonacoPerformanceMarks) {
+// 			sharedObj.MonacoPerformanceMarks = _define();
+// 		}
+// 		return sharedObj.MonacoPerformanceMarks;
+// 	}
+// 
+// 	// This module can be loaded in an amd and commonjs-context.
+// 	// Because we want both instances to use the same perf-data
+// 	// we store them globally
+// 
+// 	// eslint-disable-next-line no-var
+// 	var sharedObj;
+// 	if (typeof global === 'object') {
+// 		// nodejs
+// 		sharedObj = global;
+// 	} else if (typeof self === 'object') {
+// 		// browser
+// 		sharedObj = self;
+// 	} else {
+// 		sharedObj = {};
+// 	}
+// 
+// 	if (typeof define === 'function') {
+// 		// amd
+// 		define([], function () { return _factory(sharedObj); });
+// 	} else if (typeof module === 'object' && typeof module.exports === 'object') {
+// 		// commonjs
+// 		module.exports = _factory(sharedObj);
+// 	} else {
+// 		console.trace('perf-util defined in UNKNOWN context (neither requirejs or commonjs)');
+// 		sharedObj.perf = _factory(sharedObj);
+// 	}
+// 
+// })();
+// ESM-comment-end
+
+// ESM-uncomment-begin
+export const mark = (name) => {
+	performance.mark(name);
+};
+
+export const getMarks = () => {
+	let timeOrigin = performance.timeOrigin;
+	if (typeof timeOrigin !== 'number') {
+		// safari: there is no timerOrigin but in renderers there is the timing-property
+		// see https://bugs.webkit.org/show_bug.cgi?id=174862
+		timeOrigin = performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart;
+	}
+	const result = [{ name: 'code/timeOrigin', startTime: Math.round(timeOrigin) }];
+	for (const entry of performance.getEntriesByType('mark')) {
+		result.push({
+			name: entry.name,
+			startTime: Math.round(timeOrigin + entry.startTime)
+		});
+	}
+	return result;
+};
+// ESM-uncomment-end
diff -urN -x '*.map' a/vs/base/common/platform.js b/vs/base/common/platform.js
--- a/vs/base/common/platform.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/platform.js	2023-12-06 14:23:14.351854734 +0000
@@ -1,4 +1,3 @@
-var _a;
 /*---------------------------------------------------------------------------------------------
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
@@ -33,8 +32,8 @@
     // Native environment (non-sandboxed)
     nodeProcess = process;
 }
-const isElectronProcess = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === 'string';
-const isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === 'renderer';
+const isElectronProcess = typeof nodeProcess?.versions?.electron === 'string';
+const isElectronRenderer = isElectronProcess && nodeProcess?.type === 'renderer';
 // Web environment
 if (typeof navigator === 'object' && !isElectronRenderer) {
     _userAgent = navigator.userAgent;
@@ -42,14 +41,14 @@
     _isMacintosh = _userAgent.indexOf('Macintosh') >= 0;
     _isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
     _isLinux = _userAgent.indexOf('Linux') >= 0;
-    _isMobile = (_userAgent === null || _userAgent === void 0 ? void 0 : _userAgent.indexOf('Mobi')) >= 0;
+    _isMobile = _userAgent?.indexOf('Mobi') >= 0;
     _isWeb = true;
     const configuredLocale = nls.getConfiguredDefaultLocale(
     // This call _must_ be done in the file that calls `nls.getConfiguredDefaultLocale`
     // to ensure that the NLS AMD Loader plugin has been loaded and configured.
     // This is because the loader plugin decides what the default locale is based on
     // how it's able to resolve the strings.
-    nls.localize({ key: 'ensureLoaderPluginIsLoaded', comment: ['{Locked}'] }, '_'));
+    nls.localizeWithPath('vs/base/common/platform', { key: 'ensureLoaderPluginIsLoaded', comment: ['{Locked}'] }, '_'));
     _locale = configuredLocale || LANGUAGE_DEFAULT;
     _language = _locale;
     _platformLocale = navigator.language;
@@ -84,6 +83,14 @@
 else {
     console.error('Unable to resolve platform.');
 }
+export function PlatformToString(platform) {
+    switch (platform) {
+        case 0 /* Platform.Web */: return 'Web';
+        case 1 /* Platform.Mac */: return 'Mac';
+        case 2 /* Platform.Linux */: return 'Linux';
+        case 3 /* Platform.Windows */: return 'Windows';
+    }
+}
 let _platform = 0 /* Platform.Web */;
 if (_isMacintosh) {
     _platform = 1 /* Platform.Mac */;
@@ -97,11 +104,19 @@
 export const isWindows = _isWindows;
 export const isMacintosh = _isMacintosh;
 export const isLinux = _isLinux;
+export const isLinuxSnap = _isLinuxSnap;
 export const isNative = _isNative;
+export const isElectron = _isElectron;
 export const isWeb = _isWeb;
 export const isWebWorker = (_isWeb && typeof globals.importScripts === 'function');
 export const isIOS = _isIOS;
 export const isMobile = _isMobile;
+/**
+ * Whether we run inside a CI environment, such as
+ * GH actions or Azure Pipelines.
+ */
+export const isCI = _isCI;
+export const platform = _platform;
 export const userAgent = _userAgent;
 /**
  * The language used for the user interface. The format of
@@ -109,6 +124,46 @@
  * Chinese)
  */
 export const language = _language;
+export var Language;
+(function (Language) {
+    function value() {
+        return language;
+    }
+    Language.value = value;
+    function isDefaultVariant() {
+        if (language.length === 2) {
+            return language === 'en';
+        }
+        else if (language.length >= 3) {
+            return language[0] === 'e' && language[1] === 'n' && language[2] === '-';
+        }
+        else {
+            return false;
+        }
+    }
+    Language.isDefaultVariant = isDefaultVariant;
+    function isDefault() {
+        return language === 'en';
+    }
+    Language.isDefault = isDefault;
+})(Language || (Language = {}));
+/**
+ * The OS locale or the locale specified by --locale. The format of
+ * the string is all lower case (e.g. zh-tw for Traditional
+ * Chinese). The UI is not necessarily shown in the provided locale.
+ */
+export const locale = _locale;
+/**
+ * This will always be set to the OS/browser's locale regardless of
+ * what was specified by --locale. The format of the string is all
+ * lower case (e.g. zh-tw for Traditional Chinese). The UI is not
+ * necessarily shown in the provided locale.
+ */
+export const platformLocale = _platformLocale;
+/**
+ * The translations that are available through language packs.
+ */
+export const translationsConfigFile = _translationsConfigFile;
 export const setTimeout0IsFaster = (typeof globals.postMessage === 'function' && !globals.importScripts);
 /**
  * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.
diff -urN -x '*.map' a/vs/base/common/process.js b/vs/base/common/process.js
--- a/vs/base/common/process.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/process.js	2023-12-06 14:23:14.351854734 +0000
@@ -55,3 +55,9 @@
  * environments.
  */
 export const platform = safeProcess.platform;
+/**
+ * Provides safe access to the `arch` method in node.js, sandboxed or web
+ * environments.
+ * Note: `arch` is `undefined` in web
+ */
+export const arch = safeProcess.arch;
diff -urN -x '*.map' a/vs/base/common/product.js b/vs/base/common/product.js
--- a/vs/base/common/product.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/base/common/product.js	2023-12-06 14:23:14.351854734 +0000
@@ -0,0 +1,5 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+export {};
diff -urN -x '*.map' a/vs/base/common/resources.js b/vs/base/common/resources.js
--- a/vs/base/common/resources.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/resources.js	2023-12-06 14:23:14.351854734 +0000
@@ -36,6 +36,9 @@
             fragment: ignoreFragment ? null : undefined
         }).toString();
     }
+    ignorePathCasing(uri) {
+        return this._ignorePathCasing(uri);
+    }
     isEqualOrParent(base, parentCandidate, ignoreFragment = false) {
         if (base.scheme === parentCandidate.scheme) {
             if (base.scheme === Schemas.file) {
@@ -224,6 +227,23 @@
 export const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);
 export const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);
 export const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);
+//#endregion
+export function distinctParents(items, resourceAccessor) {
+    const distinctParents = [];
+    for (let i = 0; i < items.length; i++) {
+        const candidateResource = resourceAccessor(items[i]);
+        if (items.some((otherItem, index) => {
+            if (index === i) {
+                return false;
+            }
+            return isEqualOrParent(candidateResource, resourceAccessor(otherItem));
+        })) {
+            continue;
+        }
+        distinctParents.push(items[i]);
+    }
+    return distinctParents;
+}
 /**
  * Data URI related helpers.
  */
@@ -254,3 +274,13 @@
     }
     DataUri.parseMetaData = parseMetaData;
 })(DataUri || (DataUri = {}));
+export function toLocalResource(resource, authority, localScheme) {
+    if (authority) {
+        let path = resource.path;
+        if (path && path[0] !== paths.posix.sep) {
+            path = paths.posix.sep + path;
+        }
+        return resource.with({ scheme: localScheme, authority, path });
+    }
+    return resource.with({ scheme: localScheme });
+}
diff -urN -x '*.map' a/vs/base/common/scrollable.js b/vs/base/common/scrollable.js
--- a/vs/base/common/scrollable.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/scrollable.js	2023-12-06 14:23:14.351854734 +0000
@@ -117,11 +117,10 @@
         return this._state;
     }
     setScrollDimensions(dimensions, useRawScrollPositions) {
-        var _a;
         const newState = this._state.withScrollDimensions(dimensions, useRawScrollPositions);
         this._setState(newState, Boolean(this._smoothScrolling));
         // Validate outstanding animated scroll position target
-        (_a = this._smoothScrolling) === null || _a === void 0 ? void 0 : _a.acceptScrollDimensions(this._state);
+        this._smoothScrolling?.acceptScrollDimensions(this._state);
     }
     /**
      * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
diff -urN -x '*.map' a/vs/base/common/sequence.js b/vs/base/common/sequence.js
--- a/vs/base/common/sequence.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/sequence.js	2023-12-06 14:23:14.351854734 +0000
@@ -1 +1,16 @@
-export {};
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { Emitter } from './event.js';
+export class Sequence {
+    constructor() {
+        this.elements = [];
+        this._onDidSplice = new Emitter();
+        this.onDidSplice = this._onDidSplice.event;
+    }
+    splice(start, deleteCount, toInsert = []) {
+        this.elements.splice(start, deleteCount, ...toInsert);
+        this._onDidSplice.fire({ start, deleteCount, toInsert });
+    }
+}
diff -urN -x '*.map' a/vs/base/common/stopwatch.js b/vs/base/common/stopwatch.js
--- a/vs/base/common/stopwatch.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/stopwatch.js	2023-12-06 14:23:14.351854734 +0000
@@ -15,6 +15,10 @@
     stop() {
         this._stopTime = this._now();
     }
+    reset() {
+        this._startTime = this._now();
+        this._stopTime = -1;
+    }
     elapsed() {
         if (this._stopTime !== -1) {
             return this._stopTime - this._startTime;
diff -urN -x '*.map' a/vs/base/common/stream.js b/vs/base/common/stream.js
--- a/vs/base/common/stream.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/base/common/stream.js	2023-12-06 14:23:14.351854734 +0000
@@ -0,0 +1,462 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { onUnexpectedError } from './errors.js';
+import { DisposableStore, toDisposable } from './lifecycle.js';
+export function isReadable(obj) {
+    const candidate = obj;
+    if (!candidate) {
+        return false;
+    }
+    return typeof candidate.read === 'function';
+}
+export function isReadableStream(obj) {
+    const candidate = obj;
+    if (!candidate) {
+        return false;
+    }
+    return [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');
+}
+export function isReadableBufferedStream(obj) {
+    const candidate = obj;
+    if (!candidate) {
+        return false;
+    }
+    return isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';
+}
+export function newWriteableStream(reducer, options) {
+    return new WriteableStreamImpl(reducer, options);
+}
+class WriteableStreamImpl {
+    constructor(reducer, options) {
+        this.reducer = reducer;
+        this.options = options;
+        this.state = {
+            flowing: false,
+            ended: false,
+            destroyed: false
+        };
+        this.buffer = {
+            data: [],
+            error: []
+        };
+        this.listeners = {
+            data: [],
+            error: [],
+            end: []
+        };
+        this.pendingWritePromises = [];
+    }
+    pause() {
+        if (this.state.destroyed) {
+            return;
+        }
+        this.state.flowing = false;
+    }
+    resume() {
+        if (this.state.destroyed) {
+            return;
+        }
+        if (!this.state.flowing) {
+            this.state.flowing = true;
+            // emit buffered events
+            this.flowData();
+            this.flowErrors();
+            this.flowEnd();
+        }
+    }
+    write(data) {
+        if (this.state.destroyed) {
+            return;
+        }
+        // flowing: directly send the data to listeners
+        if (this.state.flowing) {
+            this.emitData(data);
+        }
+        // not yet flowing: buffer data until flowing
+        else {
+            this.buffer.data.push(data);
+            // highWaterMark: if configured, signal back when buffer reached limits
+            if (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {
+                return new Promise(resolve => this.pendingWritePromises.push(resolve));
+            }
+        }
+    }
+    error(error) {
+        if (this.state.destroyed) {
+            return;
+        }
+        // flowing: directly send the error to listeners
+        if (this.state.flowing) {
+            this.emitError(error);
+        }
+        // not yet flowing: buffer errors until flowing
+        else {
+            this.buffer.error.push(error);
+        }
+    }
+    end(result) {
+        if (this.state.destroyed) {
+            return;
+        }
+        // end with data if provided
+        if (typeof result !== 'undefined') {
+            this.write(result);
+        }
+        // flowing: send end event to listeners
+        if (this.state.flowing) {
+            this.emitEnd();
+            this.destroy();
+        }
+        // not yet flowing: remember state
+        else {
+            this.state.ended = true;
+        }
+    }
+    emitData(data) {
+        this.listeners.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event
+    }
+    emitError(error) {
+        if (this.listeners.error.length === 0) {
+            onUnexpectedError(error); // nobody listened to this error so we log it as unexpected
+        }
+        else {
+            this.listeners.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event
+        }
+    }
+    emitEnd() {
+        this.listeners.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event
+    }
+    on(event, callback) {
+        if (this.state.destroyed) {
+            return;
+        }
+        switch (event) {
+            case 'data':
+                this.listeners.data.push(callback);
+                // switch into flowing mode as soon as the first 'data'
+                // listener is added and we are not yet in flowing mode
+                this.resume();
+                break;
+            case 'end':
+                this.listeners.end.push(callback);
+                // emit 'end' event directly if we are flowing
+                // and the end has already been reached
+                //
+                // finish() when it went through
+                if (this.state.flowing && this.flowEnd()) {
+                    this.destroy();
+                }
+                break;
+            case 'error':
+                this.listeners.error.push(callback);
+                // emit buffered 'error' events unless done already
+                // now that we know that we have at least one listener
+                if (this.state.flowing) {
+                    this.flowErrors();
+                }
+                break;
+        }
+    }
+    removeListener(event, callback) {
+        if (this.state.destroyed) {
+            return;
+        }
+        let listeners = undefined;
+        switch (event) {
+            case 'data':
+                listeners = this.listeners.data;
+                break;
+            case 'end':
+                listeners = this.listeners.end;
+                break;
+            case 'error':
+                listeners = this.listeners.error;
+                break;
+        }
+        if (listeners) {
+            const index = listeners.indexOf(callback);
+            if (index >= 0) {
+                listeners.splice(index, 1);
+            }
+        }
+    }
+    flowData() {
+        if (this.buffer.data.length > 0) {
+            const fullDataBuffer = this.reducer(this.buffer.data);
+            this.emitData(fullDataBuffer);
+            this.buffer.data.length = 0;
+            // When the buffer is empty, resolve all pending writers
+            const pendingWritePromises = [...this.pendingWritePromises];
+            this.pendingWritePromises.length = 0;
+            pendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());
+        }
+    }
+    flowErrors() {
+        if (this.listeners.error.length > 0) {
+            for (const error of this.buffer.error) {
+                this.emitError(error);
+            }
+            this.buffer.error.length = 0;
+        }
+    }
+    flowEnd() {
+        if (this.state.ended) {
+            this.emitEnd();
+            return this.listeners.end.length > 0;
+        }
+        return false;
+    }
+    destroy() {
+        if (!this.state.destroyed) {
+            this.state.destroyed = true;
+            this.state.ended = true;
+            this.buffer.data.length = 0;
+            this.buffer.error.length = 0;
+            this.listeners.data.length = 0;
+            this.listeners.error.length = 0;
+            this.listeners.end.length = 0;
+            this.pendingWritePromises.length = 0;
+        }
+    }
+}
+/**
+ * Helper to fully read a T readable into a T.
+ */
+export function consumeReadable(readable, reducer) {
+    const chunks = [];
+    let chunk;
+    while ((chunk = readable.read()) !== null) {
+        chunks.push(chunk);
+    }
+    return reducer(chunks);
+}
+/**
+ * Helper to read a T readable up to a maximum of chunks. If the limit is
+ * reached, will return a readable instead to ensure all data can still
+ * be read.
+ */
+export function peekReadable(readable, reducer, maxChunks) {
+    const chunks = [];
+    let chunk = undefined;
+    while ((chunk = readable.read()) !== null && chunks.length < maxChunks) {
+        chunks.push(chunk);
+    }
+    // If the last chunk is null, it means we reached the end of
+    // the readable and return all the data at once
+    if (chunk === null && chunks.length > 0) {
+        return reducer(chunks);
+    }
+    // Otherwise, we still have a chunk, it means we reached the maxChunks
+    // value and as such we return a new Readable that first returns
+    // the existing read chunks and then continues with reading from
+    // the underlying readable.
+    return {
+        read: () => {
+            // First consume chunks from our array
+            if (chunks.length > 0) {
+                return chunks.shift();
+            }
+            // Then ensure to return our last read chunk
+            if (typeof chunk !== 'undefined') {
+                const lastReadChunk = chunk;
+                // explicitly use undefined here to indicate that we consumed
+                // the chunk, which could have either been null or valued.
+                chunk = undefined;
+                return lastReadChunk;
+            }
+            // Finally delegate back to the Readable
+            return readable.read();
+        }
+    };
+}
+export function consumeStream(stream, reducer) {
+    return new Promise((resolve, reject) => {
+        const chunks = [];
+        listenStream(stream, {
+            onData: chunk => {
+                if (reducer) {
+                    chunks.push(chunk);
+                }
+            },
+            onError: error => {
+                if (reducer) {
+                    reject(error);
+                }
+                else {
+                    resolve(undefined);
+                }
+            },
+            onEnd: () => {
+                if (reducer) {
+                    resolve(reducer(chunks));
+                }
+                else {
+                    resolve(undefined);
+                }
+            }
+        });
+    });
+}
+/**
+ * Helper to listen to all events of a T stream in proper order.
+ */
+export function listenStream(stream, listener, token) {
+    stream.on('error', error => {
+        if (!token?.isCancellationRequested) {
+            listener.onError(error);
+        }
+    });
+    stream.on('end', () => {
+        if (!token?.isCancellationRequested) {
+            listener.onEnd();
+        }
+    });
+    // Adding the `data` listener will turn the stream
+    // into flowing mode. As such it is important to
+    // add this listener last (DO NOT CHANGE!)
+    stream.on('data', data => {
+        if (!token?.isCancellationRequested) {
+            listener.onData(data);
+        }
+    });
+}
+/**
+ * Helper to peek up to `maxChunks` into a stream. The return type signals if
+ * the stream has ended or not. If not, caller needs to add a `data` listener
+ * to continue reading.
+ */
+export function peekStream(stream, maxChunks) {
+    return new Promise((resolve, reject) => {
+        const streamListeners = new DisposableStore();
+        const buffer = [];
+        // Data Listener
+        const dataListener = (chunk) => {
+            // Add to buffer
+            buffer.push(chunk);
+            // We reached maxChunks and thus need to return
+            if (buffer.length > maxChunks) {
+                // Dispose any listeners and ensure to pause the
+                // stream so that it can be consumed again by caller
+                streamListeners.dispose();
+                stream.pause();
+                return resolve({ stream, buffer, ended: false });
+            }
+        };
+        // Error Listener
+        const errorListener = (error) => {
+            streamListeners.dispose();
+            return reject(error);
+        };
+        // End Listener
+        const endListener = () => {
+            streamListeners.dispose();
+            return resolve({ stream, buffer, ended: true });
+        };
+        streamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));
+        stream.on('error', errorListener);
+        streamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));
+        stream.on('end', endListener);
+        // Important: leave the `data` listener last because
+        // this can turn the stream into flowing mode and we
+        // want `error` events to be received as well.
+        streamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));
+        stream.on('data', dataListener);
+    });
+}
+/**
+ * Helper to create a readable stream from an existing T.
+ */
+export function toStream(t, reducer) {
+    const stream = newWriteableStream(reducer);
+    stream.end(t);
+    return stream;
+}
+/**
+ * Helper to create an empty stream
+ */
+export function emptyStream() {
+    const stream = newWriteableStream(() => { throw new Error('not supported'); });
+    stream.end();
+    return stream;
+}
+/**
+ * Helper to convert a T into a Readable<T>.
+ */
+export function toReadable(t) {
+    let consumed = false;
+    return {
+        read: () => {
+            if (consumed) {
+                return null;
+            }
+            consumed = true;
+            return t;
+        }
+    };
+}
+/**
+ * Helper to transform a readable stream into another stream.
+ */
+export function transform(stream, transformer, reducer) {
+    const target = newWriteableStream(reducer);
+    listenStream(stream, {
+        onData: data => target.write(transformer.data(data)),
+        onError: error => target.error(transformer.error ? transformer.error(error) : error),
+        onEnd: () => target.end()
+    });
+    return target;
+}
+/**
+ * Helper to take an existing readable that will
+ * have a prefix injected to the beginning.
+ */
+export function prefixedReadable(prefix, readable, reducer) {
+    let prefixHandled = false;
+    return {
+        read: () => {
+            const chunk = readable.read();
+            // Handle prefix only once
+            if (!prefixHandled) {
+                prefixHandled = true;
+                // If we have also a read-result, make
+                // sure to reduce it to a single result
+                if (chunk !== null) {
+                    return reducer([prefix, chunk]);
+                }
+                // Otherwise, just return prefix directly
+                return prefix;
+            }
+            return chunk;
+        }
+    };
+}
+/**
+ * Helper to take an existing stream that will
+ * have a prefix injected to the beginning.
+ */
+export function prefixedStream(prefix, stream, reducer) {
+    let prefixHandled = false;
+    const target = newWriteableStream(reducer);
+    listenStream(stream, {
+        onData: data => {
+            // Handle prefix only once
+            if (!prefixHandled) {
+                prefixHandled = true;
+                return target.write(reducer([prefix, data]));
+            }
+            return target.write(data);
+        },
+        onError: error => target.error(error),
+        onEnd: () => {
+            // Handle prefix only once
+            if (!prefixHandled) {
+                prefixHandled = true;
+                target.write(prefix);
+            }
+            target.end();
+        }
+    });
+    return target;
+}
diff -urN -x '*.map' a/vs/base/common/strings.js b/vs/base/common/strings.js
--- a/vs/base/common/strings.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/strings.js	2023-12-06 14:23:14.351854734 +0000
@@ -29,6 +29,14 @@
             args[idx];
     });
 }
+const _format2Regexp = /{([^}]+)}/g;
+/**
+ * Helper to create a string from a template and a string record.
+ * Similar to `format` but with objects instead of positional arguments.
+ */
+export function format2(template, values) {
+    return template.replace(_format2Regexp, (match, group) => (values[group] ?? match));
+}
 /**
  * Converts HTML characters inside the string to use entities instead. Makes the string safe from
  * being used e.g. in HTMLElement.innerHTML.
@@ -50,6 +58,25 @@
     return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, '\\$&');
 }
 /**
+ * Counts how often `character` occurs inside `value`.
+ */
+export function count(value, character) {
+    let result = 0;
+    const ch = character.charCodeAt(0);
+    for (let i = value.length - 1; i >= 0; i--) {
+        if (value.charCodeAt(i) === ch) {
+            result++;
+        }
+    }
+    return result;
+}
+export function truncate(value, maxLength, suffix = '…') {
+    if (value.length <= maxLength) {
+        return value;
+    }
+    return `${value.substr(0, maxLength)}${suffix}`;
+}
+/**
  * Removes all occurrences of needle from the beginning and end of haystack.
  * @param haystack string to trim
  * @param needle the thing to trim (default is a blank)
@@ -192,6 +219,24 @@
     }
     return -1;
 }
+/**
+ * Function that works identically to String.prototype.replace, except, the
+ * replace function is allowed to be async and return a Promise.
+ */
+export function replaceAsync(str, search, replacer) {
+    const parts = [];
+    let last = 0;
+    for (const match of str.matchAll(search)) {
+        parts.push(str.slice(last, match.index));
+        if (match.index === undefined) {
+            throw new Error('match.index should be defined');
+        }
+        last = match.index + match[0].length;
+        parts.push(replacer(match[0], ...match.slice(1), match.index, str, match.groups));
+    }
+    parts.push(str.slice(last));
+    return Promise.all(parts).then(p => p.join(''));
+}
 export function compare(a, b) {
     if (a < b) {
         return -1;
@@ -442,6 +487,15 @@
     const startOffset = endOffset - prevCharLength(str, endOffset);
     return [startOffset, endOffset];
 }
+export function charCount(str) {
+    const iterator = new GraphemeIterator(str);
+    let length = 0;
+    while (!iterator.eol()) {
+        length++;
+        iterator.nextGraphemeLength();
+    }
+    return length;
+}
 let CONTAINS_RTL = undefined;
 function makeContainsRtl() {
     // Generated using https://github.com/alexdima/unicode-utils/blob/main/rtl-test.js
@@ -524,11 +578,68 @@
         || (x >= 128992 && x <= 129008) || (x >= 129280 && x <= 129535)
         || (x >= 129648 && x <= 129782));
 }
+/**
+ * Given a string and a max length returns a shorted version. Shorting
+ * happens at favorable positions - such as whitespace or punctuation characters.
+ */
+export function lcut(text, n) {
+    if (text.length < n) {
+        return text;
+    }
+    const re = /\b/g;
+    let i = 0;
+    while (re.test(text)) {
+        if (text.length - re.lastIndex < n) {
+            break;
+        }
+        i = re.lastIndex;
+        re.lastIndex += 1;
+    }
+    return text.substring(i).replace(/^\s/, '');
+}
+// Escape codes, compiled from https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Functions-using-CSI-_-ordered-by-the-final-character_s_
+const CSI_SEQUENCE = /(:?\x1b\[|\x9B)[=?>!]?[\d;:]*["$#'* ]?[a-zA-Z@^`{}|~]/g;
+// Plus additional markers for custom `\x1b]...\x07` instructions.
+const CSI_CUSTOM_SEQUENCE = /\x1b\].*?\x07/g;
+export function removeAnsiEscapeCodes(str) {
+    if (str) {
+        str = str.replace(CSI_SEQUENCE, '').replace(CSI_CUSTOM_SEQUENCE, '');
+    }
+    return str;
+}
 // -- UTF-8 BOM
 export const UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* CharCode.UTF8_BOM */);
 export function startsWithUTF8BOM(str) {
     return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* CharCode.UTF8_BOM */);
 }
+export function stripUTF8BOM(str) {
+    return startsWithUTF8BOM(str) ? str.substr(1) : str;
+}
+/**
+ * Checks if the characters of the provided query string are included in the
+ * target string. The characters do not have to be contiguous within the string.
+ */
+export function fuzzyContains(target, query) {
+    if (!target || !query) {
+        return false; // return early if target or query are undefined
+    }
+    if (target.length < query.length) {
+        return false; // impossible for query to be contained in target
+    }
+    const queryLen = query.length;
+    const targetLower = target.toLowerCase();
+    let index = 0;
+    let lastIndexOf = -1;
+    while (index < queryLen) {
+        const indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);
+        if (indexOf < 0) {
+            return false;
+        }
+        lastIndexOf = indexOf;
+        index++;
+    }
+    return true;
+}
 export function containsUppercaseCharacter(target, ignoreEscapedChars = false) {
     if (!target) {
         return false;
@@ -538,6 +649,26 @@
     }
     return target.toLowerCase() !== target;
 }
+export function uppercaseFirstLetter(str) {
+    return str.charAt(0).toUpperCase() + str.slice(1);
+}
+export function getNLines(str, n = 1) {
+    if (n === 0) {
+        return '';
+    }
+    let idx = -1;
+    do {
+        idx = str.indexOf('\n', idx + 1);
+        n--;
+    } while (n > 0 && idx >= 0);
+    if (idx === -1) {
+        return str;
+    }
+    if (str[idx - 1] === '\r') {
+        idx--;
+    }
+    return str.substr(0, idx);
+}
 /**
  * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.
  */
@@ -549,6 +680,11 @@
     }
     return String.fromCharCode(65 /* CharCode.A */ + n - LETTERS_CNT);
 }
+//#region Unicode Grapheme Break
+export function getGraphemeBreakType(codePoint) {
+    const graphemeBreakTree = GraphemeBreakTree.getInstance();
+    return graphemeBreakTree.getGraphemeBreakType(codePoint);
+}
 function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
     // http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules
     // !!! Let's make the common case a bit faster
diff -urN -x '*.map' a/vs/base/common/ternarySearchTree.js b/vs/base/common/ternarySearchTree.js
--- a/vs/base/common/ternarySearchTree.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/ternarySearchTree.js	2023-12-06 14:23:14.351854734 +0000
@@ -1,3 +1,8 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { shuffle } from './arrays.js';
 import { compare, compareIgnoreCase, compareSubstring, compareSubstringIgnoreCase } from './strings.js';
 export class StringIterator {
     constructor() {
@@ -205,6 +210,9 @@
     constructor() {
         this.height = 1;
     }
+    isEmpty() {
+        return !this.left && !this.mid && !this.right && !this.value;
+    }
     rotateLeft() {
         const tmp = this.right;
         this.right = tmp.left;
@@ -228,18 +236,19 @@
         return this.heightRight - this.heightLeft;
     }
     get heightLeft() {
-        var _a, _b;
-        return (_b = (_a = this.left) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0;
+        return this.left?.height ?? 0;
     }
     get heightRight() {
-        var _a, _b;
-        return (_b = (_a = this.right) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0;
+        return this.right?.height ?? 0;
     }
 }
 export class TernarySearchTree {
     static forUris(ignorePathCasing = () => false, ignoreQueryAndFragment = () => false) {
         return new TernarySearchTree(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));
     }
+    static forPaths(ignorePathCasing = false) {
+        return new TernarySearchTree(new PathIterator(undefined, !ignorePathCasing));
+    }
     static forStrings() {
         return new TernarySearchTree(new StringIterator());
     }
@@ -252,6 +261,22 @@
     clear() {
         this._root = undefined;
     }
+    fill(values, keys) {
+        if (keys) {
+            const arr = keys.slice(0);
+            shuffle(arr);
+            for (const k of arr) {
+                this.set(k, values);
+            }
+        }
+        else {
+            const arr = values.slice(0);
+            shuffle(arr);
+            for (const entry of arr) {
+                this.set(entry[0], entry[1]);
+            }
+        }
+    }
     set(key, element) {
         const iter = this._iter.reset(key);
         let node;
@@ -352,8 +377,7 @@
         return oldElement;
     }
     get(key) {
-        var _a;
-        return (_a = this._getNode(key)) === null || _a === void 0 ? void 0 : _a.value;
+        return this._getNode(key)?.value;
     }
     _getNode(key) {
         const iter = this._iter.reset(key);
@@ -381,7 +405,7 @@
     }
     has(key) {
         const node = this._getNode(key);
-        return !((node === null || node === void 0 ? void 0 : node.value) === undefined && (node === null || node === void 0 ? void 0 : node.mid) === undefined);
+        return !(node?.value === undefined && node?.mid === undefined);
     }
     delete(key) {
         return this._delete(key, false);
@@ -390,7 +414,6 @@
         return this._delete(key, true);
     }
     _delete(key, superStr) {
-        var _a;
         const iter = this._iter.reset(key);
         const stack = [];
         let node = this._root;
@@ -450,7 +473,7 @@
             }
             else {
                 // empty or half empty
-                const newChild = (_a = node.left) !== null && _a !== void 0 ? _a : node.right;
+                const newChild = node.left ?? node.right;
                 if (stack.length > 0) {
                     const [dir, parent] = stack[stack.length - 1];
                     switch (dir) {
@@ -588,6 +611,9 @@
         }
         return undefined;
     }
+    hasElementOrSubtree(key) {
+        return this._findSuperstrOrElement(key, true) !== undefined;
+    }
     forEach(callback) {
         for (const [key, value] of this) {
             callback(value, key);
@@ -619,4 +645,18 @@
             this._dfsEntries(node.right, bucket);
         }
     }
+    // for debug/testing
+    _isBalanced() {
+        const nodeIsBalanced = (node) => {
+            if (!node) {
+                return true;
+            }
+            const bf = node.balanceFactor();
+            if (bf < -1 || bf > 1) {
+                return false;
+            }
+            return nodeIsBalanced(node.left) && nodeIsBalanced(node.right);
+        };
+        return nodeIsBalanced(this._root);
+    }
 }
diff -urN -x '*.map' a/vs/base/common/tfIdf.js b/vs/base/common/tfIdf.js
--- a/vs/base/common/tfIdf.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/tfIdf.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,182 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-function countMapFrom(values) {
-    var _a;
-    const map = new Map();
-    for (const value of values) {
-        map.set(value, ((_a = map.get(value)) !== null && _a !== void 0 ? _a : 0) + 1);
-    }
-    return map;
-}
-/**
- * Implementation of tf-idf (term frequency-inverse document frequency) for a set of
- * documents where each document contains one or more chunks of text.
- * Each document is identified by a key, and the score for each document is computed
- * by taking the max score over all the chunks in the document.
- */
-export class TfIdfCalculator {
-    constructor() {
-        /**
-         * Total number of chunks
-         */
-        this.chunkCount = 0;
-        this.chunkOccurrences = new Map();
-        this.documents = new Map();
-    }
-    calculateScores(query, token) {
-        const embedding = this.computeEmbedding(query);
-        const idfCache = new Map();
-        const scores = [];
-        // For each document, generate one score
-        for (const [key, doc] of this.documents) {
-            if (token.isCancellationRequested) {
-                return [];
-            }
-            for (const chunk of doc.chunks) {
-                const score = this.computeSimilarityScore(chunk, embedding, idfCache);
-                if (score > 0) {
-                    scores.push({ key, score });
-                }
-            }
-        }
-        return scores;
-    }
-    /**
-     * Count how many times each term (word) appears in a string.
-     */
-    static termFrequencies(input) {
-        return countMapFrom(TfIdfCalculator.splitTerms(input));
-    }
-    /**
-     * Break a string into terms (words).
-     */
-    static *splitTerms(input) {
-        const normalize = (word) => word.toLowerCase();
-        // Only match on words that are at least 3 characters long and start with a letter
-        for (const [word] of input.matchAll(/\b\p{Letter}[\p{Letter}\d]{2,}\b/gu)) {
-            yield normalize(word);
-            // eslint-disable-next-line local/code-no-look-behind-regex
-            const camelParts = word.split(/(?<=[a-z])(?=[A-Z])/g);
-            if (camelParts.length > 1) {
-                for (const part of camelParts) {
-                    // Require at least 3 letters in the parts of a camel case word
-                    if (part.length > 2 && /\p{Letter}{3,}/gu.test(part)) {
-                        yield normalize(part);
-                    }
-                }
-            }
-        }
-    }
-    updateDocuments(documents) {
-        var _a;
-        for (const { key } of documents) {
-            this.deleteDocument(key);
-        }
-        for (const doc of documents) {
-            const chunks = [];
-            for (const text of doc.textChunks) {
-                // TODO: See if we can compute the tf lazily
-                // The challenge is that we need to also update the `chunkOccurrences`
-                // and all of those updates need to get flushed before the real TF-IDF of
-                // anything is computed.
-                const tf = TfIdfCalculator.termFrequencies(text);
-                // Update occurrences list
-                for (const term of tf.keys()) {
-                    this.chunkOccurrences.set(term, ((_a = this.chunkOccurrences.get(term)) !== null && _a !== void 0 ? _a : 0) + 1);
-                }
-                chunks.push({ text, tf });
-            }
-            this.chunkCount += chunks.length;
-            this.documents.set(doc.key, { chunks });
-        }
-        return this;
-    }
-    deleteDocument(key) {
-        const doc = this.documents.get(key);
-        if (!doc) {
-            return;
-        }
-        this.documents.delete(key);
-        this.chunkCount -= doc.chunks.length;
-        // Update term occurrences for the document
-        for (const chunk of doc.chunks) {
-            for (const term of chunk.tf.keys()) {
-                const currentOccurrences = this.chunkOccurrences.get(term);
-                if (typeof currentOccurrences === 'number') {
-                    const newOccurrences = currentOccurrences - 1;
-                    if (newOccurrences <= 0) {
-                        this.chunkOccurrences.delete(term);
-                    }
-                    else {
-                        this.chunkOccurrences.set(term, newOccurrences);
-                    }
-                }
-            }
-        }
-    }
-    computeSimilarityScore(chunk, queryEmbedding, idfCache) {
-        // Compute the dot product between the chunk's embedding and the query embedding
-        // Note that the chunk embedding is computed lazily on a per-term basis.
-        // This lets us skip a large number of calculations because the majority
-        // of chunks do not share any terms with the query.
-        let sum = 0;
-        for (const [term, termTfidf] of Object.entries(queryEmbedding)) {
-            const chunkTf = chunk.tf.get(term);
-            if (!chunkTf) {
-                // Term does not appear in chunk so it has no contribution
-                continue;
-            }
-            let chunkIdf = idfCache.get(term);
-            if (typeof chunkIdf !== 'number') {
-                chunkIdf = this.computeIdf(term);
-                idfCache.set(term, chunkIdf);
-            }
-            const chunkTfidf = chunkTf * chunkIdf;
-            sum += chunkTfidf * termTfidf;
-        }
-        return sum;
-    }
-    computeEmbedding(input) {
-        const tf = TfIdfCalculator.termFrequencies(input);
-        return this.computeTfidf(tf);
-    }
-    computeIdf(term) {
-        var _a;
-        const chunkOccurrences = (_a = this.chunkOccurrences.get(term)) !== null && _a !== void 0 ? _a : 0;
-        return chunkOccurrences > 0
-            ? Math.log((this.chunkCount + 1) / chunkOccurrences)
-            : 0;
-    }
-    computeTfidf(termFrequencies) {
-        const embedding = Object.create(null);
-        for (const [word, occurrences] of termFrequencies) {
-            const idf = this.computeIdf(word);
-            if (idf > 0) {
-                embedding[word] = occurrences * idf;
-            }
-        }
-        return embedding;
-    }
-}
-/**
- * Normalize the scores to be between 0 and 1 and sort them decending.
- * @param scores array of scores from {@link TfIdfCalculator.calculateScores}
- * @returns normalized scores
- */
-export function normalizeTfIdfScores(scores) {
-    var _a, _b;
-    // copy of scores
-    const result = scores.slice(0);
-    // sort descending
-    result.sort((a, b) => b.score - a.score);
-    // normalize
-    const max = (_b = (_a = result[0]) === null || _a === void 0 ? void 0 : _a.score) !== null && _b !== void 0 ? _b : 0;
-    if (max > 0) {
-        for (const score of result) {
-            score.score /= max;
-        }
-    }
-    return result;
-}
diff -urN -x '*.map' a/vs/base/common/themables.js b/vs/base/common/themables.js
--- a/vs/base/common/themables.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/themables.js	2023-12-06 14:23:14.351854734 +0000
@@ -10,6 +10,9 @@
     }
     ThemeColor.isThemeColor = isThemeColor;
 })(ThemeColor || (ThemeColor = {}));
+export function themeColorFromId(id) {
+    return { id };
+}
 export var ThemeIcon;
 (function (ThemeIcon) {
     ThemeIcon.iconNameSegment = '[A-Za-z0-9]+';
@@ -77,8 +80,7 @@
     }
     ThemeIcon.getModifier = getModifier;
     function isEqual(ti1, ti2) {
-        var _a, _b;
-        return ti1.id === ti2.id && ((_a = ti1.color) === null || _a === void 0 ? void 0 : _a.id) === ((_b = ti2.color) === null || _b === void 0 ? void 0 : _b.id);
+        return ti1.id === ti2.id && ti1.color?.id === ti2.color?.id;
     }
     ThemeIcon.isEqual = isEqual;
 })(ThemeIcon || (ThemeIcon = {}));
diff -urN -x '*.map' a/vs/base/common/types.js b/vs/base/common/types.js
--- a/vs/base/common/types.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/types.js	2023-12-06 14:23:14.351854734 +0000
@@ -9,6 +9,12 @@
     return (typeof str === 'string');
 }
 /**
+ * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.
+ */
+export function isStringArray(value) {
+    return Array.isArray(value) && value.every(elem => isString(elem));
+}
+/**
  * @returns whether the provided parameter is of type `object` but **not**
  *	`null`, an `array`, a `regexp`, nor a `date`.
  */
@@ -81,12 +87,44 @@
     }
     return arg;
 }
+export function assertAllDefined(...args) {
+    const result = [];
+    for (let i = 0; i < args.length; i++) {
+        const arg = args[i];
+        if (isUndefinedOrNull(arg)) {
+            throw new Error(`Assertion Failed: argument at index ${i} is undefined or null`);
+        }
+        result.push(arg);
+    }
+    return result;
+}
+const hasOwnProperty = Object.prototype.hasOwnProperty;
+/**
+ * @returns whether the provided parameter is an empty JavaScript Object or not.
+ */
+export function isEmptyObject(obj) {
+    if (!isObject(obj)) {
+        return false;
+    }
+    for (const key in obj) {
+        if (hasOwnProperty.call(obj, key)) {
+            return false;
+        }
+    }
+    return true;
+}
 /**
  * @returns whether the provided parameter is a JavaScript Function or not.
  */
 export function isFunction(obj) {
     return (typeof obj === 'function');
 }
+/**
+ * @returns whether the provided parameters is are JavaScript Function or not.
+ */
+export function areFunctions(...objects) {
+    return objects.length > 0 && objects.every(isFunction);
+}
 export function validateConstraints(args, constraints) {
     const len = Math.min(args.length, constraints.length);
     for (let i = 0; i < len; i++) {
@@ -105,7 +143,7 @@
                 return;
             }
         }
-        catch (_a) {
+        catch {
             // ignore
         }
         if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
diff -urN -x '*.map' a/vs/base/common/uri.js b/vs/base/common/uri.js
--- a/vs/base/common/uri.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/uri.js	2023-12-06 14:23:14.355854741 +0000
@@ -308,7 +308,6 @@
         return this;
     }
     static revive(data) {
-        var _a, _b;
         if (!data) {
             return data;
         }
@@ -317,12 +316,22 @@
         }
         else {
             const result = new Uri(data);
-            result._formatted = (_a = data.external) !== null && _a !== void 0 ? _a : null;
-            result._fsPath = data._sep === _pathSepMarker ? (_b = data.fsPath) !== null && _b !== void 0 ? _b : null : null;
+            result._formatted = data.external ?? null;
+            result._fsPath = data._sep === _pathSepMarker ? data.fsPath ?? null : null;
             return result;
         }
     }
 }
+export function isUriComponents(thing) {
+    if (!thing || typeof thing !== 'object') {
+        return false;
+    }
+    return typeof thing.scheme === 'string'
+        && (typeof thing.authority === 'string' || typeof thing.authority === 'undefined')
+        && (typeof thing.path === 'string' || typeof thing.path === 'undefined')
+        && (typeof thing.query === 'string' || typeof thing.query === 'undefined')
+        && (typeof thing.fragment === 'string' || typeof thing.fragment === 'undefined');
+}
 const _pathSepMarker = isWindows ? 1 : undefined;
 // This class exists so that URI is compatible with vscode.Uri (API).
 class Uri extends URI {
@@ -585,7 +594,7 @@
     try {
         return decodeURIComponent(str);
     }
-    catch (_a) {
+    catch {
         if (str.length > 3) {
             return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
         }
diff -urN -x '*.map' a/vs/base/common/uuid.js b/vs/base/common/uuid.js
--- a/vs/base/common/uuid.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/uuid.js	2023-12-06 14:23:14.355854741 +0000
@@ -1,3 +1,11 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
+export function isUUID(value) {
+    return _UUIDPattern.test(value);
+}
 export const generateUuid = (function () {
     // use `randomUUID` if possible
     if (typeof crypto === 'object' && typeof crypto.randomUUID === 'function') {
diff -urN -x '*.map' a/vs/base/common/worker/simpleWorker.js b/vs/base/common/worker/simpleWorker.js
--- a/vs/base/common/worker/simpleWorker.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/common/worker/simpleWorker.js	2023-12-06 14:23:14.355854741 +0000
@@ -208,7 +208,7 @@
         }, (err) => {
             // in Firefox, web workers fail lazily :(
             // we will reject the proxy
-            lazyProxyReject === null || lazyProxyReject === void 0 ? void 0 : lazyProxyReject(err);
+            lazyProxyReject?.(err);
         }));
         this._protocol = new SimpleWorkerProtocol({
             sendMessage: (msg, transfer) => {
diff -urN -x '*.map' a/vs/base/parts/sandbox/common/electronTypes.js b/vs/base/parts/sandbox/common/electronTypes.js
--- a/vs/base/parts/sandbox/common/electronTypes.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/base/parts/sandbox/common/electronTypes.js	2023-12-06 14:23:14.355854741 +0000
@@ -0,0 +1,5 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+export {};
diff -urN -x '*.map' a/vs/base/parts/storage/common/storage.js b/vs/base/parts/storage/common/storage.js
--- a/vs/base/parts/storage/common/storage.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/base/parts/storage/common/storage.js	2023-12-06 14:23:14.355854741 +0000
@@ -2,19 +2,10 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { ThrottledDelayer } from '../../../common/async.js';
 import { Event, PauseableEmitter } from '../../../common/event.js';
 import { Disposable } from '../../../common/lifecycle.js';
-import { stringify } from '../../../common/marshalling.js';
+import { parse, stringify } from '../../../common/marshalling.js';
 import { isObject, isUndefinedOrNull } from '../../../common/types.js';
 export var StorageHint;
 (function (StorageHint) {
@@ -27,6 +18,10 @@
     // is backed by an in-memory storage.
     StorageHint[StorageHint["STORAGE_IN_MEMORY"] = 1] = "STORAGE_IN_MEMORY";
 })(StorageHint || (StorageHint = {}));
+export function isStorageItemsChangeEvent(thing) {
+    const candidate = thing;
+    return candidate?.changed instanceof Map || candidate?.deleted instanceof Set;
+}
 export var StorageState;
 (function (StorageState) {
     StorageState[StorageState["None"] = 0] = "None";
@@ -45,6 +40,7 @@
         this.flushDelayer = this._register(new ThrottledDelayer(Storage.DEFAULT_FLUSH_DELAY));
         this.pendingDeletes = new Set();
         this.pendingInserts = new Map();
+        this.pendingClose = undefined;
         this.whenFlushedCallbacks = [];
         this.registerListeners();
     }
@@ -52,14 +48,13 @@
         this._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));
     }
     onDidChangeItemsExternal(e) {
-        var _a, _b;
         this._onDidChangeStorage.pause();
         try {
             // items that change external require us to update our
             // caches with the values. we just accept the value and
             // emit an event if there is a change.
-            (_a = e.changed) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => this.acceptExternal(key, value));
-            (_b = e.deleted) === null || _b === void 0 ? void 0 : _b.forEach(key => this.acceptExternal(key, undefined));
+            e.changed?.forEach((value, key) => this.acceptExternal(key, value));
+            e.deleted?.forEach(key => this.acceptExternal(key, undefined));
         }
         finally {
             this._onDidChangeStorage.resume();
@@ -87,6 +82,25 @@
             this._onDidChangeStorage.fire({ key, external: true });
         }
     }
+    get items() {
+        return this.cache;
+    }
+    get size() {
+        return this.cache.size;
+    }
+    async init() {
+        if (this.state !== StorageState.None) {
+            return; // either closed or already initialized
+        }
+        this.state = StorageState.Initialized;
+        if (this.options.hint === StorageHint.STORAGE_DOES_NOT_EXIST) {
+            // return early if we know the storage file does not exist. this is a performance
+            // optimization to not load all items of the underlying storage if we know that
+            // there can be no items because the storage does not exist.
+            return;
+        }
+        this.cache = await this.database.getItems();
+    }
     get(key, fallbackValue) {
         const value = this.cache.get(key);
         if (isUndefinedOrNull(value)) {
@@ -108,85 +122,130 @@
         }
         return parseInt(value, 10);
     }
-    set(key, value, external = false) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (this.state === StorageState.Closed) {
-                return; // Return early if we are already closed
-            }
-            // We remove the key for undefined/null values
-            if (isUndefinedOrNull(value)) {
-                return this.delete(key, external);
-            }
-            // Otherwise, convert to String and store
-            const valueStr = isObject(value) || Array.isArray(value) ? stringify(value) : String(value);
-            // Return early if value already set
-            const currentValue = this.cache.get(key);
-            if (currentValue === valueStr) {
-                return;
-            }
-            // Update in cache and pending
-            this.cache.set(key, valueStr);
-            this.pendingInserts.set(key, valueStr);
-            this.pendingDeletes.delete(key);
-            // Event
-            this._onDidChangeStorage.fire({ key, external });
-            // Accumulate work by scheduling after timeout
-            return this.doFlush();
-        });
+    getObject(key, fallbackValue) {
+        const value = this.get(key);
+        if (isUndefinedOrNull(value)) {
+            return fallbackValue;
+        }
+        return parse(value);
     }
-    delete(key, external = false) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (this.state === StorageState.Closed) {
-                return; // Return early if we are already closed
-            }
-            // Remove from cache and add to pending
-            const wasDeleted = this.cache.delete(key);
-            if (!wasDeleted) {
-                return; // Return early if value already deleted
-            }
-            if (!this.pendingDeletes.has(key)) {
-                this.pendingDeletes.add(key);
-            }
-            this.pendingInserts.delete(key);
-            // Event
-            this._onDidChangeStorage.fire({ key, external });
-            // Accumulate work by scheduling after timeout
-            return this.doFlush();
-        });
+    async set(key, value, external = false) {
+        if (this.state === StorageState.Closed) {
+            return; // Return early if we are already closed
+        }
+        // We remove the key for undefined/null values
+        if (isUndefinedOrNull(value)) {
+            return this.delete(key, external);
+        }
+        // Otherwise, convert to String and store
+        const valueStr = isObject(value) || Array.isArray(value) ? stringify(value) : String(value);
+        // Return early if value already set
+        const currentValue = this.cache.get(key);
+        if (currentValue === valueStr) {
+            return;
+        }
+        // Update in cache and pending
+        this.cache.set(key, valueStr);
+        this.pendingInserts.set(key, valueStr);
+        this.pendingDeletes.delete(key);
+        // Event
+        this._onDidChangeStorage.fire({ key, external });
+        // Accumulate work by scheduling after timeout
+        return this.doFlush();
+    }
+    async delete(key, external = false) {
+        if (this.state === StorageState.Closed) {
+            return; // Return early if we are already closed
+        }
+        // Remove from cache and add to pending
+        const wasDeleted = this.cache.delete(key);
+        if (!wasDeleted) {
+            return; // Return early if value already deleted
+        }
+        if (!this.pendingDeletes.has(key)) {
+            this.pendingDeletes.add(key);
+        }
+        this.pendingInserts.delete(key);
+        // Event
+        this._onDidChangeStorage.fire({ key, external });
+        // Accumulate work by scheduling after timeout
+        return this.doFlush();
+    }
+    async optimize() {
+        if (this.state === StorageState.Closed) {
+            return; // Return early if we are already closed
+        }
+        // Await pending data to be flushed to the DB
+        // before attempting to optimize the DB
+        await this.flush(0);
+        return this.database.optimize();
+    }
+    async close() {
+        if (!this.pendingClose) {
+            this.pendingClose = this.doClose();
+        }
+        return this.pendingClose;
+    }
+    async doClose() {
+        // Update state
+        this.state = StorageState.Closed;
+        // Trigger new flush to ensure data is persisted and then close
+        // even if there is an error flushing. We must always ensure
+        // the DB is closed to avoid corruption.
+        //
+        // Recovery: we pass our cache over as recovery option in case
+        // the DB is not healthy.
+        try {
+            await this.doFlush(0 /* as soon as possible */);
+        }
+        catch (error) {
+            // Ignore
+        }
+        await this.database.close(() => this.cache);
     }
     get hasPending() {
         return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
     }
-    flushPending() {
-        return __awaiter(this, void 0, void 0, function* () {
+    async flushPending() {
+        if (!this.hasPending) {
+            return; // return early if nothing to do
+        }
+        // Get pending data
+        const updateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };
+        // Reset pending data for next run
+        this.pendingDeletes = new Set();
+        this.pendingInserts = new Map();
+        // Update in storage and release any
+        // waiters we have once done
+        return this.database.updateItems(updateRequest).finally(() => {
             if (!this.hasPending) {
-                return; // return early if nothing to do
-            }
-            // Get pending data
-            const updateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };
-            // Reset pending data for next run
-            this.pendingDeletes = new Set();
-            this.pendingInserts = new Map();
-            // Update in storage and release any
-            // waiters we have once done
-            return this.database.updateItems(updateRequest).finally(() => {
-                var _a;
-                if (!this.hasPending) {
-                    while (this.whenFlushedCallbacks.length) {
-                        (_a = this.whenFlushedCallbacks.pop()) === null || _a === void 0 ? void 0 : _a();
-                    }
+                while (this.whenFlushedCallbacks.length) {
+                    this.whenFlushedCallbacks.pop()?.();
                 }
-            });
-        });
-    }
-    doFlush(delay) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {
-                return this.flushPending(); // return early if in-memory
             }
-            return this.flushDelayer.trigger(() => this.flushPending(), delay);
         });
     }
+    async flush(delay) {
+        if (!this.hasPending) {
+            return; // return early if nothing to do
+        }
+        return this.doFlush(delay);
+    }
+    async doFlush(delay) {
+        if (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {
+            return this.flushPending(); // return early if in-memory
+        }
+        return this.flushDelayer.trigger(() => this.flushPending(), delay);
+    }
+    async whenFlushed() {
+        if (!this.hasPending) {
+            return; // return early if nothing to do
+        }
+        return new Promise(resolve => this.whenFlushedCallbacks.push(resolve));
+    }
+    isInMemory() {
+        return this.options.hint === StorageHint.STORAGE_IN_MEMORY;
+    }
 }
 Storage.DEFAULT_FLUSH_DELAY = 100;
 export class InMemoryStorageDatabase {
@@ -194,11 +253,13 @@
         this.onDidChangeItemsExternal = Event.None;
         this.items = new Map();
     }
-    updateItems(request) {
-        var _a, _b;
-        return __awaiter(this, void 0, void 0, function* () {
-            (_a = request.insert) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => this.items.set(key, value));
-            (_b = request.delete) === null || _b === void 0 ? void 0 : _b.forEach(key => this.items.delete(key));
-        });
+    async getItems() {
+        return this.items;
+    }
+    async updateItems(request) {
+        request.insert?.forEach((value, key) => this.items.set(key, value));
+        request.delete?.forEach(key => this.items.delete(key));
     }
+    async optimize() { }
+    async close() { }
 }
diff -urN -x '*.map' a/vs/editor/browser/config/editorConfiguration.js b/vs/editor/browser/config/editorConfiguration.js
--- a/vs/editor/browser/config/editorConfiguration.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/config/editorConfiguration.js	2023-12-06 14:23:14.355854741 +0000
@@ -212,7 +212,7 @@
         this._values[id] = value;
     }
 }
-class EditorOptionsUtil {
+export class EditorOptionsUtil {
     static validateOptions(options) {
         const result = new ValidatedEditorOptions();
         for (const editorOption of editorOptionsRegistry) {
diff -urN -x '*.map' a/vs/editor/browser/config/fontMeasurements.js b/vs/editor/browser/config/fontMeasurements.js
--- a/vs/editor/browser/config/fontMeasurements.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/config/fontMeasurements.js	2023-12-06 14:23:14.355854741 +0000
@@ -7,7 +7,7 @@
 import { Disposable } from '../../../base/common/lifecycle.js';
 import { CharWidthRequest, readCharWidths } from './charWidthReader.js';
 import { EditorFontLigatures } from '../../common/config/editorOptions.js';
-import { FontInfo } from '../../common/config/fontInfo.js';
+import { FontInfo, SERIALIZED_FONT_INFO_VERSION } from '../../common/config/fontInfo.js';
 export class FontMeasurementsImpl extends Disposable {
     constructor() {
         super();
@@ -54,6 +54,28 @@
         }
     }
     /**
+     * Serialized currently cached font information.
+     */
+    serializeFontInfo() {
+        // Only save trusted font info (that has been measured in this running instance)
+        return this._cache.getValues().filter(item => item.isTrusted);
+    }
+    /**
+     * Restore previously serialized font informations.
+     */
+    restoreFontInfo(savedFontInfos) {
+        // Take all the saved font info and insert them in the cache without the trusted flag.
+        // The reason for this is that a font might have been installed on the OS in the meantime.
+        for (const savedFontInfo of savedFontInfos) {
+            if (savedFontInfo.version !== SERIALIZED_FONT_INFO_VERSION) {
+                // cannot use older version
+                continue;
+            }
+            const fontInfo = new FontInfo(savedFontInfo, false);
+            this._writeToCache(fontInfo, fontInfo);
+        }
+    }
+    /**
      * Read font information.
      */
     readFontInfo(bareFontInfo) {
@@ -87,7 +109,7 @@
     _createRequest(chr, type, all, monospace) {
         const result = new CharWidthRequest(chr, type);
         all.push(result);
-        monospace === null || monospace === void 0 ? void 0 : monospace.push(result);
+        monospace?.push(result);
         return result;
     }
     _actualReadFontInfo(bareFontInfo) {
diff -urN -x '*.map' a/vs/editor/browser/controller/mouseHandler.js b/vs/editor/browser/controller/mouseHandler.js
--- a/vs/editor/browser/controller/mouseHandler.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/controller/mouseHandler.js	2023-12-06 14:23:14.355854741 +0000
@@ -249,6 +249,9 @@
             target: t
         });
     }
+    _onMouseWheel(e) {
+        this.viewController.emitMouseWheel(e);
+    }
 }
 class MouseDownOperation extends Disposable {
     constructor(_context, _viewController, _viewHelper, _mouseTargetFactory, createMouseTarget, getMouseColumn) {
diff -urN -x '*.map' a/vs/editor/browser/controller/mouseTarget.js b/vs/editor/browser/controller/mouseTarget.js
--- a/vs/editor/browser/controller/mouseTarget.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/controller/mouseTarget.js	2023-12-06 14:23:14.355854741 +0000
@@ -46,7 +46,7 @@
         if (!range && position) {
             return new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);
         }
-        return range !== null && range !== void 0 ? range : null;
+        return range ?? null;
     }
     static createUnknown(element, mouseColumn, position) {
         return { type: 0 /* MouseTargetType.UNKNOWN */, element, mouseColumn, position, range: this._deduceRage(position) };
diff -urN -x '*.map' a/vs/editor/browser/controller/textAreaHandler.js b/vs/editor/browser/controller/textAreaHandler.js
--- a/vs/editor/browser/controller/textAreaHandler.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/controller/textAreaHandler.js	2023-12-06 14:23:14.355854741 +0000
@@ -127,7 +127,7 @@
         this.textArea.setAttribute('aria-required', options.get(5 /* EditorOption.ariaRequired */) ? 'true' : 'false');
         this.textArea.setAttribute('tabindex', String(options.get(123 /* EditorOption.tabIndex */)));
         this.textArea.setAttribute('role', 'textbox');
-        this.textArea.setAttribute('aria-roledescription', nls.localize('editor', "editor"));
+        this.textArea.setAttribute('aria-roledescription', nls.localizeWithPath('vs/editor/browser/controller/textAreaHandler', 'editor', "editor"));
         this.textArea.setAttribute('aria-multiline', 'true');
         this.textArea.setAttribute('aria-autocomplete', options.get(90 /* EditorOption.readOnly */) ? 'none' : 'both');
         this._ensureReadOnlyAttribute();
@@ -434,21 +434,20 @@
         return '';
     }
     _getAriaLabel(options) {
-        var _a, _b, _c;
         const accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);
         if (accessibilitySupport === 1 /* AccessibilitySupport.Disabled */) {
-            const toggleKeybindingLabel = (_a = this._keybindingService.lookupKeybinding('editor.action.toggleScreenReaderAccessibilityMode')) === null || _a === void 0 ? void 0 : _a.getAriaLabel();
-            const runCommandKeybindingLabel = (_b = this._keybindingService.lookupKeybinding('workbench.action.showCommands')) === null || _b === void 0 ? void 0 : _b.getAriaLabel();
-            const keybindingEditorKeybindingLabel = (_c = this._keybindingService.lookupKeybinding('workbench.action.openGlobalKeybindings')) === null || _c === void 0 ? void 0 : _c.getAriaLabel();
-            const editorNotAccessibleMessage = nls.localize('accessibilityModeOff', "The editor is not accessible at this time.");
+            const toggleKeybindingLabel = this._keybindingService.lookupKeybinding('editor.action.toggleScreenReaderAccessibilityMode')?.getAriaLabel();
+            const runCommandKeybindingLabel = this._keybindingService.lookupKeybinding('workbench.action.showCommands')?.getAriaLabel();
+            const keybindingEditorKeybindingLabel = this._keybindingService.lookupKeybinding('workbench.action.openGlobalKeybindings')?.getAriaLabel();
+            const editorNotAccessibleMessage = nls.localizeWithPath('vs/editor/browser/controller/textAreaHandler', 'accessibilityModeOff', "The editor is not accessible at this time.");
             if (toggleKeybindingLabel) {
-                return nls.localize('accessibilityOffAriaLabel', "{0} To enable screen reader optimized mode, use {1}", editorNotAccessibleMessage, toggleKeybindingLabel);
+                return nls.localizeWithPath('vs/editor/browser/controller/textAreaHandler', 'accessibilityOffAriaLabel', "{0} To enable screen reader optimized mode, use {1}", editorNotAccessibleMessage, toggleKeybindingLabel);
             }
             else if (runCommandKeybindingLabel) {
-                return nls.localize('accessibilityOffAriaLabelNoKb', "{0} To enable screen reader optimized mode, open the quick pick with {1} and run the command Toggle Screen Reader Accessibility Mode, which is currently not triggerable via keyboard.", editorNotAccessibleMessage, runCommandKeybindingLabel);
+                return nls.localizeWithPath('vs/editor/browser/controller/textAreaHandler', 'accessibilityOffAriaLabelNoKb', "{0} To enable screen reader optimized mode, open the quick pick with {1} and run the command Toggle Screen Reader Accessibility Mode, which is currently not triggerable via keyboard.", editorNotAccessibleMessage, runCommandKeybindingLabel);
             }
             else if (keybindingEditorKeybindingLabel) {
-                return nls.localize('accessibilityOffAriaLabelNoKbs', "{0} Please assign a keybinding for the command Toggle Screen Reader Accessibility Mode by accessing the keybindings editor with {1} and run it.", editorNotAccessibleMessage, keybindingEditorKeybindingLabel);
+                return nls.localizeWithPath('vs/editor/browser/controller/textAreaHandler', 'accessibilityOffAriaLabelNoKbs', "{0} Please assign a keybinding for the command Toggle Screen Reader Accessibility Mode by accessing the keybindings editor with {1} and run it.", editorNotAccessibleMessage, keybindingEditorKeybindingLabel);
             }
             else {
                 // SOS
@@ -549,6 +548,9 @@
     focusTextArea() {
         this._textAreaInput.focusTextArea();
     }
+    refreshFocusState() {
+        this._textAreaInput.refreshFocusState();
+    }
     getLastRenderData() {
         return this._lastRenderPosition;
     }
@@ -581,17 +583,15 @@
         }
     }
     prepareRender(ctx) {
-        var _a;
         this._primaryCursorPosition = new Position(this._selections[0].positionLineNumber, this._selections[0].positionColumn);
         this._primaryCursorVisibleRange = ctx.visibleRangeForPosition(this._primaryCursorPosition);
-        (_a = this._visibleTextArea) === null || _a === void 0 ? void 0 : _a.prepareRender(ctx);
+        this._visibleTextArea?.prepareRender(ctx);
     }
     render(ctx) {
         this._textAreaInput.writeScreenReaderContent('render');
         this._render();
     }
     _render() {
-        var _a;
         if (this._visibleTextArea) {
             // The text area is visible for composition reasons
             const visibleStart = this._visibleTextArea.visibleTextareaStart;
@@ -681,7 +681,7 @@
             // In case the textarea contains a word, we're going to try to align the textarea's cursor
             // with our cursor by scrolling the textarea as much as possible
             this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;
-            const lineCount = (_a = this._textAreaInput.textAreaState.newlineCountBeforeSelection) !== null && _a !== void 0 ? _a : this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
+            const lineCount = this._textAreaInput.textAreaState.newlineCountBeforeSelection ?? this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
             this.textArea.domNode.scrollTop = lineCount * this._lineHeight;
             return;
         }
diff -urN -x '*.map' a/vs/editor/browser/controller/textAreaInput.js b/vs/editor/browser/controller/textAreaInput.js
--- a/vs/editor/browser/controller/textAreaInput.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/controller/textAreaInput.js	2023-12-06 14:23:14.355854741 +0000
@@ -309,6 +309,10 @@
             }
         }));
     }
+    _initializeFromTest() {
+        this._hasFocus = true;
+        this._textAreaState = TextAreaState.readFromTextArea(this._textArea, null);
+    }
     _installSelectionChangeListener() {
         // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256
         // When using a Braille display, it is possible for users to reposition the
@@ -492,6 +496,7 @@
         super();
         this._actual = _actual;
         this.onKeyDown = this._register(new DomEmitter(this._actual, 'keydown')).event;
+        this.onKeyPress = this._register(new DomEmitter(this._actual, 'keypress')).event;
         this.onKeyUp = this._register(new DomEmitter(this._actual, 'keyup')).event;
         this.onCompositionStart = this._register(new DomEmitter(this._actual, 'compositionstart')).event;
         this.onCompositionUpdate = this._register(new DomEmitter(this._actual, 'compositionupdate')).event;
diff -urN -x '*.map' a/vs/editor/browser/controller/textAreaState.js b/vs/editor/browser/controller/textAreaState.js
--- a/vs/editor/browser/controller/textAreaState.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/controller/textAreaState.js	2023-12-06 14:23:14.355854741 +0000
@@ -54,21 +54,20 @@
         }
     }
     deduceEditorPosition(offset) {
-        var _a, _b, _c, _d, _e, _f, _g, _h;
         if (offset <= this.selectionStart) {
             const str = this.value.substring(offset, this.selectionStart);
-            return this._finishDeduceEditorPosition((_b = (_a = this.selection) === null || _a === void 0 ? void 0 : _a.getStartPosition()) !== null && _b !== void 0 ? _b : null, str, -1);
+            return this._finishDeduceEditorPosition(this.selection?.getStartPosition() ?? null, str, -1);
         }
         if (offset >= this.selectionEnd) {
             const str = this.value.substring(this.selectionEnd, offset);
-            return this._finishDeduceEditorPosition((_d = (_c = this.selection) === null || _c === void 0 ? void 0 : _c.getEndPosition()) !== null && _d !== void 0 ? _d : null, str, 1);
+            return this._finishDeduceEditorPosition(this.selection?.getEndPosition() ?? null, str, 1);
         }
         const str1 = this.value.substring(this.selectionStart, offset);
         if (str1.indexOf(String.fromCharCode(8230)) === -1) {
-            return this._finishDeduceEditorPosition((_f = (_e = this.selection) === null || _e === void 0 ? void 0 : _e.getStartPosition()) !== null && _f !== void 0 ? _f : null, str1, 1);
+            return this._finishDeduceEditorPosition(this.selection?.getStartPosition() ?? null, str1, 1);
         }
         const str2 = this.value.substring(offset, this.selectionEnd);
-        return this._finishDeduceEditorPosition((_h = (_g = this.selection) === null || _g === void 0 ? void 0 : _g.getEndPosition()) !== null && _h !== void 0 ? _h : null, str2, -1);
+        return this._finishDeduceEditorPosition(this.selection?.getEndPosition() ?? null, str2, -1);
     }
     _finishDeduceEditorPosition(anchor, deltaText, signum) {
         let lineFeedCnt = 0;
diff -urN -x '*.map' a/vs/editor/browser/coreCommands.js b/vs/editor/browser/coreCommands.js
--- a/vs/editor/browser/coreCommands.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/coreCommands.js	2023-12-06 14:23:14.355854741 +0000
@@ -857,7 +857,7 @@
                         type: 'object',
                         properties: {
                             'sticky': {
-                                description: nls.localize('stickydesc', "Stick to the end even when going to longer lines"),
+                                description: nls.localizeWithPath('vs/editor/browser/coreCommands', 'stickydesc', "Stick to the end even when going to longer lines"),
                                 type: 'boolean',
                                 default: false
                             }
@@ -885,7 +885,7 @@
                         type: 'object',
                         properties: {
                             'sticky': {
-                                description: nls.localize('stickydesc', "Stick to the end even when going to longer lines"),
+                                description: nls.localizeWithPath('vs/editor/browser/coreCommands', 'stickydesc', "Stick to the end even when going to longer lines"),
                                 type: 'boolean',
                                 default: false
                             }
@@ -1433,7 +1433,7 @@
                 viewModel.getPrimaryCursorState()
             ]);
             viewModel.revealPrimaryCursor(args.source, true);
-            status(nls.localize('removedCursor', "Removed secondary cursors"));
+            status(nls.localizeWithPath('vs/editor/browser/coreCommands', 'removedCursor', "Removed secondary cursors"));
         }
     });
     CoreNavigationCommands.RevealLine = registerEditorCommand(new class extends CoreEditorCommand {
diff -urN -x '*.map' a/vs/editor/browser/dnd.js b/vs/editor/browser/dnd.js
--- a/vs/editor/browser/dnd.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/dnd.js	2023-12-06 14:23:14.355854741 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { DataTransfers } from '../../base/browser/dnd.js';
 import { createFileDataTransferItem, createStringDataTransferItem, UriList, VSDataTransfer } from '../../base/common/dataTransfer.js';
 import { Mimes } from '../../base/common/mime.js';
@@ -35,9 +26,9 @@
 }
 function createFileDataTransferItemFromFile(file) {
     const uri = file.path ? URI.parse(file.path) : undefined;
-    return createFileDataTransferItem(file.name, uri, () => __awaiter(this, void 0, void 0, function* () {
-        return new Uint8Array(yield file.arrayBuffer());
-    }));
+    return createFileDataTransferItem(file.name, uri, async () => {
+        return new Uint8Array(await file.arrayBuffer());
+    });
 }
 const INTERNAL_DND_MIME_TYPES = Object.freeze([
     CodeDataTransfers.EDITORS,
@@ -68,7 +59,7 @@
                             editorData.push(URI.parse(file.name, true).toString());
                         }
                     }
-                    catch (_a) {
+                    catch {
                         // Parsing failed. Leave out from list
                     }
                 }
diff -urN -x '*.map' a/vs/editor/browser/editorBrowser.js b/vs/editor/browser/editorBrowser.js
--- a/vs/editor/browser/editorBrowser.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/editorBrowser.js	2023-12-06 14:23:14.355854741 +0000
@@ -48,3 +48,12 @@
     }
     return null;
 }
+/**
+ *@internal
+ */
+export function getIEditor(thing) {
+    if (isCodeEditor(thing) || isDiffEditor(thing)) {
+        return thing;
+    }
+    return null;
+}
diff -urN -x '*.map' a/vs/editor/browser/editorExtensions.js b/vs/editor/browser/editorExtensions.js
--- a/vs/editor/browser/editorExtensions.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/editorExtensions.js	2023-12-06 14:23:14.355854741 +0000
@@ -168,7 +168,7 @@
         }
         return editor.invokeWithinContext((editorAccessor) => {
             const kbService = editorAccessor.get(IContextKeyService);
-            if (!kbService.contextMatchesRules(precondition !== null && precondition !== void 0 ? precondition : undefined)) {
+            if (!kbService.contextMatchesRules(precondition ?? undefined)) {
                 // precondition does not hold
                 return;
             }
@@ -270,12 +270,11 @@
         }
         // precondition does hold
         return editor.invokeWithinContext((editorAccessor) => {
-            var _a, _b;
             const kbService = editorAccessor.get(IContextKeyService);
             const logService = editorAccessor.get(ILogService);
-            const enabled = kbService.contextMatchesRules((_a = this.desc.precondition) !== null && _a !== void 0 ? _a : undefined);
+            const enabled = kbService.contextMatchesRules(this.desc.precondition ?? undefined);
             if (!enabled) {
-                logService.debug(`[EditorAction2] NOT running command because its precondition is FALSE`, this.desc.id, (_b = this.desc.precondition) === null || _b === void 0 ? void 0 : _b.serialize());
+                logService.debug(`[EditorAction2] NOT running command because its precondition is FALSE`, this.desc.id, this.desc.precondition?.serialize());
                 return;
             }
             return this.runEditorCommand(editorAccessor, editor, ...args);
@@ -333,6 +332,13 @@
 export function registerEditorContribution(id, ctor, instantiation) {
     EditorContributionRegistry.INSTANCE.registerEditorContribution(id, ctor, instantiation);
 }
+/**
+ * Registers a diff editor contribution. Diff editor contributions have a lifecycle which
+ * is bound to a specific diff editor instance.
+ */
+export function registerDiffEditorContribution(id, ctor) {
+    EditorContributionRegistry.INSTANCE.registerDiffEditorContribution(id, ctor);
+}
 export var EditorExtensionsRegistry;
 (function (EditorExtensionsRegistry) {
     function getEditorCommand(commandId) {
@@ -373,6 +379,9 @@
     getEditorContributions() {
         return this.editorContributions.slice(0);
     }
+    registerDiffEditorContribution(id, ctor) {
+        this.diffEditorContributions.push({ id, ctor: ctor });
+    }
     getDiffEditorContributions() {
         return this.diffEditorContributions.slice(0);
     }
@@ -407,12 +416,12 @@
     menuOpts: [{
             menuId: MenuId.MenubarEditMenu,
             group: '1_do',
-            title: nls.localize({ key: 'miUndo', comment: ['&& denotes a mnemonic'] }, "&&Undo"),
+            title: nls.localizeWithPath('vs/editor/browser/editorExtensions', { key: 'miUndo', comment: ['&& denotes a mnemonic'] }, "&&Undo"),
             order: 1
         }, {
             menuId: MenuId.CommandPalette,
             group: '',
-            title: nls.localize('undo', "Undo"),
+            title: nls.localizeWithPath('vs/editor/browser/editorExtensions', 'undo', "Undo"),
             order: 1
         }]
 }));
@@ -429,12 +438,12 @@
     menuOpts: [{
             menuId: MenuId.MenubarEditMenu,
             group: '1_do',
-            title: nls.localize({ key: 'miRedo', comment: ['&& denotes a mnemonic'] }, "&&Redo"),
+            title: nls.localizeWithPath('vs/editor/browser/editorExtensions', { key: 'miRedo', comment: ['&& denotes a mnemonic'] }, "&&Redo"),
             order: 2
         }, {
             menuId: MenuId.CommandPalette,
             group: '',
-            title: nls.localize('redo', "Redo"),
+            title: nls.localizeWithPath('vs/editor/browser/editorExtensions', 'redo', "Redo"),
             order: 1
         }]
 }));
@@ -450,12 +459,12 @@
     menuOpts: [{
             menuId: MenuId.MenubarSelectionMenu,
             group: '1_basic',
-            title: nls.localize({ key: 'miSelectAll', comment: ['&& denotes a mnemonic'] }, "&&Select All"),
+            title: nls.localizeWithPath('vs/editor/browser/editorExtensions', { key: 'miSelectAll', comment: ['&& denotes a mnemonic'] }, "&&Select All"),
             order: 1
         }, {
             menuId: MenuId.CommandPalette,
             group: '',
-            title: nls.localize('selectAll', "Select All"),
+            title: nls.localizeWithPath('vs/editor/browser/editorExtensions', 'selectAll', "Select All"),
             order: 1
         }]
 }));
diff -urN -x '*.map' a/vs/editor/browser/services/abstractCodeEditorService.js b/vs/editor/browser/services/abstractCodeEditorService.js
--- a/vs/editor/browser/services/abstractCodeEditorService.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/services/abstractCodeEditorService.js	2023-12-06 14:23:14.355854741 +0000
@@ -1,3 +1,7 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
     var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
     if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
@@ -7,35 +11,39 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
+import * as dom from '../../../base/browser/dom.js';
 import { Emitter } from '../../../base/common/event.js';
-import { Disposable, toDisposable } from '../../../base/common/lifecycle.js';
+import { DisposableStore, Disposable, toDisposable } from '../../../base/common/lifecycle.js';
 import { LinkedList } from '../../../base/common/linkedList.js';
+import * as strings from '../../../base/common/strings.js';
+import { URI } from '../../../base/common/uri.js';
+import { isThemeColor } from '../../common/editorCommon.js';
+import { OverviewRulerLane } from '../../common/model.js';
 import { IThemeService } from '../../../platform/theme/common/themeService.js';
 let AbstractCodeEditorService = class AbstractCodeEditorService extends Disposable {
     constructor(_themeService) {
         super();
         this._themeService = _themeService;
         this._onWillCreateCodeEditor = this._register(new Emitter());
+        this.onWillCreateCodeEditor = this._onWillCreateCodeEditor.event;
         this._onCodeEditorAdd = this._register(new Emitter());
         this.onCodeEditorAdd = this._onCodeEditorAdd.event;
         this._onCodeEditorRemove = this._register(new Emitter());
         this.onCodeEditorRemove = this._onCodeEditorRemove.event;
         this._onWillCreateDiffEditor = this._register(new Emitter());
+        this.onWillCreateDiffEditor = this._onWillCreateDiffEditor.event;
         this._onDiffEditorAdd = this._register(new Emitter());
         this.onDiffEditorAdd = this._onDiffEditorAdd.event;
         this._onDiffEditorRemove = this._register(new Emitter());
         this.onDiffEditorRemove = this._onDiffEditorRemove.event;
+        this._onDidChangeTransientModelProperty = this._register(new Emitter());
+        this.onDidChangeTransientModelProperty = this._onDidChangeTransientModelProperty.event;
+        this._onDecorationTypeRegistered = this._register(new Emitter());
+        this.onDecorationTypeRegistered = this._onDecorationTypeRegistered.event;
         this._decorationOptionProviders = new Map();
+        this._editorStyleSheets = new Map();
         this._codeEditorOpenHandlers = new LinkedList();
+        this._transientWatchers = {};
         this._modelProperties = new Map();
         this._codeEditors = Object.create(null);
         this._diffEditors = Object.create(null);
@@ -63,6 +71,11 @@
         this._diffEditors[editor.getId()] = editor;
         this._onDiffEditorAdd.fire(editor);
     }
+    removeDiffEditor(editor) {
+        if (delete this._diffEditors[editor.getId()]) {
+            this._onDiffEditorRemove.fire(editor);
+        }
+    }
     listDiffEditors() {
         return Object.keys(this._diffEditors).map(id => this._diffEditors[id]);
     }
@@ -80,6 +93,62 @@
         }
         return editorWithWidgetFocus;
     }
+    _getOrCreateGlobalStyleSheet() {
+        if (!this._globalStyleSheet) {
+            this._globalStyleSheet = this._createGlobalStyleSheet();
+        }
+        return this._globalStyleSheet;
+    }
+    _createGlobalStyleSheet() {
+        return new GlobalStyleSheet(dom.createStyleSheet());
+    }
+    _getOrCreateStyleSheet(editor) {
+        if (!editor) {
+            return this._getOrCreateGlobalStyleSheet();
+        }
+        const domNode = editor.getContainerDomNode();
+        if (!dom.isInShadowDOM(domNode)) {
+            return this._getOrCreateGlobalStyleSheet();
+        }
+        const editorId = editor.getId();
+        if (!this._editorStyleSheets.has(editorId)) {
+            const refCountedStyleSheet = new RefCountedStyleSheet(this, editorId, dom.createStyleSheet(domNode));
+            this._editorStyleSheets.set(editorId, refCountedStyleSheet);
+        }
+        return this._editorStyleSheets.get(editorId);
+    }
+    _removeEditorStyleSheets(editorId) {
+        this._editorStyleSheets.delete(editorId);
+    }
+    registerDecorationType(description, key, options, parentTypeKey, editor) {
+        let provider = this._decorationOptionProviders.get(key);
+        if (!provider) {
+            const styleSheet = this._getOrCreateStyleSheet(editor);
+            const providerArgs = {
+                styleSheet: styleSheet,
+                key: key,
+                parentTypeKey: parentTypeKey,
+                options: options || Object.create(null)
+            };
+            if (!parentTypeKey) {
+                provider = new DecorationTypeOptionsProvider(description, this._themeService, styleSheet, providerArgs);
+            }
+            else {
+                provider = new DecorationSubTypeOptionsProvider(this._themeService, styleSheet, providerArgs);
+            }
+            this._decorationOptionProviders.set(key, provider);
+            this._onDecorationTypeRegistered.fire(key);
+        }
+        provider.refCount++;
+        return {
+            dispose: () => {
+                this.removeDecorationType(key);
+            }
+        };
+    }
+    listDecorationTypes() {
+        return Array.from(this._decorationOptionProviders.keys());
+    }
     removeDecorationType(key) {
         const provider = this._decorationOptionProviders.get(key);
         if (provider) {
@@ -91,6 +160,20 @@
             }
         }
     }
+    resolveDecorationOptions(decorationTypeKey, writable) {
+        const provider = this._decorationOptionProviders.get(decorationTypeKey);
+        if (!provider) {
+            throw new Error('Unknown decoration type key: ' + decorationTypeKey);
+        }
+        return provider.getOptions(this, writable);
+    }
+    resolveDecorationCSSRules(decorationTypeKey) {
+        const provider = this._decorationOptionProviders.get(decorationTypeKey);
+        if (!provider) {
+            return null;
+        }
+        return provider.resolveDecorationCSSRules();
+    }
     setModelProperty(resource, key, value) {
         const key1 = resource.toString();
         let dest;
@@ -111,16 +194,47 @@
         }
         return undefined;
     }
-    openCodeEditor(input, source, sideBySide) {
-        return __awaiter(this, void 0, void 0, function* () {
-            for (const handler of this._codeEditorOpenHandlers) {
-                const candidate = yield handler(input, source, sideBySide);
-                if (candidate !== null) {
-                    return candidate;
-                }
+    setTransientModelProperty(model, key, value) {
+        const uri = model.uri.toString();
+        let w;
+        if (this._transientWatchers.hasOwnProperty(uri)) {
+            w = this._transientWatchers[uri];
+        }
+        else {
+            w = new ModelTransientSettingWatcher(uri, model, this);
+            this._transientWatchers[uri] = w;
+        }
+        const previousValue = w.get(key);
+        if (previousValue !== value) {
+            w.set(key, value);
+            this._onDidChangeTransientModelProperty.fire(model);
+        }
+    }
+    getTransientModelProperty(model, key) {
+        const uri = model.uri.toString();
+        if (!this._transientWatchers.hasOwnProperty(uri)) {
+            return undefined;
+        }
+        return this._transientWatchers[uri].get(key);
+    }
+    getTransientModelProperties(model) {
+        const uri = model.uri.toString();
+        if (!this._transientWatchers.hasOwnProperty(uri)) {
+            return undefined;
+        }
+        return this._transientWatchers[uri].keys().map(key => [key, this._transientWatchers[uri].get(key)]);
+    }
+    _removeWatcher(w) {
+        delete this._transientWatchers[w.uri];
+    }
+    async openCodeEditor(input, source, sideBySide) {
+        for (const handler of this._codeEditorOpenHandlers) {
+            const candidate = await handler(input, source, sideBySide);
+            if (candidate !== null) {
+                return candidate;
             }
-            return null;
-        });
+        }
+        return null;
     }
     registerCodeEditorOpenHandler(handler) {
         const rm = this._codeEditorOpenHandlers.unshift(handler);
@@ -131,8 +245,440 @@
     __param(0, IThemeService)
 ], AbstractCodeEditorService);
 export { AbstractCodeEditorService };
+export class ModelTransientSettingWatcher {
+    constructor(uri, model, owner) {
+        this.uri = uri;
+        this._values = {};
+        model.onWillDispose(() => owner._removeWatcher(this));
+    }
+    set(key, value) {
+        this._values[key] = value;
+    }
+    get(key) {
+        return this._values[key];
+    }
+    keys() {
+        return Object.keys(this._values);
+    }
+}
+class RefCountedStyleSheet {
+    get sheet() {
+        return this._styleSheet.sheet;
+    }
+    constructor(parent, editorId, styleSheet) {
+        this._parent = parent;
+        this._editorId = editorId;
+        this._styleSheet = styleSheet;
+        this._refCount = 0;
+    }
+    ref() {
+        this._refCount++;
+    }
+    unref() {
+        this._refCount--;
+        if (this._refCount === 0) {
+            this._styleSheet.parentNode?.removeChild(this._styleSheet);
+            this._parent._removeEditorStyleSheets(this._editorId);
+        }
+    }
+    insertRule(rule, index) {
+        const sheet = this._styleSheet.sheet;
+        sheet.insertRule(rule, index);
+    }
+    removeRulesContainingSelector(ruleName) {
+        dom.removeCSSRulesContainingSelector(ruleName, this._styleSheet);
+    }
+}
 export class GlobalStyleSheet {
+    get sheet() {
+        return this._styleSheet.sheet;
+    }
     constructor(styleSheet) {
         this._styleSheet = styleSheet;
     }
+    ref() {
+    }
+    unref() {
+    }
+    insertRule(rule, index) {
+        const sheet = this._styleSheet.sheet;
+        sheet.insertRule(rule, index);
+    }
+    removeRulesContainingSelector(ruleName) {
+        dom.removeCSSRulesContainingSelector(ruleName, this._styleSheet);
+    }
+}
+class DecorationSubTypeOptionsProvider {
+    constructor(themeService, styleSheet, providerArgs) {
+        this._styleSheet = styleSheet;
+        this._styleSheet.ref();
+        this._parentTypeKey = providerArgs.parentTypeKey;
+        this.refCount = 0;
+        this._beforeContentRules = new DecorationCSSRules(3 /* ModelDecorationCSSRuleType.BeforeContentClassName */, providerArgs, themeService);
+        this._afterContentRules = new DecorationCSSRules(4 /* ModelDecorationCSSRuleType.AfterContentClassName */, providerArgs, themeService);
+    }
+    getOptions(codeEditorService, writable) {
+        const options = codeEditorService.resolveDecorationOptions(this._parentTypeKey, true);
+        if (this._beforeContentRules) {
+            options.beforeContentClassName = this._beforeContentRules.className;
+        }
+        if (this._afterContentRules) {
+            options.afterContentClassName = this._afterContentRules.className;
+        }
+        return options;
+    }
+    resolveDecorationCSSRules() {
+        return this._styleSheet.sheet.cssRules;
+    }
+    dispose() {
+        if (this._beforeContentRules) {
+            this._beforeContentRules.dispose();
+            this._beforeContentRules = null;
+        }
+        if (this._afterContentRules) {
+            this._afterContentRules.dispose();
+            this._afterContentRules = null;
+        }
+        this._styleSheet.unref();
+    }
+}
+class DecorationTypeOptionsProvider {
+    constructor(description, themeService, styleSheet, providerArgs) {
+        this._disposables = new DisposableStore();
+        this.description = description;
+        this._styleSheet = styleSheet;
+        this._styleSheet.ref();
+        this.refCount = 0;
+        const createCSSRules = (type) => {
+            const rules = new DecorationCSSRules(type, providerArgs, themeService);
+            this._disposables.add(rules);
+            if (rules.hasContent) {
+                return rules.className;
+            }
+            return undefined;
+        };
+        const createInlineCSSRules = (type) => {
+            const rules = new DecorationCSSRules(type, providerArgs, themeService);
+            this._disposables.add(rules);
+            if (rules.hasContent) {
+                return { className: rules.className, hasLetterSpacing: rules.hasLetterSpacing };
+            }
+            return null;
+        };
+        this.className = createCSSRules(0 /* ModelDecorationCSSRuleType.ClassName */);
+        const inlineData = createInlineCSSRules(1 /* ModelDecorationCSSRuleType.InlineClassName */);
+        if (inlineData) {
+            this.inlineClassName = inlineData.className;
+            this.inlineClassNameAffectsLetterSpacing = inlineData.hasLetterSpacing;
+        }
+        this.beforeContentClassName = createCSSRules(3 /* ModelDecorationCSSRuleType.BeforeContentClassName */);
+        this.afterContentClassName = createCSSRules(4 /* ModelDecorationCSSRuleType.AfterContentClassName */);
+        if (providerArgs.options.beforeInjectedText && providerArgs.options.beforeInjectedText.contentText) {
+            const beforeInlineData = createInlineCSSRules(5 /* ModelDecorationCSSRuleType.BeforeInjectedTextClassName */);
+            this.beforeInjectedText = {
+                content: providerArgs.options.beforeInjectedText.contentText,
+                inlineClassName: beforeInlineData?.className,
+                inlineClassNameAffectsLetterSpacing: beforeInlineData?.hasLetterSpacing || providerArgs.options.beforeInjectedText.affectsLetterSpacing
+            };
+        }
+        if (providerArgs.options.afterInjectedText && providerArgs.options.afterInjectedText.contentText) {
+            const afterInlineData = createInlineCSSRules(6 /* ModelDecorationCSSRuleType.AfterInjectedTextClassName */);
+            this.afterInjectedText = {
+                content: providerArgs.options.afterInjectedText.contentText,
+                inlineClassName: afterInlineData?.className,
+                inlineClassNameAffectsLetterSpacing: afterInlineData?.hasLetterSpacing || providerArgs.options.afterInjectedText.affectsLetterSpacing
+            };
+        }
+        this.glyphMarginClassName = createCSSRules(2 /* ModelDecorationCSSRuleType.GlyphMarginClassName */);
+        const options = providerArgs.options;
+        this.isWholeLine = Boolean(options.isWholeLine);
+        this.stickiness = options.rangeBehavior;
+        const lightOverviewRulerColor = options.light && options.light.overviewRulerColor || options.overviewRulerColor;
+        const darkOverviewRulerColor = options.dark && options.dark.overviewRulerColor || options.overviewRulerColor;
+        if (typeof lightOverviewRulerColor !== 'undefined'
+            || typeof darkOverviewRulerColor !== 'undefined') {
+            this.overviewRuler = {
+                color: lightOverviewRulerColor || darkOverviewRulerColor,
+                darkColor: darkOverviewRulerColor || lightOverviewRulerColor,
+                position: options.overviewRulerLane || OverviewRulerLane.Center
+            };
+        }
+    }
+    getOptions(codeEditorService, writable) {
+        if (!writable) {
+            return this;
+        }
+        return {
+            description: this.description,
+            inlineClassName: this.inlineClassName,
+            beforeContentClassName: this.beforeContentClassName,
+            afterContentClassName: this.afterContentClassName,
+            className: this.className,
+            glyphMarginClassName: this.glyphMarginClassName,
+            isWholeLine: this.isWholeLine,
+            overviewRuler: this.overviewRuler,
+            stickiness: this.stickiness,
+            before: this.beforeInjectedText,
+            after: this.afterInjectedText
+        };
+    }
+    resolveDecorationCSSRules() {
+        return this._styleSheet.sheet.rules;
+    }
+    dispose() {
+        this._disposables.dispose();
+        this._styleSheet.unref();
+    }
+}
+export const _CSS_MAP = {
+    color: 'color:{0} !important;',
+    opacity: 'opacity:{0};',
+    backgroundColor: 'background-color:{0};',
+    outline: 'outline:{0};',
+    outlineColor: 'outline-color:{0};',
+    outlineStyle: 'outline-style:{0};',
+    outlineWidth: 'outline-width:{0};',
+    border: 'border:{0};',
+    borderColor: 'border-color:{0};',
+    borderRadius: 'border-radius:{0};',
+    borderSpacing: 'border-spacing:{0};',
+    borderStyle: 'border-style:{0};',
+    borderWidth: 'border-width:{0};',
+    fontStyle: 'font-style:{0};',
+    fontWeight: 'font-weight:{0};',
+    fontSize: 'font-size:{0};',
+    fontFamily: 'font-family:{0};',
+    textDecoration: 'text-decoration:{0};',
+    cursor: 'cursor:{0};',
+    letterSpacing: 'letter-spacing:{0};',
+    gutterIconPath: 'background:{0} center center no-repeat;',
+    gutterIconSize: 'background-size:{0};',
+    contentText: 'content:\'{0}\';',
+    contentIconPath: 'content:{0};',
+    margin: 'margin:{0};',
+    padding: 'padding:{0};',
+    width: 'width:{0};',
+    height: 'height:{0};',
+    verticalAlign: 'vertical-align:{0};',
+};
+class DecorationCSSRules {
+    constructor(ruleType, providerArgs, themeService) {
+        this._theme = themeService.getColorTheme();
+        this._ruleType = ruleType;
+        this._providerArgs = providerArgs;
+        this._usesThemeColors = false;
+        this._hasContent = false;
+        this._hasLetterSpacing = false;
+        let className = CSSNameHelper.getClassName(this._providerArgs.key, ruleType);
+        if (this._providerArgs.parentTypeKey) {
+            className = className + ' ' + CSSNameHelper.getClassName(this._providerArgs.parentTypeKey, ruleType);
+        }
+        this._className = className;
+        this._unThemedSelector = CSSNameHelper.getSelector(this._providerArgs.key, this._providerArgs.parentTypeKey, ruleType);
+        this._buildCSS();
+        if (this._usesThemeColors) {
+            this._themeListener = themeService.onDidColorThemeChange(theme => {
+                this._theme = themeService.getColorTheme();
+                this._removeCSS();
+                this._buildCSS();
+            });
+        }
+        else {
+            this._themeListener = null;
+        }
+    }
+    dispose() {
+        if (this._hasContent) {
+            this._removeCSS();
+            this._hasContent = false;
+        }
+        if (this._themeListener) {
+            this._themeListener.dispose();
+            this._themeListener = null;
+        }
+    }
+    get hasContent() {
+        return this._hasContent;
+    }
+    get hasLetterSpacing() {
+        return this._hasLetterSpacing;
+    }
+    get className() {
+        return this._className;
+    }
+    _buildCSS() {
+        const options = this._providerArgs.options;
+        let unthemedCSS, lightCSS, darkCSS;
+        switch (this._ruleType) {
+            case 0 /* ModelDecorationCSSRuleType.ClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationClassName(options);
+                lightCSS = this.getCSSTextForModelDecorationClassName(options.light);
+                darkCSS = this.getCSSTextForModelDecorationClassName(options.dark);
+                break;
+            case 1 /* ModelDecorationCSSRuleType.InlineClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationInlineClassName(options);
+                lightCSS = this.getCSSTextForModelDecorationInlineClassName(options.light);
+                darkCSS = this.getCSSTextForModelDecorationInlineClassName(options.dark);
+                break;
+            case 2 /* ModelDecorationCSSRuleType.GlyphMarginClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options);
+                lightCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options.light);
+                darkCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options.dark);
+                break;
+            case 3 /* ModelDecorationCSSRuleType.BeforeContentClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.before);
+                lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.before);
+                darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.before);
+                break;
+            case 4 /* ModelDecorationCSSRuleType.AfterContentClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.after);
+                lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.after);
+                darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.after);
+                break;
+            case 5 /* ModelDecorationCSSRuleType.BeforeInjectedTextClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.beforeInjectedText);
+                lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.beforeInjectedText);
+                darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.beforeInjectedText);
+                break;
+            case 6 /* ModelDecorationCSSRuleType.AfterInjectedTextClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.afterInjectedText);
+                lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.afterInjectedText);
+                darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.afterInjectedText);
+                break;
+            default:
+                throw new Error('Unknown rule type: ' + this._ruleType);
+        }
+        const sheet = this._providerArgs.styleSheet;
+        let hasContent = false;
+        if (unthemedCSS.length > 0) {
+            sheet.insertRule(`${this._unThemedSelector} {${unthemedCSS}}`, 0);
+            hasContent = true;
+        }
+        if (lightCSS.length > 0) {
+            sheet.insertRule(`.vs${this._unThemedSelector}, .hc-light${this._unThemedSelector} {${lightCSS}}`, 0);
+            hasContent = true;
+        }
+        if (darkCSS.length > 0) {
+            sheet.insertRule(`.vs-dark${this._unThemedSelector}, .hc-black${this._unThemedSelector} {${darkCSS}}`, 0);
+            hasContent = true;
+        }
+        this._hasContent = hasContent;
+    }
+    _removeCSS() {
+        this._providerArgs.styleSheet.removeRulesContainingSelector(this._unThemedSelector);
+    }
+    /**
+     * Build the CSS for decorations styled via `className`.
+     */
+    getCSSTextForModelDecorationClassName(opts) {
+        if (!opts) {
+            return '';
+        }
+        const cssTextArr = [];
+        this.collectCSSText(opts, ['backgroundColor'], cssTextArr);
+        this.collectCSSText(opts, ['outline', 'outlineColor', 'outlineStyle', 'outlineWidth'], cssTextArr);
+        this.collectBorderSettingsCSSText(opts, cssTextArr);
+        return cssTextArr.join('');
+    }
+    /**
+     * Build the CSS for decorations styled via `inlineClassName`.
+     */
+    getCSSTextForModelDecorationInlineClassName(opts) {
+        if (!opts) {
+            return '';
+        }
+        const cssTextArr = [];
+        this.collectCSSText(opts, ['fontStyle', 'fontWeight', 'textDecoration', 'cursor', 'color', 'opacity', 'letterSpacing'], cssTextArr);
+        if (opts.letterSpacing) {
+            this._hasLetterSpacing = true;
+        }
+        return cssTextArr.join('');
+    }
+    /**
+     * Build the CSS for decorations styled before or after content.
+     */
+    getCSSTextForModelDecorationContentClassName(opts) {
+        if (!opts) {
+            return '';
+        }
+        const cssTextArr = [];
+        if (typeof opts !== 'undefined') {
+            this.collectBorderSettingsCSSText(opts, cssTextArr);
+            if (typeof opts.contentIconPath !== 'undefined') {
+                cssTextArr.push(strings.format(_CSS_MAP.contentIconPath, dom.asCSSUrl(URI.revive(opts.contentIconPath))));
+            }
+            if (typeof opts.contentText === 'string') {
+                const truncated = opts.contentText.match(/^.*$/m)[0]; // only take first line
+                const escaped = truncated.replace(/['\\]/g, '\\$&');
+                cssTextArr.push(strings.format(_CSS_MAP.contentText, escaped));
+            }
+            this.collectCSSText(opts, ['verticalAlign', 'fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'textDecoration', 'color', 'opacity', 'backgroundColor', 'margin', 'padding'], cssTextArr);
+            if (this.collectCSSText(opts, ['width', 'height'], cssTextArr)) {
+                cssTextArr.push('display:inline-block;');
+            }
+        }
+        return cssTextArr.join('');
+    }
+    /**
+     * Build the CSS for decorations styled via `glyphMarginClassName`.
+     */
+    getCSSTextForModelDecorationGlyphMarginClassName(opts) {
+        if (!opts) {
+            return '';
+        }
+        const cssTextArr = [];
+        if (typeof opts.gutterIconPath !== 'undefined') {
+            cssTextArr.push(strings.format(_CSS_MAP.gutterIconPath, dom.asCSSUrl(URI.revive(opts.gutterIconPath))));
+            if (typeof opts.gutterIconSize !== 'undefined') {
+                cssTextArr.push(strings.format(_CSS_MAP.gutterIconSize, opts.gutterIconSize));
+            }
+        }
+        return cssTextArr.join('');
+    }
+    collectBorderSettingsCSSText(opts, cssTextArr) {
+        if (this.collectCSSText(opts, ['border', 'borderColor', 'borderRadius', 'borderSpacing', 'borderStyle', 'borderWidth'], cssTextArr)) {
+            cssTextArr.push(strings.format('box-sizing: border-box;'));
+            return true;
+        }
+        return false;
+    }
+    collectCSSText(opts, properties, cssTextArr) {
+        const lenBefore = cssTextArr.length;
+        for (const property of properties) {
+            const value = this.resolveValue(opts[property]);
+            if (typeof value === 'string') {
+                cssTextArr.push(strings.format(_CSS_MAP[property], value));
+            }
+        }
+        return cssTextArr.length !== lenBefore;
+    }
+    resolveValue(value) {
+        if (isThemeColor(value)) {
+            this._usesThemeColors = true;
+            const color = this._theme.getColor(value.id);
+            if (color) {
+                return color.toString();
+            }
+            return 'transparent';
+        }
+        return value;
+    }
+}
+class CSSNameHelper {
+    static getClassName(key, type) {
+        return 'ced-' + key + '-' + type;
+    }
+    static getSelector(key, parentKey, ruleType) {
+        let selector = '.monaco-editor .' + this.getClassName(key, ruleType);
+        if (parentKey) {
+            selector = selector + '.' + this.getClassName(parentKey, ruleType);
+        }
+        if (ruleType === 3 /* ModelDecorationCSSRuleType.BeforeContentClassName */) {
+            selector += '::before';
+        }
+        else if (ruleType === 4 /* ModelDecorationCSSRuleType.AfterContentClassName */) {
+            selector += '::after';
+        }
+        return selector;
+    }
 }
diff -urN -x '*.map' a/vs/editor/browser/services/editorWorkerService.js b/vs/editor/browser/services/editorWorkerService.js
--- a/vs/editor/browser/services/editorWorkerService.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/services/editorWorkerService.js	2023-12-06 14:23:14.355854741 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { IntervalTimer, timeout } from '../../../base/common/async.js';
 import { Disposable, dispose, toDisposable, DisposableStore } from '../../../base/common/lifecycle.js';
 import { SimpleWorkerClient, logOnceWebWorkerWarning } from '../../../base/common/worker/simpleWorker.js';
@@ -32,7 +23,7 @@
 import { isNonEmptyArray } from '../../../base/common/arrays.js';
 import { ILogService } from '../../../platform/log/common/log.js';
 import { StopWatch } from '../../../base/common/stopwatch.js';
-import { canceled } from '../../../base/common/errors.js';
+import { canceled, onUnexpectedError } from '../../../base/common/errors.js';
 import { ILanguageFeaturesService } from '../../common/services/languageFeatures.js';
 import { MovedText } from '../../common/diff/linesDiffComputer.js';
 import { DetailedLineRangeMapping, RangeMapping, LineRangeMapping } from '../../common/diff/rangeMapping.js';
@@ -83,27 +74,28 @@
     computedUnicodeHighlights(uri, options, range) {
         return this._workerManager.withWorker().then(client => client.computedUnicodeHighlights(uri, options, range));
     }
-    computeDiff(original, modified, options, algorithm) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const result = yield this._workerManager.withWorker().then(client => client.computeDiff(original, modified, options, algorithm));
-            if (!result) {
-                return null;
-            }
-            // Convert from space efficient JSON data to rich objects.
-            const diff = {
-                identical: result.identical,
-                quitEarly: result.quitEarly,
-                changes: toLineRangeMappings(result.changes),
-                moves: result.moves.map(m => new MovedText(new LineRangeMapping(new LineRange(m[0], m[1]), new LineRange(m[2], m[3])), toLineRangeMappings(m[4])))
-            };
-            return diff;
-            function toLineRangeMappings(changes) {
-                return changes.map((c) => {
-                    var _a;
-                    return new DetailedLineRangeMapping(new LineRange(c[0], c[1]), new LineRange(c[2], c[3]), (_a = c[4]) === null || _a === void 0 ? void 0 : _a.map((c) => new RangeMapping(new Range(c[0], c[1], c[2], c[3]), new Range(c[4], c[5], c[6], c[7]))));
-                });
-            }
-        });
+    async computeDiff(original, modified, options, algorithm) {
+        const result = await this._workerManager.withWorker().then(client => client.computeDiff(original, modified, options, algorithm));
+        if (!result) {
+            return null;
+        }
+        // Convert from space efficient JSON data to rich objects.
+        const diff = {
+            identical: result.identical,
+            quitEarly: result.quitEarly,
+            changes: toLineRangeMappings(result.changes),
+            moves: result.moves.map(m => new MovedText(new LineRangeMapping(new LineRange(m[0], m[1]), new LineRange(m[2], m[3])), toLineRangeMappings(m[4])))
+        };
+        return diff;
+        function toLineRangeMappings(changes) {
+            return changes.map((c) => new DetailedLineRangeMapping(new LineRange(c[0], c[1]), new LineRange(c[2], c[3]), c[4]?.map((c) => new RangeMapping(new Range(c[0], c[1], c[2], c[3]), new Range(c[4], c[5], c[6], c[7])))));
+        }
+    }
+    canComputeDirtyDiff(original, modified) {
+        return (canSyncModel(this._modelService, original) && canSyncModel(this._modelService, modified));
+    }
+    computeDirtyDiff(original, modified, ignoreTrimWhitespace) {
+        return this._workerManager.withWorker().then(client => client.computeDirtyDiff(original, modified, ignoreTrimWhitespace));
     }
     computeMoreMinimalEdits(resource, edits, pretty = false) {
         if (isNonEmptyArray(edits)) {
@@ -119,6 +111,24 @@
             return Promise.resolve(undefined);
         }
     }
+    computeHumanReadableDiff(resource, edits) {
+        if (isNonEmptyArray(edits)) {
+            if (!canSyncModel(this._modelService, resource)) {
+                return Promise.resolve(edits); // File too large
+            }
+            const sw = StopWatch.create();
+            const result = this._workerManager.withWorker().then(client => client.computeHumanReadableDiff(resource, edits, { ignoreTrimWhitespace: false, maxComputationTimeMs: 1000, computeMoves: false, })).catch((err) => {
+                onUnexpectedError(err);
+                // In case of an exception, fall back to computeMoreMinimalEdits
+                return this.computeMoreMinimalEdits(resource, edits, true);
+            });
+            result.finally(() => this._logService.trace('FORMAT#computeHumanReadableDiff', resource.toString(true), sw.elapsed()));
+            return result;
+        }
+        else {
+            return Promise.resolve(undefined);
+        }
+    }
     canNavigateValueSet(resource) {
         return (canSyncModel(this._modelService, resource));
     }
@@ -148,57 +158,55 @@
         this._configurationService = configurationService;
         this._modelService = modelService;
     }
-    provideCompletionItems(model, position) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const config = this._configurationService.getValue(model.uri, position, 'editor');
-            if (!config.wordBasedSuggestions) {
-                return undefined;
+    async provideCompletionItems(model, position) {
+        const config = this._configurationService.getValue(model.uri, position, 'editor');
+        if (!config.wordBasedSuggestions) {
+            return undefined;
+        }
+        const models = [];
+        if (config.wordBasedSuggestionsMode === 'currentDocument') {
+            // only current file and only if not too large
+            if (canSyncModel(this._modelService, model.uri)) {
+                models.push(model.uri);
             }
-            const models = [];
-            if (config.wordBasedSuggestionsMode === 'currentDocument') {
-                // only current file and only if not too large
-                if (canSyncModel(this._modelService, model.uri)) {
-                    models.push(model.uri);
+        }
+        else {
+            // either all files or files of same language
+            for (const candidate of this._modelService.getModels()) {
+                if (!canSyncModel(this._modelService, candidate.uri)) {
+                    continue;
                 }
-            }
-            else {
-                // either all files or files of same language
-                for (const candidate of this._modelService.getModels()) {
-                    if (!canSyncModel(this._modelService, candidate.uri)) {
-                        continue;
-                    }
-                    if (candidate === model) {
-                        models.unshift(candidate.uri);
-                    }
-                    else if (config.wordBasedSuggestionsMode === 'allDocuments' || candidate.getLanguageId() === model.getLanguageId()) {
-                        models.push(candidate.uri);
-                    }
+                if (candidate === model) {
+                    models.unshift(candidate.uri);
+                }
+                else if (config.wordBasedSuggestionsMode === 'allDocuments' || candidate.getLanguageId() === model.getLanguageId()) {
+                    models.push(candidate.uri);
                 }
             }
-            if (models.length === 0) {
-                return undefined; // File too large, no other files
-            }
-            const wordDefRegExp = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
-            const word = model.getWordAtPosition(position);
-            const replace = !word ? Range.fromPositions(position) : new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
-            const insert = replace.setEndPosition(position.lineNumber, position.column);
-            const client = yield this._workerManager.withWorker();
-            const data = yield client.textualSuggest(models, word === null || word === void 0 ? void 0 : word.word, wordDefRegExp);
-            if (!data) {
-                return undefined;
-            }
-            return {
-                duration: data.duration,
-                suggestions: data.words.map((word) => {
-                    return {
-                        kind: 18 /* languages.CompletionItemKind.Text */,
-                        label: word,
-                        insertText: word,
-                        range: { insert, replace }
-                    };
-                }),
-            };
-        });
+        }
+        if (models.length === 0) {
+            return undefined; // File too large, no other files
+        }
+        const wordDefRegExp = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
+        const word = model.getWordAtPosition(position);
+        const replace = !word ? Range.fromPositions(position) : new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
+        const insert = replace.setEndPosition(position.lineNumber, position.column);
+        const client = await this._workerManager.withWorker();
+        const data = await client.textualSuggest(models, word?.word, wordDefRegExp);
+        if (!data) {
+            return undefined;
+        }
+        return {
+            duration: data.duration,
+            suggestions: data.words.map((word) => {
+                return {
+                    kind: 18 /* languages.CompletionItemKind.Text */,
+                    label: word,
+                    insertText: word,
+                    range: { insert, replace }
+                };
+            }),
+        };
     }
 }
 class WorkerManager extends Disposable {
@@ -394,15 +402,13 @@
         }
         return this._modelManager;
     }
-    _withSyncedResources(resources, forceLargeModels = false) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (this._disposed) {
-                return Promise.reject(canceled());
-            }
-            return this._getProxy().then((proxy) => {
-                this._getOrCreateModelManager(proxy).ensureSyncedResources(resources, forceLargeModels);
-                return proxy;
-            });
+    async _withSyncedResources(resources, forceLargeModels = false) {
+        if (this._disposed) {
+            return Promise.reject(canceled());
+        }
+        return this._getProxy().then((proxy) => {
+            this._getOrCreateModelManager(proxy).ensureSyncedResources(resources, forceLargeModels);
+            return proxy;
         });
     }
     computedUnicodeHighlights(uri, options, range) {
@@ -415,11 +421,21 @@
             return proxy.computeDiff(original.toString(), modified.toString(), options, algorithm);
         });
     }
+    computeDirtyDiff(original, modified, ignoreTrimWhitespace) {
+        return this._withSyncedResources([original, modified]).then(proxy => {
+            return proxy.computeDirtyDiff(original.toString(), modified.toString(), ignoreTrimWhitespace);
+        });
+    }
     computeMoreMinimalEdits(resource, edits, pretty) {
         return this._withSyncedResources([resource]).then(proxy => {
             return proxy.computeMoreMinimalEdits(resource.toString(), edits, pretty);
         });
     }
+    computeHumanReadableDiff(resource, edits, options) {
+        return this._withSyncedResources([resource]).then(proxy => {
+            return proxy.computeHumanReadableDiff(resource.toString(), edits, options);
+        });
+    }
     computeLinks(resource) {
         return this._withSyncedResources([resource]).then(proxy => {
             return proxy.computeLinks(resource.toString());
@@ -430,13 +446,11 @@
             return proxy.computeDefaultDocumentColors(resource.toString());
         });
     }
-    textualSuggest(resources, leadingWord, wordDefRegExp) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const proxy = yield this._withSyncedResources(resources);
-            const wordDef = wordDefRegExp.source;
-            const wordDefFlags = wordDefRegExp.flags;
-            return proxy.textualSuggest(resources.map(r => r.toString()), leadingWord, wordDef, wordDefFlags);
-        });
+    async textualSuggest(resources, leadingWord, wordDefRegExp) {
+        const proxy = await this._withSyncedResources(resources);
+        const wordDef = wordDefRegExp.source;
+        const wordDefFlags = wordDefRegExp.flags;
+        return proxy.textualSuggest(resources.map(r => r.toString()), leadingWord, wordDef, wordDefFlags);
     }
     computeWordRanges(resource, range) {
         return this._withSyncedResources([resource]).then(proxy => {
diff -urN -x '*.map' a/vs/editor/browser/services/openerService.js b/vs/editor/browser/services/openerService.js
--- a/vs/editor/browser/services/openerService.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/services/openerService.js	2023-12-06 14:23:14.355854741 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import * as dom from '../../../base/browser/dom.js';
 import { CancellationToken } from '../../../base/common/cancellation.js';
 import { LinkedList } from '../../../base/common/linkedList.js';
@@ -36,46 +27,44 @@
     constructor(_commandService) {
         this._commandService = _commandService;
     }
-    open(target, options) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!matchesScheme(target, Schemas.command)) {
-                return false;
-            }
-            if (!(options === null || options === void 0 ? void 0 : options.allowCommands)) {
-                // silently ignore commands when command-links are disabled, also
-                // suppress other openers by returning TRUE
+    async open(target, options) {
+        if (!matchesScheme(target, Schemas.command)) {
+            return false;
+        }
+        if (!options?.allowCommands) {
+            // silently ignore commands when command-links are disabled, also
+            // suppress other openers by returning TRUE
+            return true;
+        }
+        if (typeof target === 'string') {
+            target = URI.parse(target);
+        }
+        if (Array.isArray(options.allowCommands)) {
+            // Only allow specific commands
+            if (!options.allowCommands.includes(target.path)) {
+                // Suppress other openers by returning TRUE
                 return true;
             }
-            if (typeof target === 'string') {
-                target = URI.parse(target);
-            }
-            if (Array.isArray(options.allowCommands)) {
-                // Only allow specific commands
-                if (!options.allowCommands.includes(target.path)) {
-                    // Suppress other openers by returning TRUE
-                    return true;
-                }
-            }
-            // execute as command
-            let args = [];
+        }
+        // execute as command
+        let args = [];
+        try {
+            args = parse(decodeURIComponent(target.query));
+        }
+        catch {
+            // ignore and retry
             try {
-                args = parse(decodeURIComponent(target.query));
-            }
-            catch (_a) {
-                // ignore and retry
-                try {
-                    args = parse(target.query);
-                }
-                catch (_b) {
-                    // ignore error
-                }
+                args = parse(target.query);
             }
-            if (!Array.isArray(args)) {
-                args = [args];
+            catch {
+                // ignore error
             }
-            yield this._commandService.executeCommand(target.path, ...args);
-            return true;
-        });
+        }
+        if (!Array.isArray(args)) {
+            args = [args];
+        }
+        await this._commandService.executeCommand(target.path, ...args);
+        return true;
     }
 };
 CommandOpener = __decorate([
@@ -85,22 +74,24 @@
     constructor(_editorService) {
         this._editorService = _editorService;
     }
-    open(target, options) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (typeof target === 'string') {
-                target = URI.parse(target);
-            }
-            const { selection, uri } = extractSelection(target);
-            target = uri;
-            if (target.scheme === Schemas.file) {
-                target = normalizePath(target); // workaround for non-normalized paths (https://github.com/microsoft/vscode/issues/12954)
-            }
-            yield this._editorService.openCodeEditor({
-                resource: target,
-                options: Object.assign({ selection, source: (options === null || options === void 0 ? void 0 : options.fromUserGesture) ? EditorOpenSource.USER : EditorOpenSource.API }, options === null || options === void 0 ? void 0 : options.editorOptions)
-            }, this._editorService.getFocusedCodeEditor(), options === null || options === void 0 ? void 0 : options.openToSide);
-            return true;
-        });
+    async open(target, options) {
+        if (typeof target === 'string') {
+            target = URI.parse(target);
+        }
+        const { selection, uri } = extractSelection(target);
+        target = uri;
+        if (target.scheme === Schemas.file) {
+            target = normalizePath(target); // workaround for non-normalized paths (https://github.com/microsoft/vscode/issues/12954)
+        }
+        await this._editorService.openCodeEditor({
+            resource: target,
+            options: {
+                selection,
+                source: options?.fromUserGesture ? EditorOpenSource.USER : EditorOpenSource.API,
+                ...options?.editorOptions
+            }
+        }, this._editorService.getFocusedCodeEditor(), options?.openToSide);
+        return true;
     }
 };
 EditorOpener = __decorate([
@@ -115,7 +106,7 @@
         this._externalOpeners = new LinkedList();
         // Default external opener is going through window.open()
         this._defaultExternalOpener = {
-            openExternal: (href) => __awaiter(this, void 0, void 0, function* () {
+            openExternal: async (href) => {
                 // ensure to open HTTP/HTTPS links into new windows
                 // to not trigger a navigation. Any other link is
                 // safe to be set as HREF to prevent a blank window
@@ -127,18 +118,18 @@
                     window.location.href = href;
                 }
                 return true;
-            })
+            }
         };
         // Default opener: any external, maito, http(s), command, and catch-all-editors
         this._openers.push({
-            open: (target, options) => __awaiter(this, void 0, void 0, function* () {
-                if ((options === null || options === void 0 ? void 0 : options.openExternal) || matchesSomeScheme(target, Schemas.mailto, Schemas.http, Schemas.https, Schemas.vsls)) {
+            open: async (target, options) => {
+                if (options?.openExternal || matchesSomeScheme(target, Schemas.mailto, Schemas.http, Schemas.https, Schemas.vsls)) {
                     // open externally
-                    yield this._doOpenExternal(target, options);
+                    await this._doOpenExternal(target, options);
                     return true;
                 }
                 return false;
-            })
+            }
         });
         this._openers.push(new CommandOpener(commandService));
         this._openers.push(new EditorOpener(editorService));
@@ -147,81 +138,89 @@
         const remove = this._openers.unshift(opener);
         return { dispose: remove };
     }
-    open(target, options) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            // check with contributed validators
-            const targetURI = typeof target === 'string' ? URI.parse(target) : target;
-            // validate against the original URI that this URI resolves to, if one exists
-            const validationTarget = (_a = this._resolvedUriTargets.get(targetURI)) !== null && _a !== void 0 ? _a : target;
-            for (const validator of this._validators) {
-                if (!(yield validator.shouldOpen(validationTarget, options))) {
-                    return false;
-                }
+    registerValidator(validator) {
+        const remove = this._validators.push(validator);
+        return { dispose: remove };
+    }
+    registerExternalUriResolver(resolver) {
+        const remove = this._resolvers.push(resolver);
+        return { dispose: remove };
+    }
+    setDefaultExternalOpener(externalOpener) {
+        this._defaultExternalOpener = externalOpener;
+    }
+    registerExternalOpener(opener) {
+        const remove = this._externalOpeners.push(opener);
+        return { dispose: remove };
+    }
+    async open(target, options) {
+        // check with contributed validators
+        const targetURI = typeof target === 'string' ? URI.parse(target) : target;
+        // validate against the original URI that this URI resolves to, if one exists
+        const validationTarget = this._resolvedUriTargets.get(targetURI) ?? target;
+        for (const validator of this._validators) {
+            if (!(await validator.shouldOpen(validationTarget, options))) {
+                return false;
             }
-            // check with contributed openers
-            for (const opener of this._openers) {
-                const handled = yield opener.open(target, options);
-                if (handled) {
-                    return true;
-                }
+        }
+        // check with contributed openers
+        for (const opener of this._openers) {
+            const handled = await opener.open(target, options);
+            if (handled) {
+                return true;
             }
-            return false;
-        });
+        }
+        return false;
     }
-    resolveExternalUri(resource, options) {
-        return __awaiter(this, void 0, void 0, function* () {
-            for (const resolver of this._resolvers) {
-                try {
-                    const result = yield resolver.resolveExternalUri(resource, options);
-                    if (result) {
-                        if (!this._resolvedUriTargets.has(result.resolved)) {
-                            this._resolvedUriTargets.set(result.resolved, resource);
-                        }
-                        return result;
+    async resolveExternalUri(resource, options) {
+        for (const resolver of this._resolvers) {
+            try {
+                const result = await resolver.resolveExternalUri(resource, options);
+                if (result) {
+                    if (!this._resolvedUriTargets.has(result.resolved)) {
+                        this._resolvedUriTargets.set(result.resolved, resource);
                     }
+                    return result;
                 }
-                catch (_a) {
-                    // noop
-                }
-            }
-            throw new Error('Could not resolve external URI: ' + resource.toString());
-        });
-    }
-    _doOpenExternal(resource, options) {
-        return __awaiter(this, void 0, void 0, function* () {
-            //todo@jrieken IExternalUriResolver should support `uri: URI | string`
-            const uri = typeof resource === 'string' ? URI.parse(resource) : resource;
-            let externalUri;
-            try {
-                externalUri = (yield this.resolveExternalUri(uri, options)).resolved;
             }
-            catch (_a) {
-                externalUri = uri;
+            catch {
+                // noop
             }
-            let href;
-            if (typeof resource === 'string' && uri.toString() === externalUri.toString()) {
-                // open the url-string AS IS
-                href = resource;
-            }
-            else {
-                // open URI using the toString(noEncode)+encodeURI-trick
-                href = encodeURI(externalUri.toString(true));
-            }
-            if (options === null || options === void 0 ? void 0 : options.allowContributedOpeners) {
-                const preferredOpenerId = typeof (options === null || options === void 0 ? void 0 : options.allowContributedOpeners) === 'string' ? options === null || options === void 0 ? void 0 : options.allowContributedOpeners : undefined;
-                for (const opener of this._externalOpeners) {
-                    const didOpen = yield opener.openExternal(href, {
-                        sourceUri: uri,
-                        preferredOpenerId,
-                    }, CancellationToken.None);
-                    if (didOpen) {
-                        return true;
-                    }
+        }
+        throw new Error('Could not resolve external URI: ' + resource.toString());
+    }
+    async _doOpenExternal(resource, options) {
+        //todo@jrieken IExternalUriResolver should support `uri: URI | string`
+        const uri = typeof resource === 'string' ? URI.parse(resource) : resource;
+        let externalUri;
+        try {
+            externalUri = (await this.resolveExternalUri(uri, options)).resolved;
+        }
+        catch {
+            externalUri = uri;
+        }
+        let href;
+        if (typeof resource === 'string' && uri.toString() === externalUri.toString()) {
+            // open the url-string AS IS
+            href = resource;
+        }
+        else {
+            // open URI using the toString(noEncode)+encodeURI-trick
+            href = encodeURI(externalUri.toString(true));
+        }
+        if (options?.allowContributedOpeners) {
+            const preferredOpenerId = typeof options?.allowContributedOpeners === 'string' ? options?.allowContributedOpeners : undefined;
+            for (const opener of this._externalOpeners) {
+                const didOpen = await opener.openExternal(href, {
+                    sourceUri: uri,
+                    preferredOpenerId,
+                }, CancellationToken.None);
+                if (didOpen) {
+                    return true;
                 }
             }
-            return this._defaultExternalOpener.openExternal(href, { sourceUri: uri }, CancellationToken.None);
-        });
+        }
+        return this._defaultExternalOpener.openExternal(href, { sourceUri: uri }, CancellationToken.None);
     }
     dispose() {
         this._validators.clear();
diff -urN -x '*.map' a/vs/editor/browser/view/domLineBreaksComputer.js b/vs/editor/browser/view/domLineBreaksComputer.js
--- a/vs/editor/browser/view/domLineBreaksComputer.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/view/domLineBreaksComputer.js	2023-12-06 14:23:14.355854741 +0000
@@ -30,7 +30,6 @@
     }
 }
 function createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent, wordBreak, injectedTextsPerLine) {
-    var _a;
     function createEmptyLineBreakWithPossiblyInjectedText(requestIdx) {
         const injectedTexts = injectedTextsPerLine[requestIdx];
         if (injectedTexts) {
@@ -103,7 +102,7 @@
         allVisibleColumns[i] = tmp[1];
     }
     const html = sb.build();
-    const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;
+    const trustedhtml = ttPolicy?.createHTML(html) ?? html;
     containerDomNode.innerHTML = trustedhtml;
     containerDomNode.style.position = 'absolute';
     containerDomNode.style.top = '10000';
diff -urN -x '*.map' a/vs/editor/browser/view/renderingContext.js b/vs/editor/browser/view/renderingContext.js
--- a/vs/editor/browser/view/renderingContext.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/view/renderingContext.js	2023-12-06 14:23:14.355854741 +0000
@@ -44,6 +44,36 @@
     }
 }
 export class LineVisibleRanges {
+    /**
+     * Returns the element with the smallest `lineNumber`.
+     */
+    static firstLine(ranges) {
+        if (!ranges) {
+            return null;
+        }
+        let result = null;
+        for (const range of ranges) {
+            if (!result || range.lineNumber < result.lineNumber) {
+                result = range;
+            }
+        }
+        return result;
+    }
+    /**
+     * Returns the element with the largest `lineNumber`.
+     */
+    static lastLine(ranges) {
+        if (!ranges) {
+            return null;
+        }
+        let result = null;
+        for (const range of ranges) {
+            if (!result || range.lineNumber > result.lineNumber) {
+                result = range;
+            }
+        }
+        return result;
+    }
     constructor(outsideRenderedLine, lineNumber, ranges, 
     /**
      * Indicates if the requested range does not end in this line, but continues on the next line.
diff -urN -x '*.map' a/vs/editor/browser/view/viewUserInputEvents.js b/vs/editor/browser/view/viewUserInputEvents.js
--- a/vs/editor/browser/view/viewUserInputEvents.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/view/viewUserInputEvents.js	2023-12-06 14:23:14.355854741 +0000
@@ -19,48 +19,37 @@
         this._coordinatesConverter = coordinatesConverter;
     }
     emitKeyDown(e) {
-        var _a;
-        (_a = this.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(this, e);
+        this.onKeyDown?.(e);
     }
     emitKeyUp(e) {
-        var _a;
-        (_a = this.onKeyUp) === null || _a === void 0 ? void 0 : _a.call(this, e);
+        this.onKeyUp?.(e);
     }
     emitContextMenu(e) {
-        var _a;
-        (_a = this.onContextMenu) === null || _a === void 0 ? void 0 : _a.call(this, this._convertViewToModelMouseEvent(e));
+        this.onContextMenu?.(this._convertViewToModelMouseEvent(e));
     }
     emitMouseMove(e) {
-        var _a;
-        (_a = this.onMouseMove) === null || _a === void 0 ? void 0 : _a.call(this, this._convertViewToModelMouseEvent(e));
+        this.onMouseMove?.(this._convertViewToModelMouseEvent(e));
     }
     emitMouseLeave(e) {
-        var _a;
-        (_a = this.onMouseLeave) === null || _a === void 0 ? void 0 : _a.call(this, this._convertViewToModelMouseEvent(e));
+        this.onMouseLeave?.(this._convertViewToModelMouseEvent(e));
     }
     emitMouseDown(e) {
-        var _a;
-        (_a = this.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(this, this._convertViewToModelMouseEvent(e));
+        this.onMouseDown?.(this._convertViewToModelMouseEvent(e));
     }
     emitMouseUp(e) {
-        var _a;
-        (_a = this.onMouseUp) === null || _a === void 0 ? void 0 : _a.call(this, this._convertViewToModelMouseEvent(e));
+        this.onMouseUp?.(this._convertViewToModelMouseEvent(e));
     }
     emitMouseDrag(e) {
-        var _a;
-        (_a = this.onMouseDrag) === null || _a === void 0 ? void 0 : _a.call(this, this._convertViewToModelMouseEvent(e));
+        this.onMouseDrag?.(this._convertViewToModelMouseEvent(e));
     }
     emitMouseDrop(e) {
-        var _a;
-        (_a = this.onMouseDrop) === null || _a === void 0 ? void 0 : _a.call(this, this._convertViewToModelMouseEvent(e));
+        this.onMouseDrop?.(this._convertViewToModelMouseEvent(e));
     }
     emitMouseDropCanceled() {
-        var _a;
-        (_a = this.onMouseDropCanceled) === null || _a === void 0 ? void 0 : _a.call(this);
+        this.onMouseDropCanceled?.();
     }
     emitMouseWheel(e) {
-        var _a;
-        (_a = this.onMouseWheel) === null || _a === void 0 ? void 0 : _a.call(this, e);
+        this.onMouseWheel?.(e);
     }
     _convertViewToModelMouseEvent(e) {
         if (e.target) {
@@ -75,7 +64,7 @@
         return ViewUserInputEvents.convertViewToModelMouseTarget(target, this._coordinatesConverter);
     }
     static convertViewToModelMouseTarget(target, coordinatesConverter) {
-        const result = Object.assign({}, target);
+        const result = { ...target };
         if (result.position) {
             result.position = coordinatesConverter.convertViewPositionToModelPosition(result.position);
         }
diff -urN -x '*.map' a/vs/editor/browser/view.js b/vs/editor/browser/view.js
--- a/vs/editor/browser/view.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/view.js	2023-12-06 14:23:14.355854741 +0000
@@ -172,8 +172,7 @@
         let glyphs = [];
         // Add all margin decorations
         glyphs = glyphs.concat(model.getAllMarginDecorations().map((decoration) => {
-            var _a, _b;
-            const lane = (_b = (_a = decoration.options.glyphMargin) === null || _a === void 0 ? void 0 : _a.position) !== null && _b !== void 0 ? _b : GlyphMarginLane.Left;
+            const lane = decoration.options.glyphMargin?.position ?? GlyphMarginLane.Left;
             return { range: decoration.range, lane };
         }));
         // Add all glyph margin widgets
@@ -435,6 +434,9 @@
     isFocused() {
         return this._textAreaHandler.isFocused();
     }
+    refreshFocusState() {
+        this._textAreaHandler.refreshFocusState();
+    }
     setAriaOptions(options) {
         this._textAreaHandler.setAriaOptions(options);
     }
@@ -444,8 +446,7 @@
         this._scheduleRender();
     }
     layoutContentWidget(widgetData) {
-        var _a, _b, _c, _d, _e, _f, _g, _h;
-        this._contentWidgets.setWidgetPosition(widgetData.widget, (_b = (_a = widgetData.position) === null || _a === void 0 ? void 0 : _a.position) !== null && _b !== void 0 ? _b : null, (_d = (_c = widgetData.position) === null || _c === void 0 ? void 0 : _c.secondaryPosition) !== null && _d !== void 0 ? _d : null, (_f = (_e = widgetData.position) === null || _e === void 0 ? void 0 : _e.preference) !== null && _f !== void 0 ? _f : null, (_h = (_g = widgetData.position) === null || _g === void 0 ? void 0 : _g.positionAffinity) !== null && _h !== void 0 ? _h : null);
+        this._contentWidgets.setWidgetPosition(widgetData.widget, widgetData.position?.position ?? null, widgetData.position?.secondaryPosition ?? null, widgetData.position?.preference ?? null, widgetData.position?.positionAffinity ?? null);
         this._scheduleRender();
     }
     removeContentWidget(widgetData) {
diff -urN -x '*.map' a/vs/editor/browser/viewParts/blockDecorations/blockDecorations.js b/vs/editor/browser/viewParts/blockDecorations/blockDecorations.js
--- a/vs/editor/browser/viewParts/blockDecorations/blockDecorations.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/viewParts/blockDecorations/blockDecorations.js	2023-12-06 14:23:14.355854741 +0000
@@ -54,7 +54,6 @@
         // Nothing to read
     }
     render(ctx) {
-        var _a;
         let count = 0;
         const decorations = ctx.getDecorationsInViewport();
         for (const decoration of decorations) {
@@ -79,7 +78,7 @@
                     ? ctx.getVerticalOffsetForLineNumber(decoration.range.startLineNumber, false)
                     : ctx.getVerticalOffsetAfterLineNumber(decoration.range.endLineNumber, true);
             }
-            const [paddingTop, paddingRight, paddingBottom, paddingLeft] = (_a = decoration.options.blockPadding) !== null && _a !== void 0 ? _a : [0, 0, 0, 0];
+            const [paddingTop, paddingRight, paddingBottom, paddingLeft] = decoration.options.blockPadding ?? [0, 0, 0, 0];
             block.setClassName('blockDecorations-block ' + decoration.options.blockClassName);
             block.setLeft(this.contentLeft - paddingLeft);
             block.setWidth(this.contentWidth + paddingLeft + paddingRight);
diff -urN -x '*.map' a/vs/editor/browser/viewParts/contentWidgets/contentWidgets.js b/vs/editor/browser/viewParts/contentWidgets/contentWidgets.js
--- a/vs/editor/browser/viewParts/contentWidgets/contentWidgets.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/viewParts/contentWidgets/contentWidgets.js	2023-12-06 14:23:14.355854741 +0000
@@ -173,7 +173,7 @@
             // Do not trust that widgets give a valid position
             const validModelPosition = viewModel.model.validatePosition(position);
             if (viewModel.coordinatesConverter.modelPositionIsVisible(validModelPosition)) {
-                const viewPosition = viewModel.coordinatesConverter.convertModelPositionToViewPosition(validModelPosition, affinity !== null && affinity !== void 0 ? affinity : undefined);
+                const viewPosition = viewModel.coordinatesConverter.convertModelPositionToViewPosition(validModelPosition, affinity ?? undefined);
                 return new PositionPair(position, viewPosition);
             }
             return new PositionPair(position, null);
@@ -183,7 +183,7 @@
         const elDocument = this.domNode.domNode.ownerDocument;
         const elWindow = elDocument.defaultView;
         return (this.allowEditorOverflow
-            ? (elWindow === null || elWindow === void 0 ? void 0 : elWindow.innerWidth) || elDocument.documentElement.offsetWidth || elDocument.body.offsetWidth
+            ? elWindow?.innerWidth || elDocument.documentElement.offsetWidth || elDocument.body.offsetWidth
             : this._contentWidth);
     }
     setPosition(primaryAnchor, secondaryAnchor, preference, affinity) {
@@ -225,7 +225,6 @@
         return { fitsAbove, aboveTop, fitsBelow, belowTop, left };
     }
     _layoutHorizontalSegmentInPage(windowSize, domNodePosition, left, width) {
-        var _a;
         // Leave some clearance to the left/right
         const LEFT_PADDING = 15;
         const RIGHT_PADDING = 15;
@@ -234,7 +233,7 @@
         const MAX_LIMIT = Math.min(domNodePosition.left + domNodePosition.width + width, windowSize.width - RIGHT_PADDING);
         const elDocument = this._viewDomNode.domNode.ownerDocument;
         const elWindow = elDocument.defaultView;
-        let absoluteLeft = domNodePosition.left + left - ((_a = elWindow === null || elWindow === void 0 ? void 0 : elWindow.scrollX) !== null && _a !== void 0 ? _a : 0);
+        let absoluteLeft = domNodePosition.left + left - (elWindow?.scrollX ?? 0);
         if (absoluteLeft + width > MAX_LIMIT) {
             const delta = absoluteLeft - (MAX_LIMIT - width);
             absoluteLeft -= delta;
@@ -248,14 +247,13 @@
         return [left, absoluteLeft];
     }
     _layoutBoxInPage(anchor, width, height, ctx) {
-        var _a, _b;
         const aboveTop = anchor.top - height;
         const belowTop = anchor.top + anchor.height;
         const domNodePosition = dom.getDomNodePagePosition(this._viewDomNode.domNode);
         const elDocument = this._viewDomNode.domNode.ownerDocument;
         const elWindow = elDocument.defaultView;
-        const absoluteAboveTop = domNodePosition.top + aboveTop - ((_a = elWindow === null || elWindow === void 0 ? void 0 : elWindow.scrollY) !== null && _a !== void 0 ? _a : 0);
-        const absoluteBelowTop = domNodePosition.top + belowTop - ((_b = elWindow === null || elWindow === void 0 ? void 0 : elWindow.scrollY) !== null && _b !== void 0 ? _b : 0);
+        const absoluteAboveTop = domNodePosition.top + aboveTop - (elWindow?.scrollY ?? 0);
+        const absoluteBelowTop = domNodePosition.top + belowTop - (elWindow?.scrollY ?? 0);
         const windowSize = dom.getClientArea(elDocument.body);
         const [left, absoluteAboveLeft] = this._layoutHorizontalSegmentInPage(windowSize, domNodePosition, anchor.left - ctx.scrollLeft + this._contentLeft, width);
         // Leave some clearance to the top/bottom
@@ -283,9 +281,8 @@
      * The content widget should touch if possible the secondary anchor.
      */
     _getAnchorsCoordinates(ctx) {
-        var _a, _b;
         const primary = getCoordinates(this._primaryAnchor.viewPosition, this._affinity, this._lineHeight);
-        const secondaryViewPosition = (((_a = this._secondaryAnchor.viewPosition) === null || _a === void 0 ? void 0 : _a.lineNumber) === ((_b = this._primaryAnchor.viewPosition) === null || _b === void 0 ? void 0 : _b.lineNumber) ? this._secondaryAnchor.viewPosition : null);
+        const secondaryViewPosition = (this._secondaryAnchor.viewPosition?.lineNumber === this._primaryAnchor.viewPosition?.lineNumber ? this._secondaryAnchor.viewPosition : null);
         const secondary = getCoordinates(secondaryViewPosition, this._affinity, this._lineHeight);
         return { primary, secondary };
         function getCoordinates(position, affinity, lineHeight) {
@@ -455,7 +452,7 @@
     try {
         return fn.call(thisArg, ...args);
     }
-    catch (_a) {
+    catch {
         // ignore
         return null;
     }
diff -urN -x '*.map' a/vs/editor/browser/viewParts/decorations/decorations.js b/vs/editor/browser/viewParts/decorations/decorations.js
--- a/vs/editor/browser/viewParts/decorations/decorations.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/viewParts/decorations/decorations.js	2023-12-06 14:23:14.359854747 +0000
@@ -114,7 +114,6 @@
         }
     }
     _renderNormalDecorations(ctx, decorations, output) {
-        var _a;
         const lineHeight = String(this._lineHeight);
         const visibleStartLineNumber = ctx.visibleRange.startLineNumber;
         let prevClassName = null;
@@ -144,7 +143,7 @@
             prevClassName = className;
             prevShowIfCollapsed = showIfCollapsed;
             prevRange = range;
-            prevShouldFillLineOnLineBreak = (_a = d.options.shouldFillLineOnLineBreak) !== null && _a !== void 0 ? _a : false;
+            prevShouldFillLineOnLineBreak = d.options.shouldFillLineOnLineBreak ?? false;
         }
         if (prevClassName !== null) {
             this._renderNormalDecoration(ctx, prevRange, prevClassName, prevShouldFillLineOnLineBreak, prevShowIfCollapsed, lineHeight, visibleStartLineNumber, output);
diff -urN -x '*.map' a/vs/editor/browser/viewParts/glyphMargin/glyphMargin.js b/vs/editor/browser/viewParts/glyphMargin/glyphMargin.js
--- a/vs/editor/browser/viewParts/glyphMargin/glyphMargin.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/viewParts/glyphMargin/glyphMargin.js	2023-12-06 14:23:14.359854747 +0000
@@ -18,7 +18,7 @@
         this.startLineNumber = +startLineNumber;
         this.endLineNumber = +endLineNumber;
         this.className = String(className);
-        this.zIndex = zIndex !== null && zIndex !== void 0 ? zIndex : 0;
+        this.zIndex = zIndex ?? 0;
     }
 }
 /**
@@ -179,19 +179,17 @@
         return true;
     }
     removeWidget(widget) {
-        var _a;
         const widgetId = widget.getId();
         if (this._widgets[widgetId]) {
             const widgetData = this._widgets[widgetId];
             const domNode = widgetData.domNode.domNode;
             delete this._widgets[widgetId];
-            (_a = domNode.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(domNode);
+            domNode.parentNode?.removeChild(domNode);
             this.setShouldRender();
         }
     }
     // --- end widget management
     _collectDecorationBasedGlyphRenderRequest(ctx, requests) {
-        var _a, _b, _c;
         const visibleStartLineNumber = ctx.visibleRange.startLineNumber;
         const visibleEndLineNumber = ctx.visibleRange.endLineNumber;
         const decorations = ctx.getDecorationsInViewport();
@@ -202,8 +200,8 @@
             }
             const startLineNumber = Math.max(d.range.startLineNumber, visibleStartLineNumber);
             const endLineNumber = Math.min(d.range.endLineNumber, visibleEndLineNumber);
-            const lane = Math.min((_b = (_a = d.options.glyphMargin) === null || _a === void 0 ? void 0 : _a.position) !== null && _b !== void 0 ? _b : 1, this._glyphMarginDecorationLaneCount);
-            const zIndex = (_c = d.options.zIndex) !== null && _c !== void 0 ? _c : 0;
+            const lane = Math.min(d.options.glyphMargin?.position ?? 1, this._glyphMarginDecorationLaneCount);
+            const zIndex = d.options.zIndex ?? 0;
             for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
                 requests.push(new DecorationBasedGlyphRenderRequest(lineNumber, lane, zIndex, glyphMarginClassName));
             }
@@ -307,7 +305,7 @@
             }
             while (this._managedDomNodes.length > 0) {
                 const domNode = this._managedDomNodes.pop();
-                domNode === null || domNode === void 0 ? void 0 : domNode.domNode.remove();
+                domNode?.domNode.remove();
             }
             return;
         }
@@ -352,7 +350,7 @@
         // remove extra dom nodes
         while (this._managedDomNodes.length > this._decorationGlyphsToRender.length) {
             const domNode = this._managedDomNodes.pop();
-            domNode === null || domNode === void 0 ? void 0 : domNode.domNode.remove();
+            domNode?.domNode.remove();
         }
     }
 }
diff -urN -x '*.map' a/vs/editor/browser/viewParts/indentGuides/indentGuides.js b/vs/editor/browser/viewParts/indentGuides/indentGuides.js
--- a/vs/editor/browser/viewParts/indentGuides/indentGuides.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/viewParts/indentGuides/indentGuides.js	2023-12-06 14:23:14.359854747 +0000
@@ -43,10 +43,9 @@
         return true;
     }
     onCursorStateChanged(e) {
-        var _a;
         const selection = e.selections[0];
         const newPosition = selection.getPosition();
-        if (!((_a = this._primaryPosition) === null || _a === void 0 ? void 0 : _a.equals(newPosition))) {
+        if (!this._primaryPosition?.equals(newPosition)) {
             this._primaryPosition = newPosition;
             return true;
         }
@@ -79,7 +78,6 @@
     }
     // --- end event handlers
     prepareRender(ctx) {
-        var _a, _b, _c, _d;
         if (!this._bracketPairGuideOptions.indentation && this._bracketPairGuideOptions.bracketPairs === false) {
             this._renderResult = null;
             return;
@@ -95,7 +93,7 @@
             const lineIndex = lineNumber - visibleStartLineNumber;
             const indent = indents[lineIndex];
             let result = '';
-            const leftOffset = (_b = (_a = ctx.visibleRangeForPosition(new Position(lineNumber, 1))) === null || _a === void 0 ? void 0 : _a.left) !== null && _b !== void 0 ? _b : 0;
+            const leftOffset = ctx.visibleRangeForPosition(new Position(lineNumber, 1))?.left ?? 0;
             for (const guide of indent) {
                 const left = guide.column === -1
                     ? leftOffset + (guide.visibleColumn - 1) * this._spaceWidth
@@ -105,7 +103,7 @@
                 }
                 const className = guide.horizontalLine ? (guide.horizontalLine.top ? 'horizontal-top' : 'horizontal-bottom') : 'vertical';
                 const width = guide.horizontalLine
-                    ? ((_d = (_c = ctx.visibleRangeForPosition(new Position(lineNumber, guide.horizontalLine.endColumn))) === null || _c === void 0 ? void 0 : _c.left) !== null && _d !== void 0 ? _d : (left + this._spaceWidth)) - left
+                    ? (ctx.visibleRangeForPosition(new Position(lineNumber, guide.horizontalLine.endColumn))?.left ?? (left + this._spaceWidth)) - left
                     : this._spaceWidth;
                 result += `<div class="core-guide ${guide.className} ${className}" style="left:${left}px;height:${lineHeight}px;width:${width}px"></div>`;
             }
@@ -200,12 +198,11 @@
     ];
     const colorValues = colors
         .map(c => {
-        var _a, _b;
         const bracketColor = theme.getColor(c.bracketColor);
         const guideColor = theme.getColor(c.guideColor);
         const guideColorActive = theme.getColor(c.guideColorActive);
-        const effectiveGuideColor = transparentToUndefined((_a = transparentToUndefined(guideColor)) !== null && _a !== void 0 ? _a : bracketColor === null || bracketColor === void 0 ? void 0 : bracketColor.transparent(0.3));
-        const effectiveGuideColorActive = transparentToUndefined((_b = transparentToUndefined(guideColorActive)) !== null && _b !== void 0 ? _b : bracketColor);
+        const effectiveGuideColor = transparentToUndefined(transparentToUndefined(guideColor) ?? bracketColor?.transparent(0.3));
+        const effectiveGuideColorActive = transparentToUndefined(transparentToUndefined(guideColorActive) ?? bracketColor);
         if (!effectiveGuideColor || !effectiveGuideColorActive) {
             return undefined;
         }
diff -urN -x '*.map' a/vs/editor/browser/viewParts/lines/viewLine.js b/vs/editor/browser/viewParts/lines/viewLine.js
--- a/vs/editor/browser/viewParts/lines/viewLine.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/viewParts/lines/viewLine.js	2023-12-06 14:23:14.359854747 +0000
@@ -267,7 +267,7 @@
         }
         if (this._cachedWidth === -1) {
             this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;
-            context === null || context === void 0 ? void 0 : context.markDidDomLayout();
+            context?.markDidDomLayout();
         }
         return this._cachedWidth;
     }
@@ -371,7 +371,7 @@
         }
         if (this._cachedWidth === -1) {
             this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;
-            context === null || context === void 0 ? void 0 : context.markDidDomLayout();
+            context?.markDidDomLayout();
         }
         return this._cachedWidth;
     }
diff -urN -x '*.map' a/vs/editor/browser/viewParts/lines/viewLines.js b/vs/editor/browser/viewParts/lines/viewLines.js
--- a/vs/editor/browser/viewParts/lines/viewLines.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/viewParts/lines/viewLines.js	2023-12-06 14:23:14.359854747 +0000
@@ -377,6 +377,10 @@
         }
         return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);
     }
+    // --- implementation
+    updateLineWidths() {
+        this._updateLineWidths(false);
+    }
     /**
      * Updates the max line width if it is fast to compute.
      * Returns true if all lines were taken into account.
diff -urN -x '*.map' a/vs/editor/browser/viewParts/minimap/minimap.js b/vs/editor/browser/viewParts/minimap/minimap.js
--- a/vs/editor/browser/viewParts/minimap/minimap.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/viewParts/minimap/minimap.js	2023-12-06 14:23:14.359854747 +0000
@@ -1043,13 +1043,11 @@
         return false;
     }
     onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {
-        var _a;
-        (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);
+        this._lastRenderData?.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);
         return true;
     }
     onLinesInserted(insertFromLineNumber, insertToLineNumber) {
-        var _a;
-        (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesInserted(insertFromLineNumber, insertToLineNumber);
+        this._lastRenderData?.onLinesInserted(insertFromLineNumber, insertToLineNumber);
         return true;
     }
     onScrollChanged() {
diff -urN -x '*.map' a/vs/editor/browser/viewParts/overlayWidgets/overlayWidgets.js b/vs/editor/browser/viewParts/overlayWidgets/overlayWidgets.js
--- a/vs/editor/browser/viewParts/overlayWidgets/overlayWidgets.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/viewParts/overlayWidgets/overlayWidgets.js	2023-12-06 14:23:14.359854747 +0000
@@ -76,13 +76,12 @@
         }
     }
     _updateMaxMinWidth() {
-        var _a, _b;
         let maxMinWidth = 0;
         const keys = Object.keys(this._widgets);
         for (let i = 0, len = keys.length; i < len; i++) {
             const widgetId = keys[i];
             const widget = this._widgets[widgetId];
-            const widgetMinWidthInPx = (_b = (_a = widget.widget).getMinContentWidthInPx) === null || _b === void 0 ? void 0 : _b.call(_a);
+            const widgetMinWidthInPx = widget.widget.getMinContentWidthInPx?.();
             if (typeof widgetMinWidthInPx !== 'undefined') {
                 maxMinWidth = Math.max(maxMinWidth, widgetMinWidthInPx);
             }
diff -urN -x '*.map' a/vs/editor/browser/viewParts/viewZones/viewZones.js b/vs/editor/browser/viewParts/viewZones/viewZones.js
--- a/vs/editor/browser/viewParts/viewZones/viewZones.js	2023-12-06 14:22:33.795782401 +0000
+++ b/vs/editor/browser/viewParts/viewZones/viewZones.js	2023-12-06 14:23:14.359854747 +0000
@@ -84,8 +84,7 @@
     }
     // ---- end view event handlers
     _getZoneOrdinal(zone) {
-        var _a, _b;
-        return (_b = (_a = zone.ordinal) !== null && _a !== void 0 ? _a : zone.afterColumn) !== null && _b !== void 0 ? _b : 10000;
+        return zone.ordinal ?? zone.afterColumn ?? 10000;
     }
     _computeWhitespaceProps(zone) {
         if (zone.afterLineNumber === 0) {
diff -urN -x '*.map' a/vs/editor/browser/widget/codeEditorContributions.js b/vs/editor/browser/widget/codeEditorContributions.js
--- a/vs/editor/browser/widget/codeEditorContributions.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/codeEditorContributions.js	2023-12-06 14:23:14.359854747 +0000
@@ -77,6 +77,12 @@
         this._instantiateById(id);
         return this._instances.get(id) || null;
     }
+    /**
+     * used by tests
+     */
+    set(id, value) {
+        this._instances.set(id, value);
+    }
     onBeforeInteractionEvent() {
         // this method is called very often by the editor!
         this._instantiateSome(2 /* EditorContributionInstantiation.BeforeFirstInteraction */);
diff -urN -x '*.map' a/vs/editor/browser/widget/codeEditorWidget.js b/vs/editor/browser/widget/codeEditorWidget.js
--- a/vs/editor/browser/widget/codeEditorWidget.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/codeEditorWidget.js	2023-12-06 14:23:14.359854747 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var CodeEditorWidget_1;
 import '../services/markerDecorations.js';
 import './media/editor.css';
@@ -27,6 +18,7 @@
 import * as dom from '../../../base/browser/dom.js';
 import { onUnexpectedError } from '../../../base/common/errors.js';
 import { Emitter, createEventDeliveryQueue } from '../../../base/common/event.js';
+import { hash } from '../../../base/common/hash.js';
 import { Disposable, dispose } from '../../../base/common/lifecycle.js';
 import { Schemas } from '../../../base/common/network.js';
 import { EditorConfiguration } from '../config/editorConfiguration.js';
@@ -86,7 +78,6 @@
         return this._configuration.isSimpleWidget;
     }
     constructor(domElement, _options, codeEditorWidgetOptions, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {
-        var _a;
         super();
         this.languageConfigurationService = languageConfigurationService;
         //#region Eventing
@@ -170,7 +161,7 @@
         this._bannerDomNode = null;
         this._dropIntoEditorDecorations = this.createDecorationsCollection();
         codeEditorService.willCreateCodeEditor();
-        const options = Object.assign({}, _options);
+        const options = { ..._options };
         this._domElement = domElement;
         this._overflowWidgetsDomNode = options.overflowWidgetsDomNode;
         delete options.overflowWidgetsDomNode;
@@ -216,7 +207,7 @@
                 onUnexpectedError(new Error(`Cannot have two actions with the same id ${action.id}`));
                 continue;
             }
-            const internalAction = new InternalEditorAction(action.id, action.label, action.alias, (_a = action.precondition) !== null && _a !== void 0 ? _a : undefined, () => {
+            const internalAction = new InternalEditorAction(action.id, action.label, action.alias, action.precondition ?? undefined, () => {
                 return this._instantiationService.invokeFunction((accessor) => {
                     return Promise.resolve(action.runEditorCommand(accessor, this, null));
                 });
@@ -234,11 +225,11 @@
                     return;
                 }
                 const target = this.getTargetAtClientPoint(e.clientX, e.clientY);
-                if (target === null || target === void 0 ? void 0 : target.position) {
+                if (target?.position) {
                     this.showDropIndicatorAt(target.position);
                 }
             },
-            onDrop: (e) => __awaiter(this, void 0, void 0, function* () {
+            onDrop: async (e) => {
                 if (!isDropIntoEnabled()) {
                     return;
                 }
@@ -247,10 +238,10 @@
                     return;
                 }
                 const target = this.getTargetAtClientPoint(e.clientX, e.clientY);
-                if (target === null || target === void 0 ? void 0 : target.position) {
+                if (target?.position) {
                     this._onDropIntoEditor.fire({ position: target.position, event: e });
                 }
-            }),
+            },
             onDragLeave: () => {
                 this.removeDropIndicator();
             },
@@ -261,8 +252,7 @@
         this._codeEditorService.addCodeEditor(this);
     }
     writeScreenReaderContent(reason) {
-        var _a;
-        (_a = this._modelData) === null || _a === void 0 ? void 0 : _a.view.writeScreenReaderContent(reason);
+        this._modelData?.view.writeScreenReaderContent(reason);
     }
     _createConfiguration(isSimpleWidget, options, accessibilityService) {
         return new EditorConfiguration(isSimpleWidget, options, this._domElement, accessibilityService);
@@ -424,8 +414,7 @@
         return CodeEditorWidget_1._getVerticalOffsetAfterPosition(this._modelData, lineNumber, 1, includeViewZones);
     }
     setHiddenAreas(ranges, source) {
-        var _a;
-        (_a = this._modelData) === null || _a === void 0 ? void 0 : _a.viewModel.setHiddenAreas(ranges.map(r => Range.lift(r)), source);
+        this._modelData?.viewModel.setHiddenAreas(ranges.map(r => Range.lift(r)), source);
     }
     getVisibleColumnFromPosition(rawPosition) {
         if (!this._modelData) {
@@ -435,6 +424,14 @@
         const tabSize = this._modelData.model.getOptions().tabSize;
         return CursorColumns.visibleColumnFromColumn(this._modelData.model.getLineContent(position.lineNumber), position.column, tabSize) + 1;
     }
+    getStatusbarColumn(rawPosition) {
+        if (!this._modelData) {
+            return rawPosition.column;
+        }
+        const position = this._modelData.model.validatePosition(rawPosition);
+        const tabSize = this._modelData.model.getOptions().tabSize;
+        return CursorColumns.toStatusbarColumn(this._modelData.model.getLineContent(position.lineNumber), position.column, tabSize);
+    }
     getPosition() {
         if (!this._modelData) {
             return null;
@@ -702,8 +699,14 @@
         }
     }
     handleInitialized() {
-        var _a;
-        (_a = this._getViewModel()) === null || _a === void 0 ? void 0 : _a.visibleLinesStabilized();
+        this._getViewModel()?.visibleLinesStabilized();
+    }
+    onVisible() {
+        this._modelData?.view.refreshFocusState();
+    }
+    onHide() {
+        this._modelData?.view.refreshFocusState();
+        this._focusTracker.refreshState();
     }
     getContribution(id) {
         return this._contributions.get(id);
@@ -936,6 +939,58 @@
             changeAccessor.deltaDecorations(decorationIds, []);
         });
     }
+    setDecorationsByType(description, decorationTypeKey, decorationOptions) {
+        const newDecorationsSubTypes = {};
+        const oldDecorationsSubTypes = this._decorationTypeSubtypes[decorationTypeKey] || {};
+        this._decorationTypeSubtypes[decorationTypeKey] = newDecorationsSubTypes;
+        const newModelDecorations = [];
+        for (const decorationOption of decorationOptions) {
+            let typeKey = decorationTypeKey;
+            if (decorationOption.renderOptions) {
+                // identify custom render options by a hash code over all keys and values
+                // For custom render options register a decoration type if necessary
+                const subType = hash(decorationOption.renderOptions).toString(16);
+                // The fact that `decorationTypeKey` appears in the typeKey has no influence
+                // it is just a mechanism to get predictable and unique keys (repeatable for the same options and unique across clients)
+                typeKey = decorationTypeKey + '-' + subType;
+                if (!oldDecorationsSubTypes[subType] && !newDecorationsSubTypes[subType]) {
+                    // decoration type did not exist before, register new one
+                    this._registerDecorationType(description, typeKey, decorationOption.renderOptions, decorationTypeKey);
+                }
+                newDecorationsSubTypes[subType] = true;
+            }
+            const opts = this._resolveDecorationOptions(typeKey, !!decorationOption.hoverMessage);
+            if (decorationOption.hoverMessage) {
+                opts.hoverMessage = decorationOption.hoverMessage;
+            }
+            newModelDecorations.push({ range: decorationOption.range, options: opts });
+        }
+        // remove decoration sub types that are no longer used, deregister decoration type if necessary
+        for (const subType in oldDecorationsSubTypes) {
+            if (!newDecorationsSubTypes[subType]) {
+                this._removeDecorationType(decorationTypeKey + '-' + subType);
+            }
+        }
+        // update all decorations
+        const oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey] || [];
+        this._decorationTypeKeysToIds[decorationTypeKey] = this.deltaDecorations(oldDecorationsIds, newModelDecorations);
+    }
+    setDecorationsByTypeFast(decorationTypeKey, ranges) {
+        // remove decoration sub types that are no longer used, deregister decoration type if necessary
+        const oldDecorationsSubTypes = this._decorationTypeSubtypes[decorationTypeKey] || {};
+        for (const subType in oldDecorationsSubTypes) {
+            this._removeDecorationType(decorationTypeKey + '-' + subType);
+        }
+        this._decorationTypeSubtypes[decorationTypeKey] = {};
+        const opts = ModelDecorationOptions.createDynamic(this._resolveDecorationOptions(decorationTypeKey, false));
+        const newModelDecorations = new Array(ranges.length);
+        for (let i = 0, len = ranges.length; i < len; i++) {
+            newModelDecorations[i] = { range: ranges[i], options: opts };
+        }
+        // update all decorations
+        const oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey] || [];
+        this._decorationTypeKeysToIds[decorationTypeKey] = this.deltaDecorations(oldDecorationsIds, newModelDecorations);
+    }
     removeDecorationsByType(decorationTypeKey) {
         // remove decorations for type and sub type
         const oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey];
@@ -1193,7 +1248,7 @@
                 case 6 /* OutgoingViewModelEventKind.CursorStateChanged */: {
                     if (e.reachedMaxCursorCount) {
                         const multiCursorLimit = this.getOption(79 /* EditorOption.multiCursorLimit */);
-                        const message = nls.localize('cursors.maximum', "The number of cursors has been limited to {0}. Consider using [find and replace](https://code.visualstudio.com/docs/editor/codebasics#_find-and-replace) for larger changes or increase the editor multi cursor limit setting.", multiCursorLimit);
+                        const message = nls.localizeWithPath('vs/editor/browser/widget/codeEditorWidget', 'cursors.maximum', "The number of cursors has been limited to {0}. Consider using [find and replace](https://code.visualstudio.com/docs/editor/codebasics#_find-and-replace) for larger changes or increase the editor multi cursor limit setting.", multiCursorLimit);
                         this._notificationService.prompt(Severity.Warning, message, [
                             {
                                 label: 'Find and Replace',
@@ -1202,7 +1257,7 @@
                                 }
                             },
                             {
-                                label: nls.localize('goToSetting', 'Increase Multi Cursor Limit'),
+                                label: nls.localizeWithPath('vs/editor/browser/widget/codeEditorWidget', 'goToSetting', 'Increase Multi Cursor Limit'),
                                 run: () => {
                                     this._commandService.executeCommand('workbench.action.openSettings2', {
                                         query: 'editor.multiCursorLimit'
@@ -1351,7 +1406,7 @@
         return [view, true];
     }
     _postDetachModelCleanup(detachedModel) {
-        detachedModel === null || detachedModel === void 0 ? void 0 : detachedModel.removeAllDecorationsWithOwnerId(this._id);
+        detachedModel?.removeAllDecorationsWithOwnerId(this._id);
     }
     _detachModel() {
         if (!this._modelData) {
@@ -1370,9 +1425,18 @@
         }
         return model;
     }
+    _registerDecorationType(description, key, options, parentTypeKey) {
+        this._codeEditorService.registerDecorationType(description, key, options, parentTypeKey, this);
+    }
     _removeDecorationType(key) {
         this._codeEditorService.removeDecorationType(key);
     }
+    _resolveDecorationOptions(typeKey, writable) {
+        return this._codeEditorService.resolveDecorationOptions(typeKey, writable);
+    }
+    getTelemetryData() {
+        return this._telemetryData;
+    }
     hasModel() {
         return (this._modelData !== null);
     }
@@ -1627,6 +1691,9 @@
     hasFocus() {
         return this._hasFocus;
     }
+    refreshState() {
+        this._domFocusTracker.refreshState?.();
+    }
 }
 class EditorDecorationsCollection {
     get length() {
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/accessibleDiffViewer.js b/vs/editor/browser/widget/diffEditor/accessibleDiffViewer.js
--- a/vs/editor/browser/widget/diffEditor/accessibleDiffViewer.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/accessibleDiffViewer.js	2023-12-06 14:23:14.359854747 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { addDisposableListener, addStandardDisposableListener, reset } from '../../../../base/browser/dom.js';
 import { createTrustedTypesPolicy } from '../../../../base/browser/trustedTypes.js';
 import { ActionBar } from '../../../../base/browser/ui/actionbar/actionbar.js';
@@ -42,14 +33,14 @@
 import { LineTokens } from '../../../common/tokens/lineTokens.js';
 import { RenderLineInput, renderViewLine2 } from '../../../common/viewLayout/viewLineRenderer.js';
 import { ViewLineRenderingData } from '../../../common/viewModel.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { AudioCue, IAudioCueService } from '../../../../platform/audioCues/browser/audioCueService.js';
 import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
 import { registerIcon } from '../../../../platform/theme/common/iconRegistry.js';
 import './accessibleDiffViewer.css';
-const accessibleDiffViewerInsertIcon = registerIcon('diff-review-insert', Codicon.add, localize('accessibleDiffViewerInsertIcon', 'Icon for \'Insert\' in accessible diff viewer.'));
-const accessibleDiffViewerRemoveIcon = registerIcon('diff-review-remove', Codicon.remove, localize('accessibleDiffViewerRemoveIcon', 'Icon for \'Remove\' in accessible diff viewer.'));
-const accessibleDiffViewerCloseIcon = registerIcon('diff-review-close', Codicon.close, localize('accessibleDiffViewerCloseIcon', 'Icon for \'Close\' in accessible diff viewer.'));
+const accessibleDiffViewerInsertIcon = registerIcon('diff-review-insert', Codicon.add, localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', 'accessibleDiffViewerInsertIcon', 'Icon for \'Insert\' in accessible diff viewer.'));
+const accessibleDiffViewerRemoveIcon = registerIcon('diff-review-remove', Codicon.remove, localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', 'accessibleDiffViewerRemoveIcon', 'Icon for \'Remove\' in accessible diff viewer.'));
+const accessibleDiffViewerCloseIcon = registerIcon('diff-review-close', Codicon.close, localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', 'accessibleDiffViewerCloseIcon', 'Icon for \'Close\' in accessible diff viewer.'));
 let AccessibleDiffViewer = class AccessibleDiffViewer extends Disposable {
     constructor(_parentNode, _visible, _setVisible, _canClose, _width, _height, _diffs, _editors, _instantiationService) {
         super();
@@ -117,7 +108,7 @@
         this.groups = this._groups;
         this.currentGroup = this._currentGroupIdx.map((idx, r) => this._groups.read(r)[idx]);
         this.currentGroupIndex = this._currentGroupIdx;
-        this.currentElement = this._currentElementIdx.map((idx, r) => { var _a; return (_a = this.currentGroup.read(r)) === null || _a === void 0 ? void 0 : _a.lines[idx]; });
+        this.currentElement = this._currentElementIdx.map((idx, r) => this.currentGroup.read(r)?.lines[idx]);
         this._register(autorun(reader => {
             /** @description update groups */
             const diffs = this._diffs.read(reader);
@@ -129,7 +120,7 @@
             transaction(tx => {
                 const p = this._editors.modified.getPosition();
                 if (p) {
-                    const nextGroup = groups.findIndex(g => (p === null || p === void 0 ? void 0 : p.lineNumber) < g.range.modified.endLineNumberExclusive);
+                    const nextGroup = groups.findIndex(g => p?.lineNumber < g.range.modified.endLineNumberExclusive);
                     if (nextGroup !== -1) {
                         this._currentGroupIdx.set(nextGroup, tx);
                     }
@@ -140,20 +131,19 @@
         this._register(autorun(reader => {
             /** @description play audio-cue for diff */
             const currentViewItem = this.currentElement.read(reader);
-            if ((currentViewItem === null || currentViewItem === void 0 ? void 0 : currentViewItem.type) === LineType.Deleted) {
+            if (currentViewItem?.type === LineType.Deleted) {
                 this._audioCueService.playAudioCue(AudioCue.diffLineDeleted, { source: 'accessibleDiffViewer.currentElementChanged' });
             }
-            else if ((currentViewItem === null || currentViewItem === void 0 ? void 0 : currentViewItem.type) === LineType.Added) {
+            else if (currentViewItem?.type === LineType.Added) {
                 this._audioCueService.playAudioCue(AudioCue.diffLineInserted, { source: 'accessibleDiffViewer.currentElementChanged' });
             }
         }));
         this._register(autorun(reader => {
-            var _a;
             /** @description select lines in editor */
             // This ensures editor commands (like revert/stage) work
             const currentViewItem = this.currentElement.read(reader);
             if (currentViewItem && currentViewItem.type !== LineType.Header) {
-                const lineNumber = (_a = currentViewItem.modifiedLineNumber) !== null && _a !== void 0 ? _a : currentViewItem.diff.modified.startLineNumber;
+                const lineNumber = currentViewItem.modifiedLineNumber ?? currentViewItem.diff.modified.startLineNumber;
                 this._editors.modified.setSelection(Range.fromPositions(new Position(lineNumber, 1)));
             }
         }));
@@ -308,7 +298,7 @@
             /** @description update actions */
             this._actionBar.clear();
             if (this._model.canClose.read(reader)) {
-                this._actionBar.push(new Action('diffreview.close', localize('label.close', "Close"), 'close-diff-review ' + ThemeIcon.asClassName(accessibleDiffViewerCloseIcon), true, () => __awaiter(this, void 0, void 0, function* () { return _model.close(); })), { label: false, icon: true });
+                this._actionBar.push(new Action('diffreview.close', localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', 'label.close', "Close"), 'close-diff-review ' + ThemeIcon.asClassName(accessibleDiffViewerCloseIcon), true, async () => _model.close()), { label: false, icon: true });
             }
         }));
         this._content = document.createElement('div');
@@ -358,7 +348,7 @@
         const container = document.createElement('div');
         container.className = 'diff-review-table';
         container.setAttribute('role', 'list');
-        container.setAttribute('aria-label', localize('ariaLabel', 'Accessible Diff Viewer. Use arrow up and down to navigate.'));
+        container.setAttribute('aria-label', localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', 'ariaLabel', 'Accessible Diff Viewer. Use arrow up and down to navigate.'));
         applyFontInfo(container, modifiedOptions.get(50 /* EditorOption.fontInfo */));
         reset(this._content, container);
         const originalModel = this._editors.original.getModel();
@@ -370,7 +360,7 @@
         const modifiedModelOpts = modifiedModel.getOptions();
         const lineHeight = modifiedOptions.get(66 /* EditorOption.lineHeight */);
         const group = this._model.currentGroup.get();
-        for (const viewItem of (group === null || group === void 0 ? void 0 : group.lines) || []) {
+        for (const viewItem of group?.lines || []) {
             if (!group) {
                 break;
             }
@@ -382,12 +372,12 @@
                 const r = group.range;
                 const diffIndex = this._model.currentGroupIndex.get();
                 const diffsLength = this._model.groups.get().length;
-                const getAriaLines = (lines) => lines === 0 ? localize('no_lines_changed', "no lines changed")
-                    : lines === 1 ? localize('one_line_changed', "1 line changed")
-                        : localize('more_lines_changed', "{0} lines changed", lines);
+                const getAriaLines = (lines) => lines === 0 ? localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', 'no_lines_changed', "no lines changed")
+                    : lines === 1 ? localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', 'one_line_changed', "1 line changed")
+                        : localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', 'more_lines_changed', "{0} lines changed", lines);
                 const originalChangedLinesCntAria = getAriaLines(r.original.length);
                 const modifiedChangedLinesCntAria = getAriaLines(r.modified.length);
-                header.setAttribute('aria-label', localize({
+                header.setAttribute('aria-label', localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', {
                     key: 'header',
                     comment: [
                         'This is the ARIA label for a git diff header.',
@@ -507,23 +497,23 @@
             lineContent = originalModel.getLineContent(item.originalLineNumber);
         }
         if (lineContent.length === 0) {
-            lineContent = localize('blankLine', "blank");
+            lineContent = localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', 'blankLine', "blank");
         }
         let ariaLabel = '';
         switch (item.type) {
             case LineType.Unchanged:
                 if (item.originalLineNumber === item.modifiedLineNumber) {
-                    ariaLabel = localize({ key: 'unchangedLine', comment: ['The placeholders are contents of the line and should not be translated.'] }, "{0} unchanged line {1}", lineContent, item.originalLineNumber);
+                    ariaLabel = localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', { key: 'unchangedLine', comment: ['The placeholders are contents of the line and should not be translated.'] }, "{0} unchanged line {1}", lineContent, item.originalLineNumber);
                 }
                 else {
-                    ariaLabel = localize('equalLine', "{0} original line {1} modified line {2}", lineContent, item.originalLineNumber, item.modifiedLineNumber);
+                    ariaLabel = localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', 'equalLine', "{0} original line {1} modified line {2}", lineContent, item.originalLineNumber, item.modifiedLineNumber);
                 }
                 break;
             case LineType.Added:
-                ariaLabel = localize('insertLine', "+ {0} modified line {1}", lineContent, item.modifiedLineNumber);
+                ariaLabel = localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', 'insertLine', "+ {0} modified line {1}", lineContent, item.modifiedLineNumber);
                 break;
             case LineType.Deleted:
-                ariaLabel = localize('deleteLine', "- {0} original line {1}", lineContent, item.originalLineNumber);
+                ariaLabel = localizeWithPath('vs/editor/browser/widget/diffEditor/accessibleDiffViewer', 'deleteLine', "- {0} original line {1}", lineContent, item.originalLineNumber);
                 break;
         }
         row.setAttribute('aria-label', ariaLabel);
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/colors.js b/vs/editor/browser/widget/diffEditor/colors.js
--- a/vs/editor/browser/widget/diffEditor/colors.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/colors.js	2023-12-06 14:23:14.359854747 +0000
@@ -2,7 +2,7 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { registerColor } from '../../../../platform/theme/common/colorRegistry.js';
-export const diffMoveBorder = registerColor('diffEditor.move.border', { dark: '#8b8b8b9c', light: '#8b8b8b9c', hcDark: '#8b8b8b9c', hcLight: '#8b8b8b9c', }, localize('diffEditor.move.border', 'The border color for text that got moved in the diff editor.'));
-export const diffMoveBorderActive = registerColor('diffEditor.moveActive.border', { dark: '#FFA500', light: '#FFA500', hcDark: '#FFA500', hcLight: '#FFA500', }, localize('diffEditor.moveActive.border', 'The active border color for text that got moved in the diff editor.'));
+export const diffMoveBorder = registerColor('diffEditor.move.border', { dark: '#8b8b8b9c', light: '#8b8b8b9c', hcDark: '#8b8b8b9c', hcLight: '#8b8b8b9c', }, localizeWithPath('vs/editor/browser/widget/diffEditor/colors', 'diffEditor.move.border', 'The border color for text that got moved in the diff editor.'));
+export const diffMoveBorderActive = registerColor('diffEditor.moveActive.border', { dark: '#FFA500', light: '#FFA500', hcDark: '#FFA500', hcLight: '#FFA500', }, localizeWithPath('vs/editor/browser/widget/diffEditor/colors', 'diffEditor.moveActive.border', 'The active border color for text that got moved in the diff editor.'));
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/decorations.js b/vs/editor/browser/widget/diffEditor/decorations.js
--- a/vs/editor/browser/widget/diffEditor/decorations.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/decorations.js	2023-12-06 14:23:14.359854747 +0000
@@ -6,10 +6,10 @@
 import { MarkdownString } from '../../../../base/common/htmlContent.js';
 import { ThemeIcon } from '../../../../base/common/themables.js';
 import { ModelDecorationOptions } from '../../../common/model/textModel.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { registerIcon } from '../../../../platform/theme/common/iconRegistry.js';
-export const diffInsertIcon = registerIcon('diff-insert', Codicon.add, localize('diffInsertIcon', 'Line decoration for inserts in the diff editor.'));
-export const diffRemoveIcon = registerIcon('diff-remove', Codicon.remove, localize('diffRemoveIcon', 'Line decoration for removals in the diff editor.'));
+export const diffInsertIcon = registerIcon('diff-insert', Codicon.add, localizeWithPath('vs/editor/browser/widget/diffEditor/decorations', 'diffInsertIcon', 'Line decoration for inserts in the diff editor.'));
+export const diffRemoveIcon = registerIcon('diff-remove', Codicon.remove, localizeWithPath('vs/editor/browser/widget/diffEditor/decorations', 'diffRemoveIcon', 'Line decoration for removals in the diff editor.'));
 export const diffLineAddDecorationBackgroundWithIndicator = ModelDecorationOptions.register({
     className: 'line-insert',
     description: 'line-insert',
@@ -67,7 +67,7 @@
 export const arrowRevertChange = ModelDecorationOptions.register({
     description: 'diff-editor-arrow-revert-change',
     glyphMarginHoverMessage: new MarkdownString(undefined, { isTrusted: true, supportThemeIcons: true })
-        .appendMarkdown(localize('revertChangeHoverMessage', 'Click to revert change')),
+        .appendMarkdown(localizeWithPath('vs/editor/browser/widget/diffEditor/decorations', 'revertChangeHoverMessage', 'Click to revert change')),
     glyphMarginClassName: 'arrow-revert-change ' + ThemeIcon.asClassName(Codicon.arrowRight),
     zIndex: 10001,
 });
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/delegatingEditorImpl.js b/vs/editor/browser/widget/diffEditor/delegatingEditorImpl.js
--- a/vs/editor/browser/widget/diffEditor/delegatingEditorImpl.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/delegatingEditorImpl.js	2023-12-06 14:23:14.359854747 +0000
@@ -17,6 +17,9 @@
     getVisibleColumnFromPosition(position) {
         return this._targetEditor.getVisibleColumnFromPosition(position);
     }
+    getStatusbarColumn(position) {
+        return this._targetEditor.getStatusbarColumn(position);
+    }
     getPosition() {
         return this._targetEditor.getPosition();
     }
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/diffEditor.contribution.js b/vs/editor/browser/widget/diffEditor/diffEditor.contribution.js
--- a/vs/editor/browser/widget/diffEditor/diffEditor.contribution.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/diffEditor.contribution.js	2023-12-06 14:23:14.359854747 +0000
@@ -8,7 +8,7 @@
 import { ICodeEditorService } from '../../services/codeEditorService.js';
 import { DiffEditorWidget } from './diffEditorWidget.js';
 import { EditorContextKeys } from '../../../common/editorContextKeys.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { Action2, MenuId, MenuRegistry, registerAction2 } from '../../../../platform/actions/common/actions.js';
 import { CommandsRegistry } from '../../../../platform/commands/common/commands.js';
 import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
@@ -17,7 +17,7 @@
     constructor() {
         super({
             id: 'diffEditor.toggleCollapseUnchangedRegions',
-            title: { value: localize('toggleCollapseUnchangedRegions', "Toggle Collapse Unchanged Regions"), original: 'Toggle Collapse Unchanged Regions' },
+            title: { value: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'toggleCollapseUnchangedRegions', "Toggle Collapse Unchanged Regions"), original: 'Toggle Collapse Unchanged Regions' },
             icon: Codicon.map,
             toggled: ContextKeyExpr.has('config.diffEditor.hideUnchangedRegions.enabled'),
             precondition: ContextKeyExpr.has('isInDiffEditor'),
@@ -40,7 +40,7 @@
     constructor() {
         super({
             id: 'diffEditor.toggleShowMovedCodeBlocks',
-            title: { value: localize('toggleShowMovedCodeBlocks', "Toggle Show Moved Code Blocks"), original: 'Toggle Show Moved Code Blocks' },
+            title: { value: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'toggleShowMovedCodeBlocks', "Toggle Show Moved Code Blocks"), original: 'Toggle Show Moved Code Blocks' },
             precondition: ContextKeyExpr.has('isInDiffEditor'),
         });
     }
@@ -55,7 +55,7 @@
     constructor() {
         super({
             id: 'diffEditor.toggleUseInlineViewWhenSpaceIsLimited',
-            title: { value: localize('toggleUseInlineViewWhenSpaceIsLimited', "Toggle Use Inline View When Space Is Limited"), original: 'Toggle Use Inline View When Space Is Limited' },
+            title: { value: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'toggleUseInlineViewWhenSpaceIsLimited', "Toggle Use Inline View When Space Is Limited"), original: 'Toggle Use Inline View When Space Is Limited' },
             precondition: ContextKeyExpr.has('isInDiffEditor'),
         });
     }
@@ -69,7 +69,7 @@
 MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
     command: {
         id: new ToggleUseInlineViewWhenSpaceIsLimited().desc.id,
-        title: localize('useInlineViewWhenSpaceIsLimited', "Use Inline View When Space Is Limited"),
+        title: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'useInlineViewWhenSpaceIsLimited', "Use Inline View When Space Is Limited"),
         toggled: ContextKeyExpr.has('config.diffEditor.useInlineViewWhenSpaceIsLimited'),
         precondition: ContextKeyExpr.has('isInDiffEditor'),
     },
@@ -80,7 +80,7 @@
 MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
     command: {
         id: new ToggleShowMovedCodeBlocks().desc.id,
-        title: localize('showMoves', "Show Moved Code Blocks"),
+        title: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'showMoves', "Show Moved Code Blocks"),
         icon: Codicon.move,
         toggled: ContextKeyEqualsExpr.create('config.diffEditor.experimental.showMoves', true),
         precondition: ContextKeyExpr.has('isInDiffEditor'),
@@ -90,14 +90,14 @@
     when: ContextKeyExpr.has('isInDiffEditor'),
 });
 const diffEditorCategory = {
-    value: localize('diffEditor', 'Diff Editor'),
+    value: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'diffEditor', 'Diff Editor'),
     original: 'Diff Editor',
 };
 export class SwitchSide extends EditorAction2 {
     constructor() {
         super({
             id: 'diffEditor.switchSide',
-            title: { value: localize('switchSide', "Switch Side"), original: 'Switch Side' },
+            title: { value: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'switchSide', "Switch Side"), original: 'Switch Side' },
             icon: Codicon.arrowSwap,
             precondition: ContextKeyExpr.has('isInDiffEditor'),
             f1: true,
@@ -122,7 +122,7 @@
     constructor() {
         super({
             id: 'diffEditor.exitCompareMove',
-            title: { value: localize('exitCompareMove', "Exit Compare Move"), original: 'Exit Compare Move' },
+            title: { value: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'exitCompareMove', "Exit Compare Move"), original: 'Exit Compare Move' },
             icon: Codicon.close,
             precondition: EditorContextKeys.comparingMovedCode,
             f1: false,
@@ -145,7 +145,7 @@
     constructor() {
         super({
             id: 'diffEditor.collapseAllUnchangedRegions',
-            title: { value: localize('collapseAllUnchangedRegions', "Collapse All Unchanged Regions"), original: 'Collapse All Unchanged Regions' },
+            title: { value: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'collapseAllUnchangedRegions', "Collapse All Unchanged Regions"), original: 'Collapse All Unchanged Regions' },
             icon: Codicon.fold,
             precondition: ContextKeyExpr.has('isInDiffEditor'),
             f1: true,
@@ -164,7 +164,7 @@
     constructor() {
         super({
             id: 'diffEditor.showAllUnchangedRegions',
-            title: { value: localize('showAllUnchangedRegions', "Show All Unchanged Regions"), original: 'Show All Unchanged Regions' },
+            title: { value: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'showAllUnchangedRegions', "Show All Unchanged Regions"), original: 'Show All Unchanged Regions' },
             icon: Codicon.unfold,
             precondition: ContextKeyExpr.has('isInDiffEditor'),
             f1: true,
@@ -180,14 +180,14 @@
 }
 registerAction2(ShowAllUnchangedRegions);
 const accessibleDiffViewerCategory = {
-    value: localize('accessibleDiffViewer', 'Accessible Diff Viewer'),
+    value: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'accessibleDiffViewer', 'Accessible Diff Viewer'),
     original: 'Accessible Diff Viewer',
 };
 export class AccessibleDiffViewerNext extends Action2 {
     constructor() {
         super({
             id: AccessibleDiffViewerNext.id,
-            title: { value: localize('editor.action.accessibleDiffViewer.next', "Go to Next Difference"), original: 'Go to Next Difference' },
+            title: { value: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'editor.action.accessibleDiffViewer.next', "Go to Next Difference"), original: 'Go to Next Difference' },
             category: accessibleDiffViewerCategory,
             precondition: ContextKeyExpr.has('isInDiffEditor'),
             keybinding: {
@@ -199,14 +199,14 @@
     }
     run(accessor) {
         const diffEditor = findFocusedDiffEditor(accessor);
-        diffEditor === null || diffEditor === void 0 ? void 0 : diffEditor.accessibleDiffViewerNext();
+        diffEditor?.accessibleDiffViewerNext();
     }
 }
 AccessibleDiffViewerNext.id = 'editor.action.accessibleDiffViewer.next';
 MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
     command: {
         id: AccessibleDiffViewerNext.id,
-        title: localize('Open Accessible Diff Viewer', "Open Accessible Diff Viewer"),
+        title: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'Open Accessible Diff Viewer', "Open Accessible Diff Viewer"),
         precondition: ContextKeyExpr.has('isInDiffEditor'),
     },
     order: 10,
@@ -217,7 +217,7 @@
     constructor() {
         super({
             id: AccessibleDiffViewerPrev.id,
-            title: { value: localize('editor.action.accessibleDiffViewer.prev', "Go to Previous Difference"), original: 'Go to Previous Difference' },
+            title: { value: localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditor.contribution', 'editor.action.accessibleDiffViewer.prev', "Go to Previous Difference"), original: 'Go to Previous Difference' },
             category: accessibleDiffViewerCategory,
             precondition: ContextKeyExpr.has('isInDiffEditor'),
             keybinding: {
@@ -229,15 +229,14 @@
     }
     run(accessor) {
         const diffEditor = findFocusedDiffEditor(accessor);
-        diffEditor === null || diffEditor === void 0 ? void 0 : diffEditor.accessibleDiffViewerPrev();
+        diffEditor?.accessibleDiffViewerPrev();
     }
 }
 AccessibleDiffViewerPrev.id = 'editor.action.accessibleDiffViewer.prev';
 export function findFocusedDiffEditor(accessor) {
-    var _a;
     const codeEditorService = accessor.get(ICodeEditorService);
     const diffEditors = codeEditorService.listDiffEditors();
-    const activeCodeEditor = (_a = codeEditorService.getFocusedCodeEditor()) !== null && _a !== void 0 ? _a : codeEditorService.getActiveCodeEditor();
+    const activeCodeEditor = codeEditorService.getFocusedCodeEditor() ?? codeEditorService.getActiveCodeEditor();
     if (!activeCodeEditor) {
         return null;
     }
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/diffEditorDecorations.js b/vs/editor/browser/widget/diffEditor/diffEditorDecorations.js
--- a/vs/editor/browser/widget/diffEditor/diffEditorDecorations.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/diffEditorDecorations.js	2023-12-06 14:23:14.359854747 +0000
@@ -16,8 +16,7 @@
         this._diffModel = _diffModel;
         this._options = _options;
         this._decorations = derived(this, (reader) => {
-            var _a;
-            const diff = (_a = this._diffModel.read(reader)) === null || _a === void 0 ? void 0 : _a.diff.read(reader);
+            const diff = this._diffModel.read(reader)?.diff.read(reader);
             if (!diff) {
                 return null;
             }
@@ -93,7 +92,7 @@
             }
             return { originalDecorations, modifiedDecorations };
         });
-        this._register(applyObservableDecorations(this._editors.original, this._decorations.map(d => (d === null || d === void 0 ? void 0 : d.originalDecorations) || [])));
-        this._register(applyObservableDecorations(this._editors.modified, this._decorations.map(d => (d === null || d === void 0 ? void 0 : d.modifiedDecorations) || [])));
+        this._register(applyObservableDecorations(this._editors.original, this._decorations.map(d => d?.originalDecorations || [])));
+        this._register(applyObservableDecorations(this._editors.modified, this._decorations.map(d => d?.modifiedDecorations || [])));
     }
 }
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/diffEditorEditors.js b/vs/editor/browser/widget/diffEditor/diffEditorEditors.js
--- a/vs/editor/browser/widget/diffEditor/diffEditorEditors.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/diffEditorEditors.js	2023-12-06 14:23:14.359854747 +0000
@@ -16,10 +16,11 @@
 import { autorunHandleChanges, observableFromEvent } from '../../../../base/common/observable.js';
 import { OverviewRulerPart } from './overviewRulerPart.js';
 import { EditorOptions } from '../../../common/config/editorOptions.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
 import { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';
 let DiffEditorEditors = class DiffEditorEditors extends Disposable {
+    get onDidContentSizeChange() { return this._onDidContentSizeChange.event; }
     constructor(originalEditorElement, modifiedEditorElement, _options, codeEditorWidgetOptions, _createInnerEditor, _instantiationService, _keybindingService) {
         super();
         this.originalEditorElement = originalEditorElement;
@@ -110,20 +111,23 @@
         return result;
     }
     _adjustOptionsForSubEditor(options) {
-        const clonedOptions = Object.assign(Object.assign({}, options), { dimension: {
+        const clonedOptions = {
+            ...options,
+            dimension: {
                 height: 0,
                 width: 0
-            } });
+            },
+        };
         clonedOptions.inDiffEditor = true;
         clonedOptions.automaticLayout = false;
         // Clone scrollbar options before changing them
-        clonedOptions.scrollbar = Object.assign({}, (clonedOptions.scrollbar || {}));
+        clonedOptions.scrollbar = { ...(clonedOptions.scrollbar || {}) };
         clonedOptions.scrollbar.vertical = 'visible';
         clonedOptions.folding = false;
         clonedOptions.codeLens = this._options.diffCodeLens.get();
         clonedOptions.fixedOverflowWidgets = true;
         // Clone minimap options before changing them
-        clonedOptions.minimap = Object.assign({}, (clonedOptions.minimap || {}));
+        clonedOptions.minimap = { ...(clonedOptions.minimap || {}) };
         clonedOptions.minimap.enabled = false;
         if (this._options.hideUnchangedRegions.get()) {
             clonedOptions.stickyScroll = { enabled: false };
@@ -134,11 +138,10 @@
         return clonedOptions;
     }
     _updateAriaLabel(ariaLabel) {
-        var _a;
         if (!ariaLabel) {
             ariaLabel = '';
         }
-        const ariaNavigationTip = localize('diff-aria-navigation-tip', ' use {0} to open the accessibility help.', (_a = this._keybindingService.lookupKeybinding('editor.action.accessibilityHelp')) === null || _a === void 0 ? void 0 : _a.getAriaLabel());
+        const ariaNavigationTip = localizeWithPath('vs/editor/browser/widget/diffEditor/diffEditorEditors', 'diff-aria-navigation-tip', ' use {0} to open the accessibility help.', this._keybindingService.lookupKeybinding('editor.action.accessibilityHelp')?.getAriaLabel());
         if (this._options.accessibilityVerbose.get()) {
             return ariaLabel + ariaNavigationTip;
         }
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/diffEditorOptions.js b/vs/editor/browser/widget/diffEditor/diffEditorOptions.js
--- a/vs/editor/browser/widget/diffEditor/diffEditorOptions.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/diffEditorOptions.js	2023-12-06 14:23:14.359854747 +0000
@@ -44,17 +44,16 @@
         this.hideUnchangedRegionsRevealLineCount = derived(this, reader => this._options.read(reader).hideUnchangedRegions.revealLineCount);
         this.hideUnchangedRegionsContextLineCount = derived(this, reader => this._options.read(reader).hideUnchangedRegions.contextLineCount);
         this.hideUnchangedRegionsMinimumLineCount = derived(this, reader => this._options.read(reader).hideUnchangedRegions.minimumLineCount);
-        const optionsCopy = Object.assign(Object.assign({}, options), validateDiffEditorOptions(options, diffEditorDefaultOptions));
+        const optionsCopy = { ...options, ...validateDiffEditorOptions(options, diffEditorDefaultOptions) };
         this._options = observableValue(this, optionsCopy);
     }
     updateOptions(changedOptions) {
         const newDiffEditorOptions = validateDiffEditorOptions(changedOptions, this._options.get());
-        const newOptions = Object.assign(Object.assign(Object.assign({}, this._options.get()), changedOptions), newDiffEditorOptions);
+        const newOptions = { ...this._options.get(), ...changedOptions, ...newDiffEditorOptions };
         this._options.set(newOptions, undefined, { changedOptions: changedOptions });
     }
 }
 function validateDiffEditorOptions(options, defaults) {
-    var _a, _b, _c, _d, _e, _f, _g, _h;
     return {
         enableSplitViewResizing: validateBooleanOption(options.enableSplitViewResizing, defaults.enableSplitViewResizing),
         splitViewDefaultRatio: clampedFloat(options.splitViewDefaultRatio, 0.5, 0.1, 0.9),
@@ -71,14 +70,14 @@
         diffAlgorithm: validateStringSetOption(options.diffAlgorithm, defaults.diffAlgorithm, ['legacy', 'advanced'], { 'smart': 'legacy', 'experimental': 'advanced' }),
         accessibilityVerbose: validateBooleanOption(options.accessibilityVerbose, defaults.accessibilityVerbose),
         experimental: {
-            showMoves: validateBooleanOption((_a = options.experimental) === null || _a === void 0 ? void 0 : _a.showMoves, defaults.experimental.showMoves),
-            showEmptyDecorations: validateBooleanOption((_b = options.experimental) === null || _b === void 0 ? void 0 : _b.showEmptyDecorations, defaults.experimental.showEmptyDecorations),
+            showMoves: validateBooleanOption(options.experimental?.showMoves, defaults.experimental.showMoves),
+            showEmptyDecorations: validateBooleanOption(options.experimental?.showEmptyDecorations, defaults.experimental.showEmptyDecorations),
         },
         hideUnchangedRegions: {
-            enabled: validateBooleanOption((_d = (_c = options.hideUnchangedRegions) === null || _c === void 0 ? void 0 : _c.enabled) !== null && _d !== void 0 ? _d : (_e = options.experimental) === null || _e === void 0 ? void 0 : _e.collapseUnchangedRegions, defaults.hideUnchangedRegions.enabled),
-            contextLineCount: clampedInt((_f = options.hideUnchangedRegions) === null || _f === void 0 ? void 0 : _f.contextLineCount, defaults.hideUnchangedRegions.contextLineCount, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */),
-            minimumLineCount: clampedInt((_g = options.hideUnchangedRegions) === null || _g === void 0 ? void 0 : _g.minimumLineCount, defaults.hideUnchangedRegions.minimumLineCount, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */),
-            revealLineCount: clampedInt((_h = options.hideUnchangedRegions) === null || _h === void 0 ? void 0 : _h.revealLineCount, defaults.hideUnchangedRegions.revealLineCount, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */),
+            enabled: validateBooleanOption(options.hideUnchangedRegions?.enabled ?? options.experimental?.collapseUnchangedRegions, defaults.hideUnchangedRegions.enabled),
+            contextLineCount: clampedInt(options.hideUnchangedRegions?.contextLineCount, defaults.hideUnchangedRegions.contextLineCount, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */),
+            minimumLineCount: clampedInt(options.hideUnchangedRegions?.minimumLineCount, defaults.hideUnchangedRegions.minimumLineCount, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */),
+            revealLineCount: clampedInt(options.hideUnchangedRegions?.revealLineCount, defaults.hideUnchangedRegions.revealLineCount, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */),
         },
         isInEmbeddedEditor: validateBooleanOption(options.isInEmbeddedEditor, defaults.isInEmbeddedEditor),
         onlyShowAccessibleDiffViewer: validateBooleanOption(options.onlyShowAccessibleDiffViewer, defaults.onlyShowAccessibleDiffViewer),
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/diffEditorSash.js b/vs/editor/browser/widget/diffEditor/diffEditorSash.js
--- a/vs/editor/browser/widget/diffEditor/diffEditorSash.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/diffEditorSash.js	2023-12-06 14:23:14.359854747 +0000
@@ -13,8 +13,7 @@
         this._dimensions = _dimensions;
         this._sashRatio = observableValue(this, undefined);
         this.sashLeft = derived(this, reader => {
-            var _a;
-            const ratio = (_a = this._sashRatio.read(reader)) !== null && _a !== void 0 ? _a : this._options.splitViewDefaultRatio.read(reader);
+            const ratio = this._sashRatio.read(reader) ?? this._options.splitViewDefaultRatio.read(reader);
             return this._computeSashLeft(ratio, reader);
         });
         this._sash = this._register(new Sash(this._domNode, {
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/diffEditorViewModel.js b/vs/editor/browser/widget/diffEditor/diffEditorViewModel.js
--- a/vs/editor/browser/widget/diffEditor/diffEditorViewModel.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/diffEditorViewModel.js	2023-12-06 14:23:14.359854747 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { RunOnceScheduler } from '../../../../base/common/async.js';
 import { CancellationTokenSource } from '../../../../base/common/cancellation.js';
 import { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';
@@ -36,6 +27,9 @@
     setActiveMovedText(movedText) {
         this._activeMovedText.set(movedText, undefined);
     }
+    setHoveredMovedText(movedText) {
+        this._hoveredMovedText.set(movedText, undefined);
+    }
     constructor(model, _options, _editor, _diffProviderFactoryService) {
         super();
         this.model = model;
@@ -64,7 +58,7 @@
         this.movedTextToCompare = observableValue(this, undefined);
         this._activeMovedText = observableValue(this, undefined);
         this._hoveredMovedText = observableValue(this, undefined);
-        this.activeMovedText = derived(this, r => { var _a, _b; return (_b = (_a = this.movedTextToCompare.read(r)) !== null && _a !== void 0 ? _a : this._hoveredMovedText.read(r)) !== null && _b !== void 0 ? _b : this._activeMovedText.read(r); });
+        this.activeMovedText = derived(this, r => this.movedTextToCompare.read(r) ?? this._hoveredMovedText.read(r) ?? this._activeMovedText.read(r));
         this._cancellationTokenSource = new CancellationTokenSource();
         this._diffProvider = derived(this, reader => {
             const diffProvider = this._diffProviderFactoryService.createDiffProvider(this._editor, {
@@ -142,9 +136,8 @@
             }
             debouncer.schedule();
         }));
-        this._register(autorunWithStore((reader, store) => __awaiter(this, void 0, void 0, function* () {
+        this._register(autorunWithStore(async (reader, store) => {
             /** @description compute diff */
-            var _a, _b;
             // So that they get recomputed when these settings change
             this._options.hideUnchangedRegionsMinimumLineCount.read(reader);
             this._options.hideUnchangedRegionsContextLineCount.read(reader);
@@ -165,7 +158,7 @@
                 const edits = TextEditInfo.fromModelContentChanges(e.changes);
                 modifiedTextEditInfos = combineTextEditInfos(modifiedTextEditInfos, edits);
             }));
-            let result = yield documentDiffProvider.diffProvider.computeDiff(model.original, model.modified, {
+            let result = await documentDiffProvider.diffProvider.computeDiff(model.original, model.modified, {
                 ignoreTrimWhitespace: this._options.ignoreTrimWhitespace.read(reader),
                 maxComputationTimeMs: this._options.maxComputationTimeMs.read(reader),
                 computeMoves: this._options.showMoves.read(reader),
@@ -174,8 +167,8 @@
                 return;
             }
             result = normalizeDocumentDiff(result, model.original, model.modified);
-            result = (_a = applyOriginalEdits(result, originalTextEditInfos, model.original, model.modified)) !== null && _a !== void 0 ? _a : result;
-            result = (_b = applyModifiedEdits(result, modifiedTextEditInfos, model.original, model.modified)) !== null && _b !== void 0 ? _b : result;
+            result = applyOriginalEdits(result, originalTextEditInfos, model.original, model.modified) ?? result;
+            result = applyModifiedEdits(result, modifiedTextEditInfos, model.original, model.modified) ?? result;
             transaction(tx => {
                 updateUnchangedRegions(result, tx);
                 this._lastDiff = result;
@@ -185,11 +178,10 @@
                 const currentSyncedMovedText = this.movedTextToCompare.get();
                 this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);
             });
-        })));
+        }));
     }
     ensureModifiedLineIsVisible(lineNumber, tx) {
-        var _a;
-        if (((_a = this.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0) {
+        if (this.diff.get()?.mappings.length === 0) {
             return;
         }
         const unchangedRegions = this._unchangedRegions.get().regions;
@@ -201,8 +193,7 @@
         }
     }
     ensureOriginalLineIsVisible(lineNumber, tx) {
-        var _a;
-        if (((_a = this.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0) {
+        if (this.diff.get()?.mappings.length === 0) {
             return;
         }
         const unchangedRegions = this._unchangedRegions.get().regions;
@@ -213,10 +204,8 @@
             }
         }
     }
-    waitForDiff() {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield waitForState(this.isDiffUpToDate, s => s);
-        });
+    async waitForDiff() {
+        await waitForState(this.isDiffUpToDate, s => s);
     }
     serializeState() {
         const regions = this._unchangedRegions.get();
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/diffEditorWidget.js b/vs/editor/browser/widget/diffEditor/diffEditorWidget.js
--- a/vs/editor/browser/widget/diffEditor/diffEditorWidget.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/diffEditorWidget.js	2023-12-06 14:23:14.359854747 +0000
@@ -45,8 +45,9 @@
 import { DiffEditorOptions } from './diffEditorOptions.js';
 import { DiffEditorViewModel } from './diffEditorViewModel.js';
 let DiffEditorWidget = class DiffEditorWidget extends DelegatingEditor {
+    get onDidContentSizeChange() { return this._editors.onDidContentSizeChange; }
+    get collapseUnchangedRegions() { return this._options.hideUnchangedRegions.get(); }
     constructor(_domElement, options, codeEditorWidgetOptions, _parentContextKeyService, _parentInstantiationService, codeEditorService, _audioCueService, _editorProgressService) {
-        var _a;
         super();
         this._domElement = _domElement;
         this._parentContextKeyService = _parentContextKeyService;
@@ -70,13 +71,12 @@
             : this._accessibleDiffViewerShouldBeVisible.read(reader));
         this.movedBlocksLinesPart = observableValue(this, undefined);
         this._layoutInfo = derived(this, reader => {
-            var _a, _b, _c;
             const width = this._rootSizeObserver.width.read(reader);
             const height = this._rootSizeObserver.height.read(reader);
-            const sashLeft = (_a = this._sash.read(reader)) === null || _a === void 0 ? void 0 : _a.sashLeft.read(reader);
-            const originalWidth = sashLeft !== null && sashLeft !== void 0 ? sashLeft : Math.max(5, this._editors.original.getLayoutInfo().decorationsLeft);
+            const sashLeft = this._sash.read(reader)?.sashLeft.read(reader);
+            const originalWidth = sashLeft ?? Math.max(5, this._editors.original.getLayoutInfo().decorationsLeft);
             const modifiedWidth = width - originalWidth - (this._options.renderOverviewRuler.read(reader) ? OverviewRulerPart.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);
-            const movedBlocksLinesWidth = (_c = (_b = this.movedBlocksLinesPart.read(reader)) === null || _b === void 0 ? void 0 : _b.width.read(reader)) !== null && _c !== void 0 ? _c : 0;
+            const movedBlocksLinesWidth = this.movedBlocksLinesPart.read(reader)?.width.read(reader) ?? 0;
             const originalWidthWithoutMovedBlockLines = originalWidth - movedBlocksLinesWidth;
             this.elements.original.style.width = originalWidthWithoutMovedBlockLines + 'px';
             this.elements.original.style.left = '0px';
@@ -89,14 +89,14 @@
                 originalEditor: this._editors.original.getLayoutInfo(),
             };
         });
-        this._diffValue = this._diffModel.map((m, r) => m === null || m === void 0 ? void 0 : m.diff.read(r));
+        this._diffValue = this._diffModel.map((m, r) => m?.diff.read(r));
         this.onDidUpdateDiff = Event.fromObservableLight(this._diffValue);
         codeEditorService.willCreateDiffEditor();
         this._contextKeyService.createKey('isInDiffEditor', true);
         this._domElement.appendChild(this.elements.root);
         this._register(toDisposable(() => this._domElement.removeChild(this.elements.root)));
         this._rootSizeObserver = this._register(new ObservableElementSizeObserver(this.elements.root, options.dimension));
-        this._rootSizeObserver.setAutomaticLayout((_a = options.automaticLayout) !== null && _a !== void 0 ? _a : false);
+        this._rootSizeObserver.setAutomaticLayout(options.automaticLayout ?? false);
         this._options = new DiffEditorOptions(options, this._rootSizeObserver.width);
         this._contextKeyService.createKey(EditorContextKeys.isEmbeddedDiffEditor.key, false);
         const isEmbeddedDiffEditorKey = EditorContextKeys.isEmbeddedDiffEditor.bindTo(this._contextKeyService);
@@ -106,9 +106,8 @@
         }));
         const comparingMovedCodeKey = EditorContextKeys.comparingMovedCode.bindTo(this._contextKeyService);
         this._register(autorun(reader => {
-            var _a;
             /** @description update comparingMovedCodeKey */
-            comparingMovedCodeKey.set(!!((_a = this._diffModel.read(reader)) === null || _a === void 0 ? void 0 : _a.movedTextToCompare.read(reader)));
+            comparingMovedCodeKey.set(!!this._diffModel.read(reader)?.movedTextToCompare.read(reader));
         }));
         const diffEditorRenderSideBySideInlineBreakpointReachedContextKeyValue = EditorContextKeys.diffEditorRenderSideBySideInlineBreakpointReached.bindTo(this._contextKeyService);
         this._register(autorun(reader => {
@@ -154,7 +153,7 @@
         }));
         this._register(autorunWithStore((reader, store) => {
             /** @description _accessibleDiffViewer */
-            this._accessibleDiffViewer = store.add(this._register(this._instantiationService.createInstance(readHotReloadableExport(AccessibleDiffViewer, reader), this.elements.accessibleDiffViewer, this._accessibleDiffViewerVisible, (visible, tx) => this._accessibleDiffViewerShouldBeVisible.set(visible, tx), this._options.onlyShowAccessibleDiffViewer.map(v => !v), this._rootSizeObserver.width, this._rootSizeObserver.height, this._diffModel.map((m, r) => { var _a; return (_a = m === null || m === void 0 ? void 0 : m.diff.read(r)) === null || _a === void 0 ? void 0 : _a.mappings.map(m => m.lineRangeMapping); }), this._editors)));
+            this._accessibleDiffViewer = store.add(this._register(this._instantiationService.createInstance(readHotReloadableExport(AccessibleDiffViewer, reader), this.elements.accessibleDiffViewer, this._accessibleDiffViewerVisible, (visible, tx) => this._accessibleDiffViewerShouldBeVisible.set(visible, tx), this._options.onlyShowAccessibleDiffViewer.map(v => !v), this._rootSizeObserver.width, this._rootSizeObserver.height, this._diffModel.map((m, r) => m?.diff.read(r)?.mappings.map(m => m.lineRangeMapping)), this._editors)));
         }));
         const visibility = this._accessibleDiffViewerVisible.map(v => v ? 'hidden' : 'visible');
         this._register(applyStyle(this.elements.modified, { visibility }));
@@ -167,27 +166,23 @@
         }));
         this._register(applyStyle(this.elements.overlay, {
             width: this._layoutInfo.map((i, r) => i.originalEditor.width + (this._options.renderSideBySide.read(r) ? 0 : i.modifiedEditor.width)),
-            visibility: derived(reader => /** @description visibility */ {
-                var _a, _b;
-                return (this._options.hideUnchangedRegions.read(reader) && ((_b = (_a = this._diffModel.read(reader)) === null || _a === void 0 ? void 0 : _a.diff.read(reader)) === null || _b === void 0 ? void 0 : _b.mappings.length) === 0)
-                    ? 'visible' : 'hidden';
-            }),
+            visibility: derived(reader => /** @description visibility */ (this._options.hideUnchangedRegions.read(reader) && this._diffModel.read(reader)?.diff.read(reader)?.mappings.length === 0)
+                ? 'visible' : 'hidden'),
         }));
         // Revert change when an arrow is clicked.
         this._register(this._editors.modified.onMouseDown(event => {
-            var _a, _b;
-            if (!event.event.rightButton && event.target.position && ((_a = event.target.element) === null || _a === void 0 ? void 0 : _a.className.includes('arrow-revert-change'))) {
+            if (!event.event.rightButton && event.target.position && event.target.element?.className.includes('arrow-revert-change')) {
                 const lineNumber = event.target.position.lineNumber;
                 const viewZone = event.target;
                 const model = this._diffModel.get();
                 if (!model) {
                     return;
                 }
-                const diffs = (_b = model.diff.get()) === null || _b === void 0 ? void 0 : _b.mappings;
+                const diffs = model.diff.get()?.mappings;
                 if (!diffs) {
                     return;
                 }
-                const diff = diffs.find(d => (viewZone === null || viewZone === void 0 ? void 0 : viewZone.detail.afterLineNumber) === d.lineRangeMapping.modified.startLineNumber - 1 ||
+                const diff = diffs.find(d => viewZone?.detail.afterLineNumber === d.lineRangeMapping.modified.startLineNumber - 1 ||
                     d.lineRangeMapping.modified.startLineNumber === lineNumber);
                 if (!diff) {
                     return;
@@ -197,13 +192,12 @@
             }
         }));
         this._register(Event.runAndSubscribe(this._editors.modified.onDidChangeCursorPosition, (e) => {
-            var _a, _b;
-            if ((e === null || e === void 0 ? void 0 : e.reason) === 3 /* CursorChangeReason.Explicit */) {
-                const diff = (_b = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get()) === null || _b === void 0 ? void 0 : _b.mappings.find(m => m.lineRangeMapping.modified.contains(e.position.lineNumber));
-                if (diff === null || diff === void 0 ? void 0 : diff.lineRangeMapping.modified.isEmpty) {
+            if (e?.reason === 3 /* CursorChangeReason.Explicit */) {
+                const diff = this._diffModel.get()?.diff.get()?.mappings.find(m => m.lineRangeMapping.modified.contains(e.position.lineNumber));
+                if (diff?.lineRangeMapping.modified.isEmpty) {
                     this._audioCueService.playAudioCue(AudioCue.diffLineDeleted, { source: 'diffEditor.cursorPositionChanged' });
                 }
-                else if (diff === null || diff === void 0 ? void 0 : diff.lineRangeMapping.original.isEmpty) {
+                else if (diff?.lineRangeMapping.original.isEmpty) {
                     this._audioCueService.playAudioCue(AudioCue.diffLineInserted, { source: 'diffEditor.cursorPositionChanged' });
                 }
                 else if (diff) {
@@ -211,7 +205,7 @@
                 }
             }
         }));
-        const isDiffUpToDate = this._diffModel.map((m, reader) => m === null || m === void 0 ? void 0 : m.isDiffUpToDate.read(reader));
+        const isDiffUpToDate = this._diffModel.map((m, reader) => m?.isDiffUpToDate.read(reader));
         this._register(autorunWithStore((reader, store) => {
             if (isDiffUpToDate.read(reader) === false) {
                 const r = this._editorProgressService.show(true, 1000);
@@ -219,6 +213,12 @@
             }
         }));
     }
+    getViewWidth() {
+        return this._rootSizeObserver.width.get();
+    }
+    getContentHeight() {
+        return this._editors.modified.getContentHeight();
+    }
     _createInnerEditor(instantiationService, container, options, editorWidgetOptions) {
         const editor = instantiationService.createInstance(CodeEditorWidget, container, options, editorWidgetOptions);
         return editor;
@@ -236,33 +236,40 @@
     }
     get _targetEditor() { return this._editors.modified; }
     getEditorType() { return EditorType.IDiffEditor; }
+    onVisible() {
+        // TODO: Only compute diffs when diff editor is visible
+        this._editors.original.onVisible();
+        this._editors.modified.onVisible();
+    }
+    onHide() {
+        this._editors.original.onHide();
+        this._editors.modified.onHide();
+    }
     layout(dimension) { this._rootSizeObserver.observe(dimension); }
     hasTextFocus() { return this._editors.original.hasTextFocus() || this._editors.modified.hasTextFocus(); }
     saveViewState() {
-        var _a;
         const originalViewState = this._editors.original.saveViewState();
         const modifiedViewState = this._editors.modified.saveViewState();
         return {
             original: originalViewState,
             modified: modifiedViewState,
-            modelState: (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.serializeState(),
+            modelState: this._diffModel.get()?.serializeState(),
         };
     }
     restoreViewState(s) {
-        var _a;
         if (s && s.original && s.modified) {
             const diffEditorState = s;
             this._editors.original.restoreViewState(diffEditorState.original);
             this._editors.modified.restoreViewState(diffEditorState.modified);
             if (diffEditorState.modelState) {
-                (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.restoreSerializedState(diffEditorState.modelState);
+                this._diffModel.get()?.restoreSerializedState(diffEditorState.modelState);
             }
         }
     }
     createViewModel(model) {
         return this._instantiationService.createInstance(DiffEditorViewModel, model, this._options, this);
     }
-    getModel() { var _a, _b; return (_b = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.model) !== null && _b !== void 0 ? _b : null; }
+    getModel() { return this._diffModel.get()?.model ?? null; }
     setModel(model) {
         if (!model && this._diffModel.get()) {
             // Transitioning from a model to no-model
@@ -284,20 +291,36 @@
     getContainerDomNode() { return this._domElement; }
     getOriginalEditor() { return this._editors.original; }
     getModifiedEditor() { return this._editors.modified; }
+    setBoundarySashes(sashes) {
+        this._boundarySashes.set(sashes, undefined);
+    }
+    get ignoreTrimWhitespace() { return this._options.ignoreTrimWhitespace.get(); }
+    get maxComputationTime() { return this._options.maxComputationTimeMs.get(); }
+    get renderSideBySide() { return this._options.renderSideBySide.get(); }
     /**
      * @deprecated Use `this.getDiffComputationResult().changes2` instead.
      */
     getLineChanges() {
-        var _a;
-        const diffState = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get();
+        const diffState = this._diffModel.get()?.diff.get();
         if (!diffState) {
             return null;
         }
         return toLineChanges(diffState);
     }
+    getDiffComputationResult() {
+        const diffState = this._diffModel.get()?.diff.get();
+        if (!diffState) {
+            return null;
+        }
+        return {
+            changes: this.getLineChanges(),
+            changes2: diffState.mappings.map(m => m.lineRangeMapping),
+            identical: diffState.identical,
+            quitEarly: diffState.quitEarly,
+        };
+    }
     revert(diff) {
-        var _a;
-        const model = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.model;
+        const model = this._diffModel.get()?.model;
         if (!model) {
             return;
         }
@@ -314,17 +337,65 @@
             ];
         this._editors.modified.executeEdits('diffEditor', changes);
     }
+    _goTo(diff) {
+        this._editors.modified.setPosition(new Position(diff.lineRangeMapping.modified.startLineNumber, 1));
+        this._editors.modified.revealRangeInCenter(diff.lineRangeMapping.modified.toExclusiveRange());
+    }
+    goToDiff(target) {
+        const diffs = this._diffModel.get()?.diff.get()?.mappings;
+        if (!diffs || diffs.length === 0) {
+            return;
+        }
+        const curLineNumber = this._editors.modified.getPosition().lineNumber;
+        let diff;
+        if (target === 'next') {
+            diff = diffs.find(d => d.lineRangeMapping.modified.startLineNumber > curLineNumber) ?? diffs[0];
+        }
+        else {
+            diff = findLast(diffs, d => d.lineRangeMapping.modified.startLineNumber < curLineNumber) ?? diffs[diffs.length - 1];
+        }
+        this._goTo(diff);
+        if (diff.lineRangeMapping.modified.isEmpty) {
+            this._audioCueService.playAudioCue(AudioCue.diffLineDeleted, { source: 'diffEditor.goToDiff' });
+        }
+        else if (diff.lineRangeMapping.original.isEmpty) {
+            this._audioCueService.playAudioCue(AudioCue.diffLineInserted, { source: 'diffEditor.goToDiff' });
+        }
+        else if (diff) {
+            this._audioCueService.playAudioCue(AudioCue.diffLineModified, { source: 'diffEditor.goToDiff' });
+        }
+    }
+    revealFirstDiff() {
+        const diffModel = this._diffModel.get();
+        if (!diffModel) {
+            return;
+        }
+        // wait for the diff computation to finish
+        this.waitForDiff().then(() => {
+            const diffs = diffModel.diff.get()?.mappings;
+            if (!diffs || diffs.length === 0) {
+                return;
+            }
+            this._goTo(diffs[0]);
+        });
+    }
     accessibleDiffViewerNext() { this._accessibleDiffViewer.next(); }
     accessibleDiffViewerPrev() { this._accessibleDiffViewer.prev(); }
+    async waitForDiff() {
+        const diffModel = this._diffModel.get();
+        if (!diffModel) {
+            return;
+        }
+        await diffModel.waitForDiff();
+    }
     mapToOtherSide() {
-        var _a, _b;
         const isModifiedFocus = this._editors.modified.hasWidgetFocus();
         const source = isModifiedFocus ? this._editors.modified : this._editors.original;
         const destination = isModifiedFocus ? this._editors.original : this._editors.modified;
         let destinationSelection;
         const sourceSelection = source.getSelection();
         if (sourceSelection) {
-            const mappings = (_b = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get()) === null || _b === void 0 ? void 0 : _b.mappings.map(m => isModifiedFocus ? m.lineRangeMapping.flip() : m.lineRangeMapping);
+            const mappings = this._diffModel.get()?.diff.get()?.mappings.map(m => isModifiedFocus ? m.lineRangeMapping.flip() : m.lineRangeMapping);
             if (mappings) {
                 const newRange1 = translatePosition(sourceSelection.getStartPosition(), mappings);
                 const newRange2 = translatePosition(sourceSelection.getEndPosition(), mappings);
@@ -348,8 +419,7 @@
         model.movedTextToCompare.set(undefined, undefined);
     }
     collapseAllUnchangedRegions() {
-        var _a;
-        const unchangedRegions = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.unchangedRegions.get();
+        const unchangedRegions = this._diffModel.get()?.unchangedRegions.get();
         if (!unchangedRegions) {
             return;
         }
@@ -360,8 +430,7 @@
         });
     }
     showAllUnchangedRegions() {
-        var _a;
-        const unchangedRegions = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.unchangedRegions.get();
+        const unchangedRegions = this._diffModel.get()?.unchangedRegions.get();
         if (!unchangedRegions) {
             return;
         }
@@ -372,6 +441,7 @@
         });
     }
 };
+DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH = OverviewRulerPart.ENTIRE_DIFF_OVERVIEW_WIDTH;
 DiffEditorWidget = __decorate([
     __param(3, IContextKeyService),
     __param(4, IInstantiationService),
@@ -456,7 +526,7 @@
             originalEndLineNumber,
             modifiedStartLineNumber,
             modifiedEndLineNumber,
-            charChanges: innerChanges === null || innerChanges === void 0 ? void 0 : innerChanges.map(m => ({
+            charChanges: innerChanges?.map(m => ({
                 originalStartLineNumber: m.originalRange.startLineNumber,
                 originalStartColumn: m.originalRange.startColumn,
                 originalEndLineNumber: m.originalRange.endLineNumber,
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/hideUnchangedRegionsFeature.js b/vs/editor/browser/widget/diffEditor/hideUnchangedRegionsFeature.js
--- a/vs/editor/browser/widget/diffEditor/hideUnchangedRegionsFeature.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/hideUnchangedRegionsFeature.js	2023-12-06 14:23:14.359854747 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { $, addDisposableListener, h, reset } from '../../../../base/browser/dom.js';
 import { renderIcon, renderLabelWithIcons } from '../../../../base/browser/ui/iconLabel/iconLabels.js';
 import { compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';
@@ -37,7 +28,7 @@
 import { Range } from '../../../common/core/range.js';
 import { SymbolKinds } from '../../../common/languages.js';
 import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 let HideUnchangedRegionsFeature = class HideUnchangedRegionsFeature extends Disposable {
     get isUpdatingViewZones() { return this._isUpdatingViewZones; }
     constructor(_editors, _diffModel, _options, _languageFeaturesService) {
@@ -59,8 +50,8 @@
                 const m = this._diffModel.get();
                 transaction(tx => {
                     for (const s of this._editors.original.getSelections() || []) {
-                        m === null || m === void 0 ? void 0 : m.ensureOriginalLineIsVisible(s.getStartPosition().lineNumber, tx);
-                        m === null || m === void 0 ? void 0 : m.ensureOriginalLineIsVisible(s.getEndPosition().lineNumber, tx);
+                        m?.ensureOriginalLineIsVisible(s.getStartPosition().lineNumber, tx);
+                        m?.ensureOriginalLineIsVisible(s.getEndPosition().lineNumber, tx);
                     }
                 });
             }
@@ -70,13 +61,13 @@
                 const m = this._diffModel.get();
                 transaction(tx => {
                     for (const s of this._editors.modified.getSelections() || []) {
-                        m === null || m === void 0 ? void 0 : m.ensureModifiedLineIsVisible(s.getStartPosition().lineNumber, tx);
-                        m === null || m === void 0 ? void 0 : m.ensureModifiedLineIsVisible(s.getEndPosition().lineNumber, tx);
+                        m?.ensureModifiedLineIsVisible(s.getStartPosition().lineNumber, tx);
+                        m?.ensureModifiedLineIsVisible(s.getEndPosition().lineNumber, tx);
                     }
                 });
             }
         }));
-        const unchangedRegions = this._diffModel.map((m, reader) => { var _a, _b; return ((_a = m === null || m === void 0 ? void 0 : m.diff.read(reader)) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0 ? [] : (_b = m === null || m === void 0 ? void 0 : m.unchangedRegions.read(reader)) !== null && _b !== void 0 ? _b : []; });
+        const unchangedRegions = this._diffModel.map((m, reader) => m?.diff.read(reader)?.mappings.length === 0 ? [] : m?.unchangedRegions.read(reader) ?? []);
         const viewZones = derivedWithStore(this, (reader, store) => {
             /** @description view Zones */
             const modifiedOutlineSource = this._modifiedOutlineSource.read(reader);
@@ -114,7 +105,7 @@
         const unchangedLinesDecorationShow = {
             description: 'Fold Unchanged',
             glyphMarginHoverMessage: new MarkdownString(undefined, { isTrusted: true, supportThemeIcons: true })
-                .appendMarkdown(localize('foldUnchanged', 'Fold Unchanged Region')),
+                .appendMarkdown(localizeWithPath('vs/editor/browser/widget/diffEditor/hideUnchangedRegionsFeature', 'foldUnchanged', 'Fold Unchanged Region')),
             glyphMarginClassName: 'fold-unchanged ' + ThemeIcon.asClassName(Codicon.fold),
             zIndex: 10001,
         };
@@ -161,8 +152,7 @@
             this._editors.modified.setHiddenAreas(curUnchangedRegions.map(r => r.getHiddenModifiedRange(reader).toInclusiveRange()).filter(isDefined));
         }));
         this._register(this._editors.modified.onMouseUp(event => {
-            var _a;
-            if (!event.event.rightButton && event.target.position && ((_a = event.target.element) === null || _a === void 0 ? void 0 : _a.className.includes('fold-unchanged'))) {
+            if (!event.event.rightButton && event.target.position && event.target.element?.className.includes('fold-unchanged')) {
                 const lineNumber = event.target.position.lineNumber;
                 const model = this._diffModel.get();
                 if (!model) {
@@ -178,8 +168,7 @@
             }
         }));
         this._register(this._editors.original.onMouseUp(event => {
-            var _a;
-            if (!event.event.rightButton && event.target.position && ((_a = event.target.element) === null || _a === void 0 ? void 0 : _a.className.includes('fold-unchanged'))) {
+            if (!event.event.rightButton && event.target.position && event.target.element?.className.includes('fold-unchanged')) {
                 const lineNumber = event.target.position.lineNumber;
                 const model = this._diffModel.get();
                 if (!model) {
@@ -208,16 +197,16 @@
         this._currentModel = observableValue(this, undefined);
         const documentSymbolProviderChanged = observableSignalFromEvent('documentSymbolProvider.onDidChange', this._languageFeaturesService.documentSymbolProvider.onDidChange);
         const textModelChanged = observableSignalFromEvent('_textModel.onDidChangeContent', Event.debounce(e => this._textModel.onDidChangeContent(e), () => undefined, 100));
-        this._register(autorunWithStore((reader, store) => __awaiter(this, void 0, void 0, function* () {
+        this._register(autorunWithStore(async (reader, store) => {
             documentSymbolProviderChanged.read(reader);
             textModelChanged.read(reader);
             const src = store.add(new DisposableCancellationTokenSource());
-            const model = yield OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, this._textModel, src.token);
+            const model = await OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, this._textModel, src.token);
             if (store.isDisposed) {
                 return;
             }
             this._currentModel.set(model, undefined);
-        })));
+        }));
     }
     getBreadcrumbItems(startRange, reader) {
         const m = this._currentModel.read(reader);
@@ -245,12 +234,12 @@
         this._revealModifiedHiddenLine = _revealModifiedHiddenLine;
         this._options = _options;
         this._nodes = h('div.diff-hidden-lines', [
-            h('div.top@top', { title: localize('diff.hiddenLines.top', 'Click or drag to show more above') }),
+            h('div.top@top', { title: localizeWithPath('vs/editor/browser/widget/diffEditor/hideUnchangedRegionsFeature', 'diff.hiddenLines.top', 'Click or drag to show more above') }),
             h('div.center@content', { style: { display: 'flex' } }, [
-                h('div@first', { style: { display: 'flex', justifyContent: 'center', alignItems: 'center', flexShrink: '0' } }, [$('a', { title: localize('showAll', 'Show all'), role: 'button', onclick: () => { this._unchangedRegion.showAll(undefined); } }, ...renderLabelWithIcons('$(unfold)'))]),
+                h('div@first', { style: { display: 'flex', justifyContent: 'center', alignItems: 'center', flexShrink: '0' } }, [$('a', { title: localizeWithPath('vs/editor/browser/widget/diffEditor/hideUnchangedRegionsFeature', 'showAll', 'Show all'), role: 'button', onclick: () => { this._unchangedRegion.showAll(undefined); } }, ...renderLabelWithIcons('$(unfold)'))]),
                 h('div@others', { style: { display: 'flex', justifyContent: 'center', alignItems: 'center' } }),
             ]),
-            h('div.bottom@bottom', { title: localize('diff.bottom', 'Click or drag to show more below'), role: 'button' }),
+            h('div.bottom@bottom', { title: localizeWithPath('vs/editor/browser/widget/diffEditor/hideUnchangedRegionsFeature', 'diff.bottom', 'Click or drag to show more below'), role: 'button' }),
         ]);
         root.root.appendChild(this._nodes.root);
         const layoutInfo = observableFromEvent(this._editor.onDidLayoutChange, () => this._editor.getLayoutInfo());
@@ -332,8 +321,8 @@
             const children = [];
             if (!this.hide) {
                 const lineCount = _unchangedRegion.getHiddenModifiedRange(reader).length;
-                const linesHiddenText = localize('hiddenLines', '{0} hidden lines', lineCount);
-                const span = $('span', { title: localize('diff.hiddenLines.expandAll', 'Double click to unfold') }, linesHiddenText);
+                const linesHiddenText = localizeWithPath('vs/editor/browser/widget/diffEditor/hideUnchangedRegionsFeature', 'hiddenLines', '{0} hidden lines', lineCount);
+                const span = $('span', { title: localizeWithPath('vs/editor/browser/widget/diffEditor/hideUnchangedRegionsFeature', 'diff.hiddenLines.expandAll', 'Double click to unfold') }, linesHiddenText);
                 span.addEventListener('dblclick', e => {
                     if (e.button !== 0) {
                         return;
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/inlineDiffDeletedCodeMargin.js b/vs/editor/browser/widget/diffEditor/inlineDiffDeletedCodeMargin.js
--- a/vs/editor/browser/widget/diffEditor/inlineDiffDeletedCodeMargin.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/inlineDiffDeletedCodeMargin.js	2023-12-06 14:23:14.359854747 +0000
@@ -2,22 +2,13 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { addStandardDisposableListener, getDomNodePagePosition } from '../../../../base/browser/dom.js';
 import { Action } from '../../../../base/common/actions.js';
 import { Codicon } from '../../../../base/common/codicons.js';
 import { Disposable } from '../../../../base/common/lifecycle.js';
 import { isIOS } from '../../../../base/common/platform.js';
 import { ThemeIcon } from '../../../../base/common/themables.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 export class InlineDiffDeletedCodeMargin extends Disposable {
     get visibility() {
         return this._visibility;
@@ -54,9 +45,8 @@
         let currentLineNumberOffset = 0;
         const useShadowDOM = _modifiedEditor.getOption(126 /* EditorOption.useShadowDOM */) && !isIOS; // Do not use shadow dom on IOS #122035
         const showContextMenu = (x, y) => {
-            var _a;
             this._contextMenuService.showContextMenu({
-                domForShadowRoot: useShadowDOM ? (_a = _modifiedEditor.getDomNode()) !== null && _a !== void 0 ? _a : undefined : undefined,
+                domForShadowRoot: useShadowDOM ? _modifiedEditor.getDomNode() ?? undefined : undefined,
                 getAnchor: () => ({ x, y }),
                 getActions: () => {
                     const actions = [];
@@ -64,32 +54,32 @@
                     // default action
                     actions.push(new Action('diff.clipboard.copyDeletedContent', isDeletion
                         ? (_diff.original.length > 1
-                            ? localize('diff.clipboard.copyDeletedLinesContent.label', "Copy deleted lines")
-                            : localize('diff.clipboard.copyDeletedLinesContent.single.label', "Copy deleted line"))
+                            ? localizeWithPath('vs/editor/browser/widget/diffEditor/inlineDiffDeletedCodeMargin', 'diff.clipboard.copyDeletedLinesContent.label', "Copy deleted lines")
+                            : localizeWithPath('vs/editor/browser/widget/diffEditor/inlineDiffDeletedCodeMargin', 'diff.clipboard.copyDeletedLinesContent.single.label', "Copy deleted line"))
                         : (_diff.original.length > 1
-                            ? localize('diff.clipboard.copyChangedLinesContent.label', "Copy changed lines")
-                            : localize('diff.clipboard.copyChangedLinesContent.single.label', "Copy changed line")), undefined, true, () => __awaiter(this, void 0, void 0, function* () {
+                            ? localizeWithPath('vs/editor/browser/widget/diffEditor/inlineDiffDeletedCodeMargin', 'diff.clipboard.copyChangedLinesContent.label', "Copy changed lines")
+                            : localizeWithPath('vs/editor/browser/widget/diffEditor/inlineDiffDeletedCodeMargin', 'diff.clipboard.copyChangedLinesContent.single.label', "Copy changed line")), undefined, true, async () => {
                         const originalText = this._originalTextModel.getValueInRange(_diff.original.toExclusiveRange());
-                        yield this._clipboardService.writeText(originalText);
-                    })));
+                        await this._clipboardService.writeText(originalText);
+                    }));
                     if (_diff.original.length > 1) {
                         actions.push(new Action('diff.clipboard.copyDeletedLineContent', isDeletion
-                            ? localize('diff.clipboard.copyDeletedLineContent.label', "Copy deleted line ({0})", _diff.original.startLineNumber + currentLineNumberOffset)
-                            : localize('diff.clipboard.copyChangedLineContent.label', "Copy changed line ({0})", _diff.original.startLineNumber + currentLineNumberOffset), undefined, true, () => __awaiter(this, void 0, void 0, function* () {
+                            ? localizeWithPath('vs/editor/browser/widget/diffEditor/inlineDiffDeletedCodeMargin', 'diff.clipboard.copyDeletedLineContent.label', "Copy deleted line ({0})", _diff.original.startLineNumber + currentLineNumberOffset)
+                            : localizeWithPath('vs/editor/browser/widget/diffEditor/inlineDiffDeletedCodeMargin', 'diff.clipboard.copyChangedLineContent.label', "Copy changed line ({0})", _diff.original.startLineNumber + currentLineNumberOffset), undefined, true, async () => {
                             let lineContent = this._originalTextModel.getLineContent(_diff.original.startLineNumber + currentLineNumberOffset);
                             if (lineContent === '') {
                                 // empty line -> new line
                                 const eof = this._originalTextModel.getEndOfLineSequence();
                                 lineContent = eof === 0 /* EndOfLineSequence.LF */ ? '\n' : '\r\n';
                             }
-                            yield this._clipboardService.writeText(lineContent);
-                        })));
+                            await this._clipboardService.writeText(lineContent);
+                        }));
                     }
                     const readOnly = _modifiedEditor.getOption(90 /* EditorOption.readOnly */);
                     if (!readOnly) {
-                        actions.push(new Action('diff.inline.revertChange', localize('diff.inline.revertChange.label', "Revert this change"), undefined, true, () => __awaiter(this, void 0, void 0, function* () {
+                        actions.push(new Action('diff.inline.revertChange', localizeWithPath('vs/editor/browser/widget/diffEditor/inlineDiffDeletedCodeMargin', 'diff.inline.revertChange.label', "Revert this change"), undefined, true, async () => {
                             this._editor.revert(this._diff);
-                        })));
+                        }));
                     }
                     return actions;
                 },
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/lineAlignment.js b/vs/editor/browser/widget/diffEditor/lineAlignment.js
--- a/vs/editor/browser/widget/diffEditor/lineAlignment.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/lineAlignment.js	2023-12-06 14:23:14.359854747 +0000
@@ -73,13 +73,13 @@
                 updateImmediately.schedule();
             }
         }));
-        const originalModelTokenizationCompleted = this._diffModel.map(m => m ? observableFromEvent(m.model.original.onDidChangeTokens, () => m.model.original.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) : undefined).map((m, reader) => m === null || m === void 0 ? void 0 : m.read(reader));
+        const originalModelTokenizationCompleted = this._diffModel.map(m => m ? observableFromEvent(m.model.original.onDidChangeTokens, () => m.model.original.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) : undefined).map((m, reader) => m?.read(reader));
         const alignmentViewZoneIdsOrig = new Set();
         const alignmentViewZoneIdsMod = new Set();
         const alignments = derived((reader) => {
             /** @description alignments */
             const diffModel = this._diffModel.read(reader);
-            const diff = diffModel === null || diffModel === void 0 ? void 0 : diffModel.diff.read(reader);
+            const diff = diffModel?.diff.read(reader);
             if (!diffModel || !diff) {
                 return null;
             }
@@ -89,9 +89,8 @@
             return computeRangeAlignment(this._editors.original, this._editors.modified, diff.mappings, alignmentViewZoneIdsOrig, alignmentViewZoneIdsMod, innerHunkAlignment);
         });
         const alignmentsSyncedMovedText = derived((reader) => {
-            var _a;
             /** @description alignments */
-            const syncedMovedText = (_a = this._diffModel.read(reader)) === null || _a === void 0 ? void 0 : _a.movedTextToCompare.read(reader);
+            const syncedMovedText = this._diffModel.read(reader)?.movedTextToCompare.read(reader);
             if (!syncedMovedText) {
                 return null;
             }
@@ -107,7 +106,6 @@
         }
         const alignmentViewZonesDisposables = this._register(new DisposableStore());
         const alignmentViewZones = derived((reader) => {
-            var _a, _b, _c, _d, _e, _f, _g, _h;
             /** @description alignment viewzones */
             alignmentViewZonesDisposables.clear();
             const alignmentsVal = alignments.read(reader) || [];
@@ -134,22 +132,22 @@
                 });
             }
             const renderSideBySide = this._options.renderSideBySide.read(reader);
-            const deletedCodeLineBreaksComputer = !renderSideBySide ? (_a = this._editors.modified._getViewModel()) === null || _a === void 0 ? void 0 : _a.createLineBreaksComputer() : undefined;
+            const deletedCodeLineBreaksComputer = !renderSideBySide ? this._editors.modified._getViewModel()?.createLineBreaksComputer() : undefined;
             if (deletedCodeLineBreaksComputer) {
                 for (const a of alignmentsVal) {
                     if (a.diff) {
                         for (let i = a.originalRange.startLineNumber; i < a.originalRange.endLineNumberExclusive; i++) {
-                            deletedCodeLineBreaksComputer === null || deletedCodeLineBreaksComputer === void 0 ? void 0 : deletedCodeLineBreaksComputer.addRequest(this._editors.original.getModel().getLineContent(i), null, null);
+                            deletedCodeLineBreaksComputer?.addRequest(this._editors.original.getModel().getLineContent(i), null, null);
                         }
                     }
                 }
             }
-            const lineBreakData = (_b = deletedCodeLineBreaksComputer === null || deletedCodeLineBreaksComputer === void 0 ? void 0 : deletedCodeLineBreaksComputer.finalize()) !== null && _b !== void 0 ? _b : [];
+            const lineBreakData = deletedCodeLineBreaksComputer?.finalize() ?? [];
             let lineBreakDataIdx = 0;
             const modLineHeight = this._editors.modified.getOption(66 /* EditorOption.lineHeight */);
-            const syncedMovedText = (_c = this._diffModel.read(reader)) === null || _c === void 0 ? void 0 : _c.movedTextToCompare.read(reader);
-            const mightContainNonBasicASCII = (_e = (_d = this._editors.original.getModel()) === null || _d === void 0 ? void 0 : _d.mightContainNonBasicASCII()) !== null && _e !== void 0 ? _e : false;
-            const mightContainRTL = (_g = (_f = this._editors.original.getModel()) === null || _f === void 0 ? void 0 : _f.mightContainRTL()) !== null && _g !== void 0 ? _g : false;
+            const syncedMovedText = this._diffModel.read(reader)?.movedTextToCompare.read(reader);
+            const mightContainNonBasicASCII = this._editors.original.getModel()?.mightContainNonBasicASCII() ?? false;
+            const mightContainRTL = this._editors.original.getModel()?.mightContainRTL() ?? false;
             const renderOptions = RenderOptions.fromEditor(this._editors.modified);
             for (const a of alignmentsVal) {
                 if (a.diff && !renderSideBySide) {
@@ -214,7 +212,7 @@
                 else {
                     const delta = a.modifiedHeightInPx - a.originalHeightInPx;
                     if (delta > 0) {
-                        if (syncedMovedText === null || syncedMovedText === void 0 ? void 0 : syncedMovedText.lineRangeMapping.original.delta(-1).deltaLength(2).contains(a.originalRange.endLineNumberExclusive - 1)) {
+                        if (syncedMovedText?.lineRangeMapping.original.delta(-1).deltaLength(2).contains(a.originalRange.endLineNumberExclusive - 1)) {
                             continue;
                         }
                         origViewZones.push({
@@ -226,7 +224,7 @@
                         });
                     }
                     else {
-                        if (syncedMovedText === null || syncedMovedText === void 0 ? void 0 : syncedMovedText.lineRangeMapping.modified.delta(-1).deltaLength(2).contains(a.modifiedRange.endLineNumberExclusive - 1)) {
+                        if (syncedMovedText?.lineRangeMapping.modified.delta(-1).deltaLength(2).contains(a.modifiedRange.endLineNumberExclusive - 1)) {
                             continue;
                         }
                         function createViewZoneMarginArrow() {
@@ -249,9 +247,9 @@
                     }
                 }
             }
-            for (const a of (_h = alignmentsSyncedMovedText.read(reader)) !== null && _h !== void 0 ? _h : []) {
-                if (!(syncedMovedText === null || syncedMovedText === void 0 ? void 0 : syncedMovedText.lineRangeMapping.original.intersect(a.originalRange))
-                    || !(syncedMovedText === null || syncedMovedText === void 0 ? void 0 : syncedMovedText.lineRangeMapping.modified.intersect(a.modifiedRange))) {
+            for (const a of alignmentsSyncedMovedText.read(reader) ?? []) {
+                if (!syncedMovedText?.lineRangeMapping.original.intersect(a.originalRange)
+                    || !syncedMovedText?.lineRangeMapping.modified.intersect(a.modifiedRange)) {
                     // ignore unrelated alignments outside the synced moved text
                     continue;
                 }
@@ -366,9 +364,8 @@
             }
         }));
         this._register(autorun(reader => {
-            var _a;
             /** @description update editor top offsets */
-            const m = (_a = this._diffModel.read(reader)) === null || _a === void 0 ? void 0 : _a.movedTextToCompare.read(reader);
+            const m = this._diffModel.read(reader)?.movedTextToCompare.read(reader);
             let deltaOrigToMod = 0;
             if (m) {
                 const trueTopOriginal = this._editors.original.getTopForLineNumber(m.lineRangeMapping.original.startLineNumber, true) - this._originalTopPadding.get();
@@ -460,7 +457,6 @@
         let lastModLineNumber = c.modified.startLineNumber;
         let lastOrigLineNumber = c.original.startLineNumber;
         function emitAlignment(origLineNumberExclusive, modLineNumberExclusive) {
-            var _a, _b, _c, _d;
             if (origLineNumberExclusive < lastOrigLineNumber || modLineNumberExclusive < lastModLineNumber) {
                 return;
             }
@@ -475,10 +471,12 @@
             if (originalRange.isEmpty && modifiedRange.isEmpty) {
                 return;
             }
-            const originalAdditionalHeight = (_b = (_a = originalLineHeightOverrides
-                .takeWhile(v => v.lineNumber < origLineNumberExclusive)) === null || _a === void 0 ? void 0 : _a.reduce((p, c) => p + c.heightInPx, 0)) !== null && _b !== void 0 ? _b : 0;
-            const modifiedAdditionalHeight = (_d = (_c = modifiedLineHeightOverrides
-                .takeWhile(v => v.lineNumber < modLineNumberExclusive)) === null || _c === void 0 ? void 0 : _c.reduce((p, c) => p + c.heightInPx, 0)) !== null && _d !== void 0 ? _d : 0;
+            const originalAdditionalHeight = originalLineHeightOverrides
+                .takeWhile(v => v.lineNumber < origLineNumberExclusive)
+                ?.reduce((p, c) => p + c.heightInPx, 0) ?? 0;
+            const modifiedAdditionalHeight = modifiedLineHeightOverrides
+                .takeWhile(v => v.lineNumber < modLineNumberExclusive)
+                ?.reduce((p, c) => p + c.heightInPx, 0) ?? 0;
             result.push({
                 originalRange,
                 modifiedRange,
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/movedBlocksLines.js b/vs/editor/browser/widget/diffEditor/movedBlocksLines.js
--- a/vs/editor/browser/widget/diffEditor/movedBlocksLines.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/movedBlocksLines.js	2023-12-06 14:23:14.359854747 +0000
@@ -13,7 +13,7 @@
 import { ThemeIcon } from '../../../../base/common/themables.js';
 import { PlaceholderViewZone, ViewZoneOverlayWidget, applyStyle, applyViewZones } from './utils.js';
 import { OffsetRange, OffsetRangeSet } from '../../../common/core/offsetRange.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 export class MovedBlocksLinesPart extends Disposable {
     constructor(_rootElement, _diffModel, _originalEditorLayoutInfo, _modifiedEditorLayoutInfo, _editors) {
         super();
@@ -30,10 +30,9 @@
         this._originalViewZonesChangedSignal = observableSignalFromEvent('original.onDidChangeViewZones', this._editors.original.onDidChangeViewZones);
         this._state = derivedWithStore((reader, store) => {
             /** @description state */
-            var _a;
             this._element.replaceChildren();
             const model = this._diffModel.read(reader);
-            const moves = (_a = model === null || model === void 0 ? void 0 : model.diff.read(reader)) === null || _a === void 0 ? void 0 : _a.movedTexts;
+            const moves = model?.diff.read(reader)?.movedTexts;
             if (!moves || moves.length === 0) {
                 this.width.set(0, undefined);
                 return;
@@ -129,7 +128,7 @@
         this._register(recomputeInitiallyAndOnChange(this._state));
         const movedBlockViewZones = derived(reader => {
             const model = this._diffModel.read(reader);
-            const d = model === null || model === void 0 ? void 0 : model.diff.read(reader);
+            const d = model?.diff.read(reader);
             if (!d) {
                 return [];
             }
@@ -244,10 +243,10 @@
         }));
         let text;
         if (_move.changes.length > 0) {
-            text = this._kind === 'original' ? localize('codeMovedToWithChanges', 'Code moved with changes to line {0}-{1}', this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : localize('codeMovedFromWithChanges', 'Code moved with changes from line {0}-{1}', this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1);
+            text = this._kind === 'original' ? localizeWithPath('vs/editor/browser/widget/diffEditor/movedBlocksLines', 'codeMovedToWithChanges', 'Code moved with changes to line {0}-{1}', this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : localizeWithPath('vs/editor/browser/widget/diffEditor/movedBlocksLines', 'codeMovedFromWithChanges', 'Code moved with changes from line {0}-{1}', this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1);
         }
         else {
-            text = this._kind === 'original' ? localize('codeMovedTo', 'Code moved to line {0}-{1}', this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : localize('codeMovedFrom', 'Code moved from line {0}-{1}', this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1);
+            text = this._kind === 'original' ? localizeWithPath('vs/editor/browser/widget/diffEditor/movedBlocksLines', 'codeMovedTo', 'Code moved to line {0}-{1}', this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : localizeWithPath('vs/editor/browser/widget/diffEditor/movedBlocksLines', 'codeMovedFrom', 'Code moved from line {0}-{1}', this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1);
         }
         const actionBar = this._register(new ActionBar(this._nodes.actionBar, {
             highlightToggledItems: true,
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/outlineModel.js b/vs/editor/browser/widget/diffEditor/outlineModel.js
--- a/vs/editor/browser/widget/diffEditor/outlineModel.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/outlineModel.js	2023-12-06 14:23:14.359854747 +0000
@@ -2,10 +2,11 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-import { equals } from '../../../../base/common/arrays.js';
+import { binarySearch, coalesceInPlace, equals } from '../../../../base/common/arrays.js';
 import { CancellationTokenSource } from '../../../../base/common/cancellation.js';
 import { onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { Iterable } from '../../../../base/common/iterator.js';
+import { commonPrefixLength } from '../../../../base/common/strings.js';
 import { Position } from '../../../common/core/position.js';
 import { Range } from '../../../common/core/range.js';
 // TODO@hediet: These classes are copied from outlineModel.ts because of layering issues.
@@ -13,8 +14,7 @@
 // they should be moved to the core editor as well.
 export class TreeElement {
     remove() {
-        var _a;
-        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.delete(this.id);
+        this.parent?.children.delete(this.id);
     }
     static findId(candidate, container) {
         // complex id-computation which contains the origin/extension,
@@ -35,6 +35,32 @@
         }
         return id;
     }
+    static getElementById(id, element) {
+        if (!id) {
+            return undefined;
+        }
+        const len = commonPrefixLength(id, element.id);
+        if (len === id.length) {
+            return element;
+        }
+        if (len < element.id.length) {
+            return undefined;
+        }
+        for (const [, child] of element.children) {
+            const candidate = TreeElement.getElementById(id, child);
+            if (candidate) {
+                return candidate;
+            }
+        }
+        return undefined;
+    }
+    static size(element) {
+        let res = 1;
+        for (const [, child] of element.children) {
+            res += TreeElement.size(child);
+        }
+        return res;
+    }
     static empty(element) {
         return element.children.size === 0;
     }
@@ -57,6 +83,64 @@
         this.order = order;
         this.children = new Map();
     }
+    getItemEnclosingPosition(position) {
+        return position ? this._getItemEnclosingPosition(position, this.children) : undefined;
+    }
+    _getItemEnclosingPosition(position, children) {
+        for (const [, item] of children) {
+            if (!item.symbol.range || !Range.containsPosition(item.symbol.range, position)) {
+                continue;
+            }
+            return this._getItemEnclosingPosition(position, item.children) || item;
+        }
+        return undefined;
+    }
+    updateMarker(marker) {
+        for (const [, child] of this.children) {
+            this._updateMarker(marker, child);
+        }
+    }
+    _updateMarker(markers, item) {
+        item.marker = undefined;
+        // find the proper start index to check for item/marker overlap.
+        const idx = binarySearch(markers, item.symbol.range, Range.compareRangesUsingStarts);
+        let start;
+        if (idx < 0) {
+            start = ~idx;
+            if (start > 0 && Range.areIntersecting(markers[start - 1], item.symbol.range)) {
+                start -= 1;
+            }
+        }
+        else {
+            start = idx;
+        }
+        const myMarkers = [];
+        let myTopSev;
+        for (; start < markers.length && Range.areIntersecting(item.symbol.range, markers[start]); start++) {
+            // remove markers intersecting with this outline element
+            // and store them in a 'private' array.
+            const marker = markers[start];
+            myMarkers.push(marker);
+            markers[start] = undefined;
+            if (!myTopSev || marker.severity > myTopSev) {
+                myTopSev = marker.severity;
+            }
+        }
+        // Recurse into children and let them match markers that have matched
+        // this outline element. This might remove markers from this element and
+        // therefore we remember that we have had markers. That allows us to render
+        // the dot, saying 'this element has children with markers'
+        for (const [, child] of item.children) {
+            this._updateMarker(myMarkers, child);
+        }
+        if (myTopSev) {
+            item.marker = {
+                count: myMarkers.length,
+                topSev: myTopSev
+            };
+        }
+        coalesceInPlace(markers);
+    }
 }
 export class OutlineModel extends TreeElement {
     static create(registry, textModel, token) {
@@ -64,9 +148,8 @@
         const result = new OutlineModel(textModel.uri);
         const provider = registry.ordered(textModel);
         const promises = provider.map((provider, index) => {
-            var _a;
             const id = TreeElement.findId(`provider_${index}`, result);
-            const group = new OutlineGroup(id, result, (_a = provider.displayName) !== null && _a !== void 0 ? _a : 'Unknown Outline Provider', index);
+            const group = new OutlineGroup(id, result, provider.displayName ?? 'Unknown Outline Provider', index);
             return Promise.resolve(provider.provideDocumentSymbols(textModel, cts.token)).then(result => {
                 for (const info of result || []) {
                     OutlineModel._makeOutlineElement(info, group);
@@ -112,6 +195,15 @@
         }
         container.children.set(res.id, res);
     }
+    static get(element) {
+        while (element) {
+            if (element instanceof OutlineModel) {
+                return element;
+            }
+            element = element.parent;
+        }
+        return undefined;
+    }
     constructor(uri) {
         super();
         this.uri = uri;
@@ -146,6 +238,48 @@
         }
         return this;
     }
+    merge(other) {
+        if (this.uri.toString() !== other.uri.toString()) {
+            return false;
+        }
+        if (this._groups.size !== other._groups.size) {
+            return false;
+        }
+        this._groups = other._groups;
+        this.children = other.children;
+        return true;
+    }
+    getItemEnclosingPosition(position, context) {
+        let preferredGroup;
+        if (context) {
+            let candidate = context.parent;
+            while (candidate && !preferredGroup) {
+                if (candidate instanceof OutlineGroup) {
+                    preferredGroup = candidate;
+                }
+                candidate = candidate.parent;
+            }
+        }
+        let result = undefined;
+        for (const [, group] of this._groups) {
+            result = group.getItemEnclosingPosition(position);
+            if (result && (!preferredGroup || preferredGroup === group)) {
+                break;
+            }
+        }
+        return result;
+    }
+    getItemById(id) {
+        return TreeElement.getElementById(id, this);
+    }
+    updateMarker(marker) {
+        // sort markers by start range so that we can use
+        // outline element starts for quicker look up
+        marker.sort(Range.compareRangesUsingStarts);
+        for (const [, group] of this._groups) {
+            group.updateMarker(marker.slice(0));
+        }
+    }
     getTopLevelSymbols() {
         const roots = [];
         for (const child of this.children.values()) {
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/overviewRulerPart.js b/vs/editor/browser/widget/diffEditor/overviewRulerPart.js
--- a/vs/editor/browser/widget/diffEditor/overviewRulerPart.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/overviewRulerPart.js	2023-12-06 14:23:14.359854747 +0000
@@ -84,14 +84,13 @@
                 const origHiddenRangesChanged = observableSignalFromEvent('hiddenRangesChanged', this._editors.original.onDidChangeHiddenAreas);
                 const modHiddenRangesChanged = observableSignalFromEvent('hiddenRangesChanged', this._editors.modified.onDidChangeHiddenAreas);
                 store.add(autorun(reader => {
-                    var _a;
                     /** @description set overview ruler zones */
                     origViewZonesChanged.read(reader);
                     modViewZonesChanged.read(reader);
                     origHiddenRangesChanged.read(reader);
                     modHiddenRangesChanged.read(reader);
                     const colors = currentColors.read(reader);
-                    const diff = (_a = m === null || m === void 0 ? void 0 : m.diff.read(reader)) === null || _a === void 0 ? void 0 : _a.mappings;
+                    const diff = m?.diff.read(reader)?.mappings;
                     function createZones(ranges, color, editor) {
                         const vm = editor._getViewModel();
                         if (!vm) {
@@ -111,8 +110,8 @@
                     }
                     const originalZones = createZones((diff || []).map(d => d.lineRangeMapping.original), colors.removeColor, this._editors.original);
                     const modifiedZones = createZones((diff || []).map(d => d.lineRangeMapping.modified), colors.insertColor, this._editors.modified);
-                    originalOverviewRuler === null || originalOverviewRuler === void 0 ? void 0 : originalOverviewRuler.setZones(originalZones);
-                    modifiedOverviewRuler === null || modifiedOverviewRuler === void 0 ? void 0 : modifiedOverviewRuler.setZones(modifiedZones);
+                    originalOverviewRuler?.setZones(originalZones);
+                    modifiedOverviewRuler?.setZones(modifiedZones);
                 }));
                 store.add(autorun(reader => {
                     /** @description layout overview ruler */
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/renderLines.js b/vs/editor/browser/widget/diffEditor/renderLines.js
--- a/vs/editor/browser/widget/diffEditor/renderLines.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/renderLines.js	2023-12-06 14:23:14.359854747 +0000
@@ -59,11 +59,10 @@
 }
 export class RenderOptions {
     static fromEditor(editor) {
-        var _a;
         const modifiedEditorOptions = editor.getOptions();
         const fontInfo = modifiedEditorOptions.get(50 /* EditorOption.fontInfo */);
         const layoutInfo = modifiedEditorOptions.get(143 /* EditorOption.layoutInfo */);
-        return new RenderOptions(((_a = editor.getModel()) === null || _a === void 0 ? void 0 : _a.getOptions().tabSize) || 0, fontInfo, modifiedEditorOptions.get(33 /* EditorOption.disableMonospaceOptimizations */), fontInfo.typicalHalfwidthCharacterWidth, modifiedEditorOptions.get(103 /* EditorOption.scrollBeyondLastColumn */), modifiedEditorOptions.get(66 /* EditorOption.lineHeight */), layoutInfo.decorationsWidth, modifiedEditorOptions.get(116 /* EditorOption.stopRenderingLineAfter */), modifiedEditorOptions.get(98 /* EditorOption.renderWhitespace */), modifiedEditorOptions.get(93 /* EditorOption.renderControlCharacters */), modifiedEditorOptions.get(51 /* EditorOption.fontLigatures */));
+        return new RenderOptions(editor.getModel()?.getOptions().tabSize || 0, fontInfo, modifiedEditorOptions.get(33 /* EditorOption.disableMonospaceOptimizations */), fontInfo.typicalHalfwidthCharacterWidth, modifiedEditorOptions.get(103 /* EditorOption.scrollBeyondLastColumn */), modifiedEditorOptions.get(66 /* EditorOption.lineHeight */), layoutInfo.decorationsWidth, modifiedEditorOptions.get(116 /* EditorOption.stopRenderingLineAfter */), modifiedEditorOptions.get(98 /* EditorOption.renderWhitespace */), modifiedEditorOptions.get(93 /* EditorOption.renderControlCharacters */), modifiedEditorOptions.get(51 /* EditorOption.fontLigatures */));
     }
     constructor(tabSize, fontInfo, disableMonospaceOptimizations, typicalHalfwidthCharacterWidth, scrollBeyondLastColumn, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures) {
         this.tabSize = tabSize;
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/utils.js b/vs/editor/browser/widget/diffEditor/utils.js
--- a/vs/editor/browser/widget/diffEditor/utils.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/utils.js	2023-12-06 14:23:14.359854747 +0000
@@ -5,7 +5,7 @@
 import { CancellationTokenSource } from '../../../../base/common/cancellation.js';
 import { isHotReloadEnabled, registerHotReloadHandler } from '../../../../base/common/hotReload.js';
 import { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';
-import { autorun, autorunHandleChanges, autorunOpts, observableSignalFromEvent, observableValue, transaction } from '../../../../base/common/observable.js';
+import { autorun, autorunHandleChanges, autorunOpts, observableFromEvent, observableSignalFromEvent, observableValue, transaction } from '../../../../base/common/observable.js';
 import { ElementSizeObserver } from '../../config/elementSizeObserver.js';
 export function joinCombine(arr1, arr2, keySelector, combine) {
     if (arr1.length === 0) {
@@ -67,6 +67,13 @@
         parent.removeChild(child);
     });
 }
+export function observableConfigValue(key, defaultValue, configurationService) {
+    return observableFromEvent((handleChange) => configurationService.onDidChangeConfiguration(e => {
+        if (e.affectsConfiguration(key)) {
+            handleChange(e);
+        }
+    }), () => configurationService.getValue(key) ?? defaultValue);
+}
 export class ObservableElementSizeObserver extends Disposable {
     get width() { return this._width; }
     get height() { return this._height; }
@@ -136,6 +143,22 @@
 function easeOutExpo(t, b, c, d) {
     return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
 }
+export function deepMerge(source1, source2) {
+    const result = {};
+    for (const key in source1) {
+        result[key] = source1[key];
+    }
+    for (const key in source2) {
+        const source2Value = source2[key];
+        if (typeof result[key] === 'object' && source2Value && typeof source2Value === 'object') {
+            result[key] = deepMerge(result[key], source2Value);
+        }
+        else {
+            result[key] = source2Value;
+        }
+    }
+    return result;
+}
 export class ViewZoneOverlayWidget extends Disposable {
     constructor(editor, viewZone, htmlElement) {
         super();
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditor/workerBasedDocumentDiffProvider.js b/vs/editor/browser/widget/diffEditor/workerBasedDocumentDiffProvider.js
--- a/vs/editor/browser/widget/diffEditor/workerBasedDocumentDiffProvider.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/diffEditor/workerBasedDocumentDiffProvider.js	2023-12-06 14:23:14.359854747 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var WorkerBasedDocumentDiffProvider_1;
 import { Emitter } from '../../../../base/common/event.js';
 import { StopWatch } from '../../../../base/common/stopwatch.js';
@@ -38,76 +29,71 @@
         this.setOptions(options);
     }
     dispose() {
-        var _a;
-        (_a = this.diffAlgorithmOnDidChangeSubscription) === null || _a === void 0 ? void 0 : _a.dispose();
+        this.diffAlgorithmOnDidChangeSubscription?.dispose();
     }
-    computeDiff(original, modified, options, cancellationToken) {
-        var _a, _b;
-        return __awaiter(this, void 0, void 0, function* () {
-            if (typeof this.diffAlgorithm !== 'string') {
-                return this.diffAlgorithm.computeDiff(original, modified, options, cancellationToken);
-            }
-            // This significantly speeds up the case when the original file is empty
-            if (original.getLineCount() === 1 && original.getLineMaxColumn(1) === 1) {
-                if (modified.getLineCount() === 1 && modified.getLineMaxColumn(1) === 1) {
-                    return {
-                        changes: [],
-                        identical: true,
-                        quitEarly: false,
-                        moves: [],
-                    };
-                }
-                return {
-                    changes: [
-                        new DetailedLineRangeMapping(new LineRange(1, 2), new LineRange(1, modified.getLineCount() + 1), [
-                            new RangeMapping(original.getFullModelRange(), modified.getFullModelRange())
-                        ])
-                    ],
-                    identical: false,
-                    quitEarly: false,
-                    moves: [],
-                };
-            }
-            const uriKey = JSON.stringify([original.uri.toString(), modified.uri.toString()]);
-            const context = JSON.stringify([original.id, modified.id, original.getAlternativeVersionId(), modified.getAlternativeVersionId(), JSON.stringify(options)]);
-            const c = WorkerBasedDocumentDiffProvider_1.diffCache.get(uriKey);
-            if (c && c.context === context) {
-                return c.result;
-            }
-            const sw = StopWatch.create();
-            const result = yield this.editorWorkerService.computeDiff(original.uri, modified.uri, options, this.diffAlgorithm);
-            const timeMs = sw.elapsed();
-            this.telemetryService.publicLog2('diffEditor.computeDiff', {
-                timeMs,
-                timedOut: (_a = result === null || result === void 0 ? void 0 : result.quitEarly) !== null && _a !== void 0 ? _a : true,
-                detectedMoves: options.computeMoves ? ((_b = result === null || result === void 0 ? void 0 : result.moves.length) !== null && _b !== void 0 ? _b : 0) : -1,
-            });
-            if (cancellationToken.isCancellationRequested) {
-                // Text models might be disposed!
+    async computeDiff(original, modified, options, cancellationToken) {
+        if (typeof this.diffAlgorithm !== 'string') {
+            return this.diffAlgorithm.computeDiff(original, modified, options, cancellationToken);
+        }
+        // This significantly speeds up the case when the original file is empty
+        if (original.getLineCount() === 1 && original.getLineMaxColumn(1) === 1) {
+            if (modified.getLineCount() === 1 && modified.getLineMaxColumn(1) === 1) {
                 return {
                     changes: [],
-                    identical: false,
-                    quitEarly: true,
+                    identical: true,
+                    quitEarly: false,
                     moves: [],
                 };
             }
-            if (!result) {
-                throw new Error('no diff result available');
-            }
-            // max 10 items in cache
-            if (WorkerBasedDocumentDiffProvider_1.diffCache.size > 10) {
-                WorkerBasedDocumentDiffProvider_1.diffCache.delete(WorkerBasedDocumentDiffProvider_1.diffCache.keys().next().value);
-            }
-            WorkerBasedDocumentDiffProvider_1.diffCache.set(uriKey, { result, context });
-            return result;
+            return {
+                changes: [
+                    new DetailedLineRangeMapping(new LineRange(1, 2), new LineRange(1, modified.getLineCount() + 1), [
+                        new RangeMapping(original.getFullModelRange(), modified.getFullModelRange())
+                    ])
+                ],
+                identical: false,
+                quitEarly: false,
+                moves: [],
+            };
+        }
+        const uriKey = JSON.stringify([original.uri.toString(), modified.uri.toString()]);
+        const context = JSON.stringify([original.id, modified.id, original.getAlternativeVersionId(), modified.getAlternativeVersionId(), JSON.stringify(options)]);
+        const c = WorkerBasedDocumentDiffProvider_1.diffCache.get(uriKey);
+        if (c && c.context === context) {
+            return c.result;
+        }
+        const sw = StopWatch.create();
+        const result = await this.editorWorkerService.computeDiff(original.uri, modified.uri, options, this.diffAlgorithm);
+        const timeMs = sw.elapsed();
+        this.telemetryService.publicLog2('diffEditor.computeDiff', {
+            timeMs,
+            timedOut: result?.quitEarly ?? true,
+            detectedMoves: options.computeMoves ? (result?.moves.length ?? 0) : -1,
         });
+        if (cancellationToken.isCancellationRequested) {
+            // Text models might be disposed!
+            return {
+                changes: [],
+                identical: false,
+                quitEarly: true,
+                moves: [],
+            };
+        }
+        if (!result) {
+            throw new Error('no diff result available');
+        }
+        // max 10 items in cache
+        if (WorkerBasedDocumentDiffProvider_1.diffCache.size > 10) {
+            WorkerBasedDocumentDiffProvider_1.diffCache.delete(WorkerBasedDocumentDiffProvider_1.diffCache.keys().next().value);
+        }
+        WorkerBasedDocumentDiffProvider_1.diffCache.set(uriKey, { result, context });
+        return result;
     }
     setOptions(newOptions) {
-        var _a;
         let didChange = false;
         if (newOptions.diffAlgorithm) {
             if (this.diffAlgorithm !== newOptions.diffAlgorithm) {
-                (_a = this.diffAlgorithmOnDidChangeSubscription) === null || _a === void 0 ? void 0 : _a.dispose();
+                this.diffAlgorithmOnDidChangeSubscription?.dispose();
                 this.diffAlgorithmOnDidChangeSubscription = undefined;
                 this.diffAlgorithm = newOptions.diffAlgorithm;
                 if (typeof newOptions.diffAlgorithm !== 'string') {
diff -urN -x '*.map' a/vs/editor/browser/widget/embeddedCodeEditorWidget.js b/vs/editor/browser/widget/embeddedCodeEditorWidget.js
--- a/vs/editor/browser/widget/embeddedCodeEditorWidget.js	2023-12-06 14:22:33.791782393 +0000
+++ b/vs/editor/browser/widget/embeddedCodeEditorWidget.js	2023-12-06 14:23:14.359854747 +0000
@@ -14,17 +14,20 @@
 import * as objects from '../../../base/common/objects.js';
 import { ICodeEditorService } from '../services/codeEditorService.js';
 import { CodeEditorWidget } from './codeEditorWidget.js';
+import { DiffEditorWidget } from './diffEditor/diffEditorWidget.js';
 import { ILanguageConfigurationService } from '../../common/languages/languageConfigurationRegistry.js';
 import { ILanguageFeaturesService } from '../../common/services/languageFeatures.js';
 import { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';
+import { IAudioCueService } from '../../../platform/audioCues/browser/audioCueService.js';
 import { ICommandService } from '../../../platform/commands/common/commands.js';
 import { IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';
 import { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';
 import { INotificationService } from '../../../platform/notification/common/notification.js';
+import { IEditorProgressService } from '../../../platform/progress/common/progress.js';
 import { IThemeService } from '../../../platform/theme/common/themeService.js';
 let EmbeddedCodeEditorWidget = class EmbeddedCodeEditorWidget extends CodeEditorWidget {
     constructor(domElement, options, codeEditorWidgetOptions, parentEditor, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {
-        super(domElement, Object.assign(Object.assign({}, parentEditor.getRawOptions()), { overflowWidgetsDomNode: parentEditor.getOverflowWidgetsDomNode() }), codeEditorWidgetOptions, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);
+        super(domElement, { ...parentEditor.getRawOptions(), overflowWidgetsDomNode: parentEditor.getOverflowWidgetsDomNode() }, codeEditorWidgetOptions, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);
         this._parentEditor = parentEditor;
         this._overwriteOptions = options;
         // Overwrite parent's options
@@ -55,3 +58,32 @@
     __param(12, ILanguageFeaturesService)
 ], EmbeddedCodeEditorWidget);
 export { EmbeddedCodeEditorWidget };
+let EmbeddedDiffEditorWidget = class EmbeddedDiffEditorWidget extends DiffEditorWidget {
+    constructor(domElement, options, codeEditorWidgetOptions, parentEditor, contextKeyService, instantiationService, codeEditorService, audioCueService, editorProgressService) {
+        super(domElement, parentEditor.getRawOptions(), codeEditorWidgetOptions, contextKeyService, instantiationService, codeEditorService, audioCueService, editorProgressService);
+        this._parentEditor = parentEditor;
+        this._overwriteOptions = options;
+        // Overwrite parent's options
+        super.updateOptions(this._overwriteOptions);
+        this._register(parentEditor.onDidChangeConfiguration(e => this._onParentConfigurationChanged(e)));
+    }
+    getParentEditor() {
+        return this._parentEditor;
+    }
+    _onParentConfigurationChanged(e) {
+        super.updateOptions(this._parentEditor.getRawOptions());
+        super.updateOptions(this._overwriteOptions);
+    }
+    updateOptions(newOptions) {
+        objects.mixin(this._overwriteOptions, newOptions, true);
+        super.updateOptions(this._overwriteOptions);
+    }
+};
+EmbeddedDiffEditorWidget = __decorate([
+    __param(4, IContextKeyService),
+    __param(5, IInstantiationService),
+    __param(6, ICodeEditorService),
+    __param(7, IAudioCueService),
+    __param(8, IEditorProgressService)
+], EmbeddedDiffEditorWidget);
+export { EmbeddedDiffEditorWidget };
diff -urN -x '*.map' a/vs/editor/common/config/editorConfigurationSchema.js b/vs/editor/common/config/editorConfigurationSchema.js
--- a/vs/editor/common/config/editorConfigurationSchema.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/config/editorConfigurationSchema.js	2023-12-06 14:23:14.363854755 +0000
@@ -12,15 +12,17 @@
     id: 'editor',
     order: 5,
     type: 'object',
-    title: nls.localize('editorConfigurationTitle', "Editor"),
+    title: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'editorConfigurationTitle', "Editor"),
     scope: 5 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */,
 });
-const editorConfiguration = Object.assign(Object.assign({}, editorConfigurationBaseNode), { properties: {
+const editorConfiguration = {
+    ...editorConfigurationBaseNode,
+    properties: {
         'editor.tabSize': {
             type: 'number',
             default: EDITOR_MODEL_DEFAULTS.tabSize,
             minimum: 1,
-            markdownDescription: nls.localize('tabSize', "The number of spaces a tab is equal to. This setting is overridden based on the file contents when {0} is on.", '`#editor.detectIndentation#`')
+            markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'tabSize', "The number of spaces a tab is equal to. This setting is overridden based on the file contents when {0} is on.", '`#editor.detectIndentation#`')
         },
         'editor.indentSize': {
             'anyOf': [
@@ -34,94 +36,94 @@
                 }
             ],
             default: 'tabSize',
-            markdownDescription: nls.localize('indentSize', "The number of spaces used for indentation or `\"tabSize\"` to use the value from `#editor.tabSize#`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
+            markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'indentSize', "The number of spaces used for indentation or `\"tabSize\"` to use the value from `#editor.tabSize#`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
         },
         'editor.insertSpaces': {
             type: 'boolean',
             default: EDITOR_MODEL_DEFAULTS.insertSpaces,
-            markdownDescription: nls.localize('insertSpaces', "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when {0} is on.", '`#editor.detectIndentation#`')
+            markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'insertSpaces', "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when {0} is on.", '`#editor.detectIndentation#`')
         },
         'editor.detectIndentation': {
             type: 'boolean',
             default: EDITOR_MODEL_DEFAULTS.detectIndentation,
-            markdownDescription: nls.localize('detectIndentation', "Controls whether {0} and {1} will be automatically detected when a file is opened based on the file contents.", '`#editor.tabSize#`', '`#editor.insertSpaces#`')
+            markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'detectIndentation', "Controls whether {0} and {1} will be automatically detected when a file is opened based on the file contents.", '`#editor.tabSize#`', '`#editor.insertSpaces#`')
         },
         'editor.trimAutoWhitespace': {
             type: 'boolean',
             default: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,
-            description: nls.localize('trimAutoWhitespace', "Remove trailing auto inserted whitespace.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'trimAutoWhitespace', "Remove trailing auto inserted whitespace.")
         },
         'editor.largeFileOptimizations': {
             type: 'boolean',
             default: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,
-            description: nls.localize('largeFileOptimizations', "Special handling for large files to disable certain memory intensive features.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'largeFileOptimizations', "Special handling for large files to disable certain memory intensive features.")
         },
         'editor.wordBasedSuggestions': {
             type: 'boolean',
             default: true,
-            description: nls.localize('wordBasedSuggestions', "Controls whether completions should be computed based on words in the document.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'wordBasedSuggestions', "Controls whether completions should be computed based on words in the document.")
         },
         'editor.wordBasedSuggestionsMode': {
             enum: ['currentDocument', 'matchingDocuments', 'allDocuments'],
             default: 'matchingDocuments',
             enumDescriptions: [
-                nls.localize('wordBasedSuggestionsMode.currentDocument', 'Only suggest words from the active document.'),
-                nls.localize('wordBasedSuggestionsMode.matchingDocuments', 'Suggest words from all open documents of the same language.'),
-                nls.localize('wordBasedSuggestionsMode.allDocuments', 'Suggest words from all open documents.')
+                nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'wordBasedSuggestionsMode.currentDocument', 'Only suggest words from the active document.'),
+                nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'wordBasedSuggestionsMode.matchingDocuments', 'Suggest words from all open documents of the same language.'),
+                nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'wordBasedSuggestionsMode.allDocuments', 'Suggest words from all open documents.')
             ],
-            description: nls.localize('wordBasedSuggestionsMode', "Controls from which documents word based completions are computed.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'wordBasedSuggestionsMode', "Controls from which documents word based completions are computed.")
         },
         'editor.semanticHighlighting.enabled': {
             enum: [true, false, 'configuredByTheme'],
             enumDescriptions: [
-                nls.localize('semanticHighlighting.true', 'Semantic highlighting enabled for all color themes.'),
-                nls.localize('semanticHighlighting.false', 'Semantic highlighting disabled for all color themes.'),
-                nls.localize('semanticHighlighting.configuredByTheme', 'Semantic highlighting is configured by the current color theme\'s `semanticHighlighting` setting.')
+                nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'semanticHighlighting.true', 'Semantic highlighting enabled for all color themes.'),
+                nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'semanticHighlighting.false', 'Semantic highlighting disabled for all color themes.'),
+                nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'semanticHighlighting.configuredByTheme', 'Semantic highlighting is configured by the current color theme\'s `semanticHighlighting` setting.')
             ],
             default: 'configuredByTheme',
-            description: nls.localize('semanticHighlighting.enabled', "Controls whether the semanticHighlighting is shown for the languages that support it.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'semanticHighlighting.enabled', "Controls whether the semanticHighlighting is shown for the languages that support it.")
         },
         'editor.stablePeek': {
             type: 'boolean',
             default: false,
-            markdownDescription: nls.localize('stablePeek', "Keep peek editors open even when double-clicking their content or when hitting `Escape`.")
+            markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'stablePeek', "Keep peek editors open even when double-clicking their content or when hitting `Escape`.")
         },
         'editor.maxTokenizationLineLength': {
             type: 'integer',
             default: 20000,
-            description: nls.localize('maxTokenizationLineLength', "Lines above this length will not be tokenized for performance reasons")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'maxTokenizationLineLength', "Lines above this length will not be tokenized for performance reasons")
         },
         'editor.experimental.asyncTokenization': {
             type: 'boolean',
             default: false,
-            description: nls.localize('editor.experimental.asyncTokenization', "Controls whether the tokenization should happen asynchronously on a web worker."),
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'editor.experimental.asyncTokenization', "Controls whether the tokenization should happen asynchronously on a web worker."),
             tags: ['experimental'],
         },
         'editor.experimental.asyncTokenizationLogging': {
             type: 'boolean',
             default: false,
-            description: nls.localize('editor.experimental.asyncTokenizationLogging', "Controls whether async tokenization should be logged. For debugging only."),
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'editor.experimental.asyncTokenizationLogging', "Controls whether async tokenization should be logged. For debugging only."),
         },
         'editor.experimental.asyncTokenizationVerification': {
             type: 'boolean',
             default: false,
-            description: nls.localize('editor.experimental.asyncTokenizationVerification', "Controls whether async tokenization should be verified against legacy background tokenization. Might slow down tokenization. For debugging only."),
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'editor.experimental.asyncTokenizationVerification', "Controls whether async tokenization should be verified against legacy background tokenization. Might slow down tokenization. For debugging only."),
             tags: ['experimental'],
         },
         'editor.language.brackets': {
             type: ['array', 'null'],
             default: null, // We want to distinguish the empty array from not configured.
-            description: nls.localize('schema.brackets', 'Defines the bracket symbols that increase or decrease the indentation.'),
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'schema.brackets', 'Defines the bracket symbols that increase or decrease the indentation.'),
             items: {
                 type: 'array',
                 items: [
                     {
                         type: 'string',
-                        description: nls.localize('schema.openBracket', 'The opening bracket character or string sequence.')
+                        description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'schema.openBracket', 'The opening bracket character or string sequence.')
                     },
                     {
                         type: 'string',
-                        description: nls.localize('schema.closeBracket', 'The closing bracket character or string sequence.')
+                        description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'schema.closeBracket', 'The closing bracket character or string sequence.')
                     }
                 ]
             }
@@ -129,17 +131,17 @@
         'editor.language.colorizedBracketPairs': {
             type: ['array', 'null'],
             default: null, // We want to distinguish the empty array from not configured.
-            description: nls.localize('schema.colorizedBracketPairs', 'Defines the bracket pairs that are colorized by their nesting level if bracket pair colorization is enabled.'),
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'schema.colorizedBracketPairs', 'Defines the bracket pairs that are colorized by their nesting level if bracket pair colorization is enabled.'),
             items: {
                 type: 'array',
                 items: [
                     {
                         type: 'string',
-                        description: nls.localize('schema.openBracket', 'The opening bracket character or string sequence.')
+                        description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'schema.openBracket', 'The opening bracket character or string sequence.')
                     },
                     {
                         type: 'string',
-                        description: nls.localize('schema.closeBracket', 'The closing bracket character or string sequence.')
+                        description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'schema.closeBracket', 'The closing bracket character or string sequence.')
                     }
                 ]
             }
@@ -147,56 +149,56 @@
         'diffEditor.maxComputationTime': {
             type: 'number',
             default: diffEditorDefaultOptions.maxComputationTime,
-            description: nls.localize('maxComputationTime', "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'maxComputationTime', "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
         },
         'diffEditor.maxFileSize': {
             type: 'number',
             default: diffEditorDefaultOptions.maxFileSize,
-            description: nls.localize('maxFileSize', "Maximum file size in MB for which to compute diffs. Use 0 for no limit.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'maxFileSize', "Maximum file size in MB for which to compute diffs. Use 0 for no limit.")
         },
         'diffEditor.renderSideBySide': {
             type: 'boolean',
             default: diffEditorDefaultOptions.renderSideBySide,
-            description: nls.localize('sideBySide', "Controls whether the diff editor shows the diff side by side or inline.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'sideBySide', "Controls whether the diff editor shows the diff side by side or inline.")
         },
         'diffEditor.renderSideBySideInlineBreakpoint': {
             type: 'number',
             default: diffEditorDefaultOptions.renderSideBySideInlineBreakpoint,
-            description: nls.localize('renderSideBySideInlineBreakpoint', "If the diff editor width is smaller than this value, the inline view is used.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'renderSideBySideInlineBreakpoint', "If the diff editor width is smaller than this value, the inline view is used.")
         },
         'diffEditor.useInlineViewWhenSpaceIsLimited': {
             type: 'boolean',
             default: diffEditorDefaultOptions.useInlineViewWhenSpaceIsLimited,
-            description: nls.localize('useInlineViewWhenSpaceIsLimited', "If enabled and the editor width is too small, the inline view is used.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'useInlineViewWhenSpaceIsLimited', "If enabled and the editor width is too small, the inline view is used.")
         },
         'diffEditor.renderMarginRevertIcon': {
             type: 'boolean',
             default: diffEditorDefaultOptions.renderMarginRevertIcon,
-            description: nls.localize('renderMarginRevertIcon', "When enabled, the diff editor shows arrows in its glyph margin to revert changes.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'renderMarginRevertIcon', "When enabled, the diff editor shows arrows in its glyph margin to revert changes.")
         },
         'diffEditor.ignoreTrimWhitespace': {
             type: 'boolean',
             default: diffEditorDefaultOptions.ignoreTrimWhitespace,
-            description: nls.localize('ignoreTrimWhitespace', "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'ignoreTrimWhitespace', "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
         },
         'diffEditor.renderIndicators': {
             type: 'boolean',
             default: diffEditorDefaultOptions.renderIndicators,
-            description: nls.localize('renderIndicators', "Controls whether the diff editor shows +/- indicators for added/removed changes.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'renderIndicators', "Controls whether the diff editor shows +/- indicators for added/removed changes.")
         },
         'diffEditor.codeLens': {
             type: 'boolean',
             default: diffEditorDefaultOptions.diffCodeLens,
-            description: nls.localize('codeLens', "Controls whether the editor shows CodeLens.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'codeLens', "Controls whether the editor shows CodeLens.")
         },
         'diffEditor.wordWrap': {
             type: 'string',
             enum: ['off', 'on', 'inherit'],
             default: diffEditorDefaultOptions.diffWordWrap,
             markdownEnumDescriptions: [
-                nls.localize('wordWrap.off', "Lines will never wrap."),
-                nls.localize('wordWrap.on', "Lines will wrap at the viewport width."),
-                nls.localize('wordWrap.inherit', "Lines will wrap according to the {0} setting.", '`#editor.wordWrap#`'),
+                nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'wordWrap.off', "Lines will never wrap."),
+                nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'wordWrap.on', "Lines will wrap at the viewport width."),
+                nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'wordWrap.inherit', "Lines will wrap according to the {0} setting.", '`#editor.wordWrap#`'),
             ]
         },
         'diffEditor.diffAlgorithm': {
@@ -204,45 +206,46 @@
             enum: ['legacy', 'advanced'],
             default: diffEditorDefaultOptions.diffAlgorithm,
             markdownEnumDescriptions: [
-                nls.localize('diffAlgorithm.legacy', "Uses the legacy diffing algorithm."),
-                nls.localize('diffAlgorithm.advanced', "Uses the advanced diffing algorithm."),
+                nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'diffAlgorithm.legacy', "Uses the legacy diffing algorithm."),
+                nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'diffAlgorithm.advanced', "Uses the advanced diffing algorithm."),
             ],
             tags: ['experimental'],
         },
         'diffEditor.hideUnchangedRegions.enabled': {
             type: 'boolean',
             default: diffEditorDefaultOptions.hideUnchangedRegions.enabled,
-            markdownDescription: nls.localize('hideUnchangedRegions.enabled', "Controls whether the diff editor shows unchanged regions."),
+            markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'hideUnchangedRegions.enabled', "Controls whether the diff editor shows unchanged regions."),
         },
         'diffEditor.hideUnchangedRegions.revealLineCount': {
             type: 'integer',
             default: diffEditorDefaultOptions.hideUnchangedRegions.revealLineCount,
-            markdownDescription: nls.localize('hideUnchangedRegions.revealLineCount', "Controls how many lines are used for unchanged regions."),
+            markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'hideUnchangedRegions.revealLineCount', "Controls how many lines are used for unchanged regions."),
             minimum: 1,
         },
         'diffEditor.hideUnchangedRegions.minimumLineCount': {
             type: 'integer',
             default: diffEditorDefaultOptions.hideUnchangedRegions.minimumLineCount,
-            markdownDescription: nls.localize('hideUnchangedRegions.minimumLineCount', "Controls how many lines are used as a minimum for unchanged regions."),
+            markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'hideUnchangedRegions.minimumLineCount', "Controls how many lines are used as a minimum for unchanged regions."),
             minimum: 1,
         },
         'diffEditor.hideUnchangedRegions.contextLineCount': {
             type: 'integer',
             default: diffEditorDefaultOptions.hideUnchangedRegions.contextLineCount,
-            markdownDescription: nls.localize('hideUnchangedRegions.contextLineCount', "Controls how many lines are used as context when comparing unchanged regions."),
+            markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'hideUnchangedRegions.contextLineCount', "Controls how many lines are used as context when comparing unchanged regions."),
             minimum: 1,
         },
         'diffEditor.experimental.showMoves': {
             type: 'boolean',
             default: diffEditorDefaultOptions.experimental.showMoves,
-            markdownDescription: nls.localize('showMoves', "Controls whether the diff editor should show detected code moves.")
+            markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'showMoves', "Controls whether the diff editor should show detected code moves.")
         },
         'diffEditor.experimental.showEmptyDecorations': {
             type: 'boolean',
             default: diffEditorDefaultOptions.experimental.showEmptyDecorations,
-            description: nls.localize('showEmptyDecorations', "Controls whether the diff editor shows empty decorations to see where characters got inserted or deleted."),
+            description: nls.localizeWithPath('vs/editor/common/config/editorConfigurationSchema', 'showEmptyDecorations', "Controls whether the diff editor shows empty decorations to see where characters got inserted or deleted."),
         }
-    } });
+    }
+};
 function isConfigurationPropertySchema(x) {
     return (typeof x.type !== 'undefined' || typeof x.anyOf !== 'undefined');
 }
diff -urN -x '*.map' a/vs/editor/common/config/editorOptions.js b/vs/editor/common/config/editorOptions.js
--- a/vs/editor/common/config/editorOptions.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/config/editorOptions.js	2023-12-06 14:23:14.363854755 +0000
@@ -306,13 +306,13 @@
             type: 'string',
             enum: ['auto', 'on', 'off'],
             enumDescriptions: [
-                nls.localize('accessibilitySupport.auto', "Use platform APIs to detect when a Screen Reader is attached"),
-                nls.localize('accessibilitySupport.on', "Optimize for usage with a Screen Reader"),
-                nls.localize('accessibilitySupport.off', "Assume a screen reader is not attached"),
+                nls.localizeWithPath('vs/editor/common/config/editorOptions', 'accessibilitySupport.auto', "Use platform APIs to detect when a Screen Reader is attached"),
+                nls.localizeWithPath('vs/editor/common/config/editorOptions', 'accessibilitySupport.on', "Optimize for usage with a Screen Reader"),
+                nls.localizeWithPath('vs/editor/common/config/editorOptions', 'accessibilitySupport.off', "Assume a screen reader is not attached"),
             ],
             default: 'auto',
             tags: ['accessibility'],
-            description: nls.localize('accessibilitySupport', "Controls if the UI should run in a mode where it is optimized for screen readers.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'accessibilitySupport', "Controls if the UI should run in a mode where it is optimized for screen readers.")
         });
     }
     validate(input) {
@@ -341,12 +341,12 @@
             'editor.comments.insertSpace': {
                 type: 'boolean',
                 default: defaults.insertSpace,
-                description: nls.localize('comments.insertSpace', "Controls whether a space character is inserted when commenting.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'comments.insertSpace', "Controls whether a space character is inserted when commenting.")
             },
             'editor.comments.ignoreEmptyLines': {
                 type: 'boolean',
                 default: defaults.ignoreEmptyLines,
-                description: nls.localize('comments.ignoreEmptyLines', 'Controls if empty lines should be ignored with toggle, add or remove actions for line comments.')
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'comments.ignoreEmptyLines', 'Controls if empty lines should be ignored with toggle, add or remove actions for line comments.')
             },
         });
     }
@@ -402,6 +402,19 @@
      */
     TextEditorCursorStyle[TextEditorCursorStyle["UnderlineThin"] = 6] = "UnderlineThin";
 })(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
+/**
+ * @internal
+ */
+export function cursorStyleToString(cursorStyle) {
+    switch (cursorStyle) {
+        case TextEditorCursorStyle.Line: return 'line';
+        case TextEditorCursorStyle.Block: return 'block';
+        case TextEditorCursorStyle.Underline: return 'underline';
+        case TextEditorCursorStyle.LineThin: return 'line-thin';
+        case TextEditorCursorStyle.BlockOutline: return 'block-outline';
+        case TextEditorCursorStyle.UnderlineThin: return 'underline-thin';
+    }
+}
 function _cursorStyleFromString(cursorStyle) {
     switch (cursorStyle) {
         case 'line': return TextEditorCursorStyle.Line;
@@ -445,7 +458,7 @@
 //#region emptySelectionClipboard
 class EditorEmptySelectionClipboard extends EditorBooleanOption {
     constructor() {
-        super(37 /* EditorOption.emptySelectionClipboard */, 'emptySelectionClipboard', true, { description: nls.localize('emptySelectionClipboard', "Controls whether copying without a selection copies the current line.") });
+        super(37 /* EditorOption.emptySelectionClipboard */, 'emptySelectionClipboard', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'emptySelectionClipboard', "Controls whether copying without a selection copies the current line.") });
     }
     compute(env, options, value) {
         return value && env.emptySelectionClipboard;
@@ -465,45 +478,45 @@
             'editor.find.cursorMoveOnType': {
                 type: 'boolean',
                 default: defaults.cursorMoveOnType,
-                description: nls.localize('find.cursorMoveOnType', "Controls whether the cursor should jump to find matches while typing.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'find.cursorMoveOnType', "Controls whether the cursor should jump to find matches while typing.")
             },
             'editor.find.seedSearchStringFromSelection': {
                 type: 'string',
                 enum: ['never', 'always', 'selection'],
                 default: defaults.seedSearchStringFromSelection,
                 enumDescriptions: [
-                    nls.localize('editor.find.seedSearchStringFromSelection.never', 'Never seed search string from the editor selection.'),
-                    nls.localize('editor.find.seedSearchStringFromSelection.always', 'Always seed search string from the editor selection, including word at cursor position.'),
-                    nls.localize('editor.find.seedSearchStringFromSelection.selection', 'Only seed search string from the editor selection.')
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.find.seedSearchStringFromSelection.never', 'Never seed search string from the editor selection.'),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.find.seedSearchStringFromSelection.always', 'Always seed search string from the editor selection, including word at cursor position.'),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.find.seedSearchStringFromSelection.selection', 'Only seed search string from the editor selection.')
                 ],
-                description: nls.localize('find.seedSearchStringFromSelection', "Controls whether the search string in the Find Widget is seeded from the editor selection.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'find.seedSearchStringFromSelection', "Controls whether the search string in the Find Widget is seeded from the editor selection.")
             },
             'editor.find.autoFindInSelection': {
                 type: 'string',
                 enum: ['never', 'always', 'multiline'],
                 default: defaults.autoFindInSelection,
                 enumDescriptions: [
-                    nls.localize('editor.find.autoFindInSelection.never', 'Never turn on Find in Selection automatically (default).'),
-                    nls.localize('editor.find.autoFindInSelection.always', 'Always turn on Find in Selection automatically.'),
-                    nls.localize('editor.find.autoFindInSelection.multiline', 'Turn on Find in Selection automatically when multiple lines of content are selected.')
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.find.autoFindInSelection.never', 'Never turn on Find in Selection automatically (default).'),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.find.autoFindInSelection.always', 'Always turn on Find in Selection automatically.'),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.find.autoFindInSelection.multiline', 'Turn on Find in Selection automatically when multiple lines of content are selected.')
                 ],
-                description: nls.localize('find.autoFindInSelection', "Controls the condition for turning on Find in Selection automatically.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'find.autoFindInSelection', "Controls the condition for turning on Find in Selection automatically.")
             },
             'editor.find.globalFindClipboard': {
                 type: 'boolean',
                 default: defaults.globalFindClipboard,
-                description: nls.localize('find.globalFindClipboard', "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'find.globalFindClipboard', "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
                 included: platform.isMacintosh
             },
             'editor.find.addExtraSpaceOnTop': {
                 type: 'boolean',
                 default: defaults.addExtraSpaceOnTop,
-                description: nls.localize('find.addExtraSpaceOnTop', "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'find.addExtraSpaceOnTop', "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
             },
             'editor.find.loop': {
                 type: 'boolean',
                 default: defaults.loop,
-                description: nls.localize('find.loop', "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'find.loop', "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
             },
         });
     }
@@ -537,14 +550,14 @@
             anyOf: [
                 {
                     type: 'boolean',
-                    description: nls.localize('fontLigatures', "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property."),
+                    description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'fontLigatures', "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property."),
                 },
                 {
                     type: 'string',
-                    description: nls.localize('fontFeatureSettings', "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
+                    description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'fontFeatureSettings', "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
                 }
             ],
-            description: nls.localize('fontLigaturesGeneral', "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
+            description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'fontLigaturesGeneral', "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
             default: false
         });
     }
@@ -580,14 +593,14 @@
             anyOf: [
                 {
                     type: 'boolean',
-                    description: nls.localize('fontVariations', "Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property."),
+                    description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'fontVariations', "Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property."),
                 },
                 {
                     type: 'string',
-                    description: nls.localize('fontVariationSettings', "Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.")
+                    description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'fontVariationSettings', "Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.")
                 }
             ],
-            description: nls.localize('fontVariationsGeneral', "Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property."),
+            description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'fontVariationsGeneral', "Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property."),
             default: false
         });
     }
@@ -638,7 +651,7 @@
             minimum: 6,
             maximum: 100,
             default: EDITOR_FONT_DEFAULTS.fontSize,
-            description: nls.localize('fontSize', "Controls the font size in pixels.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'fontSize', "Controls the font size in pixels.")
         });
     }
     validate(input) {
@@ -664,7 +677,7 @@
                     type: 'number',
                     minimum: EditorFontWeight.MINIMUM_VALUE,
                     maximum: EditorFontWeight.MAXIMUM_VALUE,
-                    errorMessage: nls.localize('fontWeightErrorMessage', "Only \"normal\" and \"bold\" keywords or numbers between 1 and 1000 are allowed.")
+                    errorMessage: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'fontWeightErrorMessage', "Only \"normal\" and \"bold\" keywords or numbers between 1 and 1000 are allowed.")
                 },
                 {
                     type: 'string',
@@ -675,7 +688,7 @@
                 }
             ],
             default: EDITOR_FONT_DEFAULTS.fontWeight,
-            description: nls.localize('fontWeight', "Controls the font weight. Accepts \"normal\" and \"bold\" keywords or numbers between 1 and 1000.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'fontWeight', "Controls the font weight. Accepts \"normal\" and \"bold\" keywords or numbers between 1 and 1000.")
         });
     }
     validate(input) {
@@ -708,66 +721,80 @@
             enum: ['peek', 'gotoAndPeek', 'goto'],
             default: defaults.multiple,
             enumDescriptions: [
-                nls.localize('editor.gotoLocation.multiple.peek', 'Show Peek view of the results (default)'),
-                nls.localize('editor.gotoLocation.multiple.gotoAndPeek', 'Go to the primary result and show a Peek view'),
-                nls.localize('editor.gotoLocation.multiple.goto', 'Go to the primary result and enable Peek-less navigation to others')
+                nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.gotoLocation.multiple.peek', 'Show Peek view of the results (default)'),
+                nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.gotoLocation.multiple.gotoAndPeek', 'Go to the primary result and show a Peek view'),
+                nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.gotoLocation.multiple.goto', 'Go to the primary result and enable Peek-less navigation to others')
             ]
         };
         const alternativeCommandOptions = ['', 'editor.action.referenceSearch.trigger', 'editor.action.goToReferences', 'editor.action.peekImplementation', 'editor.action.goToImplementation', 'editor.action.peekTypeDefinition', 'editor.action.goToTypeDefinition', 'editor.action.peekDeclaration', 'editor.action.revealDeclaration', 'editor.action.peekDefinition', 'editor.action.revealDefinitionAside', 'editor.action.revealDefinition'];
         super(58 /* EditorOption.gotoLocation */, 'gotoLocation', defaults, {
             'editor.gotoLocation.multiple': {
-                deprecationMessage: nls.localize('editor.gotoLocation.multiple.deprecated', "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead."),
+                deprecationMessage: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.gotoLocation.multiple.deprecated', "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead."),
+            },
+            'editor.gotoLocation.multipleDefinitions': {
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.editor.gotoLocation.multipleDefinitions', "Controls the behavior the 'Go to Definition'-command when multiple target locations exist."),
+                ...jsonSubset,
+            },
+            'editor.gotoLocation.multipleTypeDefinitions': {
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.editor.gotoLocation.multipleTypeDefinitions', "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist."),
+                ...jsonSubset,
+            },
+            'editor.gotoLocation.multipleDeclarations': {
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.editor.gotoLocation.multipleDeclarations', "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist."),
+                ...jsonSubset,
+            },
+            'editor.gotoLocation.multipleImplementations': {
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.editor.gotoLocation.multipleImplemenattions', "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist."),
+                ...jsonSubset,
+            },
+            'editor.gotoLocation.multipleReferences': {
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.editor.gotoLocation.multipleReferences', "Controls the behavior the 'Go to References'-command when multiple target locations exist."),
+                ...jsonSubset,
             },
-            'editor.gotoLocation.multipleDefinitions': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleDefinitions', "Controls the behavior the 'Go to Definition'-command when multiple target locations exist.") }, jsonSubset),
-            'editor.gotoLocation.multipleTypeDefinitions': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleTypeDefinitions', "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.") }, jsonSubset),
-            'editor.gotoLocation.multipleDeclarations': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleDeclarations', "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.") }, jsonSubset),
-            'editor.gotoLocation.multipleImplementations': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleImplemenattions', "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.") }, jsonSubset),
-            'editor.gotoLocation.multipleReferences': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleReferences', "Controls the behavior the 'Go to References'-command when multiple target locations exist.") }, jsonSubset),
             'editor.gotoLocation.alternativeDefinitionCommand': {
                 type: 'string',
                 default: defaults.alternativeDefinitionCommand,
                 enum: alternativeCommandOptions,
-                description: nls.localize('alternativeDefinitionCommand', "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'alternativeDefinitionCommand', "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
             },
             'editor.gotoLocation.alternativeTypeDefinitionCommand': {
                 type: 'string',
                 default: defaults.alternativeTypeDefinitionCommand,
                 enum: alternativeCommandOptions,
-                description: nls.localize('alternativeTypeDefinitionCommand', "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'alternativeTypeDefinitionCommand', "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
             },
             'editor.gotoLocation.alternativeDeclarationCommand': {
                 type: 'string',
                 default: defaults.alternativeDeclarationCommand,
                 enum: alternativeCommandOptions,
-                description: nls.localize('alternativeDeclarationCommand', "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'alternativeDeclarationCommand', "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
             },
             'editor.gotoLocation.alternativeImplementationCommand': {
                 type: 'string',
                 default: defaults.alternativeImplementationCommand,
                 enum: alternativeCommandOptions,
-                description: nls.localize('alternativeImplementationCommand', "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'alternativeImplementationCommand', "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
             },
             'editor.gotoLocation.alternativeReferenceCommand': {
                 type: 'string',
                 default: defaults.alternativeReferenceCommand,
                 enum: alternativeCommandOptions,
-                description: nls.localize('alternativeReferenceCommand', "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'alternativeReferenceCommand', "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
             },
         });
     }
     validate(_input) {
-        var _a, _b, _c, _d, _e;
         if (!_input || typeof _input !== 'object') {
             return this.defaultValue;
         }
         const input = _input;
         return {
             multiple: stringSet(input.multiple, this.defaultValue.multiple, ['peek', 'gotoAndPeek', 'goto']),
-            multipleDefinitions: (_a = input.multipleDefinitions) !== null && _a !== void 0 ? _a : stringSet(input.multipleDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),
-            multipleTypeDefinitions: (_b = input.multipleTypeDefinitions) !== null && _b !== void 0 ? _b : stringSet(input.multipleTypeDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),
-            multipleDeclarations: (_c = input.multipleDeclarations) !== null && _c !== void 0 ? _c : stringSet(input.multipleDeclarations, 'peek', ['peek', 'gotoAndPeek', 'goto']),
-            multipleImplementations: (_d = input.multipleImplementations) !== null && _d !== void 0 ? _d : stringSet(input.multipleImplementations, 'peek', ['peek', 'gotoAndPeek', 'goto']),
-            multipleReferences: (_e = input.multipleReferences) !== null && _e !== void 0 ? _e : stringSet(input.multipleReferences, 'peek', ['peek', 'gotoAndPeek', 'goto']),
+            multipleDefinitions: input.multipleDefinitions ?? stringSet(input.multipleDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),
+            multipleTypeDefinitions: input.multipleTypeDefinitions ?? stringSet(input.multipleTypeDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),
+            multipleDeclarations: input.multipleDeclarations ?? stringSet(input.multipleDeclarations, 'peek', ['peek', 'gotoAndPeek', 'goto']),
+            multipleImplementations: input.multipleImplementations ?? stringSet(input.multipleImplementations, 'peek', ['peek', 'gotoAndPeek', 'goto']),
+            multipleReferences: input.multipleReferences ?? stringSet(input.multipleReferences, 'peek', ['peek', 'gotoAndPeek', 'goto']),
             alternativeDefinitionCommand: EditorStringOption.string(input.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
             alternativeTypeDefinitionCommand: EditorStringOption.string(input.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
             alternativeDeclarationCommand: EditorStringOption.string(input.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
@@ -789,30 +816,30 @@
             'editor.hover.enabled': {
                 type: 'boolean',
                 default: defaults.enabled,
-                description: nls.localize('hover.enabled', "Controls whether the hover is shown.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'hover.enabled', "Controls whether the hover is shown.")
             },
             'editor.hover.delay': {
                 type: 'number',
                 default: defaults.delay,
                 minimum: 0,
                 maximum: 10000,
-                description: nls.localize('hover.delay', "Controls the delay in milliseconds after which the hover is shown.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'hover.delay', "Controls the delay in milliseconds after which the hover is shown.")
             },
             'editor.hover.sticky': {
                 type: 'boolean',
                 default: defaults.sticky,
-                description: nls.localize('hover.sticky', "Controls whether the hover should remain visible when mouse is moved over it.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'hover.sticky', "Controls whether the hover should remain visible when mouse is moved over it.")
             },
             'editor.hover.hidingDelay': {
                 type: 'integer',
                 minimum: 0,
                 default: defaults.hidingDelay,
-                description: nls.localize('hover.hidingDelay', "Controls the delay in milliseconds after thich the hover is hidden. Requires `editor.hover.sticky` to be enabled.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'hover.hidingDelay', "Controls the delay in milliseconds after thich the hover is hidden. Requires `editor.hover.sticky` to be enabled.")
             },
             'editor.hover.above': {
                 type: 'boolean',
                 default: defaults.above,
-                description: nls.localize('hover.above', "Prefer showing hovers above the line, if there's space.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'hover.above', "Prefer showing hovers above the line, if there's space.")
             },
         });
     }
@@ -1152,13 +1179,13 @@
         super(137 /* EditorOption.wrappingStrategy */, 'wrappingStrategy', 'simple', {
             'editor.wrappingStrategy': {
                 enumDescriptions: [
-                    nls.localize('wrappingStrategy.simple', "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
-                    nls.localize('wrappingStrategy.advanced', "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wrappingStrategy.simple', "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wrappingStrategy.advanced', "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
                 ],
                 type: 'string',
                 enum: ['simple', 'advanced'],
                 default: 'simple',
-                description: nls.localize('wrappingStrategy', "Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wrappingStrategy', "Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.")
             }
         });
     }
@@ -1182,7 +1209,7 @@
             'editor.lightbulb.enabled': {
                 type: 'boolean',
                 default: defaults.enabled,
-                description: nls.localize('codeActions', "Enables the Code Action lightbulb in the editor.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'codeActions', "Enables the Code Action lightbulb in the editor.")
             },
         });
     }
@@ -1203,25 +1230,25 @@
             'editor.stickyScroll.enabled': {
                 type: 'boolean',
                 default: defaults.enabled,
-                description: nls.localize('editor.stickyScroll.enabled', "Shows the nested current scopes during the scroll at the top of the editor.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.stickyScroll.enabled', "Shows the nested current scopes during the scroll at the top of the editor.")
             },
             'editor.stickyScroll.maxLineCount': {
                 type: 'number',
                 default: defaults.maxLineCount,
                 minimum: 1,
                 maximum: 10,
-                description: nls.localize('editor.stickyScroll.maxLineCount', "Defines the maximum number of sticky lines to show.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.stickyScroll.maxLineCount', "Defines the maximum number of sticky lines to show.")
             },
             'editor.stickyScroll.defaultModel': {
                 type: 'string',
                 enum: ['outlineModel', 'foldingProviderModel', 'indentationModel'],
                 default: defaults.defaultModel,
-                description: nls.localize('editor.stickyScroll.defaultModel', "Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.stickyScroll.defaultModel', "Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.")
             },
             'editor.stickyScroll.scrollWithEditor': {
                 type: 'boolean',
                 default: defaults.scrollWithEditor,
-                description: nls.localize('editor.stickyScroll.scrollWithEditor', "Enable scrolling of the sticky scroll widget with the editor's horizontal scrollbar.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.stickyScroll.scrollWithEditor', "Enable scrolling of the sticky scroll widget with the editor's horizontal scrollbar.")
             },
         });
     }
@@ -1245,29 +1272,29 @@
             'editor.inlayHints.enabled': {
                 type: 'string',
                 default: defaults.enabled,
-                description: nls.localize('inlayHints.enable', "Enables the inlay hints in the editor."),
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'inlayHints.enable', "Enables the inlay hints in the editor."),
                 enum: ['on', 'onUnlessPressed', 'offUnlessPressed', 'off'],
                 markdownEnumDescriptions: [
-                    nls.localize('editor.inlayHints.on', "Inlay hints are enabled"),
-                    nls.localize('editor.inlayHints.onUnlessPressed', "Inlay hints are showing by default and hide when holding {0}", platform.isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),
-                    nls.localize('editor.inlayHints.offUnlessPressed', "Inlay hints are hidden by default and show when holding {0}", platform.isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),
-                    nls.localize('editor.inlayHints.off', "Inlay hints are disabled"),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.inlayHints.on', "Inlay hints are enabled"),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.inlayHints.onUnlessPressed', "Inlay hints are showing by default and hide when holding {0}", platform.isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.inlayHints.offUnlessPressed', "Inlay hints are hidden by default and show when holding {0}", platform.isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.inlayHints.off', "Inlay hints are disabled"),
                 ],
             },
             'editor.inlayHints.fontSize': {
                 type: 'number',
                 default: defaults.fontSize,
-                markdownDescription: nls.localize('inlayHints.fontSize', "Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.", '`#editor.fontSize#`', '`5`')
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'inlayHints.fontSize', "Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.", '`#editor.fontSize#`', '`5`')
             },
             'editor.inlayHints.fontFamily': {
                 type: 'string',
                 default: defaults.fontFamily,
-                markdownDescription: nls.localize('inlayHints.fontFamily', "Controls font family of inlay hints in the editor. When set to empty, the {0} is used.", '`#editor.fontFamily#`')
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'inlayHints.fontFamily', "Controls font family of inlay hints in the editor. When set to empty, the {0} is used.", '`#editor.fontFamily#`')
             },
             'editor.inlayHints.padding': {
                 type: 'boolean',
                 default: defaults.padding,
-                description: nls.localize('inlayHints.padding', "Enables the padding around the inlay hints in the editor.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'inlayHints.padding', "Enables the padding around the inlay hints in the editor.")
             }
         });
     }
@@ -1316,7 +1343,7 @@
 //#region lineHeight
 class EditorLineHeight extends EditorFloatOption {
     constructor() {
-        super(66 /* EditorOption.lineHeight */, 'lineHeight', EDITOR_FONT_DEFAULTS.lineHeight, x => EditorFloatOption.clamp(x, 0, 150), { markdownDescription: nls.localize('lineHeight', "Controls the line height. \n - Use 0 to automatically compute the line height from the font size.\n - Values between 0 and 8 will be used as a multiplier with the font size.\n - Values greater than or equal to 8 will be used as effective values.") });
+        super(66 /* EditorOption.lineHeight */, 'lineHeight', EDITOR_FONT_DEFAULTS.lineHeight, x => EditorFloatOption.clamp(x, 0, 150), { markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'lineHeight', "Controls the line height. \n - Use 0 to automatically compute the line height from the font size.\n - Values between 0 and 8 will be used as a multiplier with the font size.\n - Values greater than or equal to 8 will be used as effective values.") });
     }
     compute(env, options, value) {
         // The lineHeight is computed from the fontSize if it is 0.
@@ -1341,35 +1368,35 @@
             'editor.minimap.enabled': {
                 type: 'boolean',
                 default: defaults.enabled,
-                description: nls.localize('minimap.enabled', "Controls whether the minimap is shown.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'minimap.enabled', "Controls whether the minimap is shown.")
             },
             'editor.minimap.autohide': {
                 type: 'boolean',
                 default: defaults.autohide,
-                description: nls.localize('minimap.autohide', "Controls whether the minimap is hidden automatically.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'minimap.autohide', "Controls whether the minimap is hidden automatically.")
             },
             'editor.minimap.size': {
                 type: 'string',
                 enum: ['proportional', 'fill', 'fit'],
                 enumDescriptions: [
-                    nls.localize('minimap.size.proportional', "The minimap has the same size as the editor contents (and might scroll)."),
-                    nls.localize('minimap.size.fill', "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
-                    nls.localize('minimap.size.fit', "The minimap will shrink as necessary to never be larger than the editor (no scrolling)."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'minimap.size.proportional', "The minimap has the same size as the editor contents (and might scroll)."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'minimap.size.fill', "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'minimap.size.fit', "The minimap will shrink as necessary to never be larger than the editor (no scrolling)."),
                 ],
                 default: defaults.size,
-                description: nls.localize('minimap.size', "Controls the size of the minimap.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'minimap.size', "Controls the size of the minimap.")
             },
             'editor.minimap.side': {
                 type: 'string',
                 enum: ['left', 'right'],
                 default: defaults.side,
-                description: nls.localize('minimap.side', "Controls the side where to render the minimap.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'minimap.side', "Controls the side where to render the minimap.")
             },
             'editor.minimap.showSlider': {
                 type: 'string',
                 enum: ['always', 'mouseover'],
                 default: defaults.showSlider,
-                description: nls.localize('minimap.showSlider', "Controls when the minimap slider is shown.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'minimap.showSlider', "Controls when the minimap slider is shown.")
             },
             'editor.minimap.scale': {
                 type: 'number',
@@ -1377,17 +1404,17 @@
                 minimum: 1,
                 maximum: 3,
                 enum: [1, 2, 3],
-                description: nls.localize('minimap.scale', "Scale of content drawn in the minimap: 1, 2 or 3.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'minimap.scale', "Scale of content drawn in the minimap: 1, 2 or 3.")
             },
             'editor.minimap.renderCharacters': {
                 type: 'boolean',
                 default: defaults.renderCharacters,
-                description: nls.localize('minimap.renderCharacters', "Render the actual characters on a line as opposed to color blocks.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'minimap.renderCharacters', "Render the actual characters on a line as opposed to color blocks.")
             },
             'editor.minimap.maxColumn': {
                 type: 'number',
                 default: defaults.maxColumn,
-                description: nls.localize('minimap.maxColumn', "Limit the width of the minimap to render at most a certain number of columns.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'minimap.maxColumn', "Limit the width of the minimap to render at most a certain number of columns.")
             }
         });
     }
@@ -1424,14 +1451,14 @@
                 default: 0,
                 minimum: 0,
                 maximum: 1000,
-                description: nls.localize('padding.top', "Controls the amount of space between the top edge of the editor and the first line.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'padding.top', "Controls the amount of space between the top edge of the editor and the first line.")
             },
             'editor.padding.bottom': {
                 type: 'number',
                 default: 0,
                 minimum: 0,
                 maximum: 1000,
-                description: nls.localize('padding.bottom', "Controls the amount of space between the bottom edge of the editor and the last line.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'padding.bottom', "Controls the amount of space between the bottom edge of the editor and the last line.")
             }
         });
     }
@@ -1456,12 +1483,12 @@
             'editor.parameterHints.enabled': {
                 type: 'boolean',
                 default: defaults.enabled,
-                description: nls.localize('parameterHints.enabled', "Enables a pop-up that shows parameter documentation and type information as you type.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'parameterHints.enabled', "Enables a pop-up that shows parameter documentation and type information as you type.")
             },
             'editor.parameterHints.cycle': {
                 type: 'boolean',
                 default: defaults.cycle,
-                description: nls.localize('parameterHints.cycle', "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'parameterHints.cycle', "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
             },
         });
     }
@@ -1498,7 +1525,7 @@
             {
                 type: 'string',
                 enum: ['on', 'inline', 'off'],
-                enumDescriptions: [nls.localize('on', "Quick suggestions show inside the suggest widget"), nls.localize('inline', "Quick suggestions show as ghost text"), nls.localize('off', "Quick suggestions are disabled")]
+                enumDescriptions: [nls.localizeWithPath('vs/editor/common/config/editorOptions', 'on', "Quick suggestions show inside the suggest widget"), nls.localizeWithPath('vs/editor/common/config/editorOptions', 'inline', "Quick suggestions show as ghost text"), nls.localizeWithPath('vs/editor/common/config/editorOptions', 'off', "Quick suggestions are disabled")]
             }
         ];
         super(88 /* EditorOption.quickSuggestions */, 'quickSuggestions', defaults, {
@@ -1508,21 +1535,21 @@
                 strings: {
                     anyOf: types,
                     default: defaults.strings,
-                    description: nls.localize('quickSuggestions.strings', "Enable quick suggestions inside strings.")
+                    description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'quickSuggestions.strings', "Enable quick suggestions inside strings.")
                 },
                 comments: {
                     anyOf: types,
                     default: defaults.comments,
-                    description: nls.localize('quickSuggestions.comments', "Enable quick suggestions inside comments.")
+                    description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'quickSuggestions.comments', "Enable quick suggestions inside comments.")
                 },
                 other: {
                     anyOf: types,
                     default: defaults.other,
-                    description: nls.localize('quickSuggestions.other', "Enable quick suggestions outside of strings and comments.")
+                    description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'quickSuggestions.other', "Enable quick suggestions outside of strings and comments.")
                 },
             },
             default: defaults,
-            markdownDescription: nls.localize('quickSuggestions', "Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the '{0}'-setting which controls if suggestions are triggered by special characters.", `#editor.suggestOnTriggerCharacters#`)
+            markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'quickSuggestions', "Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the '{0}'-setting which controls if suggestions are triggered by special characters.", `#editor.suggestOnTriggerCharacters#`)
         });
         this.defaultValue = defaults;
     }
@@ -1572,13 +1599,13 @@
             type: 'string',
             enum: ['off', 'on', 'relative', 'interval'],
             enumDescriptions: [
-                nls.localize('lineNumbers.off', "Line numbers are not rendered."),
-                nls.localize('lineNumbers.on', "Line numbers are rendered as absolute number."),
-                nls.localize('lineNumbers.relative', "Line numbers are rendered as distance in lines to cursor position."),
-                nls.localize('lineNumbers.interval', "Line numbers are rendered every 10 lines.")
+                nls.localizeWithPath('vs/editor/common/config/editorOptions', 'lineNumbers.off', "Line numbers are not rendered."),
+                nls.localizeWithPath('vs/editor/common/config/editorOptions', 'lineNumbers.on', "Line numbers are rendered as absolute number."),
+                nls.localizeWithPath('vs/editor/common/config/editorOptions', 'lineNumbers.relative', "Line numbers are rendered as distance in lines to cursor position."),
+                nls.localizeWithPath('vs/editor/common/config/editorOptions', 'lineNumbers.interval', "Line numbers are rendered every 10 lines.")
             ],
             default: 'on',
-            description: nls.localize('lineNumbers', "Controls the display of line numbers.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'lineNumbers', "Controls the display of line numbers.")
         });
     }
     validate(lineNumbers) {
@@ -1623,7 +1650,7 @@
 class EditorRulers extends BaseEditorOption {
     constructor() {
         const defaults = [];
-        const columnSchema = { type: 'number', description: nls.localize('rulers.size', "Number of monospace characters at which this editor ruler will render.") };
+        const columnSchema = { type: 'number', description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'rulers.size', "Number of monospace characters at which this editor ruler will render.") };
         super(101 /* EditorOption.rulers */, 'rulers', defaults, {
             type: 'array',
             items: {
@@ -1637,7 +1664,7 @@
                             column: columnSchema,
                             color: {
                                 type: 'string',
-                                description: nls.localize('rulers.color', "Color of this editor ruler."),
+                                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'rulers.color', "Color of this editor ruler."),
                                 format: 'color-hex'
                             }
                         }
@@ -1645,7 +1672,7 @@
                 ]
             },
             default: defaults,
-            description: nls.localize('rulers', "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
+            description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'rulers', "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
         });
     }
     validate(input) {
@@ -1721,38 +1748,38 @@
                 type: 'string',
                 enum: ['auto', 'visible', 'hidden'],
                 enumDescriptions: [
-                    nls.localize('scrollbar.vertical.auto', "The vertical scrollbar will be visible only when necessary."),
-                    nls.localize('scrollbar.vertical.visible', "The vertical scrollbar will always be visible."),
-                    nls.localize('scrollbar.vertical.fit', "The vertical scrollbar will always be hidden."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollbar.vertical.auto', "The vertical scrollbar will be visible only when necessary."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollbar.vertical.visible', "The vertical scrollbar will always be visible."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollbar.vertical.fit', "The vertical scrollbar will always be hidden."),
                 ],
                 default: 'auto',
-                description: nls.localize('scrollbar.vertical', "Controls the visibility of the vertical scrollbar.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollbar.vertical', "Controls the visibility of the vertical scrollbar.")
             },
             'editor.scrollbar.horizontal': {
                 type: 'string',
                 enum: ['auto', 'visible', 'hidden'],
                 enumDescriptions: [
-                    nls.localize('scrollbar.horizontal.auto', "The horizontal scrollbar will be visible only when necessary."),
-                    nls.localize('scrollbar.horizontal.visible', "The horizontal scrollbar will always be visible."),
-                    nls.localize('scrollbar.horizontal.fit', "The horizontal scrollbar will always be hidden."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollbar.horizontal.auto', "The horizontal scrollbar will be visible only when necessary."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollbar.horizontal.visible', "The horizontal scrollbar will always be visible."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollbar.horizontal.fit', "The horizontal scrollbar will always be hidden."),
                 ],
                 default: 'auto',
-                description: nls.localize('scrollbar.horizontal', "Controls the visibility of the horizontal scrollbar.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollbar.horizontal', "Controls the visibility of the horizontal scrollbar.")
             },
             'editor.scrollbar.verticalScrollbarSize': {
                 type: 'number',
                 default: defaults.verticalScrollbarSize,
-                description: nls.localize('scrollbar.verticalScrollbarSize', "The width of the vertical scrollbar.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollbar.verticalScrollbarSize', "The width of the vertical scrollbar.")
             },
             'editor.scrollbar.horizontalScrollbarSize': {
                 type: 'number',
                 default: defaults.horizontalScrollbarSize,
-                description: nls.localize('scrollbar.horizontalScrollbarSize', "The height of the horizontal scrollbar.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollbar.horizontalScrollbarSize', "The height of the horizontal scrollbar.")
             },
             'editor.scrollbar.scrollByPage': {
                 type: 'boolean',
                 default: defaults.scrollByPage,
-                description: nls.localize('scrollbar.scrollByPage', "Controls whether clicks scroll by page or jump to click position.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollbar.scrollByPage', "Controls whether clicks scroll by page or jump to click position.")
             }
         });
     }
@@ -1813,39 +1840,39 @@
                 type: ['boolean', 'string'],
                 enum: [true, false, inUntrustedWorkspace],
                 default: defaults.nonBasicASCII,
-                description: nls.localize('unicodeHighlight.nonBasicASCII', "Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'unicodeHighlight.nonBasicASCII', "Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.")
             },
             [unicodeHighlightConfigKeys.invisibleCharacters]: {
                 restricted: true,
                 type: 'boolean',
                 default: defaults.invisibleCharacters,
-                description: nls.localize('unicodeHighlight.invisibleCharacters', "Controls whether characters that just reserve space or have no width at all are highlighted.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'unicodeHighlight.invisibleCharacters', "Controls whether characters that just reserve space or have no width at all are highlighted.")
             },
             [unicodeHighlightConfigKeys.ambiguousCharacters]: {
                 restricted: true,
                 type: 'boolean',
                 default: defaults.ambiguousCharacters,
-                description: nls.localize('unicodeHighlight.ambiguousCharacters', "Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'unicodeHighlight.ambiguousCharacters', "Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.")
             },
             [unicodeHighlightConfigKeys.includeComments]: {
                 restricted: true,
                 type: ['boolean', 'string'],
                 enum: [true, false, inUntrustedWorkspace],
                 default: defaults.includeComments,
-                description: nls.localize('unicodeHighlight.includeComments', "Controls whether characters in comments should also be subject to Unicode highlighting.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'unicodeHighlight.includeComments', "Controls whether characters in comments should also be subject to Unicode highlighting.")
             },
             [unicodeHighlightConfigKeys.includeStrings]: {
                 restricted: true,
                 type: ['boolean', 'string'],
                 enum: [true, false, inUntrustedWorkspace],
                 default: defaults.includeStrings,
-                description: nls.localize('unicodeHighlight.includeStrings', "Controls whether characters in strings should also be subject to Unicode highlighting.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'unicodeHighlight.includeStrings', "Controls whether characters in strings should also be subject to Unicode highlighting.")
             },
             [unicodeHighlightConfigKeys.allowedCharacters]: {
                 restricted: true,
                 type: 'object',
                 default: defaults.allowedCharacters,
-                description: nls.localize('unicodeHighlight.allowedCharacters', "Defines allowed characters that are not being highlighted."),
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'unicodeHighlight.allowedCharacters', "Defines allowed characters that are not being highlighted."),
                 additionalProperties: {
                     type: 'boolean'
                 }
@@ -1857,7 +1884,7 @@
                     type: 'boolean'
                 },
                 default: defaults.allowedLocales,
-                description: nls.localize('unicodeHighlight.allowedLocales', "Unicode characters that are common in allowed locales are not being highlighted.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'unicodeHighlight.allowedLocales', "Unicode characters that are common in allowed locales are not being highlighted.")
             },
         });
     }
@@ -1866,14 +1893,14 @@
         if (update.allowedCharacters && value) {
             // Treat allowedCharacters atomically
             if (!objects.equals(value.allowedCharacters, update.allowedCharacters)) {
-                value = Object.assign(Object.assign({}, value), { allowedCharacters: update.allowedCharacters });
+                value = { ...value, allowedCharacters: update.allowedCharacters };
                 didChange = true;
             }
         }
         if (update.allowedLocales && value) {
             // Treat allowedLocales atomically
             if (!objects.equals(value.allowedLocales, update.allowedLocales)) {
-                value = Object.assign(Object.assign({}, value), { allowedLocales: update.allowedLocales });
+                value = { ...value, allowedLocales: update.allowedLocales };
                 didChange = true;
             }
         }
@@ -1927,22 +1954,22 @@
             'editor.inlineSuggest.enabled': {
                 type: 'boolean',
                 default: defaults.enabled,
-                description: nls.localize('inlineSuggest.enabled', "Controls whether to automatically show inline suggestions in the editor.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'inlineSuggest.enabled', "Controls whether to automatically show inline suggestions in the editor.")
             },
             'editor.inlineSuggest.showToolbar': {
                 type: 'string',
                 default: defaults.showToolbar,
                 enum: ['always', 'onHover'],
                 enumDescriptions: [
-                    nls.localize('inlineSuggest.showToolbar.always', "Show the inline suggestion toolbar whenever an inline suggestion is shown."),
-                    nls.localize('inlineSuggest.showToolbar.onHover', "Show the inline suggestion toolbar when hovering over an inline suggestion."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'inlineSuggest.showToolbar.always', "Show the inline suggestion toolbar whenever an inline suggestion is shown."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'inlineSuggest.showToolbar.onHover', "Show the inline suggestion toolbar when hovering over an inline suggestion."),
                 ],
-                description: nls.localize('inlineSuggest.showToolbar', "Controls when to show the inline suggestion toolbar."),
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'inlineSuggest.showToolbar', "Controls when to show the inline suggestion toolbar."),
             },
             'editor.inlineSuggest.suppressSuggestions': {
                 type: 'boolean',
                 default: defaults.suppressSuggestions,
-                description: nls.localize('inlineSuggest.suppressSuggestions', "Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'inlineSuggest.suppressSuggestions', "Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.")
             },
         });
     }
@@ -1973,12 +2000,12 @@
             'editor.bracketPairColorization.enabled': {
                 type: 'boolean',
                 default: defaults.enabled,
-                markdownDescription: nls.localize('bracketPairColorization.enabled', "Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.", '`#workbench.colorCustomizations#`')
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'bracketPairColorization.enabled', "Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.", '`#workbench.colorCustomizations#`')
             },
             'editor.bracketPairColorization.independentColorPoolPerBracketType': {
                 type: 'boolean',
                 default: defaults.independentColorPoolPerBracketType,
-                description: nls.localize('bracketPairColorization.independentColorPoolPerBracketType', "Controls whether each bracket type has its own independent color pool.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'bracketPairColorization.independentColorPoolPerBracketType', "Controls whether each bracket type has its own independent color pool.")
             },
         });
     }
@@ -2010,44 +2037,44 @@
                 type: ['boolean', 'string'],
                 enum: [true, 'active', false],
                 enumDescriptions: [
-                    nls.localize('editor.guides.bracketPairs.true', "Enables bracket pair guides."),
-                    nls.localize('editor.guides.bracketPairs.active', "Enables bracket pair guides only for the active bracket pair."),
-                    nls.localize('editor.guides.bracketPairs.false', "Disables bracket pair guides."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.bracketPairs.true', "Enables bracket pair guides."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.bracketPairs.active', "Enables bracket pair guides only for the active bracket pair."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.bracketPairs.false', "Disables bracket pair guides."),
                 ],
                 default: defaults.bracketPairs,
-                description: nls.localize('editor.guides.bracketPairs', "Controls whether bracket pair guides are enabled or not.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.bracketPairs', "Controls whether bracket pair guides are enabled or not.")
             },
             'editor.guides.bracketPairsHorizontal': {
                 type: ['boolean', 'string'],
                 enum: [true, 'active', false],
                 enumDescriptions: [
-                    nls.localize('editor.guides.bracketPairsHorizontal.true', "Enables horizontal guides as addition to vertical bracket pair guides."),
-                    nls.localize('editor.guides.bracketPairsHorizontal.active', "Enables horizontal guides only for the active bracket pair."),
-                    nls.localize('editor.guides.bracketPairsHorizontal.false', "Disables horizontal bracket pair guides."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.bracketPairsHorizontal.true', "Enables horizontal guides as addition to vertical bracket pair guides."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.bracketPairsHorizontal.active', "Enables horizontal guides only for the active bracket pair."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.bracketPairsHorizontal.false', "Disables horizontal bracket pair guides."),
                 ],
                 default: defaults.bracketPairsHorizontal,
-                description: nls.localize('editor.guides.bracketPairsHorizontal', "Controls whether horizontal bracket pair guides are enabled or not.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.bracketPairsHorizontal', "Controls whether horizontal bracket pair guides are enabled or not.")
             },
             'editor.guides.highlightActiveBracketPair': {
                 type: 'boolean',
                 default: defaults.highlightActiveBracketPair,
-                description: nls.localize('editor.guides.highlightActiveBracketPair', "Controls whether the editor should highlight the active bracket pair.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.highlightActiveBracketPair', "Controls whether the editor should highlight the active bracket pair.")
             },
             'editor.guides.indentation': {
                 type: 'boolean',
                 default: defaults.indentation,
-                description: nls.localize('editor.guides.indentation', "Controls whether the editor should render indent guides.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.indentation', "Controls whether the editor should render indent guides.")
             },
             'editor.guides.highlightActiveIndentation': {
                 type: ['boolean', 'string'],
                 enum: [true, 'always', false],
                 enumDescriptions: [
-                    nls.localize('editor.guides.highlightActiveIndentation.true', "Highlights the active indent guide."),
-                    nls.localize('editor.guides.highlightActiveIndentation.always', "Highlights the active indent guide even if bracket guides are highlighted."),
-                    nls.localize('editor.guides.highlightActiveIndentation.false', "Do not highlight the active indent guide."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.highlightActiveIndentation.true', "Highlights the active indent guide."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.highlightActiveIndentation.always', "Highlights the active indent guide even if bracket guides are highlighted."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.highlightActiveIndentation.false', "Do not highlight the active indent guide."),
                 ],
                 default: defaults.highlightActiveIndentation,
-                description: nls.localize('editor.guides.highlightActiveIndentation', "Controls whether the editor should highlight the active indent guide.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.guides.highlightActiveIndentation', "Controls whether the editor should highlight the active indent guide.")
             }
         });
     }
@@ -2121,221 +2148,221 @@
                 type: 'string',
                 enum: ['insert', 'replace'],
                 enumDescriptions: [
-                    nls.localize('suggest.insertMode.insert', "Insert suggestion without overwriting text right of the cursor."),
-                    nls.localize('suggest.insertMode.replace', "Insert suggestion and overwrite text right of the cursor."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.insertMode.insert', "Insert suggestion without overwriting text right of the cursor."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.insertMode.replace', "Insert suggestion and overwrite text right of the cursor."),
                 ],
                 default: defaults.insertMode,
-                description: nls.localize('suggest.insertMode', "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.insertMode', "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
             },
             'editor.suggest.filterGraceful': {
                 type: 'boolean',
                 default: defaults.filterGraceful,
-                description: nls.localize('suggest.filterGraceful', "Controls whether filtering and sorting suggestions accounts for small typos.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.filterGraceful', "Controls whether filtering and sorting suggestions accounts for small typos.")
             },
             'editor.suggest.localityBonus': {
                 type: 'boolean',
                 default: defaults.localityBonus,
-                description: nls.localize('suggest.localityBonus', "Controls whether sorting favors words that appear close to the cursor.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.localityBonus', "Controls whether sorting favors words that appear close to the cursor.")
             },
             'editor.suggest.shareSuggestSelections': {
                 type: 'boolean',
                 default: defaults.shareSuggestSelections,
-                markdownDescription: nls.localize('suggest.shareSuggestSelections', "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.shareSuggestSelections', "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
             },
             'editor.suggest.selectionMode': {
                 type: 'string',
                 enum: ['always', 'never', 'whenTriggerCharacter', 'whenQuickSuggestion'],
                 enumDescriptions: [
-                    nls.localize('suggest.insertMode.always', "Always select a suggestion when automatically triggering IntelliSense."),
-                    nls.localize('suggest.insertMode.never', "Never select a suggestion when automatically triggering IntelliSense."),
-                    nls.localize('suggest.insertMode.whenTriggerCharacter', "Select a suggestion only when triggering IntelliSense from a trigger character."),
-                    nls.localize('suggest.insertMode.whenQuickSuggestion', "Select a suggestion only when triggering IntelliSense as you type."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.insertMode.always', "Always select a suggestion when automatically triggering IntelliSense."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.insertMode.never', "Never select a suggestion when automatically triggering IntelliSense."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.insertMode.whenTriggerCharacter', "Select a suggestion only when triggering IntelliSense from a trigger character."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.insertMode.whenQuickSuggestion', "Select a suggestion only when triggering IntelliSense as you type."),
                 ],
                 default: defaults.selectionMode,
-                markdownDescription: nls.localize('suggest.selectionMode', "Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions (`#editor.quickSuggestions#` and `#editor.suggestOnTriggerCharacters#`) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.selectionMode', "Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions (`#editor.quickSuggestions#` and `#editor.suggestOnTriggerCharacters#`) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.")
             },
             'editor.suggest.snippetsPreventQuickSuggestions': {
                 type: 'boolean',
                 default: defaults.snippetsPreventQuickSuggestions,
-                description: nls.localize('suggest.snippetsPreventQuickSuggestions', "Controls whether an active snippet prevents quick suggestions.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.snippetsPreventQuickSuggestions', "Controls whether an active snippet prevents quick suggestions.")
             },
             'editor.suggest.showIcons': {
                 type: 'boolean',
                 default: defaults.showIcons,
-                description: nls.localize('suggest.showIcons', "Controls whether to show or hide icons in suggestions.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.showIcons', "Controls whether to show or hide icons in suggestions.")
             },
             'editor.suggest.showStatusBar': {
                 type: 'boolean',
                 default: defaults.showStatusBar,
-                description: nls.localize('suggest.showStatusBar', "Controls the visibility of the status bar at the bottom of the suggest widget.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.showStatusBar', "Controls the visibility of the status bar at the bottom of the suggest widget.")
             },
             'editor.suggest.preview': {
                 type: 'boolean',
                 default: defaults.preview,
-                description: nls.localize('suggest.preview', "Controls whether to preview the suggestion outcome in the editor.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.preview', "Controls whether to preview the suggestion outcome in the editor.")
             },
             'editor.suggest.showInlineDetails': {
                 type: 'boolean',
                 default: defaults.showInlineDetails,
-                description: nls.localize('suggest.showInlineDetails', "Controls whether suggest details show inline with the label or only in the details widget.")
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.showInlineDetails', "Controls whether suggest details show inline with the label or only in the details widget.")
             },
             'editor.suggest.maxVisibleSuggestions': {
                 type: 'number',
-                deprecationMessage: nls.localize('suggest.maxVisibleSuggestions.dep', "This setting is deprecated. The suggest widget can now be resized."),
+                deprecationMessage: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggest.maxVisibleSuggestions.dep', "This setting is deprecated. The suggest widget can now be resized."),
             },
             'editor.suggest.filteredTypes': {
                 type: 'object',
-                deprecationMessage: nls.localize('deprecated', "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
+                deprecationMessage: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'deprecated', "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
             },
             'editor.suggest.showMethods': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showMethods', "When enabled IntelliSense shows `method`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showMethods', "When enabled IntelliSense shows `method`-suggestions.")
             },
             'editor.suggest.showFunctions': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showFunctions', "When enabled IntelliSense shows `function`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showFunctions', "When enabled IntelliSense shows `function`-suggestions.")
             },
             'editor.suggest.showConstructors': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showConstructors', "When enabled IntelliSense shows `constructor`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showConstructors', "When enabled IntelliSense shows `constructor`-suggestions.")
             },
             'editor.suggest.showDeprecated': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showDeprecated', "When enabled IntelliSense shows `deprecated`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showDeprecated', "When enabled IntelliSense shows `deprecated`-suggestions.")
             },
             'editor.suggest.matchOnWordStartOnly': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.matchOnWordStartOnly', "When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.matchOnWordStartOnly', "When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.")
             },
             'editor.suggest.showFields': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showFields', "When enabled IntelliSense shows `field`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showFields', "When enabled IntelliSense shows `field`-suggestions.")
             },
             'editor.suggest.showVariables': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showVariables', "When enabled IntelliSense shows `variable`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showVariables', "When enabled IntelliSense shows `variable`-suggestions.")
             },
             'editor.suggest.showClasses': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showClasss', "When enabled IntelliSense shows `class`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showClasss', "When enabled IntelliSense shows `class`-suggestions.")
             },
             'editor.suggest.showStructs': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showStructs', "When enabled IntelliSense shows `struct`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showStructs', "When enabled IntelliSense shows `struct`-suggestions.")
             },
             'editor.suggest.showInterfaces': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showInterfaces', "When enabled IntelliSense shows `interface`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showInterfaces', "When enabled IntelliSense shows `interface`-suggestions.")
             },
             'editor.suggest.showModules': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showModules', "When enabled IntelliSense shows `module`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showModules', "When enabled IntelliSense shows `module`-suggestions.")
             },
             'editor.suggest.showProperties': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showPropertys', "When enabled IntelliSense shows `property`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showPropertys', "When enabled IntelliSense shows `property`-suggestions.")
             },
             'editor.suggest.showEvents': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showEvents', "When enabled IntelliSense shows `event`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showEvents', "When enabled IntelliSense shows `event`-suggestions.")
             },
             'editor.suggest.showOperators': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showOperators', "When enabled IntelliSense shows `operator`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showOperators', "When enabled IntelliSense shows `operator`-suggestions.")
             },
             'editor.suggest.showUnits': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showUnits', "When enabled IntelliSense shows `unit`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showUnits', "When enabled IntelliSense shows `unit`-suggestions.")
             },
             'editor.suggest.showValues': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showValues', "When enabled IntelliSense shows `value`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showValues', "When enabled IntelliSense shows `value`-suggestions.")
             },
             'editor.suggest.showConstants': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showConstants', "When enabled IntelliSense shows `constant`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showConstants', "When enabled IntelliSense shows `constant`-suggestions.")
             },
             'editor.suggest.showEnums': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showEnums', "When enabled IntelliSense shows `enum`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showEnums', "When enabled IntelliSense shows `enum`-suggestions.")
             },
             'editor.suggest.showEnumMembers': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showEnumMembers', "When enabled IntelliSense shows `enumMember`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showEnumMembers', "When enabled IntelliSense shows `enumMember`-suggestions.")
             },
             'editor.suggest.showKeywords': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showKeywords', "When enabled IntelliSense shows `keyword`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showKeywords', "When enabled IntelliSense shows `keyword`-suggestions.")
             },
             'editor.suggest.showWords': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showTexts', "When enabled IntelliSense shows `text`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showTexts', "When enabled IntelliSense shows `text`-suggestions.")
             },
             'editor.suggest.showColors': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showColors', "When enabled IntelliSense shows `color`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showColors', "When enabled IntelliSense shows `color`-suggestions.")
             },
             'editor.suggest.showFiles': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showFiles', "When enabled IntelliSense shows `file`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showFiles', "When enabled IntelliSense shows `file`-suggestions.")
             },
             'editor.suggest.showReferences': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showReferences', "When enabled IntelliSense shows `reference`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showReferences', "When enabled IntelliSense shows `reference`-suggestions.")
             },
             'editor.suggest.showCustomcolors': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showCustomcolors', "When enabled IntelliSense shows `customcolor`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showCustomcolors', "When enabled IntelliSense shows `customcolor`-suggestions.")
             },
             'editor.suggest.showFolders': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showFolders', "When enabled IntelliSense shows `folder`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showFolders', "When enabled IntelliSense shows `folder`-suggestions.")
             },
             'editor.suggest.showTypeParameters': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showTypeParameters', "When enabled IntelliSense shows `typeParameter`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showTypeParameters', "When enabled IntelliSense shows `typeParameter`-suggestions.")
             },
             'editor.suggest.showSnippets': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showSnippets', "When enabled IntelliSense shows `snippet`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showSnippets', "When enabled IntelliSense shows `snippet`-suggestions.")
             },
             'editor.suggest.showUsers': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showUsers', "When enabled IntelliSense shows `user`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showUsers', "When enabled IntelliSense shows `user`-suggestions.")
             },
             'editor.suggest.showIssues': {
                 type: 'boolean',
                 default: true,
-                markdownDescription: nls.localize('editor.suggest.showIssues', "When enabled IntelliSense shows `issues`-suggestions.")
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.suggest.showIssues', "When enabled IntelliSense shows `issues`-suggestions.")
             }
         });
     }
@@ -2395,12 +2422,12 @@
             selectSubwords: true,
         }, {
             'editor.smartSelect.selectLeadingAndTrailingWhitespace': {
-                description: nls.localize('selectLeadingAndTrailingWhitespace', "Whether leading and trailing whitespace should always be selected."),
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'selectLeadingAndTrailingWhitespace', "Whether leading and trailing whitespace should always be selected."),
                 default: true,
                 type: 'boolean'
             },
             'editor.smartSelect.selectSubwords': {
-                description: nls.localize('selectSubwords', "Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected."),
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'selectSubwords', "Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected."),
                 default: true,
                 type: 'boolean'
             }
@@ -2423,12 +2450,12 @@
                 type: 'string',
                 enum: ['none', 'same', 'indent', 'deepIndent'],
                 enumDescriptions: [
-                    nls.localize('wrappingIndent.none', "No indentation. Wrapped lines begin at column 1."),
-                    nls.localize('wrappingIndent.same', "Wrapped lines get the same indentation as the parent."),
-                    nls.localize('wrappingIndent.indent', "Wrapped lines get +1 indentation toward the parent."),
-                    nls.localize('wrappingIndent.deepIndent', "Wrapped lines get +2 indentation toward the parent."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wrappingIndent.none', "No indentation. Wrapped lines begin at column 1."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wrappingIndent.same', "Wrapped lines get the same indentation as the parent."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wrappingIndent.indent', "Wrapped lines get +1 indentation toward the parent."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wrappingIndent.deepIndent', "Wrapped lines get +2 indentation toward the parent."),
                 ],
-                description: nls.localize('wrappingIndent', "Controls the indentation of wrapped lines."),
+                description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wrappingIndent', "Controls the indentation of wrapped lines."),
                 default: 'same'
             }
         });
@@ -2473,18 +2500,18 @@
             'editor.dropIntoEditor.enabled': {
                 type: 'boolean',
                 default: defaults.enabled,
-                markdownDescription: nls.localize('dropIntoEditor.enabled', "Controls whether you can drag and drop a file into a text editor by holding down `shift` (instead of opening the file in an editor)."),
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'dropIntoEditor.enabled', "Controls whether you can drag and drop a file into a text editor by holding down `shift` (instead of opening the file in an editor)."),
             },
             'editor.dropIntoEditor.showDropSelector': {
                 type: 'string',
-                markdownDescription: nls.localize('dropIntoEditor.showDropSelector', "Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped."),
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'dropIntoEditor.showDropSelector', "Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped."),
                 enum: [
                     'afterDrop',
                     'never'
                 ],
                 enumDescriptions: [
-                    nls.localize('dropIntoEditor.showDropSelector.afterDrop', "Show the drop selector widget after a file is dropped into the editor."),
-                    nls.localize('dropIntoEditor.showDropSelector.never', "Never show the drop selector widget. Instead the default drop provider is always used."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'dropIntoEditor.showDropSelector.afterDrop', "Show the drop selector widget after a file is dropped into the editor."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'dropIntoEditor.showDropSelector.never', "Never show the drop selector widget. Instead the default drop provider is always used."),
                 ],
                 default: 'afterDrop',
             },
@@ -2508,18 +2535,18 @@
             'editor.pasteAs.enabled': {
                 type: 'boolean',
                 default: defaults.enabled,
-                markdownDescription: nls.localize('pasteAs.enabled', "Controls whether you can paste content in different ways."),
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'pasteAs.enabled', "Controls whether you can paste content in different ways."),
             },
             'editor.pasteAs.showPasteSelector': {
                 type: 'string',
-                markdownDescription: nls.localize('pasteAs.showPasteSelector', "Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted."),
+                markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'pasteAs.showPasteSelector', "Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted."),
                 enum: [
                     'afterPaste',
                     'never'
                 ],
                 enumDescriptions: [
-                    nls.localize('pasteAs.showPasteSelector.afterPaste', "Show the paste selector widget after content is pasted into the editor."),
-                    nls.localize('pasteAs.showPasteSelector.never', "Never show the paste selector widget. Instead the default pasting behavior is always used."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'pasteAs.showPasteSelector.afterPaste', "Show the paste selector widget after content is pasted into the editor."),
+                    nls.localizeWithPath('vs/editor/common/config/editorOptions', 'pasteAs.showPasteSelector.never', "Never show the paste selector widget. Instead the default pasting behavior is always used."),
                 ],
                 default: 'afterPaste',
             },
@@ -2559,201 +2586,201 @@
     return option;
 }
 export const EditorOptions = {
-    acceptSuggestionOnCommitCharacter: register(new EditorBooleanOption(0 /* EditorOption.acceptSuggestionOnCommitCharacter */, 'acceptSuggestionOnCommitCharacter', true, { markdownDescription: nls.localize('acceptSuggestionOnCommitCharacter', "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.") })),
+    acceptSuggestionOnCommitCharacter: register(new EditorBooleanOption(0 /* EditorOption.acceptSuggestionOnCommitCharacter */, 'acceptSuggestionOnCommitCharacter', true, { markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'acceptSuggestionOnCommitCharacter', "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.") })),
     acceptSuggestionOnEnter: register(new EditorStringEnumOption(1 /* EditorOption.acceptSuggestionOnEnter */, 'acceptSuggestionOnEnter', 'on', ['on', 'smart', 'off'], {
         markdownEnumDescriptions: [
             '',
-            nls.localize('acceptSuggestionOnEnterSmart', "Only accept a suggestion with `Enter` when it makes a textual change."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'acceptSuggestionOnEnterSmart', "Only accept a suggestion with `Enter` when it makes a textual change."),
             ''
         ],
-        markdownDescription: nls.localize('acceptSuggestionOnEnter', "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
+        markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'acceptSuggestionOnEnter', "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
     })),
     accessibilitySupport: register(new EditorAccessibilitySupport()),
     accessibilityPageSize: register(new EditorIntOption(3 /* EditorOption.accessibilityPageSize */, 'accessibilityPageSize', 10, 1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, {
-        description: nls.localize('accessibilityPageSize', "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default."),
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'accessibilityPageSize', "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default."),
         tags: ['accessibility']
     })),
-    ariaLabel: register(new EditorStringOption(4 /* EditorOption.ariaLabel */, 'ariaLabel', nls.localize('editorViewAccessibleLabel', "Editor content"))),
+    ariaLabel: register(new EditorStringOption(4 /* EditorOption.ariaLabel */, 'ariaLabel', nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editorViewAccessibleLabel', "Editor content"))),
     ariaRequired: register(new EditorBooleanOption(5 /* EditorOption.ariaRequired */, 'ariaRequired', false, undefined)),
     screenReaderAnnounceInlineSuggestion: register(new EditorBooleanOption(8 /* EditorOption.screenReaderAnnounceInlineSuggestion */, 'screenReaderAnnounceInlineSuggestion', true, {
-        description: nls.localize('screenReaderAnnounceInlineSuggestion', "Control whether inline suggestions are announced by a screen reader."),
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'screenReaderAnnounceInlineSuggestion', "Control whether inline suggestions are announced by a screen reader."),
         tags: ['accessibility']
     })),
     autoClosingBrackets: register(new EditorStringEnumOption(6 /* EditorOption.autoClosingBrackets */, 'autoClosingBrackets', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {
         enumDescriptions: [
             '',
-            nls.localize('editor.autoClosingBrackets.languageDefined', "Use language configurations to determine when to autoclose brackets."),
-            nls.localize('editor.autoClosingBrackets.beforeWhitespace', "Autoclose brackets only when the cursor is to the left of whitespace."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoClosingBrackets.languageDefined', "Use language configurations to determine when to autoclose brackets."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoClosingBrackets.beforeWhitespace', "Autoclose brackets only when the cursor is to the left of whitespace."),
             '',
         ],
-        description: nls.localize('autoClosingBrackets', "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'autoClosingBrackets', "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
     })),
     autoClosingComments: register(new EditorStringEnumOption(7 /* EditorOption.autoClosingComments */, 'autoClosingComments', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {
         enumDescriptions: [
             '',
-            nls.localize('editor.autoClosingComments.languageDefined', "Use language configurations to determine when to autoclose comments."),
-            nls.localize('editor.autoClosingComments.beforeWhitespace', "Autoclose comments only when the cursor is to the left of whitespace."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoClosingComments.languageDefined', "Use language configurations to determine when to autoclose comments."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoClosingComments.beforeWhitespace', "Autoclose comments only when the cursor is to the left of whitespace."),
             '',
         ],
-        description: nls.localize('autoClosingComments', "Controls whether the editor should automatically close comments after the user adds an opening comment.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'autoClosingComments', "Controls whether the editor should automatically close comments after the user adds an opening comment.")
     })),
     autoClosingDelete: register(new EditorStringEnumOption(9 /* EditorOption.autoClosingDelete */, 'autoClosingDelete', 'auto', ['always', 'auto', 'never'], {
         enumDescriptions: [
             '',
-            nls.localize('editor.autoClosingDelete.auto', "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoClosingDelete.auto', "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
             '',
         ],
-        description: nls.localize('autoClosingDelete', "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'autoClosingDelete', "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
     })),
     autoClosingOvertype: register(new EditorStringEnumOption(10 /* EditorOption.autoClosingOvertype */, 'autoClosingOvertype', 'auto', ['always', 'auto', 'never'], {
         enumDescriptions: [
             '',
-            nls.localize('editor.autoClosingOvertype.auto', "Type over closing quotes or brackets only if they were automatically inserted."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoClosingOvertype.auto', "Type over closing quotes or brackets only if they were automatically inserted."),
             '',
         ],
-        description: nls.localize('autoClosingOvertype', "Controls whether the editor should type over closing quotes or brackets.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'autoClosingOvertype', "Controls whether the editor should type over closing quotes or brackets.")
     })),
     autoClosingQuotes: register(new EditorStringEnumOption(11 /* EditorOption.autoClosingQuotes */, 'autoClosingQuotes', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {
         enumDescriptions: [
             '',
-            nls.localize('editor.autoClosingQuotes.languageDefined', "Use language configurations to determine when to autoclose quotes."),
-            nls.localize('editor.autoClosingQuotes.beforeWhitespace', "Autoclose quotes only when the cursor is to the left of whitespace."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoClosingQuotes.languageDefined', "Use language configurations to determine when to autoclose quotes."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoClosingQuotes.beforeWhitespace', "Autoclose quotes only when the cursor is to the left of whitespace."),
             '',
         ],
-        description: nls.localize('autoClosingQuotes', "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'autoClosingQuotes', "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
     })),
     autoIndent: register(new EditorEnumOption(12 /* EditorOption.autoIndent */, 'autoIndent', 4 /* EditorAutoIndentStrategy.Full */, 'full', ['none', 'keep', 'brackets', 'advanced', 'full'], _autoIndentFromString, {
         enumDescriptions: [
-            nls.localize('editor.autoIndent.none', "The editor will not insert indentation automatically."),
-            nls.localize('editor.autoIndent.keep', "The editor will keep the current line's indentation."),
-            nls.localize('editor.autoIndent.brackets', "The editor will keep the current line's indentation and honor language defined brackets."),
-            nls.localize('editor.autoIndent.advanced', "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
-            nls.localize('editor.autoIndent.full', "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoIndent.none', "The editor will not insert indentation automatically."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoIndent.keep', "The editor will keep the current line's indentation."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoIndent.brackets', "The editor will keep the current line's indentation and honor language defined brackets."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoIndent.advanced', "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoIndent.full', "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages."),
         ],
-        description: nls.localize('autoIndent', "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'autoIndent', "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
     })),
     automaticLayout: register(new EditorBooleanOption(13 /* EditorOption.automaticLayout */, 'automaticLayout', false)),
     autoSurround: register(new EditorStringEnumOption(14 /* EditorOption.autoSurround */, 'autoSurround', 'languageDefined', ['languageDefined', 'quotes', 'brackets', 'never'], {
         enumDescriptions: [
-            nls.localize('editor.autoSurround.languageDefined', "Use language configurations to determine when to automatically surround selections."),
-            nls.localize('editor.autoSurround.quotes', "Surround with quotes but not brackets."),
-            nls.localize('editor.autoSurround.brackets', "Surround with brackets but not quotes."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoSurround.languageDefined', "Use language configurations to determine when to automatically surround selections."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoSurround.quotes', "Surround with quotes but not brackets."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.autoSurround.brackets', "Surround with brackets but not quotes."),
             ''
         ],
-        description: nls.localize('autoSurround', "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'autoSurround', "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
     })),
     bracketPairColorization: register(new BracketPairColorization()),
     bracketPairGuides: register(new GuideOptions()),
-    stickyTabStops: register(new EditorBooleanOption(115 /* EditorOption.stickyTabStops */, 'stickyTabStops', false, { description: nls.localize('stickyTabStops', "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.") })),
-    codeLens: register(new EditorBooleanOption(17 /* EditorOption.codeLens */, 'codeLens', true, { description: nls.localize('codeLens', "Controls whether the editor shows CodeLens.") })),
-    codeLensFontFamily: register(new EditorStringOption(18 /* EditorOption.codeLensFontFamily */, 'codeLensFontFamily', '', { description: nls.localize('codeLensFontFamily', "Controls the font family for CodeLens.") })),
+    stickyTabStops: register(new EditorBooleanOption(115 /* EditorOption.stickyTabStops */, 'stickyTabStops', false, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'stickyTabStops', "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.") })),
+    codeLens: register(new EditorBooleanOption(17 /* EditorOption.codeLens */, 'codeLens', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'codeLens', "Controls whether the editor shows CodeLens.") })),
+    codeLensFontFamily: register(new EditorStringOption(18 /* EditorOption.codeLensFontFamily */, 'codeLensFontFamily', '', { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'codeLensFontFamily', "Controls the font family for CodeLens.") })),
     codeLensFontSize: register(new EditorIntOption(19 /* EditorOption.codeLensFontSize */, 'codeLensFontSize', 0, 0, 100, {
         type: 'number',
         default: 0,
         minimum: 0,
         maximum: 100,
-        markdownDescription: nls.localize('codeLensFontSize', "Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.")
+        markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'codeLensFontSize', "Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.")
     })),
-    colorDecorators: register(new EditorBooleanOption(20 /* EditorOption.colorDecorators */, 'colorDecorators', true, { description: nls.localize('colorDecorators', "Controls whether the editor should render the inline color decorators and color picker.") })),
+    colorDecorators: register(new EditorBooleanOption(20 /* EditorOption.colorDecorators */, 'colorDecorators', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'colorDecorators', "Controls whether the editor should render the inline color decorators and color picker.") })),
     colorDecoratorActivatedOn: register(new EditorStringEnumOption(146 /* EditorOption.colorDecoratorsActivatedOn */, 'colorDecoratorsActivatedOn', 'clickAndHover', ['clickAndHover', 'hover', 'click'], {
         enumDescriptions: [
-            nls.localize('editor.colorDecoratorActivatedOn.clickAndHover', "Make the color picker appear both on click and hover of the color decorator"),
-            nls.localize('editor.colorDecoratorActivatedOn.hover', "Make the color picker appear on hover of the color decorator"),
-            nls.localize('editor.colorDecoratorActivatedOn.click', "Make the color picker appear on click of the color decorator")
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.colorDecoratorActivatedOn.clickAndHover', "Make the color picker appear both on click and hover of the color decorator"),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.colorDecoratorActivatedOn.hover', "Make the color picker appear on hover of the color decorator"),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'editor.colorDecoratorActivatedOn.click', "Make the color picker appear on click of the color decorator")
         ],
-        description: nls.localize('colorDecoratorActivatedOn', "Controls the condition to make a color picker appear from a color decorator")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'colorDecoratorActivatedOn', "Controls the condition to make a color picker appear from a color decorator")
     })),
     colorDecoratorsLimit: register(new EditorIntOption(21 /* EditorOption.colorDecoratorsLimit */, 'colorDecoratorsLimit', 500, 1, 1000000, {
-        markdownDescription: nls.localize('colorDecoratorsLimit', "Controls the max number of color decorators that can be rendered in an editor at once.")
+        markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'colorDecoratorsLimit', "Controls the max number of color decorators that can be rendered in an editor at once.")
     })),
-    columnSelection: register(new EditorBooleanOption(22 /* EditorOption.columnSelection */, 'columnSelection', false, { description: nls.localize('columnSelection', "Enable that the selection with the mouse and keys is doing column selection.") })),
+    columnSelection: register(new EditorBooleanOption(22 /* EditorOption.columnSelection */, 'columnSelection', false, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'columnSelection', "Enable that the selection with the mouse and keys is doing column selection.") })),
     comments: register(new EditorComments()),
     contextmenu: register(new EditorBooleanOption(24 /* EditorOption.contextmenu */, 'contextmenu', true)),
-    copyWithSyntaxHighlighting: register(new EditorBooleanOption(25 /* EditorOption.copyWithSyntaxHighlighting */, 'copyWithSyntaxHighlighting', true, { description: nls.localize('copyWithSyntaxHighlighting', "Controls whether syntax highlighting should be copied into the clipboard.") })),
-    cursorBlinking: register(new EditorEnumOption(26 /* EditorOption.cursorBlinking */, 'cursorBlinking', 1 /* TextEditorCursorBlinkingStyle.Blink */, 'blink', ['blink', 'smooth', 'phase', 'expand', 'solid'], _cursorBlinkingStyleFromString, { description: nls.localize('cursorBlinking', "Control the cursor animation style.") })),
+    copyWithSyntaxHighlighting: register(new EditorBooleanOption(25 /* EditorOption.copyWithSyntaxHighlighting */, 'copyWithSyntaxHighlighting', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'copyWithSyntaxHighlighting', "Controls whether syntax highlighting should be copied into the clipboard.") })),
+    cursorBlinking: register(new EditorEnumOption(26 /* EditorOption.cursorBlinking */, 'cursorBlinking', 1 /* TextEditorCursorBlinkingStyle.Blink */, 'blink', ['blink', 'smooth', 'phase', 'expand', 'solid'], _cursorBlinkingStyleFromString, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'cursorBlinking', "Control the cursor animation style.") })),
     cursorSmoothCaretAnimation: register(new EditorStringEnumOption(27 /* EditorOption.cursorSmoothCaretAnimation */, 'cursorSmoothCaretAnimation', 'off', ['off', 'explicit', 'on'], {
         enumDescriptions: [
-            nls.localize('cursorSmoothCaretAnimation.off', "Smooth caret animation is disabled."),
-            nls.localize('cursorSmoothCaretAnimation.explicit', "Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture."),
-            nls.localize('cursorSmoothCaretAnimation.on', "Smooth caret animation is always enabled.")
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'cursorSmoothCaretAnimation.off', "Smooth caret animation is disabled."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'cursorSmoothCaretAnimation.explicit', "Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'cursorSmoothCaretAnimation.on', "Smooth caret animation is always enabled.")
         ],
-        description: nls.localize('cursorSmoothCaretAnimation', "Controls whether the smooth caret animation should be enabled.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'cursorSmoothCaretAnimation', "Controls whether the smooth caret animation should be enabled.")
     })),
-    cursorStyle: register(new EditorEnumOption(28 /* EditorOption.cursorStyle */, 'cursorStyle', TextEditorCursorStyle.Line, 'line', ['line', 'block', 'underline', 'line-thin', 'block-outline', 'underline-thin'], _cursorStyleFromString, { description: nls.localize('cursorStyle', "Controls the cursor style.") })),
-    cursorSurroundingLines: register(new EditorIntOption(29 /* EditorOption.cursorSurroundingLines */, 'cursorSurroundingLines', 0, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('cursorSurroundingLines', "Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.") })),
+    cursorStyle: register(new EditorEnumOption(28 /* EditorOption.cursorStyle */, 'cursorStyle', TextEditorCursorStyle.Line, 'line', ['line', 'block', 'underline', 'line-thin', 'block-outline', 'underline-thin'], _cursorStyleFromString, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'cursorStyle', "Controls the cursor style.") })),
+    cursorSurroundingLines: register(new EditorIntOption(29 /* EditorOption.cursorSurroundingLines */, 'cursorSurroundingLines', 0, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'cursorSurroundingLines', "Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.") })),
     cursorSurroundingLinesStyle: register(new EditorStringEnumOption(30 /* EditorOption.cursorSurroundingLinesStyle */, 'cursorSurroundingLinesStyle', 'default', ['default', 'all'], {
         enumDescriptions: [
-            nls.localize('cursorSurroundingLinesStyle.default', "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
-            nls.localize('cursorSurroundingLinesStyle.all', "`cursorSurroundingLines` is enforced always.")
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'cursorSurroundingLinesStyle.default', "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'cursorSurroundingLinesStyle.all', "`cursorSurroundingLines` is enforced always.")
         ],
-        markdownDescription: nls.localize('cursorSurroundingLinesStyle', "Controls when `#cursorSurroundingLines#` should be enforced.")
+        markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'cursorSurroundingLinesStyle', "Controls when `#cursorSurroundingLines#` should be enforced.")
     })),
-    cursorWidth: register(new EditorIntOption(31 /* EditorOption.cursorWidth */, 'cursorWidth', 0, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { markdownDescription: nls.localize('cursorWidth', "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.") })),
+    cursorWidth: register(new EditorIntOption(31 /* EditorOption.cursorWidth */, 'cursorWidth', 0, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'cursorWidth', "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.") })),
     disableLayerHinting: register(new EditorBooleanOption(32 /* EditorOption.disableLayerHinting */, 'disableLayerHinting', false)),
     disableMonospaceOptimizations: register(new EditorBooleanOption(33 /* EditorOption.disableMonospaceOptimizations */, 'disableMonospaceOptimizations', false)),
     domReadOnly: register(new EditorBooleanOption(34 /* EditorOption.domReadOnly */, 'domReadOnly', false)),
-    dragAndDrop: register(new EditorBooleanOption(35 /* EditorOption.dragAndDrop */, 'dragAndDrop', true, { description: nls.localize('dragAndDrop', "Controls whether the editor should allow moving selections via drag and drop.") })),
+    dragAndDrop: register(new EditorBooleanOption(35 /* EditorOption.dragAndDrop */, 'dragAndDrop', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'dragAndDrop', "Controls whether the editor should allow moving selections via drag and drop.") })),
     emptySelectionClipboard: register(new EditorEmptySelectionClipboard()),
     dropIntoEditor: register(new EditorDropIntoEditor()),
     stickyScroll: register(new EditorStickyScroll()),
     experimentalWhitespaceRendering: register(new EditorStringEnumOption(38 /* EditorOption.experimentalWhitespaceRendering */, 'experimentalWhitespaceRendering', 'svg', ['svg', 'font', 'off'], {
         enumDescriptions: [
-            nls.localize('experimentalWhitespaceRendering.svg', "Use a new rendering method with svgs."),
-            nls.localize('experimentalWhitespaceRendering.font', "Use a new rendering method with font characters."),
-            nls.localize('experimentalWhitespaceRendering.off', "Use the stable rendering method."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'experimentalWhitespaceRendering.svg', "Use a new rendering method with svgs."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'experimentalWhitespaceRendering.font', "Use a new rendering method with font characters."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'experimentalWhitespaceRendering.off', "Use the stable rendering method."),
         ],
-        description: nls.localize('experimentalWhitespaceRendering', "Controls whether whitespace is rendered with a new, experimental method.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'experimentalWhitespaceRendering', "Controls whether whitespace is rendered with a new, experimental method.")
     })),
     extraEditorClassName: register(new EditorStringOption(39 /* EditorOption.extraEditorClassName */, 'extraEditorClassName', '')),
-    fastScrollSensitivity: register(new EditorFloatOption(40 /* EditorOption.fastScrollSensitivity */, 'fastScrollSensitivity', 5, x => (x <= 0 ? 5 : x), { markdownDescription: nls.localize('fastScrollSensitivity', "Scrolling speed multiplier when pressing `Alt`.") })),
+    fastScrollSensitivity: register(new EditorFloatOption(40 /* EditorOption.fastScrollSensitivity */, 'fastScrollSensitivity', 5, x => (x <= 0 ? 5 : x), { markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'fastScrollSensitivity', "Scrolling speed multiplier when pressing `Alt`.") })),
     find: register(new EditorFind()),
     fixedOverflowWidgets: register(new EditorBooleanOption(42 /* EditorOption.fixedOverflowWidgets */, 'fixedOverflowWidgets', false)),
-    folding: register(new EditorBooleanOption(43 /* EditorOption.folding */, 'folding', true, { description: nls.localize('folding', "Controls whether the editor has code folding enabled.") })),
+    folding: register(new EditorBooleanOption(43 /* EditorOption.folding */, 'folding', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'folding', "Controls whether the editor has code folding enabled.") })),
     foldingStrategy: register(new EditorStringEnumOption(44 /* EditorOption.foldingStrategy */, 'foldingStrategy', 'auto', ['auto', 'indentation'], {
         enumDescriptions: [
-            nls.localize('foldingStrategy.auto', "Use a language-specific folding strategy if available, else the indentation-based one."),
-            nls.localize('foldingStrategy.indentation', "Use the indentation-based folding strategy."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'foldingStrategy.auto', "Use a language-specific folding strategy if available, else the indentation-based one."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'foldingStrategy.indentation', "Use the indentation-based folding strategy."),
         ],
-        description: nls.localize('foldingStrategy', "Controls the strategy for computing folding ranges.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'foldingStrategy', "Controls the strategy for computing folding ranges.")
     })),
-    foldingHighlight: register(new EditorBooleanOption(45 /* EditorOption.foldingHighlight */, 'foldingHighlight', true, { description: nls.localize('foldingHighlight', "Controls whether the editor should highlight folded ranges.") })),
-    foldingImportsByDefault: register(new EditorBooleanOption(46 /* EditorOption.foldingImportsByDefault */, 'foldingImportsByDefault', false, { description: nls.localize('foldingImportsByDefault', "Controls whether the editor automatically collapses import ranges.") })),
+    foldingHighlight: register(new EditorBooleanOption(45 /* EditorOption.foldingHighlight */, 'foldingHighlight', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'foldingHighlight', "Controls whether the editor should highlight folded ranges.") })),
+    foldingImportsByDefault: register(new EditorBooleanOption(46 /* EditorOption.foldingImportsByDefault */, 'foldingImportsByDefault', false, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'foldingImportsByDefault', "Controls whether the editor automatically collapses import ranges.") })),
     foldingMaximumRegions: register(new EditorIntOption(47 /* EditorOption.foldingMaximumRegions */, 'foldingMaximumRegions', 5000, 10, 65000, // limit must be less than foldingRanges MAX_FOLDING_REGIONS
-    { description: nls.localize('foldingMaximumRegions', "The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.") })),
-    unfoldOnClickAfterEndOfLine: register(new EditorBooleanOption(48 /* EditorOption.unfoldOnClickAfterEndOfLine */, 'unfoldOnClickAfterEndOfLine', false, { description: nls.localize('unfoldOnClickAfterEndOfLine', "Controls whether clicking on the empty content after a folded line will unfold the line.") })),
-    fontFamily: register(new EditorStringOption(49 /* EditorOption.fontFamily */, 'fontFamily', EDITOR_FONT_DEFAULTS.fontFamily, { description: nls.localize('fontFamily', "Controls the font family.") })),
+    { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'foldingMaximumRegions', "The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.") })),
+    unfoldOnClickAfterEndOfLine: register(new EditorBooleanOption(48 /* EditorOption.unfoldOnClickAfterEndOfLine */, 'unfoldOnClickAfterEndOfLine', false, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'unfoldOnClickAfterEndOfLine', "Controls whether clicking on the empty content after a folded line will unfold the line.") })),
+    fontFamily: register(new EditorStringOption(49 /* EditorOption.fontFamily */, 'fontFamily', EDITOR_FONT_DEFAULTS.fontFamily, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'fontFamily', "Controls the font family.") })),
     fontInfo: register(new EditorFontInfo()),
     fontLigatures2: register(new EditorFontLigatures()),
     fontSize: register(new EditorFontSize()),
     fontWeight: register(new EditorFontWeight()),
     fontVariations: register(new EditorFontVariations()),
-    formatOnPaste: register(new EditorBooleanOption(55 /* EditorOption.formatOnPaste */, 'formatOnPaste', false, { description: nls.localize('formatOnPaste', "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.") })),
-    formatOnType: register(new EditorBooleanOption(56 /* EditorOption.formatOnType */, 'formatOnType', false, { description: nls.localize('formatOnType', "Controls whether the editor should automatically format the line after typing.") })),
-    glyphMargin: register(new EditorBooleanOption(57 /* EditorOption.glyphMargin */, 'glyphMargin', true, { description: nls.localize('glyphMargin', "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.") })),
+    formatOnPaste: register(new EditorBooleanOption(55 /* EditorOption.formatOnPaste */, 'formatOnPaste', false, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'formatOnPaste', "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.") })),
+    formatOnType: register(new EditorBooleanOption(56 /* EditorOption.formatOnType */, 'formatOnType', false, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'formatOnType', "Controls whether the editor should automatically format the line after typing.") })),
+    glyphMargin: register(new EditorBooleanOption(57 /* EditorOption.glyphMargin */, 'glyphMargin', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'glyphMargin', "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.") })),
     gotoLocation: register(new EditorGoToLocation()),
-    hideCursorInOverviewRuler: register(new EditorBooleanOption(59 /* EditorOption.hideCursorInOverviewRuler */, 'hideCursorInOverviewRuler', false, { description: nls.localize('hideCursorInOverviewRuler', "Controls whether the cursor should be hidden in the overview ruler.") })),
+    hideCursorInOverviewRuler: register(new EditorBooleanOption(59 /* EditorOption.hideCursorInOverviewRuler */, 'hideCursorInOverviewRuler', false, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'hideCursorInOverviewRuler', "Controls whether the cursor should be hidden in the overview ruler.") })),
     hover: register(new EditorHover()),
     inDiffEditor: register(new EditorBooleanOption(61 /* EditorOption.inDiffEditor */, 'inDiffEditor', false)),
-    letterSpacing: register(new EditorFloatOption(63 /* EditorOption.letterSpacing */, 'letterSpacing', EDITOR_FONT_DEFAULTS.letterSpacing, x => EditorFloatOption.clamp(x, -5, 20), { description: nls.localize('letterSpacing', "Controls the letter spacing in pixels.") })),
+    letterSpacing: register(new EditorFloatOption(63 /* EditorOption.letterSpacing */, 'letterSpacing', EDITOR_FONT_DEFAULTS.letterSpacing, x => EditorFloatOption.clamp(x, -5, 20), { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'letterSpacing', "Controls the letter spacing in pixels.") })),
     lightbulb: register(new EditorLightbulb()),
     lineDecorationsWidth: register(new EditorLineDecorationsWidth()),
     lineHeight: register(new EditorLineHeight()),
     lineNumbers: register(new EditorRenderLineNumbersOption()),
     lineNumbersMinChars: register(new EditorIntOption(68 /* EditorOption.lineNumbersMinChars */, 'lineNumbersMinChars', 5, 1, 300)),
-    linkedEditing: register(new EditorBooleanOption(69 /* EditorOption.linkedEditing */, 'linkedEditing', false, { description: nls.localize('linkedEditing', "Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.") })),
-    links: register(new EditorBooleanOption(70 /* EditorOption.links */, 'links', true, { description: nls.localize('links', "Controls whether the editor should detect links and make them clickable.") })),
-    matchBrackets: register(new EditorStringEnumOption(71 /* EditorOption.matchBrackets */, 'matchBrackets', 'always', ['always', 'near', 'never'], { description: nls.localize('matchBrackets', "Highlight matching brackets.") })),
+    linkedEditing: register(new EditorBooleanOption(69 /* EditorOption.linkedEditing */, 'linkedEditing', false, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'linkedEditing', "Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.") })),
+    links: register(new EditorBooleanOption(70 /* EditorOption.links */, 'links', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'links', "Controls whether the editor should detect links and make them clickable.") })),
+    matchBrackets: register(new EditorStringEnumOption(71 /* EditorOption.matchBrackets */, 'matchBrackets', 'always', ['always', 'near', 'never'], { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'matchBrackets', "Highlight matching brackets.") })),
     minimap: register(new EditorMinimap()),
     mouseStyle: register(new EditorStringEnumOption(73 /* EditorOption.mouseStyle */, 'mouseStyle', 'text', ['text', 'default', 'copy'])),
-    mouseWheelScrollSensitivity: register(new EditorFloatOption(74 /* EditorOption.mouseWheelScrollSensitivity */, 'mouseWheelScrollSensitivity', 1, x => (x === 0 ? 1 : x), { markdownDescription: nls.localize('mouseWheelScrollSensitivity', "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.") })),
-    mouseWheelZoom: register(new EditorBooleanOption(75 /* EditorOption.mouseWheelZoom */, 'mouseWheelZoom', false, { markdownDescription: nls.localize('mouseWheelZoom', "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.") })),
-    multiCursorMergeOverlapping: register(new EditorBooleanOption(76 /* EditorOption.multiCursorMergeOverlapping */, 'multiCursorMergeOverlapping', true, { description: nls.localize('multiCursorMergeOverlapping', "Merge multiple cursors when they are overlapping.") })),
+    mouseWheelScrollSensitivity: register(new EditorFloatOption(74 /* EditorOption.mouseWheelScrollSensitivity */, 'mouseWheelScrollSensitivity', 1, x => (x === 0 ? 1 : x), { markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'mouseWheelScrollSensitivity', "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.") })),
+    mouseWheelZoom: register(new EditorBooleanOption(75 /* EditorOption.mouseWheelZoom */, 'mouseWheelZoom', false, { markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'mouseWheelZoom', "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.") })),
+    multiCursorMergeOverlapping: register(new EditorBooleanOption(76 /* EditorOption.multiCursorMergeOverlapping */, 'multiCursorMergeOverlapping', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'multiCursorMergeOverlapping', "Merge multiple cursors when they are overlapping.") })),
     multiCursorModifier: register(new EditorEnumOption(77 /* EditorOption.multiCursorModifier */, 'multiCursorModifier', 'altKey', 'alt', ['ctrlCmd', 'alt'], _multiCursorModifierFromString, {
         markdownEnumDescriptions: [
-            nls.localize('multiCursorModifier.ctrlCmd', "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
-            nls.localize('multiCursorModifier.alt', "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'multiCursorModifier.ctrlCmd', "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'multiCursorModifier.alt', "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
         ],
-        markdownDescription: nls.localize({
+        markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', {
             key: 'multiCursorModifier',
             comment: [
                 '- `ctrlCmd` refers to a value the setting can take and should not be localized.',
@@ -2763,145 +2790,145 @@
     })),
     multiCursorPaste: register(new EditorStringEnumOption(78 /* EditorOption.multiCursorPaste */, 'multiCursorPaste', 'spread', ['spread', 'full'], {
         markdownEnumDescriptions: [
-            nls.localize('multiCursorPaste.spread', "Each cursor pastes a single line of the text."),
-            nls.localize('multiCursorPaste.full', "Each cursor pastes the full text.")
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'multiCursorPaste.spread', "Each cursor pastes a single line of the text."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'multiCursorPaste.full', "Each cursor pastes the full text.")
         ],
-        markdownDescription: nls.localize('multiCursorPaste', "Controls pasting when the line count of the pasted text matches the cursor count.")
+        markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'multiCursorPaste', "Controls pasting when the line count of the pasted text matches the cursor count.")
     })),
     multiCursorLimit: register(new EditorIntOption(79 /* EditorOption.multiCursorLimit */, 'multiCursorLimit', 10000, 1, 100000, {
-        markdownDescription: nls.localize('multiCursorLimit', "Controls the max number of cursors that can be in an active editor at once.")
+        markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'multiCursorLimit', "Controls the max number of cursors that can be in an active editor at once.")
     })),
-    occurrencesHighlight: register(new EditorBooleanOption(80 /* EditorOption.occurrencesHighlight */, 'occurrencesHighlight', true, { description: nls.localize('occurrencesHighlight', "Controls whether the editor should highlight semantic symbol occurrences.") })),
-    overviewRulerBorder: register(new EditorBooleanOption(81 /* EditorOption.overviewRulerBorder */, 'overviewRulerBorder', true, { description: nls.localize('overviewRulerBorder', "Controls whether a border should be drawn around the overview ruler.") })),
+    occurrencesHighlight: register(new EditorBooleanOption(80 /* EditorOption.occurrencesHighlight */, 'occurrencesHighlight', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'occurrencesHighlight', "Controls whether the editor should highlight semantic symbol occurrences.") })),
+    overviewRulerBorder: register(new EditorBooleanOption(81 /* EditorOption.overviewRulerBorder */, 'overviewRulerBorder', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'overviewRulerBorder', "Controls whether a border should be drawn around the overview ruler.") })),
     overviewRulerLanes: register(new EditorIntOption(82 /* EditorOption.overviewRulerLanes */, 'overviewRulerLanes', 3, 0, 3)),
     padding: register(new EditorPadding()),
     pasteAs: register(new EditorPasteAs()),
     parameterHints: register(new EditorParameterHints()),
     peekWidgetDefaultFocus: register(new EditorStringEnumOption(86 /* EditorOption.peekWidgetDefaultFocus */, 'peekWidgetDefaultFocus', 'tree', ['tree', 'editor'], {
         enumDescriptions: [
-            nls.localize('peekWidgetDefaultFocus.tree', "Focus the tree when opening peek"),
-            nls.localize('peekWidgetDefaultFocus.editor', "Focus the editor when opening peek")
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'peekWidgetDefaultFocus.tree', "Focus the tree when opening peek"),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'peekWidgetDefaultFocus.editor', "Focus the editor when opening peek")
         ],
-        description: nls.localize('peekWidgetDefaultFocus', "Controls whether to focus the inline editor or the tree in the peek widget.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'peekWidgetDefaultFocus', "Controls whether to focus the inline editor or the tree in the peek widget.")
     })),
-    definitionLinkOpensInPeek: register(new EditorBooleanOption(87 /* EditorOption.definitionLinkOpensInPeek */, 'definitionLinkOpensInPeek', false, { description: nls.localize('definitionLinkOpensInPeek', "Controls whether the Go to Definition mouse gesture always opens the peek widget.") })),
+    definitionLinkOpensInPeek: register(new EditorBooleanOption(87 /* EditorOption.definitionLinkOpensInPeek */, 'definitionLinkOpensInPeek', false, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'definitionLinkOpensInPeek', "Controls whether the Go to Definition mouse gesture always opens the peek widget.") })),
     quickSuggestions: register(new EditorQuickSuggestions()),
-    quickSuggestionsDelay: register(new EditorIntOption(89 /* EditorOption.quickSuggestionsDelay */, 'quickSuggestionsDelay', 10, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('quickSuggestionsDelay', "Controls the delay in milliseconds after which quick suggestions will show up.") })),
+    quickSuggestionsDelay: register(new EditorIntOption(89 /* EditorOption.quickSuggestionsDelay */, 'quickSuggestionsDelay', 10, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'quickSuggestionsDelay', "Controls the delay in milliseconds after which quick suggestions will show up.") })),
     readOnly: register(new EditorBooleanOption(90 /* EditorOption.readOnly */, 'readOnly', false)),
     readOnlyMessage: register(new ReadonlyMessage()),
-    renameOnType: register(new EditorBooleanOption(92 /* EditorOption.renameOnType */, 'renameOnType', false, { description: nls.localize('renameOnType', "Controls whether the editor auto renames on type."), markdownDeprecationMessage: nls.localize('renameOnTypeDeprecate', "Deprecated, use `editor.linkedEditing` instead.") })),
-    renderControlCharacters: register(new EditorBooleanOption(93 /* EditorOption.renderControlCharacters */, 'renderControlCharacters', true, { description: nls.localize('renderControlCharacters', "Controls whether the editor should render control characters."), restricted: true })),
-    renderFinalNewline: register(new EditorStringEnumOption(94 /* EditorOption.renderFinalNewline */, 'renderFinalNewline', (platform.isLinux ? 'dimmed' : 'on'), ['off', 'on', 'dimmed'], { description: nls.localize('renderFinalNewline', "Render last line number when the file ends with a newline.") })),
+    renameOnType: register(new EditorBooleanOption(92 /* EditorOption.renameOnType */, 'renameOnType', false, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'renameOnType', "Controls whether the editor auto renames on type."), markdownDeprecationMessage: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'renameOnTypeDeprecate', "Deprecated, use `editor.linkedEditing` instead.") })),
+    renderControlCharacters: register(new EditorBooleanOption(93 /* EditorOption.renderControlCharacters */, 'renderControlCharacters', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'renderControlCharacters', "Controls whether the editor should render control characters."), restricted: true })),
+    renderFinalNewline: register(new EditorStringEnumOption(94 /* EditorOption.renderFinalNewline */, 'renderFinalNewline', (platform.isLinux ? 'dimmed' : 'on'), ['off', 'on', 'dimmed'], { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'renderFinalNewline', "Render last line number when the file ends with a newline.") })),
     renderLineHighlight: register(new EditorStringEnumOption(95 /* EditorOption.renderLineHighlight */, 'renderLineHighlight', 'line', ['none', 'gutter', 'line', 'all'], {
         enumDescriptions: [
             '',
             '',
             '',
-            nls.localize('renderLineHighlight.all', "Highlights both the gutter and the current line."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'renderLineHighlight.all', "Highlights both the gutter and the current line."),
         ],
-        description: nls.localize('renderLineHighlight', "Controls how the editor should render the current line highlight.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'renderLineHighlight', "Controls how the editor should render the current line highlight.")
     })),
-    renderLineHighlightOnlyWhenFocus: register(new EditorBooleanOption(96 /* EditorOption.renderLineHighlightOnlyWhenFocus */, 'renderLineHighlightOnlyWhenFocus', false, { description: nls.localize('renderLineHighlightOnlyWhenFocus', "Controls if the editor should render the current line highlight only when the editor is focused.") })),
+    renderLineHighlightOnlyWhenFocus: register(new EditorBooleanOption(96 /* EditorOption.renderLineHighlightOnlyWhenFocus */, 'renderLineHighlightOnlyWhenFocus', false, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'renderLineHighlightOnlyWhenFocus', "Controls if the editor should render the current line highlight only when the editor is focused.") })),
     renderValidationDecorations: register(new EditorStringEnumOption(97 /* EditorOption.renderValidationDecorations */, 'renderValidationDecorations', 'editable', ['editable', 'on', 'off'])),
     renderWhitespace: register(new EditorStringEnumOption(98 /* EditorOption.renderWhitespace */, 'renderWhitespace', 'selection', ['none', 'boundary', 'selection', 'trailing', 'all'], {
         enumDescriptions: [
             '',
-            nls.localize('renderWhitespace.boundary', "Render whitespace characters except for single spaces between words."),
-            nls.localize('renderWhitespace.selection', "Render whitespace characters only on selected text."),
-            nls.localize('renderWhitespace.trailing', "Render only trailing whitespace characters."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'renderWhitespace.boundary', "Render whitespace characters except for single spaces between words."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'renderWhitespace.selection', "Render whitespace characters only on selected text."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'renderWhitespace.trailing', "Render only trailing whitespace characters."),
             ''
         ],
-        description: nls.localize('renderWhitespace', "Controls how the editor should render whitespace characters.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'renderWhitespace', "Controls how the editor should render whitespace characters.")
     })),
     revealHorizontalRightPadding: register(new EditorIntOption(99 /* EditorOption.revealHorizontalRightPadding */, 'revealHorizontalRightPadding', 15, 0, 1000)),
-    roundedSelection: register(new EditorBooleanOption(100 /* EditorOption.roundedSelection */, 'roundedSelection', true, { description: nls.localize('roundedSelection', "Controls whether selections should have rounded corners.") })),
+    roundedSelection: register(new EditorBooleanOption(100 /* EditorOption.roundedSelection */, 'roundedSelection', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'roundedSelection', "Controls whether selections should have rounded corners.") })),
     rulers: register(new EditorRulers()),
     scrollbar: register(new EditorScrollbar()),
-    scrollBeyondLastColumn: register(new EditorIntOption(103 /* EditorOption.scrollBeyondLastColumn */, 'scrollBeyondLastColumn', 4, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('scrollBeyondLastColumn', "Controls the number of extra characters beyond which the editor will scroll horizontally.") })),
-    scrollBeyondLastLine: register(new EditorBooleanOption(104 /* EditorOption.scrollBeyondLastLine */, 'scrollBeyondLastLine', true, { description: nls.localize('scrollBeyondLastLine', "Controls whether the editor will scroll beyond the last line.") })),
-    scrollPredominantAxis: register(new EditorBooleanOption(105 /* EditorOption.scrollPredominantAxis */, 'scrollPredominantAxis', true, { description: nls.localize('scrollPredominantAxis', "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.") })),
+    scrollBeyondLastColumn: register(new EditorIntOption(103 /* EditorOption.scrollBeyondLastColumn */, 'scrollBeyondLastColumn', 4, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollBeyondLastColumn', "Controls the number of extra characters beyond which the editor will scroll horizontally.") })),
+    scrollBeyondLastLine: register(new EditorBooleanOption(104 /* EditorOption.scrollBeyondLastLine */, 'scrollBeyondLastLine', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollBeyondLastLine', "Controls whether the editor will scroll beyond the last line.") })),
+    scrollPredominantAxis: register(new EditorBooleanOption(105 /* EditorOption.scrollPredominantAxis */, 'scrollPredominantAxis', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'scrollPredominantAxis', "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.") })),
     selectionClipboard: register(new EditorBooleanOption(106 /* EditorOption.selectionClipboard */, 'selectionClipboard', true, {
-        description: nls.localize('selectionClipboard', "Controls whether the Linux primary clipboard should be supported."),
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'selectionClipboard', "Controls whether the Linux primary clipboard should be supported."),
         included: platform.isLinux
     })),
-    selectionHighlight: register(new EditorBooleanOption(107 /* EditorOption.selectionHighlight */, 'selectionHighlight', true, { description: nls.localize('selectionHighlight', "Controls whether the editor should highlight matches similar to the selection.") })),
+    selectionHighlight: register(new EditorBooleanOption(107 /* EditorOption.selectionHighlight */, 'selectionHighlight', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'selectionHighlight', "Controls whether the editor should highlight matches similar to the selection.") })),
     selectOnLineNumbers: register(new EditorBooleanOption(108 /* EditorOption.selectOnLineNumbers */, 'selectOnLineNumbers', true)),
     showFoldingControls: register(new EditorStringEnumOption(109 /* EditorOption.showFoldingControls */, 'showFoldingControls', 'mouseover', ['always', 'never', 'mouseover'], {
         enumDescriptions: [
-            nls.localize('showFoldingControls.always', "Always show the folding controls."),
-            nls.localize('showFoldingControls.never', "Never show the folding controls and reduce the gutter size."),
-            nls.localize('showFoldingControls.mouseover', "Only show the folding controls when the mouse is over the gutter."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'showFoldingControls.always', "Always show the folding controls."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'showFoldingControls.never', "Never show the folding controls and reduce the gutter size."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'showFoldingControls.mouseover', "Only show the folding controls when the mouse is over the gutter."),
         ],
-        description: nls.localize('showFoldingControls', "Controls when the folding controls on the gutter are shown.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'showFoldingControls', "Controls when the folding controls on the gutter are shown.")
     })),
-    showUnused: register(new EditorBooleanOption(110 /* EditorOption.showUnused */, 'showUnused', true, { description: nls.localize('showUnused', "Controls fading out of unused code.") })),
-    showDeprecated: register(new EditorBooleanOption(138 /* EditorOption.showDeprecated */, 'showDeprecated', true, { description: nls.localize('showDeprecated', "Controls strikethrough deprecated variables.") })),
+    showUnused: register(new EditorBooleanOption(110 /* EditorOption.showUnused */, 'showUnused', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'showUnused', "Controls fading out of unused code.") })),
+    showDeprecated: register(new EditorBooleanOption(138 /* EditorOption.showDeprecated */, 'showDeprecated', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'showDeprecated', "Controls strikethrough deprecated variables.") })),
     inlayHints: register(new EditorInlayHints()),
     snippetSuggestions: register(new EditorStringEnumOption(111 /* EditorOption.snippetSuggestions */, 'snippetSuggestions', 'inline', ['top', 'bottom', 'inline', 'none'], {
         enumDescriptions: [
-            nls.localize('snippetSuggestions.top', "Show snippet suggestions on top of other suggestions."),
-            nls.localize('snippetSuggestions.bottom', "Show snippet suggestions below other suggestions."),
-            nls.localize('snippetSuggestions.inline', "Show snippets suggestions with other suggestions."),
-            nls.localize('snippetSuggestions.none', "Do not show snippet suggestions."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'snippetSuggestions.top', "Show snippet suggestions on top of other suggestions."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'snippetSuggestions.bottom', "Show snippet suggestions below other suggestions."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'snippetSuggestions.inline', "Show snippets suggestions with other suggestions."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'snippetSuggestions.none', "Do not show snippet suggestions."),
         ],
-        description: nls.localize('snippetSuggestions', "Controls whether snippets are shown with other suggestions and how they are sorted.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'snippetSuggestions', "Controls whether snippets are shown with other suggestions and how they are sorted.")
     })),
     smartSelect: register(new SmartSelect()),
-    smoothScrolling: register(new EditorBooleanOption(113 /* EditorOption.smoothScrolling */, 'smoothScrolling', false, { description: nls.localize('smoothScrolling', "Controls whether the editor will scroll using an animation.") })),
+    smoothScrolling: register(new EditorBooleanOption(113 /* EditorOption.smoothScrolling */, 'smoothScrolling', false, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'smoothScrolling', "Controls whether the editor will scroll using an animation.") })),
     stopRenderingLineAfter: register(new EditorIntOption(116 /* EditorOption.stopRenderingLineAfter */, 'stopRenderingLineAfter', 10000, -1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */)),
     suggest: register(new EditorSuggest()),
     inlineSuggest: register(new InlineEditorSuggest()),
-    inlineCompletionsAccessibilityVerbose: register(new EditorBooleanOption(147 /* EditorOption.inlineCompletionsAccessibilityVerbose */, 'inlineCompletionsAccessibilityVerbose', false, { description: nls.localize('inlineCompletionsAccessibilityVerbose', "Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.") })),
-    suggestFontSize: register(new EditorIntOption(118 /* EditorOption.suggestFontSize */, 'suggestFontSize', 0, 0, 1000, { markdownDescription: nls.localize('suggestFontSize', "Font size for the suggest widget. When set to {0}, the value of {1} is used.", '`0`', '`#editor.fontSize#`') })),
-    suggestLineHeight: register(new EditorIntOption(119 /* EditorOption.suggestLineHeight */, 'suggestLineHeight', 0, 0, 1000, { markdownDescription: nls.localize('suggestLineHeight', "Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.", '`0`', '`#editor.lineHeight#`') })),
-    suggestOnTriggerCharacters: register(new EditorBooleanOption(120 /* EditorOption.suggestOnTriggerCharacters */, 'suggestOnTriggerCharacters', true, { description: nls.localize('suggestOnTriggerCharacters', "Controls whether suggestions should automatically show up when typing trigger characters.") })),
+    inlineCompletionsAccessibilityVerbose: register(new EditorBooleanOption(147 /* EditorOption.inlineCompletionsAccessibilityVerbose */, 'inlineCompletionsAccessibilityVerbose', false, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'inlineCompletionsAccessibilityVerbose', "Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.") })),
+    suggestFontSize: register(new EditorIntOption(118 /* EditorOption.suggestFontSize */, 'suggestFontSize', 0, 0, 1000, { markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggestFontSize', "Font size for the suggest widget. When set to {0}, the value of {1} is used.", '`0`', '`#editor.fontSize#`') })),
+    suggestLineHeight: register(new EditorIntOption(119 /* EditorOption.suggestLineHeight */, 'suggestLineHeight', 0, 0, 1000, { markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggestLineHeight', "Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.", '`0`', '`#editor.lineHeight#`') })),
+    suggestOnTriggerCharacters: register(new EditorBooleanOption(120 /* EditorOption.suggestOnTriggerCharacters */, 'suggestOnTriggerCharacters', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggestOnTriggerCharacters', "Controls whether suggestions should automatically show up when typing trigger characters.") })),
     suggestSelection: register(new EditorStringEnumOption(121 /* EditorOption.suggestSelection */, 'suggestSelection', 'first', ['first', 'recentlyUsed', 'recentlyUsedByPrefix'], {
         markdownEnumDescriptions: [
-            nls.localize('suggestSelection.first', "Always select the first suggestion."),
-            nls.localize('suggestSelection.recentlyUsed', "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
-            nls.localize('suggestSelection.recentlyUsedByPrefix', "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggestSelection.first', "Always select the first suggestion."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggestSelection.recentlyUsed', "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggestSelection.recentlyUsedByPrefix', "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`."),
         ],
-        description: nls.localize('suggestSelection', "Controls how suggestions are pre-selected when showing the suggest list.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'suggestSelection', "Controls how suggestions are pre-selected when showing the suggest list.")
     })),
     tabCompletion: register(new EditorStringEnumOption(122 /* EditorOption.tabCompletion */, 'tabCompletion', 'off', ['on', 'off', 'onlySnippets'], {
         enumDescriptions: [
-            nls.localize('tabCompletion.on', "Tab complete will insert the best matching suggestion when pressing tab."),
-            nls.localize('tabCompletion.off', "Disable tab completions."),
-            nls.localize('tabCompletion.onlySnippets', "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'tabCompletion.on', "Tab complete will insert the best matching suggestion when pressing tab."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'tabCompletion.off', "Disable tab completions."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'tabCompletion.onlySnippets', "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled."),
         ],
-        description: nls.localize('tabCompletion', "Enables tab completions.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'tabCompletion', "Enables tab completions.")
     })),
     tabIndex: register(new EditorIntOption(123 /* EditorOption.tabIndex */, 'tabIndex', 0, -1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */)),
     unicodeHighlight: register(new UnicodeHighlight()),
     unusualLineTerminators: register(new EditorStringEnumOption(125 /* EditorOption.unusualLineTerminators */, 'unusualLineTerminators', 'prompt', ['auto', 'off', 'prompt'], {
         enumDescriptions: [
-            nls.localize('unusualLineTerminators.auto', "Unusual line terminators are automatically removed."),
-            nls.localize('unusualLineTerminators.off', "Unusual line terminators are ignored."),
-            nls.localize('unusualLineTerminators.prompt', "Unusual line terminators prompt to be removed."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'unusualLineTerminators.auto', "Unusual line terminators are automatically removed."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'unusualLineTerminators.off', "Unusual line terminators are ignored."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'unusualLineTerminators.prompt', "Unusual line terminators prompt to be removed."),
         ],
-        description: nls.localize('unusualLineTerminators', "Remove unusual line terminators that might cause problems.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'unusualLineTerminators', "Remove unusual line terminators that might cause problems.")
     })),
     useShadowDOM: register(new EditorBooleanOption(126 /* EditorOption.useShadowDOM */, 'useShadowDOM', true)),
-    useTabStops: register(new EditorBooleanOption(127 /* EditorOption.useTabStops */, 'useTabStops', true, { description: nls.localize('useTabStops', "Inserting and deleting whitespace follows tab stops.") })),
+    useTabStops: register(new EditorBooleanOption(127 /* EditorOption.useTabStops */, 'useTabStops', true, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'useTabStops', "Inserting and deleting whitespace follows tab stops.") })),
     wordBreak: register(new EditorStringEnumOption(128 /* EditorOption.wordBreak */, 'wordBreak', 'normal', ['normal', 'keepAll'], {
         markdownEnumDescriptions: [
-            nls.localize('wordBreak.normal', "Use the default line break rule."),
-            nls.localize('wordBreak.keepAll', "Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wordBreak.normal', "Use the default line break rule."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wordBreak.keepAll', "Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal."),
         ],
-        description: nls.localize('wordBreak', "Controls the word break rules used for Chinese/Japanese/Korean (CJK) text.")
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wordBreak', "Controls the word break rules used for Chinese/Japanese/Korean (CJK) text.")
     })),
-    wordSeparators: register(new EditorStringOption(129 /* EditorOption.wordSeparators */, 'wordSeparators', USUAL_WORD_SEPARATORS, { description: nls.localize('wordSeparators', "Characters that will be used as word separators when doing word related navigations or operations.") })),
+    wordSeparators: register(new EditorStringOption(129 /* EditorOption.wordSeparators */, 'wordSeparators', USUAL_WORD_SEPARATORS, { description: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wordSeparators', "Characters that will be used as word separators when doing word related navigations or operations.") })),
     wordWrap: register(new EditorStringEnumOption(130 /* EditorOption.wordWrap */, 'wordWrap', 'off', ['off', 'on', 'wordWrapColumn', 'bounded'], {
         markdownEnumDescriptions: [
-            nls.localize('wordWrap.off', "Lines will never wrap."),
-            nls.localize('wordWrap.on', "Lines will wrap at the viewport width."),
-            nls.localize({
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wordWrap.off', "Lines will never wrap."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', 'wordWrap.on', "Lines will wrap at the viewport width."),
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', {
                 key: 'wordWrap.wordWrapColumn',
                 comment: [
                     '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'
                 ]
             }, "Lines will wrap at `#editor.wordWrapColumn#`."),
-            nls.localize({
+            nls.localizeWithPath('vs/editor/common/config/editorOptions', {
                 key: 'wordWrap.bounded',
                 comment: [
                     '- viewport means the edge of the visible window size.',
@@ -2909,7 +2936,7 @@
                 ]
             }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`."),
         ],
-        description: nls.localize({
+        description: nls.localizeWithPath('vs/editor/common/config/editorOptions', {
             key: 'wordWrap',
             comment: [
                 '- \'off\', \'on\', \'wordWrapColumn\' and \'bounded\' refer to values the setting can take and should not be localized.',
@@ -2924,7 +2951,7 @@
     // allow-any-unicode-next-line
     '([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋')),
     wordWrapColumn: register(new EditorIntOption(133 /* EditorOption.wordWrapColumn */, 'wordWrapColumn', 80, 1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, {
-        markdownDescription: nls.localize({
+        markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', {
             key: 'wordWrapColumn',
             comment: [
                 '- `editor.wordWrap` refers to a different setting and should not be localized.',
@@ -2936,9 +2963,9 @@
     wordWrapOverride2: register(new EditorStringEnumOption(135 /* EditorOption.wordWrapOverride2 */, 'wordWrapOverride2', 'inherit', ['off', 'on', 'inherit'])),
     // Leave these at the end (because they have dependencies!)
     editorClassName: register(new EditorClassName()),
-    defaultColorDecorators: register(new EditorBooleanOption(145 /* EditorOption.defaultColorDecorators */, 'defaultColorDecorators', false, { markdownDescription: nls.localize('defaultColorDecorators', "Controls whether inline color decorations should be shown using the default document color provider") })),
+    defaultColorDecorators: register(new EditorBooleanOption(145 /* EditorOption.defaultColorDecorators */, 'defaultColorDecorators', false, { markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'defaultColorDecorators', "Controls whether inline color decorations should be shown using the default document color provider") })),
     pixelRatio: register(new EditorPixelRatio()),
-    tabFocusMode: register(new EditorBooleanOption(142 /* EditorOption.tabFocusMode */, 'tabFocusMode', false, { markdownDescription: nls.localize('tabFocusMode', "Controls whether the editor receives tabs or defers them to the workbench for navigation.") })),
+    tabFocusMode: register(new EditorBooleanOption(142 /* EditorOption.tabFocusMode */, 'tabFocusMode', false, { markdownDescription: nls.localizeWithPath('vs/editor/common/config/editorOptions', 'tabFocusMode', "Controls whether the editor receives tabs or defers them to the workbench for navigation.") })),
     layoutInfo: register(new EditorLayoutInfoComputer()),
     wrappingInfo: register(new EditorWrappingInfoComputer()),
     wrappingIndent: register(new WrappingIndentOption()),
diff -urN -x '*.map' a/vs/editor/common/config/fontInfo.js b/vs/editor/common/config/fontInfo.js
--- a/vs/editor/common/config/fontInfo.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/config/fontInfo.js	2023-12-06 14:23:14.363854755 +0000
@@ -3,7 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import * as platform from '../../../base/common/platform.js';
-import { EditorFontVariations, EDITOR_FONT_DEFAULTS } from './editorOptions.js';
+import { EditorFontVariations, EditorOptions, EDITOR_FONT_DEFAULTS } from './editorOptions.js';
 import { EditorZoom } from './editorZoom.js';
 /**
  * Determined from empirical observations.
@@ -29,6 +29,19 @@
         return BareFontInfo._create(fontFamily, fontWeight, fontSize, fontFeatureSettings, fontVariationSettings, lineHeight, letterSpacing, pixelRatio, ignoreEditorZoom);
     }
     /**
+     * @internal
+     */
+    static createFromRawSettings(opts, pixelRatio, ignoreEditorZoom = false) {
+        const fontFamily = EditorOptions.fontFamily.validate(opts.fontFamily);
+        const fontWeight = EditorOptions.fontWeight.validate(opts.fontWeight);
+        const fontSize = EditorOptions.fontSize.validate(opts.fontSize);
+        const fontFeatureSettings = EditorOptions.fontLigatures2.validate(opts.fontLigatures);
+        const fontVariationSettings = EditorOptions.fontVariations.validate(opts.fontVariations);
+        const lineHeight = EditorOptions.lineHeight.validate(opts.lineHeight);
+        const letterSpacing = EditorOptions.letterSpacing.validate(opts.letterSpacing);
+        return BareFontInfo._create(fontFamily, fontWeight, fontSize, fontFeatureSettings, fontVariationSettings, lineHeight, letterSpacing, pixelRatio, ignoreEditorZoom);
+    }
+    /**
      * @internal
      */
     static _create(fontFamily, fontWeight, fontSize, fontFeatureSettings, fontVariationSettings, lineHeight, letterSpacing, pixelRatio, ignoreEditorZoom) {
diff -urN -x '*.map' a/vs/editor/common/core/cursorColumns.js b/vs/editor/common/core/cursorColumns.js
--- a/vs/editor/common/core/cursorColumns.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/core/cursorColumns.js	2023-12-06 14:23:14.363854755 +0000
@@ -46,6 +46,25 @@
         return result;
     }
     /**
+     * Returns the value to display as "Col" in the status bar.
+     * @see {@link CursorColumns}
+     */
+    static toStatusbarColumn(lineContent, column, tabSize) {
+        const text = lineContent.substring(0, Math.min(column - 1, lineContent.length));
+        const iterator = new strings.CodePointIterator(text);
+        let result = 0;
+        while (!iterator.eol()) {
+            const codePoint = iterator.nextCodePoint();
+            if (codePoint === 9 /* CharCode.Tab */) {
+                result = CursorColumns.nextRenderTabStop(result, tabSize);
+            }
+            else {
+                result = result + 1;
+            }
+        }
+        return result + 1;
+    }
+    /**
      * Returns a column from a visible column.
      * @see {@link CursorColumns}
      */
diff -urN -x '*.map' a/vs/editor/common/core/editorColorRegistry.js b/vs/editor/common/core/editorColorRegistry.js
--- a/vs/editor/common/core/editorColorRegistry.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/core/editorColorRegistry.js	2023-12-06 14:23:14.363854755 +0000
@@ -9,71 +9,71 @@
 /**
  * Definition of the editor colors
  */
-export const editorLineHighlight = registerColor('editor.lineHighlightBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));
-export const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));
-export const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'), true);
-export const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'), true);
-export const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('caret', 'Color of the editor cursor.'));
-export const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));
-export const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));
-export const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));
-export const deprecatedEditorIndentGuides = registerColor('editorIndentGuide.background', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'), false, nls.localize('deprecatedEditorIndentGuides', '\'editorIndentGuide.background\' is deprecated. Use \'editorIndentGuide.background1\' instead.'));
-export const deprecatedEditorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'), false, nls.localize('deprecatedEditorActiveIndentGuide', '\'editorIndentGuide.activeBackground\' is deprecated. Use \'editorIndentGuide.activeBackground1\' instead.'));
-export const editorIndentGuide1 = registerColor('editorIndentGuide.background1', { dark: deprecatedEditorIndentGuides, light: deprecatedEditorIndentGuides, hcDark: deprecatedEditorIndentGuides, hcLight: deprecatedEditorIndentGuides }, nls.localize('editorIndentGuides1', 'Color of the editor indentation guides (1).'));
-export const editorIndentGuide2 = registerColor('editorIndentGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides2', 'Color of the editor indentation guides (2).'));
-export const editorIndentGuide3 = registerColor('editorIndentGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides3', 'Color of the editor indentation guides (3).'));
-export const editorIndentGuide4 = registerColor('editorIndentGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides4', 'Color of the editor indentation guides (4).'));
-export const editorIndentGuide5 = registerColor('editorIndentGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides5', 'Color of the editor indentation guides (5).'));
-export const editorIndentGuide6 = registerColor('editorIndentGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides6', 'Color of the editor indentation guides (6).'));
-export const editorActiveIndentGuide1 = registerColor('editorIndentGuide.activeBackground1', { dark: deprecatedEditorActiveIndentGuides, light: deprecatedEditorActiveIndentGuides, hcDark: deprecatedEditorActiveIndentGuides, hcLight: deprecatedEditorActiveIndentGuides }, nls.localize('editorActiveIndentGuide1', 'Color of the active editor indentation guides (1).'));
-export const editorActiveIndentGuide2 = registerColor('editorIndentGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide2', 'Color of the active editor indentation guides (2).'));
-export const editorActiveIndentGuide3 = registerColor('editorIndentGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide3', 'Color of the active editor indentation guides (3).'));
-export const editorActiveIndentGuide4 = registerColor('editorIndentGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide4', 'Color of the active editor indentation guides (4).'));
-export const editorActiveIndentGuide5 = registerColor('editorIndentGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide5', 'Color of the active editor indentation guides (5).'));
-export const editorActiveIndentGuide6 = registerColor('editorIndentGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide6', 'Color of the active editor indentation guides (6).'));
-const deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \'editorLineNumber.activeForeground\' instead.'));
-export const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hcDark: deprecatedEditorActiveLineNumber, hcLight: deprecatedEditorActiveLineNumber }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));
-export const editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorDimmedLineNumber', 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));
-export const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorRuler', 'Color of the editor rulers.'));
-export const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));
-export const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));
-export const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));
-export const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));
-export const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler.'));
-export const editorGutter = registerColor('editorGutter.background', { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));
-export const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));
-export const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  \'editorUnnecessaryCode.border\' theme color to underline unnecessary code instead of fading it out.'));
-export const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));
-export const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));
-export const ghostTextBackground = registerColor('editorGhostText.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));
+export const editorLineHighlight = registerColor('editor.lineHighlightBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'lineHighlight', 'Background color for the highlight of line at the cursor position.'));
+export const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));
+export const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'rangeHighlightBorder', 'Background color of the border around highlighted ranges.'), true);
+export const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'symbolHighlightBorder', 'Background color of the border around highlighted symbols.'), true);
+export const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'caret', 'Color of the editor cursor.'));
+export const editorCursorBackground = registerColor('editorCursor.background', null, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));
+export const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorWhitespaces', 'Color of whitespace characters in the editor.'));
+export const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorLineNumbers', 'Color of editor line numbers.'));
+export const deprecatedEditorIndentGuides = registerColor('editorIndentGuide.background', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorIndentGuides', 'Color of the editor indentation guides.'), false, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'deprecatedEditorIndentGuides', '\'editorIndentGuide.background\' is deprecated. Use \'editorIndentGuide.background1\' instead.'));
+export const deprecatedEditorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorActiveIndentGuide', 'Color of the active editor indentation guides.'), false, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'deprecatedEditorActiveIndentGuide', '\'editorIndentGuide.activeBackground\' is deprecated. Use \'editorIndentGuide.activeBackground1\' instead.'));
+export const editorIndentGuide1 = registerColor('editorIndentGuide.background1', { dark: deprecatedEditorIndentGuides, light: deprecatedEditorIndentGuides, hcDark: deprecatedEditorIndentGuides, hcLight: deprecatedEditorIndentGuides }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorIndentGuides1', 'Color of the editor indentation guides (1).'));
+export const editorIndentGuide2 = registerColor('editorIndentGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorIndentGuides2', 'Color of the editor indentation guides (2).'));
+export const editorIndentGuide3 = registerColor('editorIndentGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorIndentGuides3', 'Color of the editor indentation guides (3).'));
+export const editorIndentGuide4 = registerColor('editorIndentGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorIndentGuides4', 'Color of the editor indentation guides (4).'));
+export const editorIndentGuide5 = registerColor('editorIndentGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorIndentGuides5', 'Color of the editor indentation guides (5).'));
+export const editorIndentGuide6 = registerColor('editorIndentGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorIndentGuides6', 'Color of the editor indentation guides (6).'));
+export const editorActiveIndentGuide1 = registerColor('editorIndentGuide.activeBackground1', { dark: deprecatedEditorActiveIndentGuides, light: deprecatedEditorActiveIndentGuides, hcDark: deprecatedEditorActiveIndentGuides, hcLight: deprecatedEditorActiveIndentGuides }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorActiveIndentGuide1', 'Color of the active editor indentation guides (1).'));
+export const editorActiveIndentGuide2 = registerColor('editorIndentGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorActiveIndentGuide2', 'Color of the active editor indentation guides (2).'));
+export const editorActiveIndentGuide3 = registerColor('editorIndentGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorActiveIndentGuide3', 'Color of the active editor indentation guides (3).'));
+export const editorActiveIndentGuide4 = registerColor('editorIndentGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorActiveIndentGuide4', 'Color of the active editor indentation guides (4).'));
+export const editorActiveIndentGuide5 = registerColor('editorIndentGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorActiveIndentGuide5', 'Color of the active editor indentation guides (5).'));
+export const editorActiveIndentGuide6 = registerColor('editorIndentGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorActiveIndentGuide6', 'Color of the active editor indentation guides (6).'));
+const deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorActiveLineNumber', 'Color of editor active line number'), false, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \'editorLineNumber.activeForeground\' instead.'));
+export const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hcDark: deprecatedEditorActiveLineNumber, hcLight: deprecatedEditorActiveLineNumber }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorActiveLineNumber', 'Color of editor active line number'));
+export const editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorDimmedLineNumber', 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));
+export const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorRuler', 'Color of the editor rulers.'));
+export const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorCodeLensForeground', 'Foreground color of editor CodeLens'));
+export const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketMatchBackground', 'Background color behind matching brackets'));
+export const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketMatchBorder', 'Color for matching brackets boxes'));
+export const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorOverviewRulerBorder', 'Color of the overview ruler border.'));
+export const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorOverviewRulerBackground', 'Background color of the editor overview ruler.'));
+export const editorGutter = registerColor('editorGutter.background', { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));
+export const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));
+export const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  \'editorUnnecessaryCode.border\' theme color to underline unnecessary code instead of fading it out.'));
+export const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorGhostTextBorder', 'Border color of ghost text in the editor.'));
+export const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));
+export const ghostTextBackground = registerColor('editorGhostText.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorGhostTextBackground', 'Background color of the ghost text in the editor.'));
 const rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));
-export const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', { dark: rulerRangeDefault, light: rulerRangeDefault, hcDark: rulerRangeDefault, hcLight: rulerRangeDefault }, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));
-export const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));
-export const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));
-export const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));
-export const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));
-export const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));
-export const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));
-export const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));
-export const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));
-export const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '' }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));
-export const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));
-export const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));
-export const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));
-export const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));
-export const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));
-export const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));
-export const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));
-export const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));
-export const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));
-export const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));
-export const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));
-export const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));
-export const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', { dark: '#BD9B03', light: '#CEA33D', hcDark: '#ff0000', hcLight: '#CEA33D' }, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));
-export const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', { dark: '#bd9b0326', light: '#cea33d14', hcDark: '#00000000', hcLight: '#cea33d14' }, nls.localize('editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));
+export const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', { dark: rulerRangeDefault, light: rulerRangeDefault, hcDark: rulerRangeDefault, hcLight: rulerRangeDefault }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'overviewRuleError', 'Overview ruler marker color for errors.'));
+export const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'overviewRuleWarning', 'Overview ruler marker color for warnings.'));
+export const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'overviewRuleInfo', 'Overview ruler marker color for infos.'));
+export const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));
+export const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));
+export const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));
+export const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));
+export const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));
+export const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));
+export const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));
+export const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));
+export const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));
+export const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));
+export const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));
+export const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));
+export const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));
+export const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));
+export const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));
+export const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));
+export const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));
+export const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));
+export const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));
+export const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', { dark: '#BD9B03', light: '#CEA33D', hcDark: '#ff0000', hcLight: '#CEA33D' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));
+export const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', { dark: '#bd9b0326', light: '#cea33d14', hcDark: '#00000000', hcLight: '#cea33d14' }, nls.localizeWithPath('vs/editor/common/core/editorColorRegistry', 'editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));
 // contains all color rules that used to defined in editor/browser/widget/editor.css
 registerThemingParticipant((theme, collector) => {
     const background = theme.getColor(editorBackground);
diff -urN -x '*.map' a/vs/editor/common/core/lineRange.js b/vs/editor/common/core/lineRange.js
--- a/vs/editor/common/core/lineRange.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/core/lineRange.js	2023-12-06 14:23:14.363854755 +0000
@@ -13,6 +13,26 @@
     static fromRange(range) {
         return new LineRange(range.startLineNumber, range.endLineNumber);
     }
+    static subtract(a, b) {
+        if (!b) {
+            return [a];
+        }
+        if (a.startLineNumber < b.startLineNumber && b.endLineNumberExclusive < a.endLineNumberExclusive) {
+            return [
+                new LineRange(a.startLineNumber, b.startLineNumber),
+                new LineRange(b.endLineNumberExclusive, a.endLineNumberExclusive)
+            ];
+        }
+        else if (b.startLineNumber <= a.startLineNumber && a.endLineNumberExclusive <= b.endLineNumberExclusive) {
+            return [];
+        }
+        else if (b.endLineNumberExclusive < a.endLineNumberExclusive) {
+            return [new LineRange(Math.max(b.endLineNumberExclusive, a.startLineNumber), a.endLineNumberExclusive)];
+        }
+        else {
+            return [new LineRange(a.startLineNumber, Math.min(b.startLineNumber, a.endLineNumberExclusive))];
+        }
+    }
     /**
      * @param lineRanges An array of sorted line ranges.
      */
@@ -178,6 +198,10 @@
         const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);
         return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;
     }
+    intersects(range) {
+        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);
+        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;
+    }
     getUnion(other) {
         if (this._normalizedRanges.length === 0) {
             return other;
diff -urN -x '*.map' a/vs/editor/common/core/offsetRange.js b/vs/editor/common/core/offsetRange.js
--- a/vs/editor/common/core/offsetRange.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/core/offsetRange.js	2023-12-06 14:23:14.363854755 +0000
@@ -89,6 +89,11 @@
         }
         return undefined;
     }
+    intersectsOrTouches(other) {
+        const start = Math.max(this.start, other.start);
+        const end = Math.min(this.endExclusive, other.endExclusive);
+        return start <= end;
+    }
     slice(arr) {
         return arr.slice(this.start, this.endExclusive);
     }
@@ -120,6 +125,13 @@
         }
         return value;
     }
+    map(f) {
+        const result = [];
+        for (let i = this.start; i < this.endExclusive; i++) {
+            result.push(f(i));
+        }
+        return result;
+    }
     forEach(f) {
         for (let i = this.start; i < this.endExclusive; i++) {
             f(i);
diff -urN -x '*.map' a/vs/editor/common/core/wordHelper.js b/vs/editor/common/core/wordHelper.js
--- a/vs/editor/common/core/wordHelper.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/core/wordHelper.js	2023-12-06 14:23:14.363854755 +0000
@@ -3,6 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { Iterable } from '../../../base/common/iterator.js';
+import { toDisposable } from '../../../base/common/lifecycle.js';
 import { LinkedList } from '../../../base/common/linkedList.js';
 export const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?';
 /**
@@ -54,6 +55,10 @@
     windowSize: 15,
     timeBudget: 150
 });
+export function setDefaultGetWordAtTextConfig(value) {
+    const rm = _defaultConfig.unshift(value);
+    return toDisposable(rm);
+}
 export function getWordAtText(column, wordDefinition, text, textOffset, config) {
     if (!config) {
         config = Iterable.first(_defaultConfig);
diff -urN -x '*.map' a/vs/editor/common/cursor/cursor.js b/vs/editor/common/cursor/cursor.js
--- a/vs/editor/common/cursor/cursor.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/cursor/cursor.js	2023-12-06 14:23:14.363854755 +0000
@@ -235,6 +235,9 @@
     getSelections() {
         return this._cursors.getSelections();
     }
+    getPosition() {
+        return this._cursors.getPrimaryCursor().modelState.position;
+    }
     setSelections(eventsCollector, source, selections, reason) {
         this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));
     }
@@ -773,7 +776,7 @@
         }
         catch (e) {
             // TODO@Alex use notification service if this should be user facing
-            // e.friendlyMessage = nls.localize('corrupt.commands', "Unexpected exception while executing command.");
+            // e.friendlyMessage = nls.localizeWithPath('vs/editor/common/cursor/cursor', 'corrupt.commands', "Unexpected exception while executing command.");
             onUnexpectedError(e);
             return {
                 operations: [],
diff -urN -x '*.map' a/vs/editor/common/cursor/cursorDeleteOperations.js b/vs/editor/common/cursor/cursorDeleteOperations.js
--- a/vs/editor/common/cursor/cursorDeleteOperations.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/cursor/cursorDeleteOperations.js	2023-12-06 14:23:14.363854755 +0000
@@ -175,7 +175,7 @@
                         endLineNumber = position.lineNumber + 1;
                         endColumn = 1;
                     }
-                    else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {
+                    else if (position.lineNumber > 1 && lastCutRange?.endLineNumber !== position.lineNumber) {
                         // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation
                         startLineNumber = position.lineNumber - 1;
                         startColumn = model.getLineMaxColumn(position.lineNumber - 1);
diff -urN -x '*.map' a/vs/editor/common/cursorCommon.js b/vs/editor/common/cursorCommon.js
--- a/vs/editor/common/cursorCommon.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/cursorCommon.js	2023-12-06 14:23:14.359854747 +0000
@@ -30,7 +30,6 @@
             || e.hasChanged(90 /* EditorOption.readOnly */));
     }
     constructor(languageId, modelOptions, configuration, languageConfigurationService) {
-        var _a;
         this.languageConfigurationService = languageConfigurationService;
         this._cursorMoveConfigurationBrand = undefined;
         this._languageId = languageId;
@@ -74,13 +73,12 @@
             }
         }
         const commentsConfiguration = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;
-        this.blockCommentStartToken = (_a = commentsConfiguration === null || commentsConfiguration === void 0 ? void 0 : commentsConfiguration.blockCommentStartToken) !== null && _a !== void 0 ? _a : null;
+        this.blockCommentStartToken = commentsConfiguration?.blockCommentStartToken ?? null;
     }
     get electricChars() {
-        var _a;
         if (!this._electricChars) {
             this._electricChars = {};
-            const electricChars = (_a = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) === null || _a === void 0 ? void 0 : _a.getElectricCharacters();
+            const electricChars = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter?.getElectricCharacters();
             if (electricChars) {
                 for (const char of electricChars) {
                     this._electricChars[char] = true;
diff -urN -x '*.map' a/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js b/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js
--- a/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js	2023-12-06 14:23:14.367854762 +0000
@@ -64,6 +64,9 @@
         }
         return new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));
     }
+    intersectsOrTouches(other) {
+        return this.seq1Range.intersectsOrTouches(other.seq1Range) || this.seq2Range.intersectsOrTouches(other.seq2Range);
+    }
     intersect(other) {
         const i1 = this.seq1Range.intersect(other.seq1Range);
         const i2 = this.seq2Range.intersect(other.seq2Range);
@@ -115,4 +118,9 @@
         }
         return this.valid;
     }
+    disable() {
+        this.timeout = Number.MAX_SAFE_INTEGER;
+        this.isValid = () => true;
+        this.valid = true;
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js b/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js
--- a/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js	2023-12-06 14:23:14.367854762 +0000
@@ -186,13 +186,12 @@
     }
     for (const s of sequenceDiffs) {
         function processWord(s1Range, s2Range) {
-            var _a, _b, _c, _d;
             if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {
                 if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {
                     const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);
                     const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);
-                    lastModifiedWord.deleted += (_a = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null && _a !== void 0 ? _a : 0;
-                    lastModifiedWord.added += (_b = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null && _b !== void 0 ? _b : 0;
+                    lastModifiedWord.deleted += s1Added?.length ?? 0;
+                    lastModifiedWord.added += s2Added?.length ?? 0;
                     lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);
                     lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);
                 }
@@ -204,8 +203,8 @@
             const changedS1 = s1Range.intersect(s.seq1Range);
             const changedS2 = s2Range.intersect(s.seq2Range);
             lastModifiedWord.count++;
-            lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null && _c !== void 0 ? _c : 0;
-            lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null && _d !== void 0 ? _d : 0;
+            lastModifiedWord.deleted += changedS1?.length ?? 0;
+            lastModifiedWord.added += changedS2?.length ?? 0;
         }
         const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);
         const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);
@@ -325,7 +324,7 @@
                     return Math.min(v, max);
                 }
                 if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)
-                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (Math.pow((Math.pow(max, 1.5)), 1.5)) * 1.3) {
+                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {
                     return true;
                 }
                 return false;
diff -urN -x '*.map' a/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js b/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js
--- a/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js	2023-12-06 14:23:14.367854762 +0000
@@ -126,9 +126,8 @@
         return this.elements[offset1] === this.elements[offset2];
     }
     extendToFullLines(range) {
-        var _a, _b;
-        const start = (_a = findLastMonotonous(this.firstCharOffsetByLine, x => x <= range.start)) !== null && _a !== void 0 ? _a : 0;
-        const end = (_b = findFirstMonotonous(this.firstCharOffsetByLine, x => range.endExclusive <= x)) !== null && _b !== void 0 ? _b : this.elements.length;
+        const start = findLastMonotonous(this.firstCharOffsetByLine, x => x <= range.start) ?? 0;
+        const end = findFirstMonotonous(this.firstCharOffsetByLine, x => range.endExclusive <= x) ?? this.elements.length;
         return new OffsetRange(start, end);
     }
 }
diff -urN -x '*.map' a/vs/editor/common/diff/defaultLinesDiffComputer/utils.js b/vs/editor/common/diff/defaultLinesDiffComputer/utils.js
--- a/vs/editor/common/diff/defaultLinesDiffComputer/utils.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/diff/defaultLinesDiffComputer/utils.js	2023-12-06 14:23:14.367854762 +0000
@@ -49,11 +49,10 @@
         this.totalCount = counter;
     }
     computeSimilarity(other) {
-        var _a, _b;
         let sumDifferences = 0;
         const maxLength = Math.max(this.histogram.length, other.histogram.length);
         for (let i = 0; i < maxLength; i++) {
-            sumDifferences += Math.abs(((_a = this.histogram[i]) !== null && _a !== void 0 ? _a : 0) - ((_b = other.histogram[i]) !== null && _b !== void 0 ? _b : 0));
+            sumDifferences += Math.abs((this.histogram[i] ?? 0) - (other.histogram[i] ?? 0));
         }
         return 1 - (sumDifferences / (this.totalCount + other.totalCount));
     }
diff -urN -x '*.map' a/vs/editor/common/diff/legacyLinesDiffComputer.js b/vs/editor/common/diff/legacyLinesDiffComputer.js
--- a/vs/editor/common/diff/legacyLinesDiffComputer.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/diff/legacyLinesDiffComputer.js	2023-12-06 14:23:14.367854762 +0000
@@ -12,7 +12,6 @@
 const MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
 export class LegacyLinesDiffComputer {
     computeDiff(originalLines, modifiedLines, options) {
-        var _a;
         const diffComputer = new DiffComputer(originalLines, modifiedLines, {
             maxComputationTime: options.maxComputationTimeMs,
             shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,
@@ -40,7 +39,7 @@
             else {
                 modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);
             }
-            let change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));
+            let change = new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));
             if (lastChange) {
                 if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber
                     || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {
diff -urN -x '*.map' a/vs/editor/common/diff/linesDiffComputer.js b/vs/editor/common/diff/linesDiffComputer.js
--- a/vs/editor/common/diff/linesDiffComputer.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/diff/linesDiffComputer.js	2023-12-06 14:23:14.367854762 +0000
@@ -24,4 +24,7 @@
         this.lineRangeMapping = lineRangeMapping;
         this.changes = changes;
     }
+    flip() {
+        return new MovedText(this.lineRangeMapping.flip(), this.changes.map(c => c.flip()));
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/diff/rangeMapping.js b/vs/editor/common/diff/rangeMapping.js
--- a/vs/editor/common/diff/rangeMapping.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/diff/rangeMapping.js	2023-12-06 14:23:14.367854762 +0000
@@ -38,6 +38,9 @@
     join(other) {
         return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));
     }
+    get changedLineCount() {
+        return Math.max(this.original.length, this.modified.length);
+    }
 }
 /**
  * Maps a line range in the original text model to a line range in the modified text model.
@@ -49,8 +52,7 @@
         this.innerChanges = innerChanges;
     }
     flip() {
-        var _a;
-        return new DetailedLineRangeMapping(this.modified, this.original, (_a = this.innerChanges) === null || _a === void 0 ? void 0 : _a.map(c => c.flip()));
+        return new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));
     }
 }
 /**
diff -urN -x '*.map' a/vs/editor/common/editorCommon.js b/vs/editor/common/editorCommon.js
--- a/vs/editor/common/editorCommon.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/editorCommon.js	2023-12-06 14:23:14.363854755 +0000
@@ -3,6 +3,12 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 /**
+ * @internal
+ */
+export function isThemeColor(o) {
+    return o && typeof o.id === 'string';
+}
+/**
  * The type of the `IEditor`.
  */
 export const EditorType = {
diff -urN -x '*.map' a/vs/editor/common/editorContextKeys.js b/vs/editor/common/editorContextKeys.js
--- a/vs/editor/common/editorContextKeys.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/editorContextKeys.js	2023-12-06 14:23:14.363854755 +0000
@@ -11,63 +11,63 @@
      * A context key that is set when the editor's text has focus (cursor is blinking).
      * Is false when focus is in simple editor widgets (repl input, scm commit input).
      */
-    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', "Whether the editor text has focus (cursor is blinking)"));
+    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorTextFocus', "Whether the editor text has focus (cursor is blinking)"));
     /**
      * A context key that is set when the editor's text or an editor's widget has focus.
      */
-    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', "Whether the editor or an editor widget has focus (e.g. focus is in the find widget)"));
+    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorFocus', "Whether the editor or an editor widget has focus (e.g. focus is in the find widget)"));
     /**
      * A context key that is set when any editor input has focus (regular editor, repl input...).
      */
-    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', "Whether an editor or a rich text input has focus (cursor is blinking)"));
-    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', "Whether the editor is read-only"));
-    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', "Whether the context is a diff editor"));
-    EditorContextKeys.isEmbeddedDiffEditor = new RawContextKey('isEmbeddedDiffEditor', false, nls.localize('isEmbeddedDiffEditor', "Whether the context is an embedded diff editor"));
-    EditorContextKeys.comparingMovedCode = new RawContextKey('comparingMovedCode', false, nls.localize('comparingMovedCode', "Whether a moved code block is selected for comparison"));
-    EditorContextKeys.accessibleDiffViewerVisible = new RawContextKey('accessibleDiffViewerVisible', false, nls.localize('accessibleDiffViewerVisible', "Whether the accessible diff viewer is visible"));
-    EditorContextKeys.diffEditorRenderSideBySideInlineBreakpointReached = new RawContextKey('diffEditorRenderSideBySideInlineBreakpointReached', false, nls.localize('diffEditorRenderSideBySideInlineBreakpointReached', "Whether the diff editor render side by side inline breakpoint is reached"));
-    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', "Whether `editor.columnSelection` is enabled"));
+    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'textInputFocus', "Whether an editor or a rich text input has focus (cursor is blinking)"));
+    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorReadonly', "Whether the editor is read-only"));
+    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'inDiffEditor', "Whether the context is a diff editor"));
+    EditorContextKeys.isEmbeddedDiffEditor = new RawContextKey('isEmbeddedDiffEditor', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'isEmbeddedDiffEditor', "Whether the context is an embedded diff editor"));
+    EditorContextKeys.comparingMovedCode = new RawContextKey('comparingMovedCode', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'comparingMovedCode', "Whether a moved code block is selected for comparison"));
+    EditorContextKeys.accessibleDiffViewerVisible = new RawContextKey('accessibleDiffViewerVisible', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'accessibleDiffViewerVisible', "Whether the accessible diff viewer is visible"));
+    EditorContextKeys.diffEditorRenderSideBySideInlineBreakpointReached = new RawContextKey('diffEditorRenderSideBySideInlineBreakpointReached', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'diffEditorRenderSideBySideInlineBreakpointReached', "Whether the diff editor render side by side inline breakpoint is reached"));
+    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorColumnSelection', "Whether `editor.columnSelection` is enabled"));
     EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();
-    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', "Whether the editor has text selected"));
+    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasSelection', "Whether the editor has text selected"));
     EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();
-    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', "Whether the editor has multiple selections"));
+    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasMultipleSelections', "Whether the editor has multiple selections"));
     EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();
-    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', "Whether `Tab` will move focus out of the editor"));
+    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorTabMovesFocus', "Whether `Tab` will move focus out of the editor"));
     EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();
     EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);
     EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);
     EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);
-    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', "Whether the editor hover is visible"));
-    EditorContextKeys.hoverFocused = new RawContextKey('editorHoverFocused', false, nls.localize('editorHoverFocused', "Whether the editor hover is focused"));
-    EditorContextKeys.stickyScrollFocused = new RawContextKey('stickyScrollFocused', false, nls.localize('stickyScrollFocused', "Whether the sticky scroll is focused"));
-    EditorContextKeys.stickyScrollVisible = new RawContextKey('stickyScrollVisible', false, nls.localize('stickyScrollVisible', "Whether the sticky scroll is visible"));
-    EditorContextKeys.standaloneColorPickerVisible = new RawContextKey('standaloneColorPickerVisible', false, nls.localize('standaloneColorPickerVisible', "Whether the standalone color picker is visible"));
-    EditorContextKeys.standaloneColorPickerFocused = new RawContextKey('standaloneColorPickerFocused', false, nls.localize('standaloneColorPickerFocused', "Whether the standalone color picker is focused"));
+    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHoverVisible', "Whether the editor hover is visible"));
+    EditorContextKeys.hoverFocused = new RawContextKey('editorHoverFocused', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHoverFocused', "Whether the editor hover is focused"));
+    EditorContextKeys.stickyScrollFocused = new RawContextKey('stickyScrollFocused', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'stickyScrollFocused', "Whether the sticky scroll is focused"));
+    EditorContextKeys.stickyScrollVisible = new RawContextKey('stickyScrollVisible', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'stickyScrollVisible', "Whether the sticky scroll is visible"));
+    EditorContextKeys.standaloneColorPickerVisible = new RawContextKey('standaloneColorPickerVisible', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'standaloneColorPickerVisible', "Whether the standalone color picker is visible"));
+    EditorContextKeys.standaloneColorPickerFocused = new RawContextKey('standaloneColorPickerFocused', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'standaloneColorPickerFocused', "Whether the standalone color picker is focused"));
     /**
      * A context key that is set when an editor is part of a larger editor, like notebooks or
      * (future) a diff editor
      */
-    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', "Whether the editor is part of a larger editor (e.g. notebooks)"));
+    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'inCompositeEditor', "Whether the editor is part of a larger editor (e.g. notebooks)"));
     EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();
     // -- mode context keys
-    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', "The language identifier of the editor"));
-    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', "Whether the editor has a completion item provider"));
-    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', "Whether the editor has a code actions provider"));
-    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', "Whether the editor has a code lens provider"));
-    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', "Whether the editor has a definition provider"));
-    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', "Whether the editor has a declaration provider"));
-    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', "Whether the editor has an implementation provider"));
-    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', "Whether the editor has a type definition provider"));
-    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', "Whether the editor has a hover provider"));
-    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', "Whether the editor has a document highlight provider"));
-    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', "Whether the editor has a document symbol provider"));
-    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', "Whether the editor has a reference provider"));
-    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', "Whether the editor has a rename provider"));
-    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', "Whether the editor has a signature help provider"));
-    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', "Whether the editor has an inline hints provider"));
+    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorLangId', "The language identifier of the editor"));
+    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasCompletionItemProvider', "Whether the editor has a completion item provider"));
+    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasCodeActionsProvider', "Whether the editor has a code actions provider"));
+    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasCodeLensProvider', "Whether the editor has a code lens provider"));
+    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasDefinitionProvider', "Whether the editor has a definition provider"));
+    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasDeclarationProvider', "Whether the editor has a declaration provider"));
+    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasImplementationProvider', "Whether the editor has an implementation provider"));
+    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasTypeDefinitionProvider', "Whether the editor has a type definition provider"));
+    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasHoverProvider', "Whether the editor has a hover provider"));
+    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasDocumentHighlightProvider', "Whether the editor has a document highlight provider"));
+    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasDocumentSymbolProvider', "Whether the editor has a document symbol provider"));
+    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasReferenceProvider', "Whether the editor has a reference provider"));
+    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasRenameProvider', "Whether the editor has a rename provider"));
+    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasSignatureHelpProvider', "Whether the editor has a signature help provider"));
+    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasInlayHintsProvider', "Whether the editor has an inline hints provider"));
     // -- mode context keys: formatting
-    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', "Whether the editor has a document formatting provider"));
-    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', "Whether the editor has a document selection formatting provider"));
-    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', "Whether the editor has multiple document formatting providers"));
-    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', "Whether the editor has multiple document selection formatting providers"));
+    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasDocumentFormattingProvider', "Whether the editor has a document formatting provider"));
+    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasDocumentSelectionFormattingProvider', "Whether the editor has a document selection formatting provider"));
+    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasMultipleDocumentFormattingProvider', "Whether the editor has multiple document formatting providers"));
+    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localizeWithPath('vs/editor/common/editorContextKeys', 'editorHasMultipleDocumentSelectionFormattingProvider', "Whether the editor has multiple document selection formatting providers"));
 })(EditorContextKeys || (EditorContextKeys = {}));
diff -urN -x '*.map' a/vs/editor/common/languageFeatureRegistry.js b/vs/editor/common/languageFeatureRegistry.js
--- a/vs/editor/common/languageFeatureRegistry.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/languageFeatureRegistry.js	2023-12-06 14:23:14.363854755 +0000
@@ -25,11 +25,10 @@
         this.notebookType = notebookType;
     }
     equals(other) {
-        var _a, _b;
         return this.notebookType === other.notebookType
             && this.languageId === other.languageId
             && this.uri.toString() === other.uri.toString()
-            && ((_a = this.notebookUri) === null || _a === void 0 ? void 0 : _a.toString()) === ((_b = other.notebookUri) === null || _b === void 0 ? void 0 : _b.toString());
+            && this.notebookUri?.toString() === other.notebookUri?.toString();
     }
 }
 export class LanguageFeatureRegistry {
@@ -109,14 +108,13 @@
         }
     }
     _updateScores(model) {
-        var _a, _b;
-        const notebookInfo = (_a = this._notebookInfoResolver) === null || _a === void 0 ? void 0 : _a.call(this, model.uri);
+        const notebookInfo = this._notebookInfoResolver?.(model.uri);
         // use the uri (scheme, pattern) of the notebook info iff we have one
         // otherwise it's the model's/document's uri
         const candidate = notebookInfo
             ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type)
             : new MatchCandidate(model.uri, model.getLanguageId(), undefined, undefined);
-        if ((_b = this._lastCandidate) === null || _b === void 0 ? void 0 : _b.equals(candidate)) {
+        if (this._lastCandidate?.equals(candidate)) {
             // nothing has changed
             return;
         }
diff -urN -x '*.map' a/vs/editor/common/languageSelector.js b/vs/editor/common/languageSelector.js
--- a/vs/editor/common/languageSelector.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/languageSelector.js	2023-12-06 14:23:14.363854755 +0000
@@ -92,7 +92,7 @@
                 // because we will compare it against `Uri.fsPath`
                 // which uses platform specific separators.
                 // Refs: https://github.com/microsoft/vscode/issues/99938
-                normalizedPattern = Object.assign(Object.assign({}, pattern), { base: normalize(pattern.base) });
+                normalizedPattern = { ...pattern, base: normalize(pattern.base) };
             }
             if (normalizedPattern === candidateUri.fsPath || matchGlobPattern(normalizedPattern, candidateUri.fsPath)) {
                 ret = 10;
diff -urN -x '*.map' a/vs/editor/common/languages/languageConfigurationRegistry.js b/vs/editor/common/languages/languageConfigurationRegistry.js
--- a/vs/editor/common/languages/languageConfigurationRegistry.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/languages/languageConfigurationRegistry.js	2023-12-06 14:23:14.367854762 +0000
@@ -278,7 +278,7 @@
     }
     getLanguageConfiguration(languageId) {
         const entries = this._entries.get(languageId);
-        return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;
+        return entries?.getResolvedConfiguration() || null;
     }
 }
 /**
diff -urN -x '*.map' a/vs/editor/common/languages/modesRegistry.js b/vs/editor/common/languages/modesRegistry.js
--- a/vs/editor/common/languages/modesRegistry.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/languages/modesRegistry.js	2023-12-06 14:23:14.367854762 +0000
@@ -42,7 +42,7 @@
 ModesRegistry.registerLanguage({
     id: PLAINTEXT_LANGUAGE_ID,
     extensions: [PLAINTEXT_EXTENSION],
-    aliases: [nls.localize('plainText.alias', "Plain Text"), 'text'],
+    aliases: [nls.localizeWithPath('vs/editor/common/languages/modesRegistry', 'plainText.alias', "Plain Text"), 'text'],
     mimetypes: [Mimes.text]
 });
 Registry.as(ConfigurationExtensions.Configuration)
diff -urN -x '*.map' a/vs/editor/common/languages/supports/characterPair.js b/vs/editor/common/languages/supports/characterPair.js
--- a/vs/editor/common/languages/supports/characterPair.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/languages/supports/characterPair.js	2023-12-06 14:23:14.367854762 +0000
@@ -35,3 +35,4 @@
 }
 CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \n\t';
 CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\'"`;:.,=}])> \n\t';
+CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_WHITESPACE = ' \n\t';
diff -urN -x '*.map' a/vs/editor/common/languages/supports/tokenization.js b/vs/editor/common/languages/supports/tokenization.js
--- a/vs/editor/common/languages/supports/tokenization.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/languages/supports/tokenization.js	2023-12-06 14:23:14.367854762 +0000
@@ -145,6 +145,12 @@
     getColorMap() {
         return this._colorMap.getColorMap();
     }
+    /**
+     * used for testing purposes
+     */
+    getThemeTrieElement() {
+        return this._root.toExternalThemeTrieElement();
+    }
     _match(token) {
         return this._root.match(token);
     }
@@ -217,12 +223,36 @@
             | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;
     }
 }
+export class ExternalThemeTrieElement {
+    constructor(mainRule, children = new Map()) {
+        this.mainRule = mainRule;
+        if (children instanceof Map) {
+            this.children = children;
+        }
+        else {
+            this.children = new Map();
+            for (const key in children) {
+                this.children.set(key, children[key]);
+            }
+        }
+    }
+}
 export class ThemeTrieElement {
     constructor(mainRule) {
         this._themeTrieElementBrand = undefined;
         this._mainRule = mainRule;
         this._children = new Map();
     }
+    /**
+     * used for testing purposes
+     */
+    toExternalThemeTrieElement() {
+        const children = new Map();
+        this._children.forEach((element, index) => {
+            children.set(index, element.toExternalThemeTrieElement());
+        });
+        return new ExternalThemeTrieElement(this._mainRule, children);
+    }
     match(token) {
         if (token === '') {
             return this._mainRule;
diff -urN -x '*.map' a/vs/editor/common/languages/textToHtmlTokenizer.js b/vs/editor/common/languages/textToHtmlTokenizer.js
--- a/vs/editor/common/languages/textToHtmlTokenizer.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/languages/textToHtmlTokenizer.js	2023-12-06 14:23:14.367854762 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import * as strings from '../../../base/common/strings.js';
 import { LineTokens } from '../tokens/lineTokens.js';
 import { TokenizationRegistry } from '../languages.js';
@@ -19,14 +10,15 @@
     getInitialState: () => NullState,
     tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0 /* LanguageId.Null */, state)
 };
-export function tokenizeToString(languageService, text, languageId) {
-    return __awaiter(this, void 0, void 0, function* () {
-        if (!languageId) {
-            return _tokenizeToString(text, languageService.languageIdCodec, fallback);
-        }
-        const tokenizationSupport = yield TokenizationRegistry.getOrCreate(languageId);
-        return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);
-    });
+export function tokenizeToStringSync(languageService, text, languageId) {
+    return _tokenizeToString(text, languageService.languageIdCodec, TokenizationRegistry.get(languageId) || fallback);
+}
+export async function tokenizeToString(languageService, text, languageId) {
+    if (!languageId) {
+        return _tokenizeToString(text, languageService.languageIdCodec, fallback);
+    }
+    const tokenizationSupport = await TokenizationRegistry.getOrCreate(languageId);
+    return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);
 }
 export function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {
     let result = `<div>`;
diff -urN -x '*.map' a/vs/editor/common/languages.js b/vs/editor/common/languages.js
--- a/vs/editor/common/languages.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/languages.js	2023-12-06 14:23:14.363854755 +0000
@@ -1,8 +1,13 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 import { Codicon } from '../../base/common/codicons.js';
 import { URI } from '../../base/common/uri.js';
+import { EditOperation } from './core/editOperation.js';
 import { Range } from './core/range.js';
 import { TokenizationRegistry as TokenizationRegistryImpl } from './tokenizationRegistry.js';
-import { localize } from '../../nls.js';
+import { localizeWithPath } from '../../nls.js';
 export class Token {
     constructor(offset, type, language) {
         this.offset = offset;
@@ -198,38 +203,38 @@
  * @internal
  */
 export const symbolKindNames = {
-    [17 /* SymbolKind.Array */]: localize('Array', "array"),
-    [16 /* SymbolKind.Boolean */]: localize('Boolean', "boolean"),
-    [4 /* SymbolKind.Class */]: localize('Class', "class"),
-    [13 /* SymbolKind.Constant */]: localize('Constant', "constant"),
-    [8 /* SymbolKind.Constructor */]: localize('Constructor', "constructor"),
-    [9 /* SymbolKind.Enum */]: localize('Enum', "enumeration"),
-    [21 /* SymbolKind.EnumMember */]: localize('EnumMember', "enumeration member"),
-    [23 /* SymbolKind.Event */]: localize('Event', "event"),
-    [7 /* SymbolKind.Field */]: localize('Field', "field"),
-    [0 /* SymbolKind.File */]: localize('File', "file"),
-    [11 /* SymbolKind.Function */]: localize('Function', "function"),
-    [10 /* SymbolKind.Interface */]: localize('Interface', "interface"),
-    [19 /* SymbolKind.Key */]: localize('Key', "key"),
-    [5 /* SymbolKind.Method */]: localize('Method', "method"),
-    [1 /* SymbolKind.Module */]: localize('Module', "module"),
-    [2 /* SymbolKind.Namespace */]: localize('Namespace', "namespace"),
-    [20 /* SymbolKind.Null */]: localize('Null', "null"),
-    [15 /* SymbolKind.Number */]: localize('Number', "number"),
-    [18 /* SymbolKind.Object */]: localize('Object', "object"),
-    [24 /* SymbolKind.Operator */]: localize('Operator', "operator"),
-    [3 /* SymbolKind.Package */]: localize('Package', "package"),
-    [6 /* SymbolKind.Property */]: localize('Property', "property"),
-    [14 /* SymbolKind.String */]: localize('String', "string"),
-    [22 /* SymbolKind.Struct */]: localize('Struct', "struct"),
-    [25 /* SymbolKind.TypeParameter */]: localize('TypeParameter', "type parameter"),
-    [12 /* SymbolKind.Variable */]: localize('Variable', "variable"),
+    [17 /* SymbolKind.Array */]: localizeWithPath('vs/editor/common/languages', 'Array', "array"),
+    [16 /* SymbolKind.Boolean */]: localizeWithPath('vs/editor/common/languages', 'Boolean', "boolean"),
+    [4 /* SymbolKind.Class */]: localizeWithPath('vs/editor/common/languages', 'Class', "class"),
+    [13 /* SymbolKind.Constant */]: localizeWithPath('vs/editor/common/languages', 'Constant', "constant"),
+    [8 /* SymbolKind.Constructor */]: localizeWithPath('vs/editor/common/languages', 'Constructor', "constructor"),
+    [9 /* SymbolKind.Enum */]: localizeWithPath('vs/editor/common/languages', 'Enum', "enumeration"),
+    [21 /* SymbolKind.EnumMember */]: localizeWithPath('vs/editor/common/languages', 'EnumMember', "enumeration member"),
+    [23 /* SymbolKind.Event */]: localizeWithPath('vs/editor/common/languages', 'Event', "event"),
+    [7 /* SymbolKind.Field */]: localizeWithPath('vs/editor/common/languages', 'Field', "field"),
+    [0 /* SymbolKind.File */]: localizeWithPath('vs/editor/common/languages', 'File', "file"),
+    [11 /* SymbolKind.Function */]: localizeWithPath('vs/editor/common/languages', 'Function', "function"),
+    [10 /* SymbolKind.Interface */]: localizeWithPath('vs/editor/common/languages', 'Interface', "interface"),
+    [19 /* SymbolKind.Key */]: localizeWithPath('vs/editor/common/languages', 'Key', "key"),
+    [5 /* SymbolKind.Method */]: localizeWithPath('vs/editor/common/languages', 'Method', "method"),
+    [1 /* SymbolKind.Module */]: localizeWithPath('vs/editor/common/languages', 'Module', "module"),
+    [2 /* SymbolKind.Namespace */]: localizeWithPath('vs/editor/common/languages', 'Namespace', "namespace"),
+    [20 /* SymbolKind.Null */]: localizeWithPath('vs/editor/common/languages', 'Null', "null"),
+    [15 /* SymbolKind.Number */]: localizeWithPath('vs/editor/common/languages', 'Number', "number"),
+    [18 /* SymbolKind.Object */]: localizeWithPath('vs/editor/common/languages', 'Object', "object"),
+    [24 /* SymbolKind.Operator */]: localizeWithPath('vs/editor/common/languages', 'Operator', "operator"),
+    [3 /* SymbolKind.Package */]: localizeWithPath('vs/editor/common/languages', 'Package', "package"),
+    [6 /* SymbolKind.Property */]: localizeWithPath('vs/editor/common/languages', 'Property', "property"),
+    [14 /* SymbolKind.String */]: localizeWithPath('vs/editor/common/languages', 'String', "string"),
+    [22 /* SymbolKind.Struct */]: localizeWithPath('vs/editor/common/languages', 'Struct', "struct"),
+    [25 /* SymbolKind.TypeParameter */]: localizeWithPath('vs/editor/common/languages', 'TypeParameter', "type parameter"),
+    [12 /* SymbolKind.Variable */]: localizeWithPath('vs/editor/common/languages', 'Variable', "variable"),
 };
 /**
  * @internal
  */
 export function getAriaLabelForSymbol(symbolName, kind) {
-    return localize('symbolAriaLabel', '{0} ({1})', symbolName, symbolKindNames[kind]);
+    return localizeWithPath('vs/editor/common/languages', 'symbolAriaLabel', '{0} ({1})', symbolName, symbolKindNames[kind]);
 }
 /**
  * @internal
@@ -278,6 +283,9 @@
 })(SymbolKinds || (SymbolKinds = {}));
 /** @internal */
 export class TextEdit {
+    static asEditOperation(edit) {
+        return EditOperation.replace(Range.lift(edit.range), edit.text);
+    }
 }
 export class FoldingRangeKind {
     /**
@@ -332,6 +340,44 @@
     }
     Command.is = is;
 })(Command || (Command = {}));
+/**
+ * @internal
+ */
+export var CommentThreadCollapsibleState;
+(function (CommentThreadCollapsibleState) {
+    /**
+     * Determines an item is collapsed
+     */
+    CommentThreadCollapsibleState[CommentThreadCollapsibleState["Collapsed"] = 0] = "Collapsed";
+    /**
+     * Determines an item is expanded
+     */
+    CommentThreadCollapsibleState[CommentThreadCollapsibleState["Expanded"] = 1] = "Expanded";
+})(CommentThreadCollapsibleState || (CommentThreadCollapsibleState = {}));
+/**
+ * @internal
+ */
+export var CommentThreadState;
+(function (CommentThreadState) {
+    CommentThreadState[CommentThreadState["Unresolved"] = 0] = "Unresolved";
+    CommentThreadState[CommentThreadState["Resolved"] = 1] = "Resolved";
+})(CommentThreadState || (CommentThreadState = {}));
+/**
+ * @internal
+ */
+export var CommentMode;
+(function (CommentMode) {
+    CommentMode[CommentMode["Editing"] = 0] = "Editing";
+    CommentMode[CommentMode["Preview"] = 1] = "Preview";
+})(CommentMode || (CommentMode = {}));
+/**
+ * @internal
+ */
+export var CommentState;
+(function (CommentState) {
+    CommentState[CommentState["Published"] = 0] = "Published";
+    CommentState[CommentState["Draft"] = 1] = "Draft";
+})(CommentState || (CommentState = {}));
 export var InlayHintKind;
 (function (InlayHintKind) {
     InlayHintKind[InlayHintKind["Type"] = 1] = "Type";
@@ -365,3 +411,13 @@
  * @internal
  */
 export const TokenizationRegistry = new TokenizationRegistryImpl();
+/**
+ * @internal
+ */
+export var ExternalUriOpenerPriority;
+(function (ExternalUriOpenerPriority) {
+    ExternalUriOpenerPriority[ExternalUriOpenerPriority["None"] = 0] = "None";
+    ExternalUriOpenerPriority[ExternalUriOpenerPriority["Option"] = 1] = "Option";
+    ExternalUriOpenerPriority[ExternalUriOpenerPriority["Default"] = 2] = "Default";
+    ExternalUriOpenerPriority[ExternalUriOpenerPriority["Preferred"] = 3] = "Preferred";
+})(ExternalUriOpenerPriority || (ExternalUriOpenerPriority = {}));
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js	2023-12-06 14:23:14.367854762 +0000
@@ -23,8 +23,7 @@
         this.onDidChange = this.onDidChangeEmitter.event;
         this.bracketsRequested = false;
         this._register(this.languageConfigurationService.onDidChange(e => {
-            var _a;
-            if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {
+            if (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {
                 this.bracketPairsTree.clear();
                 this.updateBracketPairsTree();
             }
@@ -40,16 +39,13 @@
         this.updateBracketPairsTree();
     }
     handleDidChangeContent(change) {
-        var _a;
-        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);
+        this.bracketPairsTree.value?.object.handleContentChanged(change);
     }
     handleDidChangeBackgroundTokenizationState() {
-        var _a;
-        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeBackgroundTokenizationState();
+        this.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();
     }
     handleDidChangeTokens(e) {
-        var _a;
-        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeTokens(e);
+        this.bracketPairsTree.value?.object.handleDidChangeTokens(e);
     }
     //#endregion
     updateBracketPairsTree() {
@@ -76,22 +72,19 @@
      * The result is sorted by the start position.
     */
     getBracketPairsInRange(range) {
-        var _a;
         this.bracketsRequested = true;
         this.updateBracketPairsTree();
-        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || CallbackIterable.empty;
+        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || CallbackIterable.empty;
     }
     getBracketPairsInRangeWithMinIndentation(range) {
-        var _a;
         this.bracketsRequested = true;
         this.updateBracketPairsTree();
-        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || CallbackIterable.empty;
+        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || CallbackIterable.empty;
     }
     getBracketsInRange(range, onlyColorizedBrackets = false) {
-        var _a;
         this.bracketsRequested = true;
         this.updateBracketPairsTree();
-        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range, onlyColorizedBrackets)) || CallbackIterable.empty;
+        return this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || CallbackIterable.empty;
     }
     findMatchingBracketUp(_bracket, _position, maxDuration) {
         const position = this.textModel.validatePosition(_position);
@@ -400,12 +393,11 @@
         return null;
     }
     findPrevBracket(_position) {
-        var _a;
         const position = this.textModel.validatePosition(_position);
         if (this.canBuildAST) {
             this.bracketsRequested = true;
             this.updateBracketPairsTree();
-            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketBefore(position)) || null;
+            return this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;
         }
         let languageId = null;
         let modeBrackets = null;
@@ -478,12 +470,11 @@
         return null;
     }
     findNextBracket(_position) {
-        var _a;
         const position = this.textModel.validatePosition(_position);
         if (this.canBuildAST) {
             this.bracketsRequested = true;
             this.updateBracketPairsTree();
-            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketAfter(position)) || null;
+            return this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;
         }
         const lineCount = this.textModel.getLineCount();
         let languageId = null;
@@ -695,7 +686,7 @@
 function createDisposableRef(object, disposable) {
     return {
         object,
-        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),
+        dispose: () => disposable?.dispose(),
     };
 }
 function createTimeBasedContinueBracketSearchPredicate(maxDuration) {
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js	2023-12-06 14:23:14.367854762 +0000
@@ -88,6 +88,9 @@
         }
         return true;
     }
+    flattenLists() {
+        return PairAstNode.create(this.openingBracket.flattenLists(), this.child && this.child.flattenLists(), this.closingBracket && this.closingBracket.flattenLists());
+    }
     deepClone() {
         return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);
     }
@@ -118,6 +121,22 @@
             ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)
             : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);
     }
+    static create(items, immutable = false) {
+        if (items.length === 0) {
+            return this.getEmpty();
+        }
+        else {
+            let length = items[0].length;
+            let unopenedBrackets = items[0].missingOpeningBracketIds;
+            for (let i = 1; i < items.length; i++) {
+                length = lengthAdd(length, items[i].length);
+                unopenedBrackets = unopenedBrackets.merge(items[i].missingOpeningBracketIds);
+            }
+            return immutable
+                ? new ImmutableArrayListAstNode(length, items[0].listHeight + 1, items, unopenedBrackets)
+                : new ArrayListAstNode(length, items[0].listHeight + 1, items, unopenedBrackets);
+        }
+    }
     static getEmpty() {
         return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());
     }
@@ -198,6 +217,19 @@
         this._missingOpeningBracketIds = unopenedBrackets;
         this.cachedMinIndentation = -1;
     }
+    flattenLists() {
+        const items = [];
+        for (const c of this.children) {
+            const normalized = c.flattenLists();
+            if (normalized.kind === 4 /* AstNodeKind.List */) {
+                items.push(...normalized.children);
+            }
+            else {
+                items.push(normalized);
+            }
+        }
+        return ListAstNode.create(items);
+    }
     computeMinIndentation(offset, textModel) {
         if (this.cachedMinIndentation !== -1) {
             return this.cachedMinIndentation;
@@ -395,6 +427,9 @@
     get children() {
         return emptyArray;
     }
+    flattenLists() {
+        return this;
+    }
     deepClone() {
         return this;
     }
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js	2023-12-06 14:23:14.367854762 +0000
@@ -94,7 +94,7 @@
     parseDocumentFromTextBuffer(edits, previousAst, immutable) {
         // Is much faster if `isPure = false`.
         const isPure = false;
-        const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;
+        const previousAstClone = isPure ? previousAst?.deepClone() : previousAst;
         const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);
         const result = parseDocument(tokenizer, edits, previousAstClone, immutable);
         return result;
@@ -263,7 +263,7 @@
                     }
                     nodeOffsetStart = nodeOffsetEnd;
                 }
-                levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);
+                levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);
                 return true;
             }
             case 3 /* AstNodeKind.UnexpectedClosingBracket */: {
@@ -287,7 +287,6 @@
     }
 }
 function collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {
-    var _a;
     if (level > 200) {
         return true;
     }
@@ -309,7 +308,7 @@
             minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);
         }
         shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket
-            ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd)
+            ? lengthsToRange(lengthAdd(openingBracketEnd, node.child?.length || lengthZero), nodeOffsetEnd)
             : undefined, level, levelPerBracket, node, minIndentation));
         nodeOffsetStart = openingBracketEnd;
         if (shouldContinue && node.child) {
@@ -323,7 +322,7 @@
                 }
             }
         }
-        levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);
+        levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);
     }
     else {
         let curOffset = nodeOffsetStart;
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js	2023-12-06 14:23:14.367854762 +0000
@@ -102,4 +102,8 @@
         }
         return singleLanguageBracketTokens;
     }
+    getToken(value, languageId) {
+        const singleLanguageBracketTokens = this.getSingleLanguageBracketTokens(languageId);
+        return singleLanguageBracketTokens.getToken(value);
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js	2023-12-06 14:23:14.367854762 +0000
@@ -35,7 +35,7 @@
             const [item, remainingItem] = curItem.splitAt(s1Length);
             result.push(item);
             s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);
-            curItem = remainingItem !== null && remainingItem !== void 0 ? remainingItem : s0ToS1Map.dequeue();
+            curItem = remainingItem ?? s0ToS1Map.dequeue();
         }
         if (!lengthIsZero(s1Length)) {
             result.push(new LengthMapping(false, s1Length, s1Length));
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js	2023-12-06 14:23:14.367854762 +0000
@@ -3,16 +3,63 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { splitLines } from '../../../../../base/common/strings.js';
+import { Position } from '../../../core/position.js';
 import { Range } from '../../../core/range.js';
 /**
  * Represents a non-negative length in terms of line and column count.
  * Prefer using {@link Length} for performance reasons.
 */
 export class LengthObj {
+    static lengthDiffNonNegative(start, end) {
+        if (end.isLessThan(start)) {
+            return LengthObj.zero;
+        }
+        if (start.lineCount === end.lineCount) {
+            return new LengthObj(0, end.columnCount - start.columnCount);
+        }
+        else {
+            return new LengthObj(end.lineCount - start.lineCount, end.columnCount);
+        }
+    }
     constructor(lineCount, columnCount) {
         this.lineCount = lineCount;
         this.columnCount = columnCount;
     }
+    isZero() {
+        return this.lineCount === 0 && this.columnCount === 0;
+    }
+    toLength() {
+        return toLength(this.lineCount, this.columnCount);
+    }
+    isLessThan(other) {
+        if (this.lineCount !== other.lineCount) {
+            return this.lineCount < other.lineCount;
+        }
+        return this.columnCount < other.columnCount;
+    }
+    isGreaterThan(other) {
+        if (this.lineCount !== other.lineCount) {
+            return this.lineCount > other.lineCount;
+        }
+        return this.columnCount > other.columnCount;
+    }
+    equals(other) {
+        return this.lineCount === other.lineCount && this.columnCount === other.columnCount;
+    }
+    compare(other) {
+        if (this.lineCount !== other.lineCount) {
+            return this.lineCount - other.lineCount;
+        }
+        return this.columnCount - other.columnCount;
+    }
+    add(other) {
+        if (other.lineCount === 0) {
+            return new LengthObj(this.lineCount, this.columnCount + other.columnCount);
+        }
+        else {
+            return new LengthObj(this.lineCount + other.lineCount, other.columnCount);
+        }
+    }
     toString() {
         return `${this.lineCount},${this.columnCount}`;
     }
@@ -35,7 +82,7 @@
  * We use the upper 26 bits to store the line and the lower 26 bits to store the column.
  */
 ///*
-const factor = Math.pow(2, 26);
+const factor = 2 ** 26;
 /*/
 const factor = 1000000;
 // */
@@ -107,6 +154,12 @@
 export function lengthGreaterThanEqual(length1, length2) {
     return length1 >= length2;
 }
+export function lengthToPosition(length) {
+    const l = length;
+    const lineCount = Math.floor(l / factor);
+    const colCount = l - lineCount * factor;
+    return new Position(lineCount + 1, colCount + 1);
+}
 export function positionToLength(position) {
     return toLength(position.lineNumber - 1, position.column - 1);
 }
@@ -119,7 +172,33 @@
     const colCount2 = l2 - lineCount2 * factor;
     return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);
 }
+export function lengthOfRange(range) {
+    if (range.startLineNumber === range.endLineNumber) {
+        return new LengthObj(0, range.endColumn - range.startColumn);
+    }
+    else {
+        return new LengthObj(range.endLineNumber - range.startLineNumber, range.endColumn - 1);
+    }
+}
+export function lengthCompare(length1, length2) {
+    const l1 = length1;
+    const l2 = length2;
+    return l1 - l2;
+}
 export function lengthOfString(str) {
     const lines = splitLines(str);
     return toLength(lines.length - 1, lines[lines.length - 1].length);
 }
+export function lengthOfStringObj(str) {
+    const lines = splitLines(str);
+    return new LengthObj(lines.length - 1, lines[lines.length - 1].length);
+}
+/**
+ * Computes a numeric hash of the given length.
+*/
+export function lengthHash(length) {
+    return length;
+}
+export function lengthMax(length1, length2) {
+    return length1 > length2 ? length1 : length2;
+}
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js	2023-12-06 14:23:14.367854762 +0000
@@ -19,6 +19,18 @@
  * Non incrementally built ASTs are immutable.
 */
 class Parser {
+    /**
+     * Reports how many nodes were constructed in the last parse operation.
+    */
+    get nodesConstructed() {
+        return this._itemsConstructed;
+    }
+    /**
+     * Reports how many nodes were reused in the last parse operation.
+    */
+    get nodesReused() {
+        return this._itemsFromCache;
+    }
     constructor(tokenizer, edits, oldNode, createImmutableLists) {
         this.tokenizer = tokenizer;
         this.createImmutableLists = createImmutableLists;
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js	2023-12-06 14:23:14.367854762 +0000
@@ -46,6 +46,16 @@
         newItems[idx] |= 1 << (key & 31);
         return SmallImmutableSet.create(this.items, newItems);
     }
+    has(value, keyProvider) {
+        const key = keyProvider.getKey(value);
+        let idx = key >> 5; // divided by 32
+        if (idx === 0) {
+            // fast path
+            return (this.items & (1 << key)) !== 0;
+        }
+        idx--;
+        return ((this.additionalItems[idx] || 0) & (1 << (key & 31))) !== 0;
+    }
     merge(other) {
         const merged = this.items | other.items;
         if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {
@@ -78,6 +88,20 @@
         }
         return false;
     }
+    equals(other) {
+        if (this.items !== other.items) {
+            return false;
+        }
+        if (this.additionalItems.length !== other.additionalItems.length) {
+            return false;
+        }
+        for (let i = 0; i < this.additionalItems.length; i++) {
+            if (this.additionalItems[i] !== other.additionalItems[i]) {
+                return false;
+            }
+        }
+        return true;
+    }
 }
 SmallImmutableSet.cache = new Array(129);
 SmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);
@@ -101,4 +125,19 @@
         }
         return existing;
     }
+    reverseLookup(value) {
+        return [...this.items].find(([_key, v]) => v === value)?.[0];
+    }
+    reverseLookupSet(set) {
+        const result = [];
+        for (const [key] of this.items) {
+            if (set.has(key, this)) {
+                result.push(key);
+            }
+        }
+        return result;
+    }
+    keys() {
+        return this.items.keys();
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js	2023-12-06 14:23:14.371854769 +0000
@@ -45,6 +45,9 @@
     get length() {
         return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);
     }
+    getText() {
+        return this.textModel.getValue();
+    }
     skip(length) {
         this.didPeek = false;
         this._offset = lengthAdd(this._offset, length);
@@ -295,4 +298,7 @@
     skip(length) {
         throw new NotSupportedError();
     }
+    getText() {
+        return this.text;
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js b/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js	2023-12-06 14:23:14.367854762 +0000
@@ -57,6 +57,9 @@
             }
         };
     }
+    getValue() {
+        return this.lines.map(l => l.getLineContent()).join('\n');
+    }
     getLineCount() {
         return this.lines.length;
     }
diff -urN -x '*.map' a/vs/editor/common/model/decorationProvider.js b/vs/editor/common/model/decorationProvider.js
--- a/vs/editor/common/model/decorationProvider.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/decorationProvider.js	2023-12-06 14:23:14.367854762 +0000
@@ -1 +1,5 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 export {};
diff -urN -x '*.map' a/vs/editor/common/model/editStack.js b/vs/editor/common/model/editStack.js
--- a/vs/editor/common/model/editStack.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/editStack.js	2023-12-06 14:23:14.367854762 +0000
@@ -217,11 +217,23 @@
         }
         this._delegate = null;
     }
+    setDelegate(delegate) {
+        this._delegate = delegate;
+    }
     prepareUndoRedo() {
         if (this._delegate) {
             return this._delegate.prepareUndoRedo(this);
         }
     }
+    getMissingModels() {
+        const result = [];
+        for (const editStackElement of this._editStackElementsArr) {
+            if (URI.isUri(editStackElement.model)) {
+                result.push(editStackElement.model);
+            }
+        }
+        return result;
+    }
     matchesResource(resource) {
         const key = uriGetComparisonKey(resource);
         return (this._editStackElementsMap.has(key));
@@ -324,7 +336,7 @@
         if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {
             return lastElement;
         }
-        const newElement = new SingleModelEditStackElement(nls.localize('edit', "Typing"), 'undoredo.textBufferEdit', this._model, beforeCursorState);
+        const newElement = new SingleModelEditStackElement(nls.localizeWithPath('vs/editor/common/model/editStack', 'edit', "Typing"), 'undoredo.textBufferEdit', this._model, beforeCursorState);
         this._undoRedoService.pushElement(newElement, group);
         return newElement;
     }
diff -urN -x '*.map' a/vs/editor/common/model/guidesTextModelPart.js b/vs/editor/common/model/guidesTextModelPart.js
--- a/vs/editor/common/model/guidesTextModelPart.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/guidesTextModelPart.js	2023-12-06 14:23:14.367854762 +0000
@@ -205,7 +205,6 @@
         return { startLineNumber, endLineNumber, indent };
     }
     getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {
-        var _a;
         const result = [];
         for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
             result.push([]);
@@ -220,7 +219,7 @@
                 // We don't need to query the brackets again if the cursor is in the viewport
                 ? bracketPairs
                 : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));
-            activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;
+            activeBracketPairRange = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)?.range;
         }
         const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;
         const colorProvider = new BracketPairGuidesClassNames();
diff -urN -x '*.map' a/vs/editor/common/model/intervalTree.js b/vs/editor/common/model/intervalTree.js
--- a/vs/editor/common/model/intervalTree.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/common/model/intervalTree.js	2023-12-06 14:23:14.367854762 +0000
@@ -38,6 +38,9 @@
 function setCollapseOnReplaceEdit(node, value) {
     node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));
 }
+export function setNodeStickiness(node, stickiness) {
+    _setNodeStickiness(node, stickiness);
+}
 export class IntervalNode {
     constructor(id, start, end) {
         this.metadata = 0;
@@ -175,6 +178,9 @@
         }
         this._normalizeDeltaIfNecessary();
     }
+    getAllInOrder() {
+        return search(this, 0, false, 0, false);
+    }
     _normalizeDeltaIfNecessary() {
         if (!this.requestNormalizeDelta) {
             return;
diff -urN -x '*.map' a/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js b/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js
--- a/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js	2023-12-06 14:23:14.371854769 +0000
@@ -269,6 +269,28 @@
     createSnapshot(BOM) {
         return new PieceTreeSnapshot(this, BOM);
     }
+    equal(other) {
+        if (this.getLength() !== other.getLength()) {
+            return false;
+        }
+        if (this.getLineCount() !== other.getLineCount()) {
+            return false;
+        }
+        let offset = 0;
+        const ret = this.iterate(this.root, node => {
+            if (node === SENTINEL) {
+                return true;
+            }
+            const str = this.getNodeContent(node);
+            const len = str.length;
+            const startPosition = other.nodeAt(offset);
+            const endPosition = other.nodeAt(offset + len);
+            const val = other.getValueInRange2(startPosition, endPosition);
+            offset += len;
+            return str === val;
+        });
+        return ret;
+    }
     getOffsetAt(lineNumber, column) {
         let leftLen = 0; // inorder
         let x = this.root;
@@ -499,6 +521,10 @@
         }
         return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;
     }
+    getCharCode(offset) {
+        const nodePos = this.nodeAt(offset);
+        return this._getCharCode(nodePos);
+    }
     findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {
         const buffer = this._buffers[node.piece.bufferIndex];
         const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
@@ -944,6 +970,9 @@
         this._lastChangeBufferPos = endPos;
         return [newPiece];
     }
+    getLinesRawContent() {
+        return this.getContentOfSubTree(this.root);
+    }
     getLineRawContent(lineNumber, endOffset = 0) {
         let x = this.root;
         let ret = '';
@@ -1449,4 +1478,12 @@
         fixInsert(this, z);
         return z;
     }
+    getContentOfSubTree(node) {
+        let str = '';
+        this.iterate(node, node => {
+            str += this.getNodeContent(node);
+            return true;
+        });
+        return str;
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js b/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js
--- a/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js	2023-12-06 14:23:14.371854769 +0000
@@ -14,12 +14,26 @@
     constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {
         super();
         this._onDidChangeContent = this._register(new Emitter());
+        this.onDidChangeContent = this._onDidChangeContent.event;
         this._BOM = BOM;
         this._mightContainNonBasicASCII = !isBasicASCII;
         this._mightContainRTL = containsRTL;
         this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;
         this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);
     }
+    // #region TextBuffer
+    equals(other) {
+        if (!(other instanceof PieceTreeTextBuffer)) {
+            return false;
+        }
+        if (this._BOM !== other._BOM) {
+            return false;
+        }
+        if (this.getEOL() !== other.getEOL()) {
+            return false;
+        }
+        return this._pieceTree.equal(other._pieceTree);
+    }
     mightContainRTL() {
         return this._mightContainRTL;
     }
@@ -121,9 +135,18 @@
     getLineCharCode(lineNumber, index) {
         return this._pieceTree.getLineCharCode(lineNumber, index);
     }
+    getCharCode(offset) {
+        return this._pieceTree.getCharCode(offset);
+    }
     getLineLength(lineNumber) {
         return this._pieceTree.getLineLength(lineNumber);
     }
+    getLineMinColumn(lineNumber) {
+        return 1;
+    }
+    getLineMaxColumn(lineNumber) {
+        return this.getLineLength(lineNumber) + 1;
+    }
     getLineFirstNonWhitespaceColumn(lineNumber) {
         const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));
         if (result === -1) {
@@ -388,6 +411,35 @@
     findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
         return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
     }
+    // #endregion
+    // #region helper
+    // testing purpose.
+    getPieceTree() {
+        return this._pieceTree;
+    }
+    static _getInverseEditRange(range, text) {
+        const startLineNumber = range.startLineNumber;
+        const startColumn = range.startColumn;
+        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);
+        let resultRange;
+        if (text.length > 0) {
+            // the operation inserts something
+            const lineCount = eolCount + 1;
+            if (lineCount === 1) {
+                // single line insert
+                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLineLength);
+            }
+            else {
+                // multi line insert
+                resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLineLength + 1);
+            }
+        }
+        else {
+            // There is nothing to insert
+            resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);
+        }
+        return resultRange;
+    }
     /**
      * Assumes `operations` are validated and sorted ascending
      */
diff -urN -x '*.map' a/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js b/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js
--- a/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js	2023-12-06 14:23:14.371854769 +0000
@@ -47,6 +47,9 @@
         const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
         return { textBuffer: textBuffer, disposable: textBuffer };
     }
+    getFirstLineText(lengthLimit) {
+        return this._chunks[0].buffer.substr(0, lengthLimit).split(/\r\n|\r|\n/)[0];
+    }
 }
 export class PieceTreeTextBufferBuilder {
     constructor() {
diff -urN -x '*.map' a/vs/editor/common/model/prefixSumComputer.js b/vs/editor/common/model/prefixSumComputer.js
--- a/vs/editor/common/model/prefixSumComputer.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/model/prefixSumComputer.js	2023-12-06 14:23:14.367854762 +0000
@@ -11,6 +11,9 @@
         this.prefixSumValidIndex = new Int32Array(1);
         this.prefixSumValidIndex[0] = -1;
     }
+    getCount() {
+        return this.values.length;
+    }
     insertValues(insertIndex, insertValues) {
         insertIndex = toUint32(insertIndex);
         const oldValues = this.values;
diff -urN -x '*.map' a/vs/editor/common/model/textModel.js b/vs/editor/common/model/textModel.js
--- a/vs/editor/common/model/textModel.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/model/textModel.js	2023-12-06 14:23:14.367854762 +0000
@@ -17,6 +17,7 @@
 import { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';
 import { Emitter } from '../../../base/common/event.js';
 import { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';
+import { listenStream } from '../../../base/common/stream.js';
 import * as strings from '../../../base/common/strings.js';
 import { URI } from '../../../base/common/uri.js';
 import { countEOL } from '../core/eolCounter.js';
@@ -46,6 +47,29 @@
     builder.acceptChunk(text);
     return builder.finish();
 }
+export function createTextBufferFactoryFromStream(stream) {
+    return new Promise((resolve, reject) => {
+        const builder = new PieceTreeTextBufferBuilder();
+        let done = false;
+        listenStream(stream, {
+            onData: chunk => {
+                builder.acceptChunk((typeof chunk === 'string') ? chunk : chunk.toString());
+            },
+            onError: error => {
+                if (!done) {
+                    done = true;
+                    reject(error);
+                }
+            },
+            onEnd: () => {
+                if (!done) {
+                    done = true;
+                    resolve(builder.finish());
+                }
+            }
+        });
+    });
+}
 export function createTextBufferFactoryFromSnapshot(snapshot) {
     const builder = new PieceTreeTextBufferBuilder();
     let chunk;
@@ -225,11 +249,28 @@
         this._buffer = emptyDisposedTextBuffer;
         this._bufferDisposable = Disposable.None;
     }
+    _hasListeners() {
+        return (this._onWillDispose.hasListeners()
+            || this._onDidChangeDecorations.hasListeners()
+            || this._tokenizationTextModelPart._hasListeners()
+            || this._onDidChangeOptions.hasListeners()
+            || this._onDidChangeAttached.hasListeners()
+            || this._onDidChangeInjectedText.hasListeners()
+            || this._eventEmitter.hasListeners());
+    }
     _assertNotDisposed() {
         if (this._isDisposed) {
             throw new Error('Model is disposed!');
         }
     }
+    equalsTextBuffer(other) {
+        this._assertNotDisposed();
+        return this._buffer.equals(other);
+    }
+    getTextBuffer() {
+        this._assertNotDisposed();
+        return this._buffer;
+    }
     _emitContentChangedEvent(rawChange, change) {
         if (this.__isDisposing) {
             // Do not confuse listeners by emitting any event after disposing
@@ -1668,8 +1709,7 @@
 }
 export class ModelDecorationGlyphMarginOptions {
     constructor(options) {
-        var _a;
-        this.position = (_a = options === null || options === void 0 ? void 0 : options.position) !== null && _a !== void 0 ? _a : model.GlyphMarginLane.Left;
+        this.position = options?.position ?? model.GlyphMarginLane.Left;
     }
 }
 export class ModelDecorationMinimapOptions extends DecorationOptions {
@@ -1721,16 +1761,15 @@
         return new ModelDecorationOptions(options);
     }
     constructor(options) {
-        var _a, _b, _c, _d, _e, _f;
         this.description = options.description;
         this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;
-        this.blockDoesNotCollapse = (_a = options.blockDoesNotCollapse) !== null && _a !== void 0 ? _a : null;
-        this.blockIsAfterEnd = (_b = options.blockIsAfterEnd) !== null && _b !== void 0 ? _b : null;
-        this.blockPadding = (_c = options.blockPadding) !== null && _c !== void 0 ? _c : null;
+        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;
+        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;
+        this.blockPadding = options.blockPadding ?? null;
         this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;
         this.zIndex = options.zIndex || 0;
         this.className = options.className ? cleanClassName(options.className) : null;
-        this.shouldFillLineOnLineBreak = (_d = options.shouldFillLineOnLineBreak) !== null && _d !== void 0 ? _d : null;
+        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;
         this.hoverMessage = options.hoverMessage || null;
         this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;
         this.isWholeLine = options.isWholeLine || false;
@@ -1749,8 +1788,8 @@
         this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;
         this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;
         this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;
-        this.hideInCommentTokens = (_e = options.hideInCommentTokens) !== null && _e !== void 0 ? _e : false;
-        this.hideInStringTokens = (_f = options.hideInStringTokens) !== null && _f !== void 0 ? _f : false;
+        this.hideInCommentTokens = options.hideInCommentTokens ?? false;
+        this.hideInStringTokens = options.hideInStringTokens ?? false;
     }
 }
 ModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });
@@ -1782,17 +1821,19 @@
         this._affectsOverviewRuler = false;
         this._affectsGlyphMargin = false;
     }
+    hasListeners() {
+        return this._actual.hasListeners();
+    }
     beginDeferredEmit() {
         this._deferredCnt++;
     }
     endDeferredEmit() {
-        var _a;
         this._deferredCnt--;
         if (this._deferredCnt === 0) {
             if (this._shouldFireDeferred) {
                 this.doFire();
             }
-            (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();
+            this._affectedInjectedTextLines?.clear();
             this._affectedInjectedTextLines = null;
         }
     }
@@ -1856,6 +1897,10 @@
         this._deferredCnt = 0;
         this._deferredEvent = null;
     }
+    hasListeners() {
+        return (this._fastEmitter.hasListeners()
+            || this._slowEmitter.hasListeners());
+    }
     beginDeferredEmit() {
         this._deferredCnt++;
     }
diff -urN -x '*.map' a/vs/editor/common/model/textModelTokens.js b/vs/editor/common/model/textModelTokens.js
--- a/vs/editor/common/model/textModelTokens.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/model/textModelTokens.js	2023-12-06 14:23:14.367854762 +0000
@@ -240,17 +240,39 @@
         }
         this._lineEndStates.replace(range.startLineNumber, length, newLineCount);
     }
+    acceptChanges(changes) {
+        for (const c of changes) {
+            const [eolCount] = countEOL(c.text);
+            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);
+        }
+    }
 }
 export class RangePriorityQueueImpl {
     constructor() {
         this._ranges = [];
     }
+    getRanges() {
+        return this._ranges;
+    }
     get min() {
         if (this._ranges.length === 0) {
             return null;
         }
         return this._ranges[0].start;
     }
+    removeMin() {
+        if (this._ranges.length === 0) {
+            return null;
+        }
+        const range = this._ranges[0];
+        if (range.start + 1 === range.endExclusive) {
+            this._ranges.shift();
+        }
+        else {
+            this._ranges[0] = new OffsetRange(range.start + 1, range.endExclusive);
+        }
+        return range.start;
+    }
     delete(value) {
         const idx = this._ranges.findIndex(r => r.contains(value));
         if (idx !== -1) {
@@ -404,8 +426,7 @@
         return !this._tokenizerWithStateStore.store.allStatesValid();
     }
     _tokenizeOneInvalidLine(builder) {
-        var _a;
-        const firstInvalidLine = (_a = this._tokenizerWithStateStore) === null || _a === void 0 ? void 0 : _a.getFirstInvalidLine();
+        const firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();
         if (!firstInvalidLine) {
             return this._tokenizerWithStateStore._textModel.getLineCount() + 1;
         }
diff -urN -x '*.map' a/vs/editor/common/model/tokenizationTextModelPart.js b/vs/editor/common/model/tokenizationTextModelPart.js
--- a/vs/editor/common/model/tokenizationTextModelPart.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/model/tokenizationTextModelPart.js	2023-12-06 14:23:14.367854762 +0000
@@ -46,6 +46,11 @@
             this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();
         }));
     }
+    _hasListeners() {
+        return (this._onDidChangeLanguage.hasListeners()
+            || this._onDidChangeLanguageConfiguration.hasListeners()
+            || this._onDidChangeTokens.hasListeners());
+    }
     handleDidChangeContent(e) {
         if (e.isFlush) {
             this._semanticTokens.flush();
@@ -269,9 +274,8 @@
         }));
     }
     resetTokenization(fireTokenChangeEvent = true) {
-        var _a;
         this._tokens.flush();
-        (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.flush();
+        this._debugBackgroundTokens?.flush();
         if (this._debugBackgroundStates) {
             this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());
         }
@@ -328,14 +332,13 @@
                     this._onDidChangeBackgroundTokenizationState.fire();
                 },
                 setEndState: (lineNumber, state) => {
-                    var _a;
                     if (!this._tokenizer) {
                         return;
                     }
                     const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();
                     // Don't accept states for definitely valid states, the renderer is ahead of the worker!
                     if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {
-                        (_a = this._tokenizer) === null || _a === void 0 ? void 0 : _a.store.setEndState(lineNumber, state);
+                        this._tokenizer?.store.setEndState(lineNumber, state);
                     }
                 },
             };
@@ -347,21 +350,19 @@
                     new DefaultBackgroundTokenizer(this._tokenizer, b);
                 this._defaultBackgroundTokenizer.handleChanges();
             }
-            if ((tokenizationSupport === null || tokenizationSupport === void 0 ? void 0 : tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) && tokenizationSupport.createBackgroundTokenizer) {
+            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {
                 this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);
                 this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());
                 this._debugBackgroundTokenizer.clear();
                 this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {
                     setTokens: (tokens) => {
-                        var _a;
-                        (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.setMultilineTokens(tokens, this._textModel);
+                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);
                     },
                     backgroundTokenizationFinished() {
                         // NO OP
                     },
                     setEndState: (lineNumber, state) => {
-                        var _a;
-                        (_a = this._debugBackgroundStates) === null || _a === void 0 ? void 0 : _a.setEndState(lineNumber, state);
+                        this._debugBackgroundStates?.setEndState(lineNumber, state);
                     },
                 });
             }
@@ -374,11 +375,9 @@
         this.refreshAllVisibleLineTokens();
     }
     handleDidChangeAttached() {
-        var _a;
-        (_a = this._defaultBackgroundTokenizer) === null || _a === void 0 ? void 0 : _a.handleChanges();
+        this._defaultBackgroundTokenizer?.handleChanges();
     }
     handleDidChangeContent(e) {
-        var _a, _b, _c;
         if (e.isFlush) {
             // Don't fire the event, as the view might not have got the text change event yet
             this.resetTokenization(false);
@@ -387,13 +386,13 @@
             for (const c of e.changes) {
                 const [eolCount, firstLineLength] = countEOL(c.text);
                 this._tokens.acceptEdit(c.range, eolCount, firstLineLength);
-                (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.acceptEdit(c.range, eolCount, firstLineLength);
+                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);
             }
-            (_b = this._debugBackgroundStates) === null || _b === void 0 ? void 0 : _b.acceptChanges(e.changes);
+            this._debugBackgroundStates?.acceptChanges(e.changes);
             if (this._tokenizer) {
                 this._tokenizer.store.acceptChanges(e.changes);
             }
-            (_c = this._defaultBackgroundTokenizer) === null || _c === void 0 ? void 0 : _c.handleChanges();
+            this._defaultBackgroundTokenizer?.handleChanges();
         }
     }
     setTokens(tokens) {
@@ -413,7 +412,6 @@
         }
     }
     refreshRange(startLineNumber, endLineNumber) {
-        var _a, _b;
         if (!this._tokenizer) {
             return;
         }
@@ -427,17 +425,16 @@
             // Because old states might get reused (thus stopping invalidation),
             // we have to explicitly request the tokens for the changed ranges again.
             for (const c of changedTokens.changes) {
-                (_a = this._backgroundTokenizer.value) === null || _a === void 0 ? void 0 : _a.requestTokens(c.fromLineNumber, c.toLineNumber + 1);
+                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);
             }
         }
-        (_b = this._defaultBackgroundTokenizer) === null || _b === void 0 ? void 0 : _b.checkFinished();
+        this._defaultBackgroundTokenizer?.checkFinished();
     }
     forceTokenization(lineNumber) {
-        var _a, _b;
         const builder = new ContiguousMultilineTokensBuilder();
-        (_a = this._tokenizer) === null || _a === void 0 ? void 0 : _a.updateTokensUntilLine(builder, lineNumber);
+        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);
         this.setTokens(builder.finalize());
-        (_b = this._defaultBackgroundTokenizer) === null || _b === void 0 ? void 0 : _b.checkFinished();
+        this._defaultBackgroundTokenizer?.checkFinished();
     }
     isCheapToTokenize(lineNumber) {
         if (!this._tokenizer) {
@@ -451,13 +448,12 @@
         }
     }
     getLineTokens(lineNumber) {
-        var _a;
         const lineText = this._textModel.getLineContent(lineNumber);
         const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);
         if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {
             if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {
                 const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);
-                if (!result.equals(backgroundResult) && ((_a = this._debugBackgroundTokenizer.value) === null || _a === void 0 ? void 0 : _a.reportMismatchingTokens)) {
+                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {
                     this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);
                 }
             }
diff -urN -x '*.map' a/vs/editor/common/services/editorSimpleWorker.js b/vs/editor/common/services/editorSimpleWorker.js
--- a/vs/editor/common/services/editorSimpleWorker.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/services/editorSimpleWorker.js	2023-12-06 14:23:14.371854769 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { stringDiff } from '../../../base/common/diff/diff.js';
 import { URI } from '../../../base/common/uri.js';
 import { Position } from '../core/position.js';
@@ -22,8 +13,10 @@
 import { createMonacoBaseAPI } from './editorBaseApi.js';
 import { StopWatch } from '../../../base/common/stopwatch.js';
 import { UnicodeTextModelHighlighter } from './unicodeTextModelHighlighter.js';
+import { DiffComputer } from '../diff/legacyLinesDiffComputer.js';
 import { linesDiffComputers } from '../diff/linesDiffComputers.js';
 import { createProxyObject, getAllMethodNames } from '../../../base/common/objects.js';
+import { BugIndicatingError } from '../../../base/common/errors.js';
 import { computeDefaultDocumentColors } from '../languages/defaultDocumentColorsComputer.js';
 /**
  * @internal
@@ -69,6 +62,21 @@
         }
         return null;
     }
+    getWordUntilPosition(position, wordDefinition) {
+        const wordAtPosition = this.getWordAtPosition(position, wordDefinition);
+        if (!wordAtPosition) {
+            return {
+                word: '',
+                startColumn: position.column,
+                endColumn: position.column
+            };
+        }
+        return {
+            word: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),
+            startColumn: wordAtPosition.startColumn,
+            endColumn: position.column
+        };
+    }
     words(wordDefinition) {
         const lines = this._lines;
         const wordenize = this._wordenize.bind(this);
@@ -246,25 +254,21 @@
         }
         delete this._models[strURL];
     }
-    computeUnicodeHighlights(url, options, range) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const model = this._getModel(url);
-            if (!model) {
-                return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
-            }
-            return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);
-        });
+    async computeUnicodeHighlights(url, options, range) {
+        const model = this._getModel(url);
+        if (!model) {
+            return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
+        }
+        return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);
     }
     // ---- BEGIN diff --------------------------------------------------------------------------
-    computeDiff(originalUrl, modifiedUrl, options, algorithm) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const original = this._getModel(originalUrl);
-            const modified = this._getModel(modifiedUrl);
-            if (!original || !modified) {
-                return null;
-            }
-            return EditorSimpleWorker.computeDiff(original, modified, options, algorithm);
-        });
+    async computeDiff(originalUrl, modifiedUrl, options, algorithm) {
+        const original = this._getModel(originalUrl);
+        const modified = this._getModel(modifiedUrl);
+        if (!original || !modified) {
+            return null;
+        }
+        return EditorSimpleWorker.computeDiff(original, modified, options, algorithm);
     }
     static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {
         const diffAlgorithm = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();
@@ -273,19 +277,16 @@
         const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);
         const identical = (result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));
         function getLineChanges(changes) {
-            return changes.map(m => {
-                var _a;
-                return ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a = m.innerChanges) === null || _a === void 0 ? void 0 : _a.map(m => [
-                        m.originalRange.startLineNumber,
-                        m.originalRange.startColumn,
-                        m.originalRange.endLineNumber,
-                        m.originalRange.endColumn,
-                        m.modifiedRange.startLineNumber,
-                        m.modifiedRange.startColumn,
-                        m.modifiedRange.endLineNumber,
-                        m.modifiedRange.endColumn,
-                    ])]);
-            });
+            return changes.map(m => ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, m.innerChanges?.map(m => [
+                    m.originalRange.startLineNumber,
+                    m.originalRange.startColumn,
+                    m.originalRange.endLineNumber,
+                    m.originalRange.endColumn,
+                    m.modifiedRange.startLineNumber,
+                    m.modifiedRange.startColumn,
+                    m.modifiedRange.endLineNumber,
+                    m.modifiedRange.endColumn,
+                ])]));
         }
         return {
             identical,
@@ -315,176 +316,262 @@
         }
         return true;
     }
-    computeMoreMinimalEdits(modelUrl, edits, pretty) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const model = this._getModel(modelUrl);
-            if (!model) {
-                return edits;
-            }
-            const result = [];
-            let lastEol = undefined;
-            edits = edits.slice(0).sort((a, b) => {
-                if (a.range && b.range) {
-                    return Range.compareRangesUsingStarts(a.range, b.range);
-                }
-                // eol only changes should go to the end
-                const aRng = a.range ? 0 : 1;
-                const bRng = b.range ? 0 : 1;
-                return aRng - bRng;
-            });
-            // merge adjacent edits
-            let writeIndex = 0;
-            for (let readIndex = 1; readIndex < edits.length; readIndex++) {
-                if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {
-                    edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));
-                    edits[writeIndex].text += edits[readIndex].text;
-                }
-                else {
-                    writeIndex++;
-                    edits[writeIndex] = edits[readIndex];
+    async computeDirtyDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace) {
+        const original = this._getModel(originalUrl);
+        const modified = this._getModel(modifiedUrl);
+        if (!original || !modified) {
+            return null;
+        }
+        const originalLines = original.getLinesContent();
+        const modifiedLines = modified.getLinesContent();
+        const diffComputer = new DiffComputer(originalLines, modifiedLines, {
+            shouldComputeCharChanges: false,
+            shouldPostProcessCharChanges: false,
+            shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,
+            shouldMakePrettyDiff: true,
+            maxComputationTime: 1000
+        });
+        return diffComputer.computeDiff().changes;
+    }
+    async computeMoreMinimalEdits(modelUrl, edits, pretty) {
+        const model = this._getModel(modelUrl);
+        if (!model) {
+            return edits;
+        }
+        const result = [];
+        let lastEol = undefined;
+        edits = edits.slice(0).sort((a, b) => {
+            if (a.range && b.range) {
+                return Range.compareRangesUsingStarts(a.range, b.range);
+            }
+            // eol only changes should go to the end
+            const aRng = a.range ? 0 : 1;
+            const bRng = b.range ? 0 : 1;
+            return aRng - bRng;
+        });
+        // merge adjacent edits
+        let writeIndex = 0;
+        for (let readIndex = 1; readIndex < edits.length; readIndex++) {
+            if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {
+                edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));
+                edits[writeIndex].text += edits[readIndex].text;
+            }
+            else {
+                writeIndex++;
+                edits[writeIndex] = edits[readIndex];
+            }
+        }
+        edits.length = writeIndex + 1;
+        for (let { range, text, eol } of edits) {
+            if (typeof eol === 'number') {
+                lastEol = eol;
+            }
+            if (Range.isEmpty(range) && !text) {
+                // empty change
+                continue;
+            }
+            const original = model.getValueInRange(range);
+            text = text.replace(/\r\n|\n|\r/g, model.eol);
+            if (original === text) {
+                // noop
+                continue;
+            }
+            // make sure diff won't take too long
+            if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {
+                result.push({ range, text });
+                continue;
+            }
+            // compute diff between original and edit.text
+            const changes = stringDiff(original, text, pretty);
+            const editOffset = model.offsetAt(Range.lift(range).getStartPosition());
+            for (const change of changes) {
+                const start = model.positionAt(editOffset + change.originalStart);
+                const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
+                const newEdit = {
+                    text: text.substr(change.modifiedStart, change.modifiedLength),
+                    range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
+                };
+                if (model.getValueInRange(newEdit.range) !== newEdit.text) {
+                    result.push(newEdit);
                 }
             }
-            edits.length = writeIndex + 1;
-            for (let { range, text, eol } of edits) {
-                if (typeof eol === 'number') {
-                    lastEol = eol;
-                }
-                if (Range.isEmpty(range) && !text) {
-                    // empty change
-                    continue;
-                }
-                const original = model.getValueInRange(range);
-                text = text.replace(/\r\n|\n|\r/g, model.eol);
-                if (original === text) {
-                    // noop
-                    continue;
-                }
-                // make sure diff won't take too long
-                if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {
-                    result.push({ range, text });
-                    continue;
-                }
-                // compute diff between original and edit.text
-                const changes = stringDiff(original, text, pretty);
-                const editOffset = model.offsetAt(Range.lift(range).getStartPosition());
-                for (const change of changes) {
-                    const start = model.positionAt(editOffset + change.originalStart);
-                    const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
-                    const newEdit = {
-                        text: text.substr(change.modifiedStart, change.modifiedLength),
-                        range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
-                    };
-                    if (model.getValueInRange(newEdit.range) !== newEdit.text) {
-                        result.push(newEdit);
+        }
+        if (typeof lastEol === 'number') {
+            result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
+        }
+        return result;
+    }
+    computeHumanReadableDiff(modelUrl, edits, options) {
+        const model = this._getModel(modelUrl);
+        if (!model) {
+            return edits;
+        }
+        const result = [];
+        let lastEol = undefined;
+        edits = edits.slice(0).sort((a, b) => {
+            if (a.range && b.range) {
+                return Range.compareRangesUsingStarts(a.range, b.range);
+            }
+            // eol only changes should go to the end
+            const aRng = a.range ? 0 : 1;
+            const bRng = b.range ? 0 : 1;
+            return aRng - bRng;
+        });
+        for (let { range, text, eol } of edits) {
+            if (typeof eol === 'number') {
+                lastEol = eol;
+            }
+            if (Range.isEmpty(range) && !text) {
+                // empty change
+                continue;
+            }
+            const original = model.getValueInRange(range);
+            text = text.replace(/\r\n|\n|\r/g, model.eol);
+            if (original === text) {
+                // noop
+                continue;
+            }
+            // make sure diff won't take too long
+            if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {
+                result.push({ range, text });
+                continue;
+            }
+            // compute diff between original and edit.text
+            const originalLines = original.split(/\r\n|\n|\r/);
+            const modifiedLines = text.split(/\r\n|\n|\r/);
+            const diff = linesDiffComputers.getDefault().computeDiff(originalLines, modifiedLines, options);
+            const start = Range.lift(range).getStartPosition();
+            function addPositions(pos1, pos2) {
+                return new Position(pos1.lineNumber + pos2.lineNumber - 1, pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column);
+            }
+            function getText(lines, range) {
+                const result = [];
+                for (let i = range.startLineNumber; i <= range.endLineNumber; i++) {
+                    const line = lines[i - 1];
+                    if (i === range.startLineNumber && i === range.endLineNumber) {
+                        result.push(line.substring(range.startColumn - 1, range.endColumn - 1));
+                    }
+                    else if (i === range.startLineNumber) {
+                        result.push(line.substring(range.startColumn - 1));
+                    }
+                    else if (i === range.endLineNumber) {
+                        result.push(line.substring(0, range.endColumn - 1));
+                    }
+                    else {
+                        result.push(line);
                     }
                 }
+                return result;
             }
-            if (typeof lastEol === 'number') {
-                result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
+            for (const c of diff.changes) {
+                if (c.innerChanges) {
+                    for (const x of c.innerChanges) {
+                        result.push({
+                            range: Range.fromPositions(addPositions(start, x.originalRange.getStartPosition()), addPositions(start, x.originalRange.getEndPosition())),
+                            text: getText(modifiedLines, x.modifiedRange).join(model.eol)
+                        });
+                    }
+                }
+                else {
+                    throw new BugIndicatingError('The experimental diff algorithm always produces inner changes');
+                }
             }
-            return result;
-        });
+        }
+        if (typeof lastEol === 'number') {
+            result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
+        }
+        return result;
     }
     // ---- END minimal edits ---------------------------------------------------------------
-    computeLinks(modelUrl) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const model = this._getModel(modelUrl);
-            if (!model) {
-                return null;
-            }
-            return computeLinks(model);
-        });
+    async computeLinks(modelUrl) {
+        const model = this._getModel(modelUrl);
+        if (!model) {
+            return null;
+        }
+        return computeLinks(model);
     }
     // --- BEGIN default document colors -----------------------------------------------------------
-    computeDefaultDocumentColors(modelUrl) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const model = this._getModel(modelUrl);
+    async computeDefaultDocumentColors(modelUrl) {
+        const model = this._getModel(modelUrl);
+        if (!model) {
+            return null;
+        }
+        return computeDefaultDocumentColors(model);
+    }
+    async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
+        const sw = new StopWatch();
+        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
+        const seen = new Set();
+        outer: for (const url of modelUrls) {
+            const model = this._getModel(url);
             if (!model) {
-                return null;
+                continue;
             }
-            return computeDefaultDocumentColors(model);
-        });
-    }
-    textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const sw = new StopWatch();
-            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
-            const seen = new Set();
-            outer: for (const url of modelUrls) {
-                const model = this._getModel(url);
-                if (!model) {
+            for (const word of model.words(wordDefRegExp)) {
+                if (word === leadingWord || !isNaN(Number(word))) {
                     continue;
                 }
-                for (const word of model.words(wordDefRegExp)) {
-                    if (word === leadingWord || !isNaN(Number(word))) {
-                        continue;
-                    }
-                    seen.add(word);
-                    if (seen.size > EditorSimpleWorker._suggestionsLimit) {
-                        break outer;
-                    }
+                seen.add(word);
+                if (seen.size > EditorSimpleWorker._suggestionsLimit) {
+                    break outer;
                 }
             }
-            return { words: Array.from(seen), duration: sw.elapsed() };
-        });
+        }
+        return { words: Array.from(seen), duration: sw.elapsed() };
     }
     // ---- END suggest --------------------------------------------------------------------------
     //#region -- word ranges --
-    computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const model = this._getModel(modelUrl);
-            if (!model) {
-                return Object.create(null);
-            }
-            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
-            const result = Object.create(null);
-            for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
-                const words = model.getLineWords(line, wordDefRegExp);
-                for (const word of words) {
-                    if (!isNaN(Number(word.word))) {
-                        continue;
-                    }
-                    let array = result[word.word];
-                    if (!array) {
-                        array = [];
-                        result[word.word] = array;
-                    }
-                    array.push({
-                        startLineNumber: line,
-                        startColumn: word.startColumn,
-                        endLineNumber: line,
-                        endColumn: word.endColumn
-                    });
+    async computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
+        const model = this._getModel(modelUrl);
+        if (!model) {
+            return Object.create(null);
+        }
+        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
+        const result = Object.create(null);
+        for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
+            const words = model.getLineWords(line, wordDefRegExp);
+            for (const word of words) {
+                if (!isNaN(Number(word.word))) {
+                    continue;
                 }
+                let array = result[word.word];
+                if (!array) {
+                    array = [];
+                    result[word.word] = array;
+                }
+                array.push({
+                    startLineNumber: line,
+                    startColumn: word.startColumn,
+                    endLineNumber: line,
+                    endColumn: word.endColumn
+                });
             }
-            return result;
-        });
+        }
+        return result;
     }
     //#endregion
-    navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const model = this._getModel(modelUrl);
-            if (!model) {
-                return null;
-            }
-            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
-            if (range.startColumn === range.endColumn) {
-                range = {
-                    startLineNumber: range.startLineNumber,
-                    startColumn: range.startColumn,
-                    endLineNumber: range.endLineNumber,
-                    endColumn: range.endColumn + 1
-                };
-            }
-            const selectionText = model.getValueInRange(range);
-            const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
-            if (!wordRange) {
-                return null;
-            }
-            const word = model.getValueInRange(wordRange);
-            const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
-            return result;
-        });
+    async navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
+        const model = this._getModel(modelUrl);
+        if (!model) {
+            return null;
+        }
+        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
+        if (range.startColumn === range.endColumn) {
+            range = {
+                startLineNumber: range.startLineNumber,
+                startColumn: range.startColumn,
+                endLineNumber: range.endLineNumber,
+                endColumn: range.endColumn + 1
+            };
+        }
+        const selectionText = model.getValueInRange(range);
+        const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
+        if (!wordRange) {
+            return null;
+        }
+        const word = model.getValueInRange(wordRange);
+        const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
+        return result;
     }
     // ---- BEGIN foreign module support --------------------------------------------------------------------------
     loadForeignModule(moduleId, createData, foreignHostMethods) {
diff -urN -x '*.map' a/vs/editor/common/services/getIconClasses.js b/vs/editor/common/services/getIconClasses.js
--- a/vs/editor/common/services/getIconClasses.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/services/getIconClasses.js	2023-12-06 14:23:14.371854769 +0000
@@ -59,6 +59,9 @@
     }
     return classes;
 }
+export function getIconClassesForLanguageId(languageId) {
+    return ['file-icon', `${cssEscape(languageId)}-lang-file-icon`];
+}
 function detectLanguageId(modelService, languageService, resource) {
     if (!resource) {
         return null; // we need a resource at least
diff -urN -x '*.map' a/vs/editor/common/services/languageFeatureDebounce.js b/vs/editor/common/services/languageFeatureDebounce.js
--- a/vs/editor/common/services/languageFeatureDebounce.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/services/languageFeatureDebounce.js	2023-12-06 14:23:14.371854769 +0000
@@ -100,10 +100,9 @@
         this._isDev = envService.isExtensionDevelopment || !envService.isBuilt;
     }
     for(feature, name, config) {
-        var _a, _b, _c;
-        const min = (_a = config === null || config === void 0 ? void 0 : config.min) !== null && _a !== void 0 ? _a : 50;
-        const max = (_b = config === null || config === void 0 ? void 0 : config.max) !== null && _b !== void 0 ? _b : Math.pow(min, 2);
-        const extra = (_c = config === null || config === void 0 ? void 0 : config.key) !== null && _c !== void 0 ? _c : undefined;
+        const min = config?.min ?? 50;
+        const max = config?.max ?? min ** 2;
+        const extra = config?.key ?? undefined;
         const key = `${IdentityHash.of(feature)},${min}${extra ? ',' + extra : ''}`;
         let info = this._data.get(key);
         if (!info) {
diff -urN -x '*.map' a/vs/editor/common/services/languageFeaturesService.js b/vs/editor/common/services/languageFeaturesService.js
--- a/vs/editor/common/services/languageFeaturesService.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/services/languageFeaturesService.js	2023-12-06 14:23:14.371854769 +0000
@@ -30,14 +30,19 @@
         this.inlineCompletionsProvider = new LanguageFeatureRegistry(this._score.bind(this));
         this.completionProvider = new LanguageFeatureRegistry(this._score.bind(this));
         this.linkedEditingRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));
+        this.inlineValuesProvider = new LanguageFeatureRegistry(this._score.bind(this));
+        this.evaluatableExpressionProvider = new LanguageFeatureRegistry(this._score.bind(this));
         this.documentRangeSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));
         this.documentSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));
         this.documentOnDropEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
         this.documentPasteEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
+        this.mappedEditsProvider = new LanguageFeatureRegistry(this._score.bind(this));
+    }
+    setNotebookTypeResolver(resolver) {
+        this._notebookTypeResolver = resolver;
     }
     _score(uri) {
-        var _a;
-        return (_a = this._notebookTypeResolver) === null || _a === void 0 ? void 0 : _a.call(this, uri);
+        return this._notebookTypeResolver?.(uri);
     }
 }
 registerSingleton(ILanguageFeaturesService, LanguageFeaturesService, 1 /* InstantiationType.Delayed */);
diff -urN -x '*.map' a/vs/editor/common/services/languageService.js b/vs/editor/common/services/languageService.js
--- a/vs/editor/common/services/languageService.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/services/languageService.js	2023-12-06 14:23:14.371854769 +0000
@@ -28,9 +28,36 @@
         LanguageService.instanceCount--;
         super.dispose();
     }
+    registerLanguage(def) {
+        return this._registry.registerLanguage(def);
+    }
     isRegisteredLanguageId(languageId) {
         return this._registry.isRegisteredLanguageId(languageId);
     }
+    getRegisteredLanguageIds() {
+        return this._registry.getRegisteredLanguageIds();
+    }
+    getSortedRegisteredLanguageNames() {
+        return this._registry.getSortedRegisteredLanguageNames();
+    }
+    getLanguageName(languageId) {
+        return this._registry.getLanguageName(languageId);
+    }
+    getMimeType(languageId) {
+        return this._registry.getMimeType(languageId);
+    }
+    getIcon(languageId) {
+        return this._registry.getIcon(languageId);
+    }
+    getExtensions(languageId) {
+        return this._registry.getExtensions(languageId);
+    }
+    getFilenames(languageId) {
+        return this._registry.getFilenames(languageId);
+    }
+    getConfigurationFiles(languageId) {
+        return this._registry.getConfigurationFiles(languageId);
+    }
     getLanguageIdByLanguageName(languageName) {
         return this._registry.getLanguageIdByLanguageName(languageName);
     }
@@ -46,6 +73,12 @@
             return this._createAndGetLanguageIdentifier(languageId);
         });
     }
+    createByMimeType(mimeType) {
+        return new LanguageSelection(this.onDidChange, () => {
+            const languageId = this.getLanguageIdByMimeType(mimeType);
+            return this._createAndGetLanguageIdentifier(languageId);
+        });
+    }
     createByFilepathOrFirstLine(resource, firstLine) {
         return new LanguageSelection(this.onDidChange, () => {
             const languageId = this.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);
@@ -109,13 +142,12 @@
         return this._emitter.event;
     }
     _evaluate() {
-        var _a;
         const languageId = this._selector();
         if (languageId === this.languageId) {
             // no change
             return;
         }
         this.languageId = languageId;
-        (_a = this._emitter) === null || _a === void 0 ? void 0 : _a.fire(this.languageId);
+        this._emitter?.fire(this.languageId);
     }
 }
diff -urN -x '*.map' a/vs/editor/common/services/languagesAssociations.js b/vs/editor/common/services/languagesAssociations.js
--- a/vs/editor/common/services/languagesAssociations.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/services/languagesAssociations.js	2023-12-06 14:23:14.371854769 +0000
@@ -20,6 +20,14 @@
 export function registerPlatformLanguageAssociation(association, warnOnOverwrite = false) {
     _registerLanguageAssociation(association, false, warnOnOverwrite);
 }
+/**
+ * Associate a language to the registry (configured).
+ * * **NOTE**: This association will win over associations registered using `registerPlatformLanguageAssociation`.
+ * * **NOTE**: Use `clearConfiguredLanguageAssociations` to remove all associations registered using this function.
+ */
+export function registerConfiguredLanguageAssociation(association) {
+    _registerLanguageAssociation(association, true, false);
+}
 function _registerLanguageAssociation(association, userConfigured, warnOnOverwrite) {
     // Register
     const associationItem = toLanguageAssociationItem(association, userConfigured);
@@ -74,6 +82,20 @@
     nonUserRegisteredAssociations = [];
 }
 /**
+ * Clear language associations from the registry (configured).
+ */
+export function clearConfiguredLanguageAssociations() {
+    registeredAssociations = registeredAssociations.filter(a => !a.userConfigured);
+    userRegisteredAssociations = [];
+}
+/**
+ * Given a file, return the best matching mime types for it
+ * based on the registered language associations.
+ */
+export function getMimeTypes(resource, firstLine) {
+    return getAssociations(resource, firstLine).map(item => item.mime);
+}
+/**
  * @see `getMimeTypes`
  */
 export function getLanguageIds(resource, firstLine) {
@@ -124,7 +146,6 @@
     return [{ id: 'unknown', mime: Mimes.unknown }];
 }
 function getAssociationByPath(path, filename, associations) {
-    var _a;
     let filenameMatch = undefined;
     let patternMatch = undefined;
     let extensionMatch = undefined;
@@ -141,7 +162,7 @@
         if (association.filepattern) {
             if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {
                 const target = association.filepatternOnPath ? path : filename; // match on full path if pattern contains path separator
-                if ((_a = association.filepatternLowercase) === null || _a === void 0 ? void 0 : _a.call(association, target)) {
+                if (association.filepatternLowercase?.(target)) {
                     patternMatch = association;
                 }
             }
diff -urN -x '*.map' a/vs/editor/common/services/languagesRegistry.js b/vs/editor/common/services/languagesRegistry.js
--- a/vs/editor/common/services/languagesRegistry.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/services/languagesRegistry.js	2023-12-06 14:23:14.371854769 +0000
@@ -4,7 +4,7 @@
  *--------------------------------------------------------------------------------------------*/
 import { Emitter } from '../../../base/common/event.js';
 import { Disposable } from '../../../base/common/lifecycle.js';
-import { regExpLeadsToEndlessLoop } from '../../../base/common/strings.js';
+import { compareIgnoreCase, regExpLeadsToEndlessLoop } from '../../../base/common/strings.js';
 import { clearPlatformLanguageAssociations, getLanguageIds, registerPlatformLanguageAssociation } from './languagesAssociations.js';
 import { ModesRegistry, PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';
 import { Extensions } from '../../../platform/configuration/common/configurationRegistry.js';
@@ -61,6 +61,10 @@
         LanguagesRegistry.instanceCount--;
         super.dispose();
     }
+    setDynamicLanguages(def) {
+        this._dynamicLanguages = def;
+        this._initializeFromRegistry();
+    }
     _initializeFromRegistry() {
         this._languages = {};
         this._mimeTypesMap = {};
@@ -70,6 +74,9 @@
         const desc = [].concat(ModesRegistry.getLanguages()).concat(this._dynamicLanguages);
         this._registerLanguages(desc);
     }
+    registerLanguage(desc) {
+        return ModesRegistry.registerLanguage(desc);
+    }
     _registerLanguages(desc) {
         for (const d of desc) {
             this._registerLanguage(d);
@@ -210,6 +217,57 @@
     getRegisteredLanguageIds() {
         return Object.keys(this._languages);
     }
+    getSortedRegisteredLanguageNames() {
+        const result = [];
+        for (const languageName in this._nameMap) {
+            if (hasOwnProperty.call(this._nameMap, languageName)) {
+                result.push({
+                    languageName: languageName,
+                    languageId: this._nameMap[languageName]
+                });
+            }
+        }
+        result.sort((a, b) => compareIgnoreCase(a.languageName, b.languageName));
+        return result;
+    }
+    getLanguageName(languageId) {
+        if (!hasOwnProperty.call(this._languages, languageId)) {
+            return null;
+        }
+        return this._languages[languageId].name;
+    }
+    getMimeType(languageId) {
+        if (!hasOwnProperty.call(this._languages, languageId)) {
+            return null;
+        }
+        const language = this._languages[languageId];
+        return (language.mimetypes[0] || null);
+    }
+    getExtensions(languageId) {
+        if (!hasOwnProperty.call(this._languages, languageId)) {
+            return [];
+        }
+        return this._languages[languageId].extensions;
+    }
+    getFilenames(languageId) {
+        if (!hasOwnProperty.call(this._languages, languageId)) {
+            return [];
+        }
+        return this._languages[languageId].filenames;
+    }
+    getIcon(languageId) {
+        if (!hasOwnProperty.call(this._languages, languageId)) {
+            return null;
+        }
+        const language = this._languages[languageId];
+        return (language.icons[0] || null);
+    }
+    getConfigurationFiles(languageId) {
+        if (!hasOwnProperty.call(this._languages, languageId)) {
+            return [];
+        }
+        return this._languages[languageId].configurationFiles || [];
+    }
     getLanguageIdByLanguageName(languageName) {
         const languageNameLower = languageName.toLowerCase();
         if (!hasOwnProperty.call(this._lowercaseNameMap, languageNameLower)) {
diff -urN -x '*.map' a/vs/editor/common/services/markerDecorationsService.js b/vs/editor/common/services/markerDecorationsService.js
--- a/vs/editor/common/services/markerDecorationsService.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/services/markerDecorationsService.js	2023-12-06 14:23:14.371854769 +0000
@@ -28,6 +28,7 @@
         super();
         this._markerService = _markerService;
         this._onDidChangeMarker = this._register(new Emitter());
+        this.onDidChangeMarker = this._onDidChangeMarker.event;
         this._markerDecorations = new ResourceMap();
         modelService.getModels().forEach(model => this._onModelAdded(model));
         this._register(modelService.onModelAdded(this._onModelAdded, this));
@@ -43,6 +44,10 @@
         const markerDecorations = this._markerDecorations.get(uri);
         return markerDecorations ? (markerDecorations.getMarker(decoration) || null) : null;
     }
+    getLiveMarkers(uri) {
+        const markerDecorations = this._markerDecorations.get(uri);
+        return markerDecorations ? markerDecorations.getMarkers() : [];
+    }
     _handleMarkerChange(changedResources) {
         changedResources.forEach((resource) => {
             const markerDecorations = this._markerDecorations.get(resource);
@@ -57,7 +62,6 @@
         this._updateDecorations(markerDecorations);
     }
     _onModelRemoved(model) {
-        var _a;
         const markerDecorations = this._markerDecorations.get(model.uri);
         if (markerDecorations) {
             markerDecorations.dispose();
@@ -67,7 +71,7 @@
         if (model.uri.scheme === Schemas.inMemory
             || model.uri.scheme === Schemas.internal
             || model.uri.scheme === Schemas.vscode) {
-            (_a = this._markerService) === null || _a === void 0 ? void 0 : _a.read({ resource: model.uri }).map(marker => marker.owner).forEach(owner => this._markerService.remove(owner, [model.uri]));
+            this._markerService?.read({ resource: model.uri }).map(marker => marker.owner).forEach(owner => this._markerService.remove(owner, [model.uri]));
         }
     }
     _updateDecorations(markerDecorations) {
@@ -119,6 +123,16 @@
     getMarker(decoration) {
         return this._map.getKey(decoration.id);
     }
+    getMarkers() {
+        const res = [];
+        this._map.forEach((id, marker) => {
+            const range = this.model.getDecorationRange(id);
+            if (range) {
+                res.push([range, marker]);
+            }
+        });
+        return res;
+    }
     _createDecorationRange(model, rawMarker) {
         let ret = Range.lift(rawMarker);
         if (rawMarker.severity === MarkerSeverity.Hint && !this._hasMarkerTag(rawMarker, 1 /* MarkerTag.Unnecessary */) && !this._hasMarkerTag(rawMarker, 2 /* MarkerTag.Deprecated */)) {
diff -urN -x '*.map' a/vs/editor/common/services/modelService.js b/vs/editor/common/services/modelService.js
--- a/vs/editor/common/services/modelService.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/services/modelService.js	2023-12-06 14:23:14.371854769 +0000
@@ -15,7 +15,9 @@
 import { Emitter } from '../../../base/common/event.js';
 import { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';
 import * as platform from '../../../base/common/platform.js';
-import { TextModel } from '../model/textModel.js';
+import { EditOperation } from '../core/editOperation.js';
+import { Range } from '../core/range.js';
+import { TextModel, createTextBuffer } from '../model/textModel.js';
 import { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';
 import { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';
 import { ILanguageService } from '../languages/language.js';
@@ -77,7 +79,6 @@
         this._updateModelOptions(undefined);
     }
     static _readModelOptions(config, isForSimpleWidget) {
-        var _a;
         let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;
         if (config.editor && typeof config.editor.tabSize !== 'undefined') {
             const parsedTabSize = parseInt(config.editor.tabSize, 10);
@@ -120,7 +121,7 @@
             largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));
         }
         let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;
-        if (((_a = config.editor) === null || _a === void 0 ? void 0 : _a.bracketPairColorization) && typeof config.editor.bracketPairColorization === 'object') {
+        if (config.editor?.bracketPairColorization && typeof config.editor.bracketPairColorization === 'object') {
             bracketPairColorizationOptions = {
                 enabled: !!config.editor.bracketPairColorization.enabled,
                 independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType
@@ -291,6 +292,65 @@
         this._models[modelId] = modelData;
         return modelData;
     }
+    updateModel(model, value) {
+        const options = this.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
+        const { textBuffer, disposable } = createTextBuffer(value, options.defaultEOL);
+        // Return early if the text is already set in that form
+        if (model.equalsTextBuffer(textBuffer)) {
+            disposable.dispose();
+            return;
+        }
+        // Otherwise find a diff between the values and update model
+        model.pushStackElement();
+        model.pushEOL(textBuffer.getEOL() === '\r\n' ? 1 /* EndOfLineSequence.CRLF */ : 0 /* EndOfLineSequence.LF */);
+        model.pushEditOperations([], ModelService_1._computeEdits(model, textBuffer), () => []);
+        model.pushStackElement();
+        disposable.dispose();
+    }
+    static _commonPrefix(a, aLen, aDelta, b, bLen, bDelta) {
+        const maxResult = Math.min(aLen, bLen);
+        let result = 0;
+        for (let i = 0; i < maxResult && a.getLineContent(aDelta + i) === b.getLineContent(bDelta + i); i++) {
+            result++;
+        }
+        return result;
+    }
+    static _commonSuffix(a, aLen, aDelta, b, bLen, bDelta) {
+        const maxResult = Math.min(aLen, bLen);
+        let result = 0;
+        for (let i = 0; i < maxResult && a.getLineContent(aDelta + aLen - i) === b.getLineContent(bDelta + bLen - i); i++) {
+            result++;
+        }
+        return result;
+    }
+    /**
+     * Compute edits to bring `model` to the state of `textSource`.
+     */
+    static _computeEdits(model, textBuffer) {
+        const modelLineCount = model.getLineCount();
+        const textBufferLineCount = textBuffer.getLineCount();
+        const commonPrefix = this._commonPrefix(model, modelLineCount, 1, textBuffer, textBufferLineCount, 1);
+        if (modelLineCount === textBufferLineCount && commonPrefix === modelLineCount) {
+            // equality case
+            return [];
+        }
+        const commonSuffix = this._commonSuffix(model, modelLineCount - commonPrefix, commonPrefix, textBuffer, textBufferLineCount - commonPrefix, commonPrefix);
+        let oldRange;
+        let newRange;
+        if (commonSuffix > 0) {
+            oldRange = new Range(commonPrefix + 1, 1, modelLineCount - commonSuffix + 1, 1);
+            newRange = new Range(commonPrefix + 1, 1, textBufferLineCount - commonSuffix + 1, 1);
+        }
+        else if (commonPrefix > 0) {
+            oldRange = new Range(commonPrefix, model.getLineMaxColumn(commonPrefix), modelLineCount, model.getLineMaxColumn(modelLineCount));
+            newRange = new Range(commonPrefix, 1 + textBuffer.getLineLength(commonPrefix), textBufferLineCount, 1 + textBuffer.getLineLength(textBufferLineCount));
+        }
+        else {
+            oldRange = new Range(1, 1, modelLineCount, model.getLineMaxColumn(modelLineCount));
+            newRange = new Range(1, 1, textBufferLineCount, 1 + textBuffer.getLineLength(textBufferLineCount));
+        }
+        return [EditOperation.replaceMove(oldRange, textBuffer.getValueInRange(newRange, 0 /* EndOfLinePreference.TextDefined */))];
+    }
     createModel(value, languageSelection, resource, isForSimpleWidget = false) {
         let modelData;
         if (languageSelection) {
@@ -302,6 +362,14 @@
         this._onModelAdded.fire(modelData.model);
         return modelData.model;
     }
+    destroyModel(resource) {
+        // We need to support that not all models get disposed through this service (i.e. model.dispose() should work!)
+        const modelData = this._models[MODEL_ID(resource)];
+        if (!modelData) {
+            return;
+        }
+        modelData.model.dispose();
+    }
     getModels() {
         const ret = [];
         const keys = Object.keys(this._models);
diff -urN -x '*.map' a/vs/editor/common/services/resolverService.js b/vs/editor/common/services/resolverService.js
--- a/vs/editor/common/services/resolverService.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/services/resolverService.js	2023-12-06 14:23:14.371854769 +0000
@@ -1,2 +1,10 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';
 export const ITextModelService = createDecorator('textModelService');
+export function isResolvedTextEditorModel(model) {
+    const candidate = model;
+    return !!candidate.textEditorModel;
+}
diff -urN -x '*.map' a/vs/editor/common/services/semanticTokensDto.js b/vs/editor/common/services/semanticTokensDto.js
--- a/vs/editor/common/services/semanticTokensDto.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/services/semanticTokensDto.js	2023-12-06 14:23:14.371854769 +0000
@@ -25,6 +25,22 @@
     }
     return VSBuffer.wrap(uint8Arr);
 }
+function fromLittleEndianBuffer(buff) {
+    const uint8Arr = buff.buffer;
+    if (!platform.isLittleEndian()) {
+        // the byte order must be changed
+        reverseEndianness(uint8Arr);
+    }
+    if (uint8Arr.byteOffset % 4 === 0) {
+        return new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4);
+    }
+    else {
+        // unaligned memory access doesn't work on all platforms
+        const data = new Uint8Array(uint8Arr.byteLength);
+        data.set(uint8Arr);
+        return new Uint32Array(data.buffer, data.byteOffset, data.length / 4);
+    }
+}
 export function encodeSemanticTokensDto(semanticTokens) {
     const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));
     let offset = 0;
@@ -77,3 +93,37 @@
     }
     return result;
 }
+export function decodeSemanticTokensDto(_buff) {
+    const src = fromLittleEndianBuffer(_buff);
+    let offset = 0;
+    const id = src[offset++];
+    const type = src[offset++];
+    if (type === 1 /* EncodedSemanticTokensType.Full */) {
+        const length = src[offset++];
+        const data = src.subarray(offset, offset + length);
+        offset += length;
+        return {
+            id: id,
+            type: 'full',
+            data: data
+        };
+    }
+    const deltaCount = src[offset++];
+    const deltas = [];
+    for (let i = 0; i < deltaCount; i++) {
+        const start = src[offset++];
+        const deleteCount = src[offset++];
+        const length = src[offset++];
+        let data;
+        if (length > 0) {
+            data = src.subarray(offset, offset + length);
+            offset += length;
+        }
+        deltas[i] = { start, deleteCount, data };
+    }
+    return {
+        id: id,
+        type: 'delta',
+        deltas: deltas
+    };
+}
diff -urN -x '*.map' a/vs/editor/common/services/textResourceConfiguration.js b/vs/editor/common/services/textResourceConfiguration.js
--- a/vs/editor/common/services/textResourceConfiguration.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/services/textResourceConfiguration.js	2023-12-06 14:23:14.371854769 +0000
@@ -1,3 +1,7 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';
 export const ITextResourceConfigurationService = createDecorator('textResourceConfigurationService');
 export const ITextResourcePropertiesService = createDecorator('textResourcePropertiesService');
diff -urN -x '*.map' a/vs/editor/common/services/treeViewsDnd.js b/vs/editor/common/services/treeViewsDnd.js
--- a/vs/editor/common/services/treeViewsDnd.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/services/treeViewsDnd.js	2023-12-06 14:23:14.371854769 +0000
@@ -14,6 +14,9 @@
         }
         return undefined;
     }
+    addDragOperationTransfer(uuid, transferPromise) {
+        this._dragOperations.set(uuid, transferPromise);
+    }
 }
 export class DraggedTreeItemsIdentifier {
     constructor(identifier) {
diff -urN -x '*.map' a/vs/editor/common/standaloneStrings.js b/vs/editor/common/standaloneStrings.js
--- a/vs/editor/common/standaloneStrings.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/standaloneStrings.js	2023-12-06 14:23:14.363854755 +0000
@@ -3,38 +3,60 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import * as nls from '../../nls.js';
+export var AccessibilityHelpNLS;
+(function (AccessibilityHelpNLS) {
+    AccessibilityHelpNLS.accessibilityHelpTitle = nls.localizeWithPath('vs/editor/common/standaloneStrings', 'accessibilityHelpTitle', "Accessibility Help");
+    AccessibilityHelpNLS.openingDocs = nls.localizeWithPath('vs/editor/common/standaloneStrings', "openingDocs", "Opening the Accessibility documentation page.");
+    AccessibilityHelpNLS.readonlyDiffEditor = nls.localizeWithPath('vs/editor/common/standaloneStrings', "readonlyDiffEditor", "You are in a read-only pane of a diff editor.");
+    AccessibilityHelpNLS.editableDiffEditor = nls.localizeWithPath('vs/editor/common/standaloneStrings', "editableDiffEditor", "You are in a pane of a diff editor.");
+    AccessibilityHelpNLS.readonlyEditor = nls.localizeWithPath('vs/editor/common/standaloneStrings', "readonlyEditor", "You are in a read-only code editor.");
+    AccessibilityHelpNLS.editableEditor = nls.localizeWithPath('vs/editor/common/standaloneStrings', "editableEditor", "You are in a code editor.");
+    AccessibilityHelpNLS.changeConfigToOnMac = nls.localizeWithPath('vs/editor/common/standaloneStrings', "changeConfigToOnMac", "Configure the application to be optimized for usage with a Screen Reader (Command+E).");
+    AccessibilityHelpNLS.changeConfigToOnWinLinux = nls.localizeWithPath('vs/editor/common/standaloneStrings', "changeConfigToOnWinLinux", "Configure the application to be optimized for usage with a Screen Reader (Control+E).");
+    AccessibilityHelpNLS.auto_on = nls.localizeWithPath('vs/editor/common/standaloneStrings', "auto_on", "The application is configured to be optimized for usage with a Screen Reader.");
+    AccessibilityHelpNLS.auto_off = nls.localizeWithPath('vs/editor/common/standaloneStrings', "auto_off", "The application is configured to never be optimized for usage with a Screen Reader.");
+    AccessibilityHelpNLS.screenReaderModeEnabled = nls.localizeWithPath('vs/editor/common/standaloneStrings', "screenReaderModeEnabled", "Screen Reader Optimized Mode enabled.");
+    AccessibilityHelpNLS.screenReaderModeDisabled = nls.localizeWithPath('vs/editor/common/standaloneStrings', "screenReaderModeDisabled", "Screen Reader Optimized Mode disabled.");
+    AccessibilityHelpNLS.tabFocusModeOnMsg = nls.localizeWithPath('vs/editor/common/standaloneStrings', "tabFocusModeOnMsg", "Pressing Tab in the current editor will move focus to the next focusable element. Toggle this behavior {0}.");
+    AccessibilityHelpNLS.tabFocusModeOnMsgNoKb = nls.localizeWithPath('vs/editor/common/standaloneStrings', "tabFocusModeOnMsgNoKb", "Pressing Tab in the current editor will move focus to the next focusable element. The command {0} is currently not triggerable by a keybinding.");
+    AccessibilityHelpNLS.stickScrollKb = nls.localizeWithPath('vs/editor/common/standaloneStrings', "stickScrollKb", "Focus Sticky Scroll ({0}) to focus the currently nested scopes.");
+    AccessibilityHelpNLS.stickScrollNoKb = nls.localizeWithPath('vs/editor/common/standaloneStrings', "stickScrollNoKb", "Focus Sticky Scroll to focus the currently nested scopes. It is currently not triggerable by a keybinding.");
+    AccessibilityHelpNLS.tabFocusModeOffMsg = nls.localizeWithPath('vs/editor/common/standaloneStrings', "tabFocusModeOffMsg", "Pressing Tab in the current editor will insert the tab character. Toggle this behavior {0}.");
+    AccessibilityHelpNLS.tabFocusModeOffMsgNoKb = nls.localizeWithPath('vs/editor/common/standaloneStrings', "tabFocusModeOffMsgNoKb", "Pressing Tab in the current editor will insert the tab character. The command {0} is currently not triggerable by a keybinding.");
+    AccessibilityHelpNLS.showAccessibilityHelpAction = nls.localizeWithPath('vs/editor/common/standaloneStrings', "showAccessibilityHelpAction", "Show Accessibility Help");
+})(AccessibilityHelpNLS || (AccessibilityHelpNLS = {}));
 export var InspectTokensNLS;
 (function (InspectTokensNLS) {
-    InspectTokensNLS.inspectTokensAction = nls.localize('inspectTokens', "Developer: Inspect Tokens");
+    InspectTokensNLS.inspectTokensAction = nls.localizeWithPath('vs/editor/common/standaloneStrings', 'inspectTokens', "Developer: Inspect Tokens");
 })(InspectTokensNLS || (InspectTokensNLS = {}));
 export var GoToLineNLS;
 (function (GoToLineNLS) {
-    GoToLineNLS.gotoLineActionLabel = nls.localize('gotoLineActionLabel', "Go to Line/Column...");
+    GoToLineNLS.gotoLineActionLabel = nls.localizeWithPath('vs/editor/common/standaloneStrings', 'gotoLineActionLabel', "Go to Line/Column...");
 })(GoToLineNLS || (GoToLineNLS = {}));
 export var QuickHelpNLS;
 (function (QuickHelpNLS) {
-    QuickHelpNLS.helpQuickAccessActionLabel = nls.localize('helpQuickAccess', "Show all Quick Access Providers");
+    QuickHelpNLS.helpQuickAccessActionLabel = nls.localizeWithPath('vs/editor/common/standaloneStrings', 'helpQuickAccess', "Show all Quick Access Providers");
 })(QuickHelpNLS || (QuickHelpNLS = {}));
 export var QuickCommandNLS;
 (function (QuickCommandNLS) {
-    QuickCommandNLS.quickCommandActionLabel = nls.localize('quickCommandActionLabel', "Command Palette");
-    QuickCommandNLS.quickCommandHelp = nls.localize('quickCommandActionHelp', "Show And Run Commands");
+    QuickCommandNLS.quickCommandActionLabel = nls.localizeWithPath('vs/editor/common/standaloneStrings', 'quickCommandActionLabel', "Command Palette");
+    QuickCommandNLS.quickCommandHelp = nls.localizeWithPath('vs/editor/common/standaloneStrings', 'quickCommandActionHelp', "Show And Run Commands");
 })(QuickCommandNLS || (QuickCommandNLS = {}));
 export var QuickOutlineNLS;
 (function (QuickOutlineNLS) {
-    QuickOutlineNLS.quickOutlineActionLabel = nls.localize('quickOutlineActionLabel', "Go to Symbol...");
-    QuickOutlineNLS.quickOutlineByCategoryActionLabel = nls.localize('quickOutlineByCategoryActionLabel', "Go to Symbol by Category...");
+    QuickOutlineNLS.quickOutlineActionLabel = nls.localizeWithPath('vs/editor/common/standaloneStrings', 'quickOutlineActionLabel', "Go to Symbol...");
+    QuickOutlineNLS.quickOutlineByCategoryActionLabel = nls.localizeWithPath('vs/editor/common/standaloneStrings', 'quickOutlineByCategoryActionLabel', "Go to Symbol by Category...");
 })(QuickOutlineNLS || (QuickOutlineNLS = {}));
 export var StandaloneCodeEditorNLS;
 (function (StandaloneCodeEditorNLS) {
-    StandaloneCodeEditorNLS.editorViewAccessibleLabel = nls.localize('editorViewAccessibleLabel', "Editor content");
-    StandaloneCodeEditorNLS.accessibilityHelpMessage = nls.localize('accessibilityHelpMessage', "Press Alt+F1 for Accessibility Options.");
+    StandaloneCodeEditorNLS.editorViewAccessibleLabel = nls.localizeWithPath('vs/editor/common/standaloneStrings', 'editorViewAccessibleLabel', "Editor content");
+    StandaloneCodeEditorNLS.accessibilityHelpMessage = nls.localizeWithPath('vs/editor/common/standaloneStrings', 'accessibilityHelpMessage', "Press Alt+F1 for Accessibility Options.");
 })(StandaloneCodeEditorNLS || (StandaloneCodeEditorNLS = {}));
 export var ToggleHighContrastNLS;
 (function (ToggleHighContrastNLS) {
-    ToggleHighContrastNLS.toggleHighContrast = nls.localize('toggleHighContrast', "Toggle High Contrast Theme");
+    ToggleHighContrastNLS.toggleHighContrast = nls.localizeWithPath('vs/editor/common/standaloneStrings', 'toggleHighContrast', "Toggle High Contrast Theme");
 })(ToggleHighContrastNLS || (ToggleHighContrastNLS = {}));
 export var StandaloneServicesNLS;
 (function (StandaloneServicesNLS) {
-    StandaloneServicesNLS.bulkEditServiceSummary = nls.localize('bulkEditServiceSummary', "Made {0} edits in {1} files");
+    StandaloneServicesNLS.bulkEditServiceSummary = nls.localizeWithPath('vs/editor/common/standaloneStrings', 'bulkEditServiceSummary', "Made {0} edits in {1} files");
 })(StandaloneServicesNLS || (StandaloneServicesNLS = {}));
diff -urN -x '*.map' a/vs/editor/common/textModelBracketPairs.js b/vs/editor/common/textModelBracketPairs.js
--- a/vs/editor/common/textModelBracketPairs.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/textModelBracketPairs.js	2023-12-06 14:23:14.363854755 +0000
@@ -26,6 +26,9 @@
     get openingBracketInfo() {
         return this.bracketPairNode.openingBracket.bracketInfo;
     }
+    get closingBracketInfo() {
+        return this.bracketPairNode.closingBracket?.bracketInfo;
+    }
 }
 export class BracketPairWithMinIndentationInfo extends BracketPairInfo {
     constructor(range, openingBracketRange, closingBracketRange, 
diff -urN -x '*.map' a/vs/editor/common/textModelEvents.js b/vs/editor/common/textModelEvents.js
--- a/vs/editor/common/textModelEvents.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/textModelEvents.js	2023-12-06 14:23:14.363854755 +0000
@@ -58,6 +58,9 @@
         this.options = options;
         this.order = order;
     }
+    withText(text) {
+        return new LineInjectedText(this.ownerId, this.lineNumber, this.column, { ...this.options, content: text }, this.order);
+    }
 }
 /**
  * An event describing that a line has changed in a model.
diff -urN -x '*.map' a/vs/editor/common/tokenizationRegistry.js b/vs/editor/common/tokenizationRegistry.js
--- a/vs/editor/common/tokenizationRegistry.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/tokenizationRegistry.js	2023-12-06 14:23:14.363854755 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { Emitter } from '../../base/common/event.js';
 import { Disposable, toDisposable } from '../../base/common/lifecycle.js';
 export class TokenizationRegistry {
@@ -42,8 +33,7 @@
         return this._tokenizationSupports.get(languageId) || null;
     }
     registerFactory(languageId, factory) {
-        var _a;
-        (_a = this._factories.get(languageId)) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._factories.get(languageId)?.dispose();
         const myData = new TokenizationSupportFactoryData(this, languageId, factory);
         this._factories.set(languageId, myData);
         return toDisposable(() => {
@@ -55,21 +45,19 @@
             v.dispose();
         });
     }
-    getOrCreate(languageId) {
-        return __awaiter(this, void 0, void 0, function* () {
-            // check first if the support is already set
-            const tokenizationSupport = this.get(languageId);
-            if (tokenizationSupport) {
-                return tokenizationSupport;
-            }
-            const factory = this._factories.get(languageId);
-            if (!factory || factory.isResolved) {
-                // no factory or factory.resolve already finished
-                return null;
-            }
-            yield factory.resolve();
-            return this.get(languageId);
-        });
+    async getOrCreate(languageId) {
+        // check first if the support is already set
+        const tokenizationSupport = this.get(languageId);
+        if (tokenizationSupport) {
+            return tokenizationSupport;
+        }
+        const factory = this._factories.get(languageId);
+        if (!factory || factory.isResolved) {
+            // no factory or factory.resolve already finished
+            return null;
+        }
+        await factory.resolve();
+        return this.get(languageId);
     }
     isResolved(languageId) {
         const tokenizationSupport = this.get(languageId);
@@ -116,21 +104,17 @@
         this._isDisposed = true;
         super.dispose();
     }
-    resolve() {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!this._resolvePromise) {
-                this._resolvePromise = this._create();
-            }
-            return this._resolvePromise;
-        });
+    async resolve() {
+        if (!this._resolvePromise) {
+            this._resolvePromise = this._create();
+        }
+        return this._resolvePromise;
     }
-    _create() {
-        return __awaiter(this, void 0, void 0, function* () {
-            const value = yield this._factory.tokenizationSupport;
-            this._isResolved = true;
-            if (value && !this._isDisposed) {
-                this._register(this._registry.register(this._languageId, value));
-            }
-        });
+    async _create() {
+        const value = await this._factory.tokenizationSupport;
+        this._isResolved = true;
+        if (value && !this._isDisposed) {
+            this._register(this._registry.register(this._languageId, value));
+        }
     }
 }
diff -urN -x '*.map' a/vs/editor/common/tokens/contiguousMultilineTokens.js b/vs/editor/common/tokens/contiguousMultilineTokens.js
--- a/vs/editor/common/tokens/contiguousMultilineTokens.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/tokens/contiguousMultilineTokens.js	2023-12-06 14:23:14.371854769 +0000
@@ -1,7 +1,33 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import * as arrays from '../../../base/common/arrays.js';
+import { readUInt32BE, writeUInt32BE } from '../../../base/common/buffer.js';
+import { Position } from '../core/position.js';
+import { countEOL } from '../core/eolCounter.js';
+import { ContiguousTokensEditing } from './contiguousTokensEditing.js';
+import { LineRange } from '../core/lineRange.js';
 /**
  * Represents contiguous tokens over a contiguous range of lines.
  */
 export class ContiguousMultilineTokens {
+    static deserialize(buff, offset, result) {
+        const view32 = new Uint32Array(buff.buffer);
+        const startLineNumber = readUInt32BE(buff, offset);
+        offset += 4;
+        const count = readUInt32BE(buff, offset);
+        offset += 4;
+        const tokens = [];
+        for (let i = 0; i < count; i++) {
+            const byteCount = readUInt32BE(buff, offset);
+            offset += 4;
+            tokens.push(view32.subarray(offset / 4, offset / 4 + byteCount / 4));
+            offset += byteCount;
+        }
+        result.push(new ContiguousMultilineTokens(startLineNumber, tokens));
+        return offset;
+    }
     /**
      * (Inclusive) start line number for these tokens.
      */
@@ -18,6 +44,9 @@
         this._startLineNumber = startLineNumber;
         this._tokens = tokens;
     }
+    getLineRange() {
+        return new LineRange(this._startLineNumber, this._startLineNumber + this._tokens.length);
+    }
     /**
      * @see {@link _tokens}
      */
@@ -27,4 +56,131 @@
     appendLineTokens(lineTokens) {
         this._tokens.push(lineTokens);
     }
+    serializeSize() {
+        let result = 0;
+        result += 4; // 4 bytes for the start line number
+        result += 4; // 4 bytes for the line count
+        for (let i = 0; i < this._tokens.length; i++) {
+            const lineTokens = this._tokens[i];
+            if (!(lineTokens instanceof Uint32Array)) {
+                throw new Error(`Not supported!`);
+            }
+            result += 4; // 4 bytes for the byte count
+            result += lineTokens.byteLength;
+        }
+        return result;
+    }
+    serialize(destination, offset) {
+        writeUInt32BE(destination, this._startLineNumber, offset);
+        offset += 4;
+        writeUInt32BE(destination, this._tokens.length, offset);
+        offset += 4;
+        for (let i = 0; i < this._tokens.length; i++) {
+            const lineTokens = this._tokens[i];
+            if (!(lineTokens instanceof Uint32Array)) {
+                throw new Error(`Not supported!`);
+            }
+            writeUInt32BE(destination, lineTokens.byteLength, offset);
+            offset += 4;
+            destination.set(new Uint8Array(lineTokens.buffer), offset);
+            offset += lineTokens.byteLength;
+        }
+        return offset;
+    }
+    applyEdit(range, text) {
+        const [eolCount, firstLineLength] = countEOL(text);
+        this._acceptDeleteRange(range);
+        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);
+    }
+    _acceptDeleteRange(range) {
+        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {
+            // Nothing to delete
+            return;
+        }
+        const firstLineIndex = range.startLineNumber - this._startLineNumber;
+        const lastLineIndex = range.endLineNumber - this._startLineNumber;
+        if (lastLineIndex < 0) {
+            // this deletion occurs entirely before this block, so we only need to adjust line numbers
+            const deletedLinesCount = lastLineIndex - firstLineIndex;
+            this._startLineNumber -= deletedLinesCount;
+            return;
+        }
+        if (firstLineIndex >= this._tokens.length) {
+            // this deletion occurs entirely after this block, so there is nothing to do
+            return;
+        }
+        if (firstLineIndex < 0 && lastLineIndex >= this._tokens.length) {
+            // this deletion completely encompasses this block
+            this._startLineNumber = 0;
+            this._tokens = [];
+            return;
+        }
+        if (firstLineIndex === lastLineIndex) {
+            // a delete on a single line
+            this._tokens[firstLineIndex] = ContiguousTokensEditing.delete(this._tokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);
+            return;
+        }
+        if (firstLineIndex >= 0) {
+            // The first line survives
+            this._tokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._tokens[firstLineIndex], range.startColumn - 1);
+            if (lastLineIndex < this._tokens.length) {
+                // The last line survives
+                const lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);
+                // Take remaining text on last line and append it to remaining text on first line
+                this._tokens[firstLineIndex] = ContiguousTokensEditing.append(this._tokens[firstLineIndex], lastLineTokens);
+                // Delete middle lines
+                this._tokens.splice(firstLineIndex + 1, lastLineIndex - firstLineIndex);
+            }
+            else {
+                // The last line does not survive
+                // Take remaining text on last line and append it to remaining text on first line
+                this._tokens[firstLineIndex] = ContiguousTokensEditing.append(this._tokens[firstLineIndex], null);
+                // Delete lines
+                this._tokens = this._tokens.slice(0, firstLineIndex + 1);
+            }
+        }
+        else {
+            // The first line does not survive
+            const deletedBefore = -firstLineIndex;
+            this._startLineNumber -= deletedBefore;
+            // Remove beginning from last line
+            this._tokens[lastLineIndex] = ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);
+            // Delete lines
+            this._tokens = this._tokens.slice(lastLineIndex);
+        }
+    }
+    _acceptInsertText(position, eolCount, firstLineLength) {
+        if (eolCount === 0 && firstLineLength === 0) {
+            // Nothing to insert
+            return;
+        }
+        const lineIndex = position.lineNumber - this._startLineNumber;
+        if (lineIndex < 0) {
+            // this insertion occurs before this block, so we only need to adjust line numbers
+            this._startLineNumber += eolCount;
+            return;
+        }
+        if (lineIndex >= this._tokens.length) {
+            // this insertion occurs after this block, so there is nothing to do
+            return;
+        }
+        if (eolCount === 0) {
+            // Inserting text on one line
+            this._tokens[lineIndex] = ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);
+            return;
+        }
+        this._tokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._tokens[lineIndex], position.column - 1);
+        this._tokens[lineIndex] = ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);
+        this._insertLines(position.lineNumber, eolCount);
+    }
+    _insertLines(insertIndex, insertCount) {
+        if (insertCount === 0) {
+            return;
+        }
+        const lineTokens = [];
+        for (let i = 0; i < insertCount; i++) {
+            lineTokens[i] = null;
+        }
+        this._tokens = arrays.arrayInsert(this._tokens, insertIndex, lineTokens);
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js b/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js
--- a/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js	2023-12-06 14:22:33.819782444 +0000
+++ b/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js	2023-12-06 14:23:14.371854769 +0000
@@ -1,5 +1,20 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { readUInt32BE, writeUInt32BE } from '../../../base/common/buffer.js';
 import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';
 export class ContiguousMultilineTokensBuilder {
+    static deserialize(buff) {
+        let offset = 0;
+        const count = readUInt32BE(buff, offset);
+        offset += 4;
+        const result = [];
+        for (let i = 0; i < count; i++) {
+            offset = ContiguousMultilineTokens.deserialize(buff, offset, result);
+        }
+        return result;
+    }
     constructor() {
         this._tokens = [];
     }
@@ -17,4 +32,26 @@
     finalize() {
         return this._tokens;
     }
+    serialize() {
+        const size = this._serializeSize();
+        const result = new Uint8Array(size);
+        this._serialize(result);
+        return result;
+    }
+    _serializeSize() {
+        let result = 0;
+        result += 4; // 4 bytes for the count
+        for (let i = 0; i < this._tokens.length; i++) {
+            result += this._tokens[i].serializeSize();
+        }
+        return result;
+    }
+    _serialize(destination) {
+        let offset = 0;
+        writeUInt32BE(destination, this._tokens.length, offset);
+        offset += 4;
+        for (let i = 0; i < this._tokens.length; i++) {
+            offset = this._tokens[i].serialize(destination, offset);
+        }
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/viewLayout/linesLayout.js b/vs/editor/common/viewLayout/linesLayout.js
--- a/vs/editor/common/viewLayout/linesLayout.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/viewLayout/linesLayout.js	2023-12-06 14:23:14.371854769 +0000
@@ -421,6 +421,13 @@
         return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;
     }
     /**
+     * Returns if there is any whitespace in the document.
+     */
+    hasWhitespace() {
+        this._checkPendingChanges();
+        return this.getWhitespacesCount() > 0;
+    }
+    /**
      * The maximum min width for all whitespaces.
      */
     getWhitespaceMinWidth() {
diff -urN -x '*.map' a/vs/editor/common/viewLayout/viewLineRenderer.js b/vs/editor/common/viewLayout/viewLineRenderer.js
--- a/vs/editor/common/viewLayout/viewLineRenderer.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/viewLayout/viewLineRenderer.js	2023-12-06 14:23:14.371854769 +0000
@@ -200,6 +200,17 @@
         }
         return max;
     }
+    inflate() {
+        const result = [];
+        for (let i = 0; i < this.length; i++) {
+            const partData = this._data[i];
+            const partIndex = CharacterMapping.getPartIndex(partData);
+            const charIndex = CharacterMapping.getCharIndex(partData);
+            const visibleColumn = this._horizontalOffset[i];
+            result.push([partIndex, charIndex, visibleColumn]);
+        }
+        return result;
+    }
 }
 export class RenderLineOutput {
     constructor(characterMapping, containsRTL, containsForeignElements) {
@@ -890,7 +901,7 @@
     }
     if (isOverflowing) {
         sb.appendString('<span class="mtkoverflow">');
-        sb.appendString(nls.localize('showMore', "Show more ({0})", renderOverflowingCharCount(overflowingCharCount)));
+        sb.appendString(nls.localizeWithPath('vs/editor/common/viewLayout/viewLineRenderer', 'showMore', "Show more ({0})", renderOverflowingCharCount(overflowingCharCount)));
         sb.appendString('</span>');
     }
     sb.appendString('</span>');
@@ -901,7 +912,7 @@
 }
 function renderOverflowingCharCount(n) {
     if (n < 1024) {
-        return nls.localize('overflow.chars', "{0} chars", n);
+        return nls.localizeWithPath('vs/editor/common/viewLayout/viewLineRenderer', 'overflow.chars', "{0} chars", n);
     }
     if (n < 1024 * 1024) {
         return `${(n / 1024).toFixed(1)} KB`;
diff -urN -x '*.map' a/vs/editor/common/viewModel/viewModelImpl.js b/vs/editor/common/viewModel/viewModelImpl.js
--- a/vs/editor/common/viewModel/viewModelImpl.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/viewModel/viewModelImpl.js	2023-12-06 14:23:14.371854769 +0000
@@ -587,9 +587,9 @@
         const decorations = this.model.getOverviewRulerDecorations();
         for (const decoration of decorations) {
             const opts1 = decoration.options.overviewRuler;
-            opts1 === null || opts1 === void 0 ? void 0 : opts1.invalidateCachedColor();
+            opts1?.invalidateCachedColor();
             const opts2 = decoration.options.minimap;
-            opts2 === null || opts2 === void 0 ? void 0 : opts2.invalidateCachedColor();
+            opts2?.invalidateCachedColor();
         }
     }
     getValueInRange(range, eol) {
diff -urN -x '*.map' a/vs/editor/common/viewModel/viewModelLines.js b/vs/editor/common/viewModel/viewModelLines.js
--- a/vs/editor/common/viewModel/viewModelLines.js	2023-12-06 14:22:33.823782450 +0000
+++ b/vs/editor/common/viewModel/viewModelLines.js	2023-12-06 14:23:14.371854769 +0000
@@ -775,6 +775,9 @@
  * Represents a view line. Can be used to efficiently query more information about it.
  */
 class ViewLineInfo {
+    get isWrappedLineContinuation() {
+        return this.modelLineWrappedLineIdx > 0;
+    }
     constructor(modelLineNumber, modelLineWrappedLineIdx) {
         this.modelLineNumber = modelLineNumber;
         this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;
diff -urN -x '*.map' a/vs/editor/contrib/anchorSelect/browser/anchorSelect.js b/vs/editor/contrib/anchorSelect/browser/anchorSelect.js
--- a/vs/editor/contrib/anchorSelect/browser/anchorSelect.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/anchorSelect/browser/anchorSelect.js	2023-12-06 14:23:14.371854769 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var SelectionAnchorController_1;
 import { alert } from '../../../../base/browser/ui/aria/aria.js';
 import { MarkdownString } from '../../../../base/common/htmlContent.js';
@@ -28,7 +19,7 @@
 import { EditorAction, registerEditorAction, registerEditorContribution } from '../../../browser/editorExtensions.js';
 import { Selection } from '../../../common/core/selection.js';
 import { EditorContextKeys } from '../../../common/editorContextKeys.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';
 export const SelectionAnchorSet = new RawContextKey('selectionAnchorSet', false);
 let SelectionAnchorController = SelectionAnchorController_1 = class SelectionAnchorController {
@@ -50,12 +41,12 @@
                 this.decorationId = accessor.addDecoration(Selection.fromPositions(position, position), {
                     description: 'selection-anchor',
                     stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,
-                    hoverMessage: new MarkdownString().appendText(localize('selectionAnchor', "Selection Anchor")),
+                    hoverMessage: new MarkdownString().appendText(localizeWithPath('vs/editor/contrib/anchorSelect/browser/anchorSelect', 'selectionAnchor', "Selection Anchor")),
                     className: 'selection-anchor'
                 });
             });
             this.selectionAnchorSetContextKey.set(!!this.decorationId);
-            alert(localize('anchorSet', "Anchor set at {0}:{1}", position.lineNumber, position.column));
+            alert(localizeWithPath('vs/editor/contrib/anchorSelect/browser/anchorSelect', 'anchorSet', "Anchor set at {0}:{1}", position.lineNumber, position.column));
         }
     }
     goToSelectionAnchor() {
@@ -99,7 +90,7 @@
     constructor() {
         super({
             id: 'editor.action.setSelectionAnchor',
-            label: localize('setSelectionAnchor', "Set Selection Anchor"),
+            label: localizeWithPath('vs/editor/contrib/anchorSelect/browser/anchorSelect', 'setSelectionAnchor', "Set Selection Anchor"),
             alias: 'Set Selection Anchor',
             precondition: undefined,
             kbOpts: {
@@ -109,34 +100,28 @@
             }
         });
     }
-    run(_accessor, editor) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            (_a = SelectionAnchorController.get(editor)) === null || _a === void 0 ? void 0 : _a.setSelectionAnchor();
-        });
+    async run(_accessor, editor) {
+        SelectionAnchorController.get(editor)?.setSelectionAnchor();
     }
 }
 class GoToSelectionAnchor extends EditorAction {
     constructor() {
         super({
             id: 'editor.action.goToSelectionAnchor',
-            label: localize('goToSelectionAnchor', "Go to Selection Anchor"),
+            label: localizeWithPath('vs/editor/contrib/anchorSelect/browser/anchorSelect', 'goToSelectionAnchor', "Go to Selection Anchor"),
             alias: 'Go to Selection Anchor',
             precondition: SelectionAnchorSet,
         });
     }
-    run(_accessor, editor) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            (_a = SelectionAnchorController.get(editor)) === null || _a === void 0 ? void 0 : _a.goToSelectionAnchor();
-        });
+    async run(_accessor, editor) {
+        SelectionAnchorController.get(editor)?.goToSelectionAnchor();
     }
 }
 class SelectFromAnchorToCursor extends EditorAction {
     constructor() {
         super({
             id: 'editor.action.selectFromAnchorToCursor',
-            label: localize('selectFromAnchorToCursor', "Select from Anchor to Cursor"),
+            label: localizeWithPath('vs/editor/contrib/anchorSelect/browser/anchorSelect', 'selectFromAnchorToCursor', "Select from Anchor to Cursor"),
             alias: 'Select from Anchor to Cursor',
             precondition: SelectionAnchorSet,
             kbOpts: {
@@ -146,18 +131,15 @@
             }
         });
     }
-    run(_accessor, editor) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            (_a = SelectionAnchorController.get(editor)) === null || _a === void 0 ? void 0 : _a.selectFromAnchorToCursor();
-        });
+    async run(_accessor, editor) {
+        SelectionAnchorController.get(editor)?.selectFromAnchorToCursor();
     }
 }
 class CancelSelectionAnchor extends EditorAction {
     constructor() {
         super({
             id: 'editor.action.cancelSelectionAnchor',
-            label: localize('cancelSelectionAnchor', "Cancel Selection Anchor"),
+            label: localizeWithPath('vs/editor/contrib/anchorSelect/browser/anchorSelect', 'cancelSelectionAnchor', "Cancel Selection Anchor"),
             alias: 'Cancel Selection Anchor',
             precondition: SelectionAnchorSet,
             kbOpts: {
@@ -167,11 +149,8 @@
             }
         });
     }
-    run(_accessor, editor) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            (_a = SelectionAnchorController.get(editor)) === null || _a === void 0 ? void 0 : _a.cancelSelectionAnchor();
-        });
+    async run(_accessor, editor) {
+        SelectionAnchorController.get(editor)?.cancelSelectionAnchor();
     }
 }
 registerEditorContribution(SelectionAnchorController.ID, SelectionAnchorController, 4 /* EditorContributionInstantiation.Lazy */);
diff -urN -x '*.map' a/vs/editor/contrib/bracketMatching/browser/bracketMatching.js b/vs/editor/contrib/bracketMatching/browser/bracketMatching.js
--- a/vs/editor/contrib/bracketMatching/browser/bracketMatching.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/bracketMatching/browser/bracketMatching.js	2023-12-06 14:23:14.371854769 +0000
@@ -16,12 +16,12 @@
 import { MenuId, MenuRegistry } from '../../../../platform/actions/common/actions.js';
 import { registerColor } from '../../../../platform/theme/common/colorRegistry.js';
 import { themeColorFromId } from '../../../../platform/theme/common/themeService.js';
-const overviewRulerBracketMatchForeground = registerColor('editorOverviewRuler.bracketMatchForeground', { dark: '#A0A0A0', light: '#A0A0A0', hcDark: '#A0A0A0', hcLight: '#A0A0A0' }, nls.localize('overviewRulerBracketMatchForeground', 'Overview ruler marker color for matching brackets.'));
+const overviewRulerBracketMatchForeground = registerColor('editorOverviewRuler.bracketMatchForeground', { dark: '#A0A0A0', light: '#A0A0A0', hcDark: '#A0A0A0', hcLight: '#A0A0A0' }, nls.localizeWithPath('vs/editor/contrib/bracketMatching/browser/bracketMatching', 'overviewRulerBracketMatchForeground', 'Overview ruler marker color for matching brackets.'));
 class JumpToBracketAction extends EditorAction {
     constructor() {
         super({
             id: 'editor.action.jumpToBracket',
-            label: nls.localize('smartSelect.jumpBracket', "Go to Bracket"),
+            label: nls.localizeWithPath('vs/editor/contrib/bracketMatching/browser/bracketMatching', 'smartSelect.jumpBracket', "Go to Bracket"),
             alias: 'Go to Bracket',
             precondition: undefined,
             kbOpts: {
@@ -32,15 +32,14 @@
         });
     }
     run(accessor, editor) {
-        var _a;
-        (_a = BracketMatchingController.get(editor)) === null || _a === void 0 ? void 0 : _a.jumpToBracket();
+        BracketMatchingController.get(editor)?.jumpToBracket();
     }
 }
 class SelectToBracketAction extends EditorAction {
     constructor() {
         super({
             id: 'editor.action.selectToBracket',
-            label: nls.localize('smartSelect.selectToBracket', "Select to Bracket"),
+            label: nls.localizeWithPath('vs/editor/contrib/bracketMatching/browser/bracketMatching', 'smartSelect.selectToBracket', "Select to Bracket"),
             alias: 'Select to Bracket',
             precondition: undefined,
             description: {
@@ -61,19 +60,18 @@
         });
     }
     run(accessor, editor, args) {
-        var _a;
         let selectBrackets = true;
         if (args && args.selectBrackets === false) {
             selectBrackets = false;
         }
-        (_a = BracketMatchingController.get(editor)) === null || _a === void 0 ? void 0 : _a.selectToBracket(selectBrackets);
+        BracketMatchingController.get(editor)?.selectToBracket(selectBrackets);
     }
 }
 class RemoveBracketsAction extends EditorAction {
     constructor() {
         super({
             id: 'editor.action.removeBrackets',
-            label: nls.localize('smartSelect.removeBrackets', "Remove Brackets"),
+            label: nls.localizeWithPath('vs/editor/contrib/bracketMatching/browser/bracketMatching', 'smartSelect.removeBrackets', "Remove Brackets"),
             alias: 'Remove Brackets',
             precondition: undefined,
             kbOpts: {
@@ -84,8 +82,7 @@
         });
     }
     run(accessor, editor) {
-        var _a;
-        (_a = BracketMatchingController.get(editor)) === null || _a === void 0 ? void 0 : _a.removeBrackets(this.id);
+        BracketMatchingController.get(editor)?.removeBrackets(this.id);
     }
 }
 class BracketsData {
@@ -345,7 +342,7 @@
     group: '5_infile_nav',
     command: {
         id: 'editor.action.jumpToBracket',
-        title: nls.localize({ key: 'miGoToBracket', comment: ['&& denotes a mnemonic'] }, "Go to &&Bracket")
+        title: nls.localizeWithPath('vs/editor/contrib/bracketMatching/browser/bracketMatching', { key: 'miGoToBracket', comment: ['&& denotes a mnemonic'] }, "Go to &&Bracket")
     },
     order: 2
 });
diff -urN -x '*.map' a/vs/editor/contrib/caretOperations/browser/caretOperations.js b/vs/editor/contrib/caretOperations/browser/caretOperations.js
--- a/vs/editor/contrib/caretOperations/browser/caretOperations.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/caretOperations/browser/caretOperations.js	2023-12-06 14:23:14.371854769 +0000
@@ -29,7 +29,7 @@
     constructor() {
         super(true, {
             id: 'editor.action.moveCarretLeftAction',
-            label: nls.localize('caret.moveLeft', "Move Selected Text Left"),
+            label: nls.localizeWithPath('vs/editor/contrib/caretOperations/browser/caretOperations', 'caret.moveLeft', "Move Selected Text Left"),
             alias: 'Move Selected Text Left',
             precondition: EditorContextKeys.writable
         });
@@ -39,7 +39,7 @@
     constructor() {
         super(false, {
             id: 'editor.action.moveCarretRightAction',
-            label: nls.localize('caret.moveRight', "Move Selected Text Right"),
+            label: nls.localizeWithPath('vs/editor/contrib/caretOperations/browser/caretOperations', 'caret.moveRight', "Move Selected Text Right"),
             alias: 'Move Selected Text Right',
             precondition: EditorContextKeys.writable
         });
diff -urN -x '*.map' a/vs/editor/contrib/caretOperations/browser/transpose.js b/vs/editor/contrib/caretOperations/browser/transpose.js
--- a/vs/editor/contrib/caretOperations/browser/transpose.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/caretOperations/browser/transpose.js	2023-12-06 14:23:14.375854776 +0000
@@ -12,7 +12,7 @@
     constructor() {
         super({
             id: 'editor.action.transposeLetters',
-            label: nls.localize('transposeLetters.label', "Transpose Letters"),
+            label: nls.localizeWithPath('vs/editor/contrib/caretOperations/browser/transpose', 'transposeLetters.label', "Transpose Letters"),
             alias: 'Transpose Letters',
             precondition: EditorContextKeys.writable,
             kbOpts: {
diff -urN -x '*.map' a/vs/editor/contrib/clipboard/browser/clipboard.js b/vs/editor/contrib/clipboard/browser/clipboard.js
--- a/vs/editor/contrib/clipboard/browser/clipboard.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/clipboard/browser/clipboard.js	2023-12-06 14:23:14.375854776 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import * as browser from '../../../../base/browser/browser.js';
 import { getActiveDocument } from '../../../../base/browser/dom.js';
 import * as platform from '../../../../base/common/platform.js';
@@ -47,23 +38,23 @@
     menuOpts: [{
             menuId: MenuId.MenubarEditMenu,
             group: '2_ccp',
-            title: nls.localize({ key: 'miCut', comment: ['&& denotes a mnemonic'] }, "Cu&&t"),
+            title: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', { key: 'miCut', comment: ['&& denotes a mnemonic'] }, "Cu&&t"),
             order: 1
         }, {
             menuId: MenuId.EditorContext,
             group: CLIPBOARD_CONTEXT_MENU_GROUP,
-            title: nls.localize('actions.clipboard.cutLabel', "Cut"),
+            title: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'actions.clipboard.cutLabel', "Cut"),
             when: EditorContextKeys.writable,
             order: 1,
         }, {
             menuId: MenuId.CommandPalette,
             group: '',
-            title: nls.localize('actions.clipboard.cutLabel', "Cut"),
+            title: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'actions.clipboard.cutLabel', "Cut"),
             order: 1
         }, {
             menuId: MenuId.SimpleEditorContext,
             group: CLIPBOARD_CONTEXT_MENU_GROUP,
-            title: nls.localize('actions.clipboard.cutLabel', "Cut"),
+            title: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'actions.clipboard.cutLabel', "Cut"),
             when: EditorContextKeys.writable,
             order: 1,
         }]
@@ -82,30 +73,30 @@
     menuOpts: [{
             menuId: MenuId.MenubarEditMenu,
             group: '2_ccp',
-            title: nls.localize({ key: 'miCopy', comment: ['&& denotes a mnemonic'] }, "&&Copy"),
+            title: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', { key: 'miCopy', comment: ['&& denotes a mnemonic'] }, "&&Copy"),
             order: 2
         }, {
             menuId: MenuId.EditorContext,
             group: CLIPBOARD_CONTEXT_MENU_GROUP,
-            title: nls.localize('actions.clipboard.copyLabel', "Copy"),
+            title: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'actions.clipboard.copyLabel', "Copy"),
             order: 2,
         }, {
             menuId: MenuId.CommandPalette,
             group: '',
-            title: nls.localize('actions.clipboard.copyLabel', "Copy"),
+            title: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'actions.clipboard.copyLabel', "Copy"),
             order: 1
         }, {
             menuId: MenuId.SimpleEditorContext,
             group: CLIPBOARD_CONTEXT_MENU_GROUP,
-            title: nls.localize('actions.clipboard.copyLabel', "Copy"),
+            title: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'actions.clipboard.copyLabel', "Copy"),
             order: 2,
         }]
 })) : undefined;
-MenuRegistry.appendMenuItem(MenuId.MenubarEditMenu, { submenu: MenuId.MenubarCopy, title: { value: nls.localize('copy as', "Copy As"), original: 'Copy As', }, group: '2_ccp', order: 3 });
-MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextCopy, title: { value: nls.localize('copy as', "Copy As"), original: 'Copy As', }, group: CLIPBOARD_CONTEXT_MENU_GROUP, order: 3 });
-MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextShare, title: { value: nls.localize('share', "Share"), original: 'Share', }, group: '11_share', order: -1, when: ContextKeyExpr.and(ContextKeyExpr.notEquals('resourceScheme', 'output'), EditorContextKeys.editorTextFocus) });
-MenuRegistry.appendMenuItem(MenuId.EditorTitleContext, { submenu: MenuId.EditorTitleContextShare, title: { value: nls.localize('share', "Share"), original: 'Share', }, group: '11_share', order: -1 });
-MenuRegistry.appendMenuItem(MenuId.ExplorerContext, { submenu: MenuId.ExplorerContextShare, title: { value: nls.localize('share', "Share"), original: 'Share', }, group: '11_share', order: -1 });
+MenuRegistry.appendMenuItem(MenuId.MenubarEditMenu, { submenu: MenuId.MenubarCopy, title: { value: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'copy as', "Copy As"), original: 'Copy As', }, group: '2_ccp', order: 3 });
+MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextCopy, title: { value: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'copy as', "Copy As"), original: 'Copy As', }, group: CLIPBOARD_CONTEXT_MENU_GROUP, order: 3 });
+MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextShare, title: { value: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'share', "Share"), original: 'Share', }, group: '11_share', order: -1, when: ContextKeyExpr.and(ContextKeyExpr.notEquals('resourceScheme', 'output'), EditorContextKeys.editorTextFocus) });
+MenuRegistry.appendMenuItem(MenuId.EditorTitleContext, { submenu: MenuId.EditorTitleContextShare, title: { value: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'share', "Share"), original: 'Share', }, group: '11_share', order: -1 });
+MenuRegistry.appendMenuItem(MenuId.ExplorerContext, { submenu: MenuId.ExplorerContextShare, title: { value: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'share', "Share"), original: 'Share', }, group: '11_share', order: -1 });
 export const PasteAction = supportsPaste ? registerCommand(new MultiCommand({
     id: 'editor.action.clipboardPasteAction',
     precondition: undefined,
@@ -121,23 +112,23 @@
     menuOpts: [{
             menuId: MenuId.MenubarEditMenu,
             group: '2_ccp',
-            title: nls.localize({ key: 'miPaste', comment: ['&& denotes a mnemonic'] }, "&&Paste"),
+            title: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', { key: 'miPaste', comment: ['&& denotes a mnemonic'] }, "&&Paste"),
             order: 4
         }, {
             menuId: MenuId.EditorContext,
             group: CLIPBOARD_CONTEXT_MENU_GROUP,
-            title: nls.localize('actions.clipboard.pasteLabel', "Paste"),
+            title: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'actions.clipboard.pasteLabel', "Paste"),
             when: EditorContextKeys.writable,
             order: 4,
         }, {
             menuId: MenuId.CommandPalette,
             group: '',
-            title: nls.localize('actions.clipboard.pasteLabel', "Paste"),
+            title: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'actions.clipboard.pasteLabel', "Paste"),
             order: 1
         }, {
             menuId: MenuId.SimpleEditorContext,
             group: CLIPBOARD_CONTEXT_MENU_GROUP,
-            title: nls.localize('actions.clipboard.pasteLabel', "Paste"),
+            title: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'actions.clipboard.pasteLabel', "Paste"),
             when: EditorContextKeys.writable,
             order: 4,
         }]
@@ -146,7 +137,7 @@
     constructor() {
         super({
             id: 'editor.action.clipboardCopyWithSyntaxHighlightingAction',
-            label: nls.localize('actions.clipboard.copyWithSyntaxHighlightingLabel', "Copy With Syntax Highlighting"),
+            label: nls.localizeWithPath('vs/editor/contrib/clipboard/browser/clipboard', 'actions.clipboard.copyWithSyntaxHighlightingLabel', "Copy With Syntax Highlighting"),
             alias: 'Copy With Syntax Highlighting',
             precondition: undefined,
             kbOpts: {
@@ -209,8 +200,8 @@
             const result = focusedEditor.getContainerDomNode().ownerDocument.execCommand('paste');
             // Use the clipboard service if document.execCommand('paste') was not successful
             if (!result && platform.isWeb) {
-                return (() => __awaiter(void 0, void 0, void 0, function* () {
-                    const clipboardText = yield clipboardService.readText();
+                return (async () => {
+                    const clipboardText = await clipboardService.readText();
                     if (clipboardText !== '') {
                         const metadata = InMemoryClipboardMetadataManager.INSTANCE.get(clipboardText);
                         let pasteOnNewLine = false;
@@ -228,7 +219,7 @@
                             mode
                         });
                     }
-                }))();
+                })();
             }
             return true;
         }
diff -urN -x '*.map' a/vs/editor/contrib/codeAction/browser/codeAction.js b/vs/editor/contrib/codeAction/browser/codeAction.js
--- a/vs/editor/contrib/codeAction/browser/codeAction.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/codeAction/browser/codeAction.js	2023-12-06 14:23:14.375854776 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { coalesce, equals, isNonEmptyArray } from '../../../../base/common/arrays.js';
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { illegalArgument, isCancellationError, onUnexpectedExternalError } from '../../../../base/common/errors.js';
@@ -32,6 +23,7 @@
 export const quickFixCommandId = 'editor.action.quickFix';
 export const autoFixCommandId = 'editor.action.autoFix';
 export const refactorCommandId = 'editor.action.refactor';
+export const refactorPreviewCommandId = 'editor.action.refactor.preview';
 export const sourceActionCommandId = 'editor.action.sourceAction';
 export const organizeImportsCommandId = 'editor.action.organizeImports';
 export const fixAllCommandId = 'editor.action.fixAll';
@@ -70,65 +62,65 @@
     }
 }
 const emptyCodeActionsResponse = { actions: [], documentation: undefined };
-export function getCodeActions(registry, model, rangeOrSelection, trigger, progress, token) {
-    var _a;
-    return __awaiter(this, void 0, void 0, function* () {
-        const filter = trigger.filter || {};
-        const notebookFilter = Object.assign(Object.assign({}, filter), { excludes: [...(filter.excludes || []), CodeActionKind.Notebook] });
-        const codeActionContext = {
-            only: (_a = filter.include) === null || _a === void 0 ? void 0 : _a.value,
-            trigger: trigger.type,
-        };
-        const cts = new TextModelCancellationTokenSource(model, token);
-        // if the trigger is auto (autosave, lightbulb, etc), we should exclude notebook codeActions
-        const excludeNotebookCodeActions = (trigger.type === 2 /* languages.CodeActionTriggerType.Auto */);
-        const providers = getCodeActionProviders(registry, model, (excludeNotebookCodeActions) ? notebookFilter : filter);
-        const disposables = new DisposableStore();
-        const promises = providers.map((provider) => __awaiter(this, void 0, void 0, function* () {
-            try {
-                progress.report(provider);
-                const providedCodeActions = yield provider.provideCodeActions(model, rangeOrSelection, codeActionContext, cts.token);
-                if (providedCodeActions) {
-                    disposables.add(providedCodeActions);
-                }
-                if (cts.token.isCancellationRequested) {
-                    return emptyCodeActionsResponse;
-                }
-                const filteredActions = ((providedCodeActions === null || providedCodeActions === void 0 ? void 0 : providedCodeActions.actions) || []).filter(action => action && filtersAction(filter, action));
-                const documentation = getDocumentationFromProvider(provider, filteredActions, filter.include);
-                return {
-                    actions: filteredActions.map(action => new CodeActionItem(action, provider)),
-                    documentation
-                };
+export async function getCodeActions(registry, model, rangeOrSelection, trigger, progress, token) {
+    const filter = trigger.filter || {};
+    const notebookFilter = {
+        ...filter,
+        excludes: [...(filter.excludes || []), CodeActionKind.Notebook],
+    };
+    const codeActionContext = {
+        only: filter.include?.value,
+        trigger: trigger.type,
+    };
+    const cts = new TextModelCancellationTokenSource(model, token);
+    // if the trigger is auto (autosave, lightbulb, etc), we should exclude notebook codeActions
+    const excludeNotebookCodeActions = (trigger.type === 2 /* languages.CodeActionTriggerType.Auto */);
+    const providers = getCodeActionProviders(registry, model, (excludeNotebookCodeActions) ? notebookFilter : filter);
+    const disposables = new DisposableStore();
+    const promises = providers.map(async (provider) => {
+        try {
+            progress.report(provider);
+            const providedCodeActions = await provider.provideCodeActions(model, rangeOrSelection, codeActionContext, cts.token);
+            if (providedCodeActions) {
+                disposables.add(providedCodeActions);
             }
-            catch (err) {
-                if (isCancellationError(err)) {
-                    throw err;
-                }
-                onUnexpectedExternalError(err);
+            if (cts.token.isCancellationRequested) {
                 return emptyCodeActionsResponse;
             }
-        }));
-        const listener = registry.onDidChange(() => {
-            const newProviders = registry.all(model);
-            if (!equals(newProviders, providers)) {
-                cts.cancel();
+            const filteredActions = (providedCodeActions?.actions || []).filter(action => action && filtersAction(filter, action));
+            const documentation = getDocumentationFromProvider(provider, filteredActions, filter.include);
+            return {
+                actions: filteredActions.map(action => new CodeActionItem(action, provider)),
+                documentation
+            };
+        }
+        catch (err) {
+            if (isCancellationError(err)) {
+                throw err;
             }
-        });
-        try {
-            const actions = yield Promise.all(promises);
-            const allActions = actions.map(x => x.actions).flat();
-            const allDocumentation = [
-                ...coalesce(actions.map(x => x.documentation)),
-                ...getAdditionalDocumentationForShowingActions(registry, model, trigger, allActions)
-            ];
-            return new ManagedCodeActionSet(allActions, allDocumentation, disposables);
-        }
-        finally {
-            listener.dispose();
-            cts.dispose();
+            onUnexpectedExternalError(err);
+            return emptyCodeActionsResponse;
         }
     });
+    const listener = registry.onDidChange(() => {
+        const newProviders = registry.all(model);
+        if (!equals(newProviders, providers)) {
+            cts.cancel();
+        }
+    });
+    try {
+        const actions = await Promise.all(promises);
+        const allActions = actions.map(x => x.actions).flat();
+        const allDocumentation = [
+            ...coalesce(actions.map(x => x.documentation)),
+            ...getAdditionalDocumentationForShowingActions(registry, model, trigger, allActions)
+        ];
+        return new ManagedCodeActionSet(allActions, allDocumentation, disposables);
+    }
+    finally {
+        listener.dispose();
+        cts.dispose();
+    }
 }
 function getCodeActionProviders(registry, model, filter) {
     return registry.all(model)
@@ -142,11 +134,10 @@
     });
 }
 function* getAdditionalDocumentationForShowingActions(registry, model, trigger, actionsToShow) {
-    var _a, _b, _c;
     if (model && actionsToShow.length) {
         for (const provider of registry.all(model)) {
             if (provider._getAdditionalMenuItems) {
-                yield* (_a = provider._getAdditionalMenuItems) === null || _a === void 0 ? void 0 : _a.call(provider, { trigger: trigger.type, only: (_c = (_b = trigger.filter) === null || _b === void 0 ? void 0 : _b.include) === null || _c === void 0 ? void 0 : _c.value }, actionsToShow.map(item => item.action));
+                yield* provider._getAdditionalMenuItems?.({ trigger: trigger.type, only: trigger.filter?.include?.value }, actionsToShow.map(item => item.action));
             }
         }
     }
@@ -172,7 +163,7 @@
             }
         }
         if (currentBest) {
-            return currentBest === null || currentBest === void 0 ? void 0 : currentBest.command;
+            return currentBest?.command;
         }
     }
     // Otherwise, check to see if any of the provided actions match.
@@ -194,48 +185,45 @@
     ApplyCodeActionReason["FromProblemsView"] = "fromProblemsView";
     ApplyCodeActionReason["FromCodeActions"] = "fromCodeActions";
 })(ApplyCodeActionReason || (ApplyCodeActionReason = {}));
-export function applyCodeAction(accessor, item, codeActionReason, options, token = CancellationToken.None) {
-    var _a;
-    return __awaiter(this, void 0, void 0, function* () {
-        const bulkEditService = accessor.get(IBulkEditService);
-        const commandService = accessor.get(ICommandService);
-        const telemetryService = accessor.get(ITelemetryService);
-        const notificationService = accessor.get(INotificationService);
-        telemetryService.publicLog2('codeAction.applyCodeAction', {
-            codeActionTitle: item.action.title,
-            codeActionKind: item.action.kind,
-            codeActionIsPreferred: !!item.action.isPreferred,
-            reason: codeActionReason,
+export async function applyCodeAction(accessor, item, codeActionReason, options, token = CancellationToken.None) {
+    const bulkEditService = accessor.get(IBulkEditService);
+    const commandService = accessor.get(ICommandService);
+    const telemetryService = accessor.get(ITelemetryService);
+    const notificationService = accessor.get(INotificationService);
+    telemetryService.publicLog2('codeAction.applyCodeAction', {
+        codeActionTitle: item.action.title,
+        codeActionKind: item.action.kind,
+        codeActionIsPreferred: !!item.action.isPreferred,
+        reason: codeActionReason,
+    });
+    await item.resolve(token);
+    if (token.isCancellationRequested) {
+        return;
+    }
+    if (item.action.edit?.edits.length) {
+        const result = await bulkEditService.apply(item.action.edit, {
+            editor: options?.editor,
+            label: item.action.title,
+            quotableLabel: item.action.title,
+            code: 'undoredo.codeAction',
+            respectAutoSaveConfig: codeActionReason !== ApplyCodeActionReason.OnSave,
+            showPreview: options?.preview,
         });
-        yield item.resolve(token);
-        if (token.isCancellationRequested) {
+        if (!result.isApplied) {
             return;
         }
-        if ((_a = item.action.edit) === null || _a === void 0 ? void 0 : _a.edits.length) {
-            const result = yield bulkEditService.apply(item.action.edit, {
-                editor: options === null || options === void 0 ? void 0 : options.editor,
-                label: item.action.title,
-                quotableLabel: item.action.title,
-                code: 'undoredo.codeAction',
-                respectAutoSaveConfig: codeActionReason !== ApplyCodeActionReason.OnSave,
-                showPreview: options === null || options === void 0 ? void 0 : options.preview,
-            });
-            if (!result.isApplied) {
-                return;
-            }
+    }
+    if (item.action.command) {
+        try {
+            await commandService.executeCommand(item.action.command.id, ...(item.action.command.arguments || []));
         }
-        if (item.action.command) {
-            try {
-                yield commandService.executeCommand(item.action.command.id, ...(item.action.command.arguments || []));
-            }
-            catch (err) {
-                const message = asMessage(err);
-                notificationService.error(typeof message === 'string'
-                    ? message
-                    : nls.localize('applyCodeActionFailed', "An unknown error occurred while applying the code action"));
-            }
+        catch (err) {
+            const message = asMessage(err);
+            notificationService.error(typeof message === 'string'
+                ? message
+                : nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeAction', 'applyCodeActionFailed', "An unknown error occurred while applying the code action"));
         }
-    });
+    }
 }
 function asMessage(err) {
     if (typeof err === 'string') {
@@ -248,37 +236,35 @@
         return undefined;
     }
 }
-CommandsRegistry.registerCommand('_executeCodeActionProvider', function (accessor, resource, rangeOrSelection, kind, itemResolveCount) {
-    return __awaiter(this, void 0, void 0, function* () {
-        if (!(resource instanceof URI)) {
-            throw illegalArgument();
-        }
-        const { codeActionProvider } = accessor.get(ILanguageFeaturesService);
-        const model = accessor.get(IModelService).getModel(resource);
-        if (!model) {
-            throw illegalArgument();
-        }
-        const validatedRangeOrSelection = Selection.isISelection(rangeOrSelection)
-            ? Selection.liftSelection(rangeOrSelection)
-            : Range.isIRange(rangeOrSelection)
-                ? model.validateRange(rangeOrSelection)
-                : undefined;
-        if (!validatedRangeOrSelection) {
-            throw illegalArgument();
-        }
-        const include = typeof kind === 'string' ? new CodeActionKind(kind) : undefined;
-        const codeActionSet = yield getCodeActions(codeActionProvider, model, validatedRangeOrSelection, { type: 1 /* languages.CodeActionTriggerType.Invoke */, triggerAction: CodeActionTriggerSource.Default, filter: { includeSourceActions: true, include } }, Progress.None, CancellationToken.None);
-        const resolving = [];
-        const resolveCount = Math.min(codeActionSet.validActions.length, typeof itemResolveCount === 'number' ? itemResolveCount : 0);
-        for (let i = 0; i < resolveCount; i++) {
-            resolving.push(codeActionSet.validActions[i].resolve(CancellationToken.None));
-        }
-        try {
-            yield Promise.all(resolving);
-            return codeActionSet.validActions.map(item => item.action);
-        }
-        finally {
-            setTimeout(() => codeActionSet.dispose(), 100);
-        }
-    });
+CommandsRegistry.registerCommand('_executeCodeActionProvider', async function (accessor, resource, rangeOrSelection, kind, itemResolveCount) {
+    if (!(resource instanceof URI)) {
+        throw illegalArgument();
+    }
+    const { codeActionProvider } = accessor.get(ILanguageFeaturesService);
+    const model = accessor.get(IModelService).getModel(resource);
+    if (!model) {
+        throw illegalArgument();
+    }
+    const validatedRangeOrSelection = Selection.isISelection(rangeOrSelection)
+        ? Selection.liftSelection(rangeOrSelection)
+        : Range.isIRange(rangeOrSelection)
+            ? model.validateRange(rangeOrSelection)
+            : undefined;
+    if (!validatedRangeOrSelection) {
+        throw illegalArgument();
+    }
+    const include = typeof kind === 'string' ? new CodeActionKind(kind) : undefined;
+    const codeActionSet = await getCodeActions(codeActionProvider, model, validatedRangeOrSelection, { type: 1 /* languages.CodeActionTriggerType.Invoke */, triggerAction: CodeActionTriggerSource.Default, filter: { includeSourceActions: true, include } }, Progress.None, CancellationToken.None);
+    const resolving = [];
+    const resolveCount = Math.min(codeActionSet.validActions.length, typeof itemResolveCount === 'number' ? itemResolveCount : 0);
+    for (let i = 0; i < resolveCount; i++) {
+        resolving.push(codeActionSet.validActions[i].resolve(CancellationToken.None));
+    }
+    try {
+        await Promise.all(resolving);
+        return codeActionSet.validActions.map(item => item.action);
+    }
+    finally {
+        setTimeout(() => codeActionSet.dispose(), 100);
+    }
 });
diff -urN -x '*.map' a/vs/editor/contrib/codeAction/browser/codeActionCommands.js b/vs/editor/contrib/codeAction/browser/codeActionCommands.js
--- a/vs/editor/contrib/codeAction/browser/codeActionCommands.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/codeAction/browser/codeActionCommands.js	2023-12-06 14:23:14.375854776 +0000
@@ -20,37 +20,37 @@
     properties: {
         'kind': {
             type: 'string',
-            description: nls.localize('args.schema.kind', "Kind of the code action to run."),
+            description: nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'args.schema.kind', "Kind of the code action to run."),
         },
         'apply': {
             type: 'string',
-            description: nls.localize('args.schema.apply', "Controls when the returned actions are applied."),
+            description: nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'args.schema.apply', "Controls when the returned actions are applied."),
             default: "ifSingle" /* CodeActionAutoApply.IfSingle */,
             enum: ["first" /* CodeActionAutoApply.First */, "ifSingle" /* CodeActionAutoApply.IfSingle */, "never" /* CodeActionAutoApply.Never */],
             enumDescriptions: [
-                nls.localize('args.schema.apply.first', "Always apply the first returned code action."),
-                nls.localize('args.schema.apply.ifSingle', "Apply the first returned code action if it is the only one."),
-                nls.localize('args.schema.apply.never', "Do not apply the returned code actions."),
+                nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'args.schema.apply.first', "Always apply the first returned code action."),
+                nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'args.schema.apply.ifSingle', "Apply the first returned code action if it is the only one."),
+                nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'args.schema.apply.never', "Do not apply the returned code actions."),
             ]
         },
         'preferred': {
             type: 'boolean',
             default: false,
-            description: nls.localize('args.schema.preferred', "Controls if only preferred code actions should be returned."),
+            description: nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'args.schema.preferred', "Controls if only preferred code actions should be returned."),
         }
     }
 };
 function triggerCodeActionsForEditorSelection(editor, notAvailableMessage, filter, autoApply, triggerAction = CodeActionTriggerSource.Default) {
     if (editor.hasModel()) {
         const controller = CodeActionController.get(editor);
-        controller === null || controller === void 0 ? void 0 : controller.manualTriggerAtCurrentPosition(notAvailableMessage, triggerAction, filter, autoApply);
+        controller?.manualTriggerAtCurrentPosition(notAvailableMessage, triggerAction, filter, autoApply);
     }
 }
 export class QuickFixAction extends EditorAction {
     constructor() {
         super({
             id: quickFixCommandId,
-            label: nls.localize('quickfix.trigger.label', "Quick Fix..."),
+            label: nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'quickfix.trigger.label', "Quick Fix..."),
             alias: 'Quick Fix...',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
             kbOpts: {
@@ -61,7 +61,7 @@
         });
     }
     run(_accessor, editor) {
-        return triggerCodeActionsForEditorSelection(editor, nls.localize('editor.action.quickFix.noneMessage', "No code actions available"), undefined, undefined, CodeActionTriggerSource.QuickFix);
+        return triggerCodeActionsForEditorSelection(editor, nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.quickFix.noneMessage', "No code actions available"), undefined, undefined, CodeActionTriggerSource.QuickFix);
     }
 }
 export class CodeActionCommand extends EditorCommand {
@@ -80,13 +80,13 @@
             kind: CodeActionKind.Empty,
             apply: "ifSingle" /* CodeActionAutoApply.IfSingle */,
         });
-        return triggerCodeActionsForEditorSelection(editor, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === 'string'
+        return triggerCodeActionsForEditorSelection(editor, typeof userArgs?.kind === 'string'
             ? args.preferred
-                ? nls.localize('editor.action.codeAction.noneMessage.preferred.kind', "No preferred code actions for '{0}' available", userArgs.kind)
-                : nls.localize('editor.action.codeAction.noneMessage.kind', "No code actions for '{0}' available", userArgs.kind)
+                ? nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.codeAction.noneMessage.preferred.kind', "No preferred code actions for '{0}' available", userArgs.kind)
+                : nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.codeAction.noneMessage.kind', "No code actions for '{0}' available", userArgs.kind)
             : args.preferred
-                ? nls.localize('editor.action.codeAction.noneMessage.preferred', "No preferred code actions available")
-                : nls.localize('editor.action.codeAction.noneMessage', "No code actions available"), {
+                ? nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.codeAction.noneMessage.preferred', "No preferred code actions available")
+                : nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.codeAction.noneMessage', "No code actions available"), {
             include: args.kind,
             includeSourceActions: true,
             onlyIncludePreferredActions: args.preferred,
@@ -97,7 +97,7 @@
     constructor() {
         super({
             id: refactorCommandId,
-            label: nls.localize('refactor.label', "Refactor..."),
+            label: nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'refactor.label', "Refactor..."),
             alias: 'Refactor...',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
             kbOpts: {
@@ -124,13 +124,13 @@
             kind: CodeActionKind.Refactor,
             apply: "never" /* CodeActionAutoApply.Never */
         });
-        return triggerCodeActionsForEditorSelection(editor, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === 'string'
+        return triggerCodeActionsForEditorSelection(editor, typeof userArgs?.kind === 'string'
             ? args.preferred
-                ? nls.localize('editor.action.refactor.noneMessage.preferred.kind', "No preferred refactorings for '{0}' available", userArgs.kind)
-                : nls.localize('editor.action.refactor.noneMessage.kind', "No refactorings for '{0}' available", userArgs.kind)
+                ? nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.refactor.noneMessage.preferred.kind', "No preferred refactorings for '{0}' available", userArgs.kind)
+                : nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.refactor.noneMessage.kind', "No refactorings for '{0}' available", userArgs.kind)
             : args.preferred
-                ? nls.localize('editor.action.refactor.noneMessage.preferred', "No preferred refactorings available")
-                : nls.localize('editor.action.refactor.noneMessage', "No refactorings available"), {
+                ? nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.refactor.noneMessage.preferred', "No preferred refactorings available")
+                : nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.refactor.noneMessage', "No refactorings available"), {
             include: CodeActionKind.Refactor.contains(args.kind) ? args.kind : CodeActionKind.None,
             onlyIncludePreferredActions: args.preferred
         }, args.apply, CodeActionTriggerSource.Refactor);
@@ -140,7 +140,7 @@
     constructor() {
         super({
             id: sourceActionCommandId,
-            label: nls.localize('source.label', "Source Action..."),
+            label: nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'source.label', "Source Action..."),
             alias: 'Source Action...',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
             contextMenuOpts: {
@@ -159,13 +159,13 @@
             kind: CodeActionKind.Source,
             apply: "never" /* CodeActionAutoApply.Never */
         });
-        return triggerCodeActionsForEditorSelection(editor, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === 'string'
+        return triggerCodeActionsForEditorSelection(editor, typeof userArgs?.kind === 'string'
             ? args.preferred
-                ? nls.localize('editor.action.source.noneMessage.preferred.kind', "No preferred source actions for '{0}' available", userArgs.kind)
-                : nls.localize('editor.action.source.noneMessage.kind', "No source actions for '{0}' available", userArgs.kind)
+                ? nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.source.noneMessage.preferred.kind', "No preferred source actions for '{0}' available", userArgs.kind)
+                : nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.source.noneMessage.kind', "No source actions for '{0}' available", userArgs.kind)
             : args.preferred
-                ? nls.localize('editor.action.source.noneMessage.preferred', "No preferred source actions available")
-                : nls.localize('editor.action.source.noneMessage', "No source actions available"), {
+                ? nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.source.noneMessage.preferred', "No preferred source actions available")
+                : nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.source.noneMessage', "No source actions available"), {
             include: CodeActionKind.Source.contains(args.kind) ? args.kind : CodeActionKind.None,
             includeSourceActions: true,
             onlyIncludePreferredActions: args.preferred,
@@ -176,7 +176,7 @@
     constructor() {
         super({
             id: organizeImportsCommandId,
-            label: nls.localize('organizeImports.label', "Organize Imports"),
+            label: nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'organizeImports.label', "Organize Imports"),
             alias: 'Organize Imports',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceOrganizeImports)),
             kbOpts: {
@@ -187,27 +187,27 @@
         });
     }
     run(_accessor, editor) {
-        return triggerCodeActionsForEditorSelection(editor, nls.localize('editor.action.organize.noneMessage', "No organize imports action available"), { include: CodeActionKind.SourceOrganizeImports, includeSourceActions: true }, "ifSingle" /* CodeActionAutoApply.IfSingle */, CodeActionTriggerSource.OrganizeImports);
+        return triggerCodeActionsForEditorSelection(editor, nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.organize.noneMessage', "No organize imports action available"), { include: CodeActionKind.SourceOrganizeImports, includeSourceActions: true }, "ifSingle" /* CodeActionAutoApply.IfSingle */, CodeActionTriggerSource.OrganizeImports);
     }
 }
 export class FixAllAction extends EditorAction {
     constructor() {
         super({
             id: fixAllCommandId,
-            label: nls.localize('fixAll.label', "Fix All"),
+            label: nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'fixAll.label', "Fix All"),
             alias: 'Fix All',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceFixAll))
         });
     }
     run(_accessor, editor) {
-        return triggerCodeActionsForEditorSelection(editor, nls.localize('fixAll.noneMessage', "No fix all action available"), { include: CodeActionKind.SourceFixAll, includeSourceActions: true }, "ifSingle" /* CodeActionAutoApply.IfSingle */, CodeActionTriggerSource.FixAll);
+        return triggerCodeActionsForEditorSelection(editor, nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'fixAll.noneMessage', "No fix all action available"), { include: CodeActionKind.SourceFixAll, includeSourceActions: true }, "ifSingle" /* CodeActionAutoApply.IfSingle */, CodeActionTriggerSource.FixAll);
     }
 }
 export class AutoFixAction extends EditorAction {
     constructor() {
         super({
             id: autoFixCommandId,
-            label: nls.localize('autoFix.label', "Auto Fix..."),
+            label: nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'autoFix.label', "Auto Fix..."),
             alias: 'Auto Fix...',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.QuickFix)),
             kbOpts: {
@@ -221,7 +221,7 @@
         });
     }
     run(_accessor, editor) {
-        return triggerCodeActionsForEditorSelection(editor, nls.localize('editor.action.autoFix.noneMessage', "No auto fixes available"), {
+        return triggerCodeActionsForEditorSelection(editor, nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionCommands', 'editor.action.autoFix.noneMessage', "No auto fixes available"), {
             include: CodeActionKind.QuickFix,
             onlyIncludePreferredActions: true
         }, "ifSingle" /* CodeActionAutoApply.IfSingle */, CodeActionTriggerSource.AutoFix);
diff -urN -x '*.map' a/vs/editor/contrib/codeAction/browser/codeActionContributions.js b/vs/editor/contrib/codeAction/browser/codeActionContributions.js
--- a/vs/editor/contrib/codeAction/browser/codeActionContributions.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/codeAction/browser/codeActionContributions.js	2023-12-06 14:23:14.375854776 +0000
@@ -19,19 +19,25 @@
 registerEditorAction(AutoFixAction);
 registerEditorAction(FixAllAction);
 registerEditorCommand(new CodeActionCommand());
-Registry.as(Extensions.Configuration).registerConfiguration(Object.assign(Object.assign({}, editorConfigurationBaseNode), { properties: {
+Registry.as(Extensions.Configuration).registerConfiguration({
+    ...editorConfigurationBaseNode,
+    properties: {
         'editor.codeActionWidget.showHeaders': {
             type: 'boolean',
             scope: 5 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */,
-            description: nls.localize('showCodeActionHeaders', "Enable/disable showing group headers in the Code Action menu."),
+            description: nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionContributions', 'showCodeActionHeaders', "Enable/disable showing group headers in the Code Action menu."),
             default: true,
         },
-    } }));
-Registry.as(Extensions.Configuration).registerConfiguration(Object.assign(Object.assign({}, editorConfigurationBaseNode), { properties: {
+    }
+});
+Registry.as(Extensions.Configuration).registerConfiguration({
+    ...editorConfigurationBaseNode,
+    properties: {
         'editor.codeActionWidget.includeNearbyQuickfixes': {
             type: 'boolean',
             scope: 5 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */,
-            description: nls.localize('includeNearbyQuickfixes', "Enable/disable showing nearest quickfix within a line when not currently on a diagnostic."),
+            description: nls.localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionContributions', 'includeNearbyQuickfixes', "Enable/disable showing nearest quickfix within a line when not currently on a diagnostic."),
             default: false,
         },
-    } }));
+    }
+});
diff -urN -x '*.map' a/vs/editor/contrib/codeAction/browser/codeActionController.js b/vs/editor/contrib/codeAction/browser/codeActionController.js
--- a/vs/editor/contrib/codeAction/browser/codeActionController.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/codeAction/browser/codeActionController.js	2023-12-06 14:23:14.375854776 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var CodeActionController_1;
 import { getDomNodePagePosition } from '../../../../base/browser/dom.js';
 import * as aria from '../../../../base/browser/ui/aria/aria.js';
@@ -34,7 +25,7 @@
 import { toMenuItems } from './codeActionMenu.js';
 import { LightBulbWidget } from './lightBulbWidget.js';
 import { MessageController } from '../../message/browser/messageController.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { IActionWidgetService } from '../../../../platform/actionWidget/browser/actionWidget.js';
 import { ICommandService } from '../../../../platform/commands/common/commands.js';
 import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
@@ -81,96 +72,96 @@
     showCodeActions(_trigger, actions, at) {
         return this.showCodeActionList(actions, at, { includeDisabledActions: false, fromLightbulb: false });
     }
+    hideCodeActions() {
+        this._actionWidgetService.hide();
+    }
     manualTriggerAtCurrentPosition(notAvailableMessage, triggerAction, filter, autoApply) {
-        var _a;
         if (!this._editor.hasModel()) {
             return;
         }
-        (_a = MessageController.get(this._editor)) === null || _a === void 0 ? void 0 : _a.closeMessage();
+        MessageController.get(this._editor)?.closeMessage();
         const triggerPosition = this._editor.getPosition();
         this._trigger({ type: 1 /* CodeActionTriggerType.Invoke */, triggerAction, filter, autoApply, context: { notAvailableMessage, position: triggerPosition } });
     }
     _trigger(trigger) {
         return this._model.trigger(trigger);
     }
-    _applyCodeAction(action, retrigger, preview) {
-        return __awaiter(this, void 0, void 0, function* () {
-            try {
-                yield this._instantiationService.invokeFunction(applyCodeAction, action, ApplyCodeActionReason.FromCodeActions, { preview, editor: this._editor });
-            }
-            finally {
-                if (retrigger) {
-                    this._trigger({ type: 2 /* CodeActionTriggerType.Auto */, triggerAction: CodeActionTriggerSource.QuickFix, filter: {} });
-                }
+    async _applyCodeAction(action, retrigger, preview) {
+        try {
+            await this._instantiationService.invokeFunction(applyCodeAction, action, ApplyCodeActionReason.FromCodeActions, { preview, editor: this._editor });
+        }
+        finally {
+            if (retrigger) {
+                this._trigger({ type: 2 /* CodeActionTriggerType.Auto */, triggerAction: CodeActionTriggerSource.QuickFix, filter: {} });
             }
-        });
+        }
     }
-    update(newState) {
-        var _a, _b, _c, _d, _e, _f, _g;
-        return __awaiter(this, void 0, void 0, function* () {
-            if (newState.type !== 1 /* CodeActionsState.Type.Triggered */) {
-                (_a = this._lightBulbWidget.rawValue) === null || _a === void 0 ? void 0 : _a.hide();
-                return;
-            }
-            let actions;
-            try {
-                actions = yield newState.actions;
-            }
-            catch (e) {
-                onUnexpectedError(e);
-                return;
-            }
-            if (this._disposed) {
-                return;
-            }
-            (_b = this._lightBulbWidget.value) === null || _b === void 0 ? void 0 : _b.update(actions, newState.trigger, newState.position);
-            if (newState.trigger.type === 1 /* CodeActionTriggerType.Invoke */) {
-                if ((_c = newState.trigger.filter) === null || _c === void 0 ? void 0 : _c.include) { // Triggered for specific scope
-                    // Check to see if we want to auto apply.
-                    const validActionToApply = this.tryGetValidActionToApply(newState.trigger, actions);
-                    if (validActionToApply) {
-                        try {
-                            (_d = this._lightBulbWidget.value) === null || _d === void 0 ? void 0 : _d.hide();
-                            yield this._applyCodeAction(validActionToApply, false, false);
-                        }
-                        finally {
-                            actions.dispose();
-                        }
-                        return;
+    hideLightBulbWidget() {
+        this._lightBulbWidget.rawValue?.hide();
+    }
+    async update(newState) {
+        if (newState.type !== 1 /* CodeActionsState.Type.Triggered */) {
+            this._lightBulbWidget.rawValue?.hide();
+            return;
+        }
+        let actions;
+        try {
+            actions = await newState.actions;
+        }
+        catch (e) {
+            onUnexpectedError(e);
+            return;
+        }
+        if (this._disposed) {
+            return;
+        }
+        this._lightBulbWidget.value?.update(actions, newState.trigger, newState.position);
+        if (newState.trigger.type === 1 /* CodeActionTriggerType.Invoke */) {
+            if (newState.trigger.filter?.include) { // Triggered for specific scope
+                // Check to see if we want to auto apply.
+                const validActionToApply = this.tryGetValidActionToApply(newState.trigger, actions);
+                if (validActionToApply) {
+                    try {
+                        this._lightBulbWidget.value?.hide();
+                        await this._applyCodeAction(validActionToApply, false, false);
                     }
-                    // Check to see if there is an action that we would have applied were it not invalid
-                    if (newState.trigger.context) {
-                        const invalidAction = this.getInvalidActionThatWouldHaveBeenApplied(newState.trigger, actions);
-                        if (invalidAction && invalidAction.action.disabled) {
-                            (_e = MessageController.get(this._editor)) === null || _e === void 0 ? void 0 : _e.showMessage(invalidAction.action.disabled, newState.trigger.context.position);
-                            actions.dispose();
-                            return;
-                        }
+                    finally {
+                        actions.dispose();
                     }
+                    return;
                 }
-                const includeDisabledActions = !!((_f = newState.trigger.filter) === null || _f === void 0 ? void 0 : _f.include);
+                // Check to see if there is an action that we would have applied were it not invalid
                 if (newState.trigger.context) {
-                    if (!actions.allActions.length || !includeDisabledActions && !actions.validActions.length) {
-                        (_g = MessageController.get(this._editor)) === null || _g === void 0 ? void 0 : _g.showMessage(newState.trigger.context.notAvailableMessage, newState.trigger.context.position);
-                        this._activeCodeActions.value = actions;
+                    const invalidAction = this.getInvalidActionThatWouldHaveBeenApplied(newState.trigger, actions);
+                    if (invalidAction && invalidAction.action.disabled) {
+                        MessageController.get(this._editor)?.showMessage(invalidAction.action.disabled, newState.trigger.context.position);
                         actions.dispose();
                         return;
                     }
                 }
-                this._activeCodeActions.value = actions;
-                this.showCodeActionList(actions, this.toCoords(newState.position), { includeDisabledActions, fromLightbulb: false });
             }
-            else {
-                // auto magically triggered
-                if (this._actionWidgetService.isVisible) {
-                    // TODO: Figure out if we should update the showing menu?
-                    actions.dispose();
-                }
-                else {
+            const includeDisabledActions = !!newState.trigger.filter?.include;
+            if (newState.trigger.context) {
+                if (!actions.allActions.length || !includeDisabledActions && !actions.validActions.length) {
+                    MessageController.get(this._editor)?.showMessage(newState.trigger.context.notAvailableMessage, newState.trigger.context.position);
                     this._activeCodeActions.value = actions;
+                    actions.dispose();
+                    return;
                 }
             }
-        });
+            this._activeCodeActions.value = actions;
+            this.showCodeActionList(actions, this.toCoords(newState.position), { includeDisabledActions, fromLightbulb: false });
+        }
+        else {
+            // auto magically triggered
+            if (this._actionWidgetService.isVisible) {
+                // TODO: Figure out if we should update the showing menu?
+                actions.dispose();
+            }
+            else {
+                this._activeCodeActions.value = actions;
+            }
+        }
     }
     getInvalidActionThatWouldHaveBeenApplied(trigger, actions) {
         if (!actions.allActions.length) {
@@ -192,53 +183,48 @@
         }
         return undefined;
     }
-    showCodeActionList(actions, at, options) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const currentDecorations = this._editor.createDecorationsCollection();
-            const editorDom = this._editor.getDomNode();
-            if (!editorDom) {
-                return;
-            }
-            const actionsToShow = options.includeDisabledActions && (this._showDisabled || actions.validActions.length === 0) ? actions.allActions : actions.validActions;
-            if (!actionsToShow.length) {
-                return;
-            }
-            const anchor = Position.isIPosition(at) ? this.toCoords(at) : at;
-            const delegate = {
-                onSelect: (action, preview) => __awaiter(this, void 0, void 0, function* () {
-                    this._applyCodeAction(action, /* retrigger */ true, !!preview);
-                    this._actionWidgetService.hide();
-                    currentDecorations.clear();
-                }),
-                onHide: () => {
-                    var _a;
-                    (_a = this._editor) === null || _a === void 0 ? void 0 : _a.focus();
+    async showCodeActionList(actions, at, options) {
+        const currentDecorations = this._editor.createDecorationsCollection();
+        const editorDom = this._editor.getDomNode();
+        if (!editorDom) {
+            return;
+        }
+        const actionsToShow = options.includeDisabledActions && (this._showDisabled || actions.validActions.length === 0) ? actions.allActions : actions.validActions;
+        if (!actionsToShow.length) {
+            return;
+        }
+        const anchor = Position.isIPosition(at) ? this.toCoords(at) : at;
+        const delegate = {
+            onSelect: async (action, preview) => {
+                this._applyCodeAction(action, /* retrigger */ true, !!preview);
+                this._actionWidgetService.hide();
+                currentDecorations.clear();
+            },
+            onHide: () => {
+                this._editor?.focus();
+                currentDecorations.clear();
+            },
+            onHover: async (action, token) => {
+                await action.resolve(token);
+                if (token.isCancellationRequested) {
+                    return;
+                }
+                return { canPreview: !!action.action.edit?.edits.length };
+            },
+            onFocus: (action) => {
+                if (action && action.highlightRange && action.action.diagnostics) {
+                    const decorations = [{ range: action.action.diagnostics[0], options: CodeActionController_1.DECORATION }];
+                    currentDecorations.set(decorations);
+                    const diagnostic = action.action.diagnostics[0];
+                    const selectionText = this._editor.getModel()?.getWordAtPosition({ lineNumber: diagnostic.startLineNumber, column: diagnostic.startColumn })?.word;
+                    aria.status(localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionController', 'editingNewSelection', "Context: {0} at line {1} and column {2}.", selectionText, diagnostic.startLineNumber, diagnostic.startColumn));
+                }
+                else {
                     currentDecorations.clear();
-                },
-                onHover: (action, token) => __awaiter(this, void 0, void 0, function* () {
-                    var _a;
-                    yield action.resolve(token);
-                    if (token.isCancellationRequested) {
-                        return;
-                    }
-                    return { canPreview: !!((_a = action.action.edit) === null || _a === void 0 ? void 0 : _a.edits.length) };
-                }),
-                onFocus: (action) => {
-                    var _a, _b;
-                    if (action && action.highlightRange && action.action.diagnostics) {
-                        const decorations = [{ range: action.action.diagnostics[0], options: CodeActionController_1.DECORATION }];
-                        currentDecorations.set(decorations);
-                        const diagnostic = action.action.diagnostics[0];
-                        const selectionText = (_b = (_a = this._editor.getModel()) === null || _a === void 0 ? void 0 : _a.getWordAtPosition({ lineNumber: diagnostic.startLineNumber, column: diagnostic.startColumn })) === null || _b === void 0 ? void 0 : _b.word;
-                        aria.status(localize('editingNewSelection', "Context: {0} at line {1} and column {2}.", selectionText, diagnostic.startLineNumber, diagnostic.startColumn));
-                    }
-                    else {
-                        currentDecorations.clear();
-                    }
                 }
-            };
-            this._actionWidgetService.show('codeActionWidget', true, toMenuItems(actionsToShow, this._shouldShowHeaders(), this._resolver.getResolver()), delegate, anchor, editorDom, this._getActionBarActions(actions, at, options));
-        });
+            }
+        };
+        this._actionWidgetService.show('codeActionWidget', true, toMenuItems(actionsToShow, this._shouldShowHeaders(), this._resolver.getResolver()), delegate, anchor, editorDom, this._getActionBarActions(actions, at, options));
     }
     toCoords(position) {
         if (!this._editor.hasModel()) {
@@ -254,29 +240,25 @@
         return { x, y };
     }
     _shouldShowHeaders() {
-        var _a;
-        const model = (_a = this._editor) === null || _a === void 0 ? void 0 : _a.getModel();
-        return this._configurationService.getValue('editor.codeActionWidget.showHeaders', { resource: model === null || model === void 0 ? void 0 : model.uri });
+        const model = this._editor?.getModel();
+        return this._configurationService.getValue('editor.codeActionWidget.showHeaders', { resource: model?.uri });
     }
     _getActionBarActions(actions, at, options) {
         if (options.fromLightbulb) {
             return [];
         }
-        const resultActions = actions.documentation.map((command) => {
-            var _a;
-            return ({
-                id: command.id,
-                label: command.title,
-                tooltip: (_a = command.tooltip) !== null && _a !== void 0 ? _a : '',
-                class: undefined,
-                enabled: true,
-                run: () => { var _a; return this._commandService.executeCommand(command.id, ...((_a = command.arguments) !== null && _a !== void 0 ? _a : [])); },
-            });
-        });
+        const resultActions = actions.documentation.map((command) => ({
+            id: command.id,
+            label: command.title,
+            tooltip: command.tooltip ?? '',
+            class: undefined,
+            enabled: true,
+            run: () => this._commandService.executeCommand(command.id, ...(command.arguments ?? [])),
+        }));
         if (options.includeDisabledActions && actions.validActions.length > 0 && actions.allActions.length !== actions.validActions.length) {
             resultActions.push(this._showDisabled ? {
                 id: 'hideMoreActions',
-                label: localize('hideMoreActions', 'Hide Disabled'),
+                label: localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionController', 'hideMoreActions', 'Hide Disabled'),
                 enabled: true,
                 tooltip: '',
                 class: undefined,
@@ -286,7 +268,7 @@
                 }
             } : {
                 id: 'showMoreActions',
-                label: localize('showMoreActions', 'Show Disabled'),
+                label: localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionController', 'showMoreActions', 'Show Disabled'),
                 enabled: true,
                 tooltip: '',
                 class: undefined,
diff -urN -x '*.map' a/vs/editor/contrib/codeAction/browser/codeActionKeybindingResolver.js b/vs/editor/contrib/codeAction/browser/codeActionKeybindingResolver.js
--- a/vs/editor/contrib/codeAction/browser/codeActionKeybindingResolver.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/codeAction/browser/codeActionKeybindingResolver.js	2023-12-06 14:23:14.375854776 +0000
@@ -34,15 +34,18 @@
             else if (item.command === fixAllCommandId) {
                 commandArgs = { kind: CodeActionKind.SourceFixAll.value };
             }
-            return Object.assign({ resolvedKeybinding: item.resolvedKeybinding }, CodeActionCommandArgs.fromUser(commandArgs, {
-                kind: CodeActionKind.None,
-                apply: "never" /* CodeActionAutoApply.Never */
-            }));
+            return {
+                resolvedKeybinding: item.resolvedKeybinding,
+                ...CodeActionCommandArgs.fromUser(commandArgs, {
+                    kind: CodeActionKind.None,
+                    apply: "never" /* CodeActionAutoApply.Never */
+                })
+            };
         }));
         return (action) => {
             if (action.kind) {
                 const binding = this.bestKeybindingForCodeAction(action, allCodeActionBindings.value);
-                return binding === null || binding === void 0 ? void 0 : binding.resolvedKeybinding;
+                return binding?.resolvedKeybinding;
             }
             return undefined;
         };
diff -urN -x '*.map' a/vs/editor/contrib/codeAction/browser/codeActionMenu.js b/vs/editor/contrib/codeAction/browser/codeActionMenu.js
--- a/vs/editor/contrib/codeAction/browser/codeActionMenu.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/codeAction/browser/codeActionMenu.js	2023-12-06 14:23:14.375854776 +0000
@@ -6,29 +6,28 @@
 import { Codicon } from '../../../../base/common/codicons.js';
 import { CodeActionKind } from '../common/types.js';
 import '../../symbolIcons/browser/symbolIcons.js'; // The codicon symbol colors are defined here and must be loaded to get colors
-import { localize } from '../../../../nls.js';
-const uncategorizedCodeActionGroup = Object.freeze({ kind: CodeActionKind.Empty, title: localize('codeAction.widget.id.more', 'More Actions...') });
+import { localizeWithPath } from '../../../../nls.js';
+const uncategorizedCodeActionGroup = Object.freeze({ kind: CodeActionKind.Empty, title: localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionMenu', 'codeAction.widget.id.more', 'More Actions...') });
 const codeActionGroups = Object.freeze([
-    { kind: CodeActionKind.QuickFix, title: localize('codeAction.widget.id.quickfix', 'Quick Fix') },
-    { kind: CodeActionKind.RefactorExtract, title: localize('codeAction.widget.id.extract', 'Extract'), icon: Codicon.wrench },
-    { kind: CodeActionKind.RefactorInline, title: localize('codeAction.widget.id.inline', 'Inline'), icon: Codicon.wrench },
-    { kind: CodeActionKind.RefactorRewrite, title: localize('codeAction.widget.id.convert', 'Rewrite'), icon: Codicon.wrench },
-    { kind: CodeActionKind.RefactorMove, title: localize('codeAction.widget.id.move', 'Move'), icon: Codicon.wrench },
-    { kind: CodeActionKind.SurroundWith, title: localize('codeAction.widget.id.surround', 'Surround With'), icon: Codicon.symbolSnippet },
-    { kind: CodeActionKind.Source, title: localize('codeAction.widget.id.source', 'Source Action'), icon: Codicon.symbolFile },
+    { kind: CodeActionKind.QuickFix, title: localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionMenu', 'codeAction.widget.id.quickfix', 'Quick Fix') },
+    { kind: CodeActionKind.RefactorExtract, title: localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionMenu', 'codeAction.widget.id.extract', 'Extract'), icon: Codicon.wrench },
+    { kind: CodeActionKind.RefactorInline, title: localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionMenu', 'codeAction.widget.id.inline', 'Inline'), icon: Codicon.wrench },
+    { kind: CodeActionKind.RefactorRewrite, title: localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionMenu', 'codeAction.widget.id.convert', 'Rewrite'), icon: Codicon.wrench },
+    { kind: CodeActionKind.RefactorMove, title: localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionMenu', 'codeAction.widget.id.move', 'Move'), icon: Codicon.wrench },
+    { kind: CodeActionKind.SurroundWith, title: localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionMenu', 'codeAction.widget.id.surround', 'Surround With'), icon: Codicon.symbolSnippet },
+    { kind: CodeActionKind.Source, title: localizeWithPath('vs/editor/contrib/codeAction/browser/codeActionMenu', 'codeAction.widget.id.source', 'Source Action'), icon: Codicon.symbolFile },
     uncategorizedCodeActionGroup,
 ]);
 export function toMenuItems(inputCodeActions, showHeaders, keybindingResolver) {
     if (!showHeaders) {
         return inputCodeActions.map((action) => {
-            var _a;
             return {
                 kind: "action" /* ActionListItemKind.Action */,
                 item: action,
                 group: uncategorizedCodeActionGroup,
                 disabled: !!action.action.disabled,
                 label: action.action.disabled || action.action.title,
-                canPreview: !!((_a = action.action.edit) === null || _a === void 0 ? void 0 : _a.edits.length),
+                canPreview: !!action.action.edit?.edits.length,
             };
         });
     }
diff -urN -x '*.map' a/vs/editor/contrib/codeAction/browser/codeActionModel.js b/vs/editor/contrib/codeAction/browser/codeActionModel.js
--- a/vs/editor/contrib/codeAction/browser/codeActionModel.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/codeAction/browser/codeActionModel.js	2023-12-06 14:23:14.375854776 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { createCancelablePromise, TimeoutTimer } from '../../../../base/common/async.js';
 import { isCancellationError } from '../../../../base/common/errors.js';
 import { Emitter } from '../../../../base/common/event.js';
@@ -141,9 +132,8 @@
         this.setState(CodeActionsState.Empty, true);
     }
     _settingEnabledNearbyQuickfixes() {
-        var _a;
-        const model = (_a = this._editor) === null || _a === void 0 ? void 0 : _a.getModel();
-        return this._configurationService ? this._configurationService.getValue('editor.codeActionWidget.includeNearbyQuickfixes', { resource: model === null || model === void 0 ? void 0 : model.uri }) : false;
+        const model = this._editor?.getModel();
+        return this._configurationService ? this._configurationService.getValue('editor.codeActionWidget.includeNearbyQuickfixes', { resource: model?.uri }) : false;
     }
     _update() {
         if (this._disposed) {
@@ -155,24 +145,22 @@
         if (model
             && this._registry.has(model)
             && !this._editor.getOption(90 /* EditorOption.readOnly */)) {
-            const supportedActions = this._registry.all(model).flatMap(provider => { var _a; return (_a = provider.providedCodeActionKinds) !== null && _a !== void 0 ? _a : []; });
+            const supportedActions = this._registry.all(model).flatMap(provider => provider.providedCodeActionKinds ?? []);
             this._supportedCodeActions.set(supportedActions.join(' '));
             this._codeActionOracle.value = new CodeActionOracle(this._editor, this._markerService, trigger => {
-                var _a;
                 if (!trigger) {
                     this.setState(CodeActionsState.Empty);
                     return;
                 }
                 const startPosition = trigger.selection.getStartPosition();
-                const actions = createCancelablePromise((token) => __awaiter(this, void 0, void 0, function* () {
-                    var _b, _c, _d, _e, _f, _g;
-                    if (this._settingEnabledNearbyQuickfixes() && trigger.trigger.type === 1 /* CodeActionTriggerType.Invoke */ && (trigger.trigger.triggerAction === CodeActionTriggerSource.QuickFix || ((_c = (_b = trigger.trigger.filter) === null || _b === void 0 ? void 0 : _b.include) === null || _c === void 0 ? void 0 : _c.contains(CodeActionKind.QuickFix)))) {
-                        const codeActionSet = yield getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token);
+                const actions = createCancelablePromise(async (token) => {
+                    if (this._settingEnabledNearbyQuickfixes() && trigger.trigger.type === 1 /* CodeActionTriggerType.Invoke */ && (trigger.trigger.triggerAction === CodeActionTriggerSource.QuickFix || trigger.trigger.filter?.include?.contains(CodeActionKind.QuickFix))) {
+                        const codeActionSet = await getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token);
                         if (token.isCancellationRequested) {
                             return emptyCodeActionSet;
                         }
                         // Search for quickfixes in the curret code action set.
-                        const foundQuickfix = (_d = codeActionSet.validActions) === null || _d === void 0 ? void 0 : _d.some(action => action.action.kind ? CodeActionKind.QuickFix.contains(new CodeActionKind(action.action.kind)) : false);
+                        const foundQuickfix = codeActionSet.validActions?.some(action => action.action.kind ? CodeActionKind.QuickFix.contains(new CodeActionKind(action.action.kind)) : false);
                         if (!foundQuickfix) {
                             const allMarkers = this._markerService.read({ resource: model.uri });
                             // If markers exists, and there are no quickfixes found or length is zero, check for quickfixes on that line.
@@ -197,12 +185,12 @@
                                     const newCodeActionTrigger = {
                                         type: trigger.trigger.type,
                                         triggerAction: trigger.trigger.triggerAction,
-                                        filter: { include: ((_e = trigger.trigger.filter) === null || _e === void 0 ? void 0 : _e.include) ? (_f = trigger.trigger.filter) === null || _f === void 0 ? void 0 : _f.include : CodeActionKind.QuickFix },
+                                        filter: { include: trigger.trigger.filter?.include ? trigger.trigger.filter?.include : CodeActionKind.QuickFix },
                                         autoApply: trigger.trigger.autoApply,
-                                        context: { notAvailableMessage: ((_g = trigger.trigger.context) === null || _g === void 0 ? void 0 : _g.notAvailableMessage) || '', position: trackedPosition }
+                                        context: { notAvailableMessage: trigger.trigger.context?.notAvailableMessage || '', position: trackedPosition }
                                     };
                                     const selectionAsPosition = new Selection(trackedPosition.lineNumber, trackedPosition.column, trackedPosition.lineNumber, trackedPosition.column);
-                                    const actionsAtMarker = yield getCodeActions(this._registry, model, selectionAsPosition, newCodeActionTrigger, Progress.None, token);
+                                    const actionsAtMarker = await getCodeActions(this._registry, model, selectionAsPosition, newCodeActionTrigger, Progress.None, token);
                                     const currentActions = [...codeActionSet.validActions];
                                     if (actionsAtMarker.validActions.length !== 0) {
                                         actionsAtMarker.validActions.forEach(action => {
@@ -218,9 +206,9 @@
                     }
                     // temporarilly hiding here as this is enabled/disabled behind a setting.
                     return getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token);
-                }));
+                });
                 if (trigger.trigger.type === 1 /* CodeActionTriggerType.Invoke */) {
-                    (_a = this._progressService) === null || _a === void 0 ? void 0 : _a.showWhile(actions, 250);
+                    this._progressService?.showWhile(actions, 250);
                 }
                 this.setState(new CodeActionsState.Triggered(trigger.trigger, startPosition, actions));
             }, undefined);
@@ -231,8 +219,7 @@
         }
     }
     trigger(trigger) {
-        var _a;
-        (_a = this._codeActionOracle.value) === null || _a === void 0 ? void 0 : _a.trigger(trigger);
+        this._codeActionOracle.value?.trigger(trigger);
     }
     setState(newState, skipNotify) {
         if (newState === this._state) {
diff -urN -x '*.map' a/vs/editor/contrib/codeAction/browser/lightBulbWidget.js b/vs/editor/contrib/codeAction/browser/lightBulbWidget.js
--- a/vs/editor/contrib/codeAction/browser/lightBulbWidget.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/codeAction/browser/lightBulbWidget.js	2023-12-06 14:23:14.375854776 +0000
@@ -91,9 +91,8 @@
             }
         }));
         this._register(Event.runAndSubscribe(keybindingService.onDidUpdateKeybindings, () => {
-            var _a, _b, _c, _d;
-            this._preferredKbLabel = (_b = (_a = keybindingService.lookupKeybinding(autoFixCommandId)) === null || _a === void 0 ? void 0 : _a.getLabel()) !== null && _b !== void 0 ? _b : undefined;
-            this._quickFixKbLabel = (_d = (_c = keybindingService.lookupKeybinding(quickFixCommandId)) === null || _c === void 0 ? void 0 : _c.getLabel()) !== null && _d !== void 0 ? _d : undefined;
+            this._preferredKbLabel = keybindingService.lookupKeybinding(autoFixCommandId)?.getLabel() ?? undefined;
+            this._quickFixKbLabel = keybindingService.lookupKeybinding(quickFixCommandId)?.getLabel() ?? undefined;
             this._updateLightBulbTitleAndIcon();
         }));
     }
@@ -169,7 +168,7 @@
             this._domNode.classList.remove(...ThemeIcon.asClassNameArray(Codicon.lightBulb));
             this._domNode.classList.add(...ThemeIcon.asClassNameArray(Codicon.lightbulbAutofix));
             if (this._preferredKbLabel) {
-                this.title = nls.localize('preferredcodeActionWithKb', "Show Code Actions. Preferred Quick Fix Available ({0})", this._preferredKbLabel);
+                this.title = nls.localizeWithPath('vs/editor/contrib/codeAction/browser/lightBulbWidget', 'preferredcodeActionWithKb', "Show Code Actions. Preferred Quick Fix Available ({0})", this._preferredKbLabel);
                 return;
             }
         }
@@ -177,10 +176,10 @@
         this._domNode.classList.remove(...ThemeIcon.asClassNameArray(Codicon.lightbulbAutofix));
         this._domNode.classList.add(...ThemeIcon.asClassNameArray(Codicon.lightBulb));
         if (this._quickFixKbLabel) {
-            this.title = nls.localize('codeActionWithKb', "Show Code Actions ({0})", this._quickFixKbLabel);
+            this.title = nls.localizeWithPath('vs/editor/contrib/codeAction/browser/lightBulbWidget', 'codeActionWithKb', "Show Code Actions ({0})", this._quickFixKbLabel);
         }
         else {
-            this.title = nls.localize('codeAction', "Show Code Actions");
+            this.title = nls.localizeWithPath('vs/editor/contrib/codeAction/browser/lightBulbWidget', 'codeAction', "Show Code Actions");
         }
     }
     set title(value) {
diff -urN -x '*.map' a/vs/editor/contrib/codeAction/common/types.js b/vs/editor/contrib/codeAction/common/types.js
--- a/vs/editor/contrib/codeAction/common/types.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/codeAction/common/types.js	2023-12-06 14:23:14.375854776 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { onUnexpectedExternalError } from '../../../../base/common/errors.js';
 export class CodeActionKind {
     constructor(value) {
@@ -147,22 +138,19 @@
         this.provider = provider;
         this.highlightRange = highlightRange;
     }
-    resolve(token) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.resolveCodeAction) && !this.action.edit) {
-                let action;
-                try {
-                    action = yield this.provider.resolveCodeAction(this.action, token);
-                }
-                catch (err) {
-                    onUnexpectedExternalError(err);
-                }
-                if (action) {
-                    this.action.edit = action.edit;
-                }
+    async resolve(token) {
+        if (this.provider?.resolveCodeAction && !this.action.edit) {
+            let action;
+            try {
+                action = await this.provider.resolveCodeAction(this.action, token);
             }
-            return this;
-        });
+            catch (err) {
+                onUnexpectedExternalError(err);
+            }
+            if (action) {
+                this.action.edit = action.edit;
+            }
+        }
+        return this;
     }
 }
diff -urN -x '*.map' a/vs/editor/contrib/codelens/browser/codeLensCache.js b/vs/editor/contrib/codelens/browser/codeLensCache.js
--- a/vs/editor/contrib/codelens/browser/codeLensCache.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/codelens/browser/codeLensCache.js	2023-12-06 14:23:14.375854776 +0000
@@ -52,10 +52,9 @@
         // create a copy of the model that is without command-ids
         // but with comand-labels
         const copyItems = data.lenses.map(item => {
-            var _a;
             return {
                 range: item.symbol.range,
-                command: item.symbol.command && { id: '', title: (_a = item.symbol.command) === null || _a === void 0 ? void 0 : _a.title },
+                command: item.symbol.command && { id: '', title: item.symbol.command?.title },
             };
         });
         const copyModel = new CodeLensModel();
@@ -99,7 +98,7 @@
                 this._cache.set(key, new CacheItem(element.lineCount, model));
             }
         }
-        catch (_a) {
+        catch {
             // ignore...
         }
     }
diff -urN -x '*.map' a/vs/editor/contrib/codelens/browser/codelens.js b/vs/editor/contrib/codelens/browser/codelens.js
--- a/vs/editor/contrib/codelens/browser/codelens.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/codelens/browser/codelens.js	2023-12-06 14:23:14.375854776 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { illegalArgument, onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { DisposableStore } from '../../../../base/common/lifecycle.js';
@@ -37,50 +28,48 @@
         }
     }
 }
-export function getCodeLensModel(registry, model, token) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const provider = registry.ordered(model);
-        const providerRanks = new Map();
-        const result = new CodeLensModel();
-        const promises = provider.map((provider, i) => __awaiter(this, void 0, void 0, function* () {
-            providerRanks.set(provider, i);
-            try {
-                const list = yield Promise.resolve(provider.provideCodeLenses(model, token));
-                if (list) {
-                    result.add(list, provider);
-                }
-            }
-            catch (err) {
-                onUnexpectedExternalError(err);
-            }
-        }));
-        yield Promise.all(promises);
-        result.lenses = result.lenses.sort((a, b) => {
-            // sort by lineNumber, provider-rank, and column
-            if (a.symbol.range.startLineNumber < b.symbol.range.startLineNumber) {
-                return -1;
-            }
-            else if (a.symbol.range.startLineNumber > b.symbol.range.startLineNumber) {
-                return 1;
-            }
-            else if ((providerRanks.get(a.provider)) < (providerRanks.get(b.provider))) {
-                return -1;
+export async function getCodeLensModel(registry, model, token) {
+    const provider = registry.ordered(model);
+    const providerRanks = new Map();
+    const result = new CodeLensModel();
+    const promises = provider.map(async (provider, i) => {
+        providerRanks.set(provider, i);
+        try {
+            const list = await Promise.resolve(provider.provideCodeLenses(model, token));
+            if (list) {
+                result.add(list, provider);
             }
-            else if ((providerRanks.get(a.provider)) > (providerRanks.get(b.provider))) {
-                return 1;
-            }
-            else if (a.symbol.range.startColumn < b.symbol.range.startColumn) {
-                return -1;
-            }
-            else if (a.symbol.range.startColumn > b.symbol.range.startColumn) {
-                return 1;
-            }
-            else {
-                return 0;
-            }
-        });
-        return result;
+        }
+        catch (err) {
+            onUnexpectedExternalError(err);
+        }
+    });
+    await Promise.all(promises);
+    result.lenses = result.lenses.sort((a, b) => {
+        // sort by lineNumber, provider-rank, and column
+        if (a.symbol.range.startLineNumber < b.symbol.range.startLineNumber) {
+            return -1;
+        }
+        else if (a.symbol.range.startLineNumber > b.symbol.range.startLineNumber) {
+            return 1;
+        }
+        else if ((providerRanks.get(a.provider)) < (providerRanks.get(b.provider))) {
+            return -1;
+        }
+        else if ((providerRanks.get(a.provider)) > (providerRanks.get(b.provider))) {
+            return 1;
+        }
+        else if (a.symbol.range.startColumn < b.symbol.range.startColumn) {
+            return -1;
+        }
+        else if (a.symbol.range.startColumn > b.symbol.range.startColumn) {
+            return 1;
+        }
+        else {
+            return 0;
+        }
     });
+    return result;
 }
 CommandsRegistry.registerCommand('_executeCodeLensProvider', function (accessor, ...args) {
     let [uri, itemResolveCount] = args;
diff -urN -x '*.map' a/vs/editor/contrib/codelens/browser/codelensController.js b/vs/editor/contrib/codelens/browser/codelensController.js
--- a/vs/editor/contrib/codelens/browser/codelensController.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/codelens/browser/codelensController.js	2023-12-06 14:23:14.375854776 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { createCancelablePromise, disposableTimeout, RunOnceScheduler } from '../../../../base/common/async.js';
 import { onUnexpectedError, onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';
@@ -30,7 +21,7 @@
 import { getCodeLensModel } from './codelens.js';
 import { ICodeLensCache } from './codeLensCache.js';
 import { CodeLensHelper, CodeLensWidget } from './codelensWidget.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { ICommandService } from '../../../../platform/commands/common/commands.js';
 import { INotificationService } from '../../../../platform/notification/common/notification.js';
 import { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';
@@ -65,11 +56,10 @@
         this._updateLensStyle();
     }
     dispose() {
-        var _a;
         this._localDispose();
         this._disposables.dispose();
         this._oldCodeLensModels.dispose();
-        (_a = this._currentCodeLensModel) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._currentCodeLensModel?.dispose();
     }
     _getLayoutInfo() {
         const lineHeightFactor = Math.max(1.3, this._editor.getOption(66 /* EditorOption.lineHeight */) / this._editor.getOption(52 /* EditorOption.fontSize */));
@@ -102,14 +92,13 @@
         });
     }
     _localDispose() {
-        var _a, _b, _c;
-        (_a = this._getCodeLensModelPromise) === null || _a === void 0 ? void 0 : _a.cancel();
+        this._getCodeLensModelPromise?.cancel();
         this._getCodeLensModelPromise = undefined;
-        (_b = this._resolveCodeLensesPromise) === null || _b === void 0 ? void 0 : _b.cancel();
+        this._resolveCodeLensesPromise?.cancel();
         this._resolveCodeLensesPromise = undefined;
         this._localToDispose.clear();
         this._oldCodeLensModels.clear();
-        (_c = this._currentCodeLensModel) === null || _c === void 0 ? void 0 : _c.dispose();
+        this._currentCodeLensModel?.dispose();
     }
     _onModelChange() {
         this._localDispose();
@@ -145,9 +134,8 @@
             }
         }
         const scheduler = new RunOnceScheduler(() => {
-            var _a;
             const t1 = Date.now();
-            (_a = this._getCodeLensModelPromise) === null || _a === void 0 ? void 0 : _a.cancel();
+            this._getCodeLensModelPromise?.cancel();
             this._getCodeLensModelPromise = createCancelablePromise(token => getCodeLensModel(this._languageFeaturesService.codeLensProvider, model, token));
             this._getCodeLensModelPromise.then(result => {
                 if (this._currentCodeLensModel) {
@@ -168,7 +156,6 @@
         this._localToDispose.add(scheduler);
         this._localToDispose.add(toDisposable(() => this._resolveCodeLensesScheduler.cancel()));
         this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
-            var _a;
             this._editor.changeDecorations(decorationsAccessor => {
                 this._editor.changeViewZones(viewZonesAccessor => {
                     const toDispose = [];
@@ -196,7 +183,7 @@
             scheduler.schedule();
             // Cancel pending and active resolve requests
             this._resolveCodeLensesScheduler.cancel();
-            (_a = this._resolveCodeLensesPromise) === null || _a === void 0 ? void 0 : _a.cancel();
+            this._resolveCodeLensesPromise?.cancel();
             this._resolveCodeLensesPromise = undefined;
         }));
         this._localToDispose.add(this._editor.onDidFocusEditorWidget(() => {
@@ -233,10 +220,10 @@
                 return;
             }
             let target = e.target.element;
-            if ((target === null || target === void 0 ? void 0 : target.tagName) === 'SPAN') {
+            if (target?.tagName === 'SPAN') {
                 target = target.parentElement;
             }
-            if ((target === null || target === void 0 ? void 0 : target.tagName) === 'A') {
+            if (target?.tagName === 'A') {
                 for (const lens of this._lenses) {
                     const command = lens.getCommand(target);
                     if (command) {
@@ -332,8 +319,7 @@
         }
     }
     _resolveCodeLensesInViewport() {
-        var _a;
-        (_a = this._resolveCodeLensesPromise) === null || _a === void 0 ? void 0 : _a.cancel();
+        this._resolveCodeLensesPromise?.cancel();
         this._resolveCodeLensesPromise = undefined;
         const model = this._editor.getModel();
         if (!model) {
@@ -393,15 +379,12 @@
             }
         });
     }
-    getModel() {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            yield this._getCodeLensModelPromise;
-            yield this._resolveCodeLensesPromise;
-            return !((_a = this._currentCodeLensModel) === null || _a === void 0 ? void 0 : _a.isDisposed)
-                ? this._currentCodeLensModel
-                : undefined;
-        });
+    async getModel() {
+        await this._getCodeLensModelPromise;
+        await this._resolveCodeLensesPromise;
+        return !this._currentCodeLensModel?.isDisposed
+            ? this._currentCodeLensModel
+            : undefined;
     }
 };
 CodeLensContribution.ID = 'css.editor.codeLens';
@@ -419,67 +402,65 @@
         super({
             id: 'codelens.showLensesInCurrentLine',
             precondition: EditorContextKeys.hasCodeLensProvider,
-            label: localize('showLensOnLine', "Show CodeLens Commands For Current Line"),
+            label: localizeWithPath('vs/editor/contrib/codelens/browser/codelensController', 'showLensOnLine', "Show CodeLens Commands For Current Line"),
             alias: 'Show CodeLens Commands For Current Line',
         });
     }
-    run(accessor, editor) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!editor.hasModel()) {
-                return;
-            }
-            const quickInputService = accessor.get(IQuickInputService);
-            const commandService = accessor.get(ICommandService);
-            const notificationService = accessor.get(INotificationService);
-            const lineNumber = editor.getSelection().positionLineNumber;
-            const codelensController = editor.getContribution(CodeLensContribution.ID);
-            if (!codelensController) {
-                return;
-            }
-            const model = yield codelensController.getModel();
-            if (!model) {
-                // nothing
-                return;
-            }
-            const items = [];
-            for (const lens of model.lenses) {
-                if (lens.symbol.command && lens.symbol.range.startLineNumber === lineNumber) {
-                    items.push({
-                        label: lens.symbol.command.title,
-                        command: lens.symbol.command
-                    });
-                }
-            }
-            if (items.length === 0) {
-                // We dont want an empty picker
-                return;
+    async run(accessor, editor) {
+        if (!editor.hasModel()) {
+            return;
+        }
+        const quickInputService = accessor.get(IQuickInputService);
+        const commandService = accessor.get(ICommandService);
+        const notificationService = accessor.get(INotificationService);
+        const lineNumber = editor.getSelection().positionLineNumber;
+        const codelensController = editor.getContribution(CodeLensContribution.ID);
+        if (!codelensController) {
+            return;
+        }
+        const model = await codelensController.getModel();
+        if (!model) {
+            // nothing
+            return;
+        }
+        const items = [];
+        for (const lens of model.lenses) {
+            if (lens.symbol.command && lens.symbol.range.startLineNumber === lineNumber) {
+                items.push({
+                    label: lens.symbol.command.title,
+                    command: lens.symbol.command
+                });
             }
-            const item = yield quickInputService.pick(items, {
-                canPickMany: false,
-                placeHolder: localize('placeHolder', "Select a command")
-            });
-            if (!item) {
-                // Nothing picked
+        }
+        if (items.length === 0) {
+            // We dont want an empty picker
+            return;
+        }
+        const item = await quickInputService.pick(items, {
+            canPickMany: false,
+            placeHolder: localizeWithPath('vs/editor/contrib/codelens/browser/codelensController', 'placeHolder', "Select a command")
+        });
+        if (!item) {
+            // Nothing picked
+            return;
+        }
+        let command = item.command;
+        if (model.isDisposed) {
+            // try to find the same command again in-case the model has been re-created in the meantime
+            // this is a best attempt approach which shouldn't be needed because eager model re-creates
+            // shouldn't happen due to focus in/out anymore
+            const newModel = await codelensController.getModel();
+            const newLens = newModel?.lenses.find(lens => lens.symbol.range.startLineNumber === lineNumber && lens.symbol.command?.title === command.title);
+            if (!newLens || !newLens.symbol.command) {
                 return;
             }
-            let command = item.command;
-            if (model.isDisposed) {
-                // try to find the same command again in-case the model has been re-created in the meantime
-                // this is a best attempt approach which shouldn't be needed because eager model re-creates
-                // shouldn't happen due to focus in/out anymore
-                const newModel = yield codelensController.getModel();
-                const newLens = newModel === null || newModel === void 0 ? void 0 : newModel.lenses.find(lens => { var _a; return lens.symbol.range.startLineNumber === lineNumber && ((_a = lens.symbol.command) === null || _a === void 0 ? void 0 : _a.title) === command.title; });
-                if (!newLens || !newLens.symbol.command) {
-                    return;
-                }
-                command = newLens.symbol.command;
-            }
-            try {
-                yield commandService.executeCommand(command.id, ...(command.arguments || []));
-            }
-            catch (err) {
-                notificationService.error(err);
-            }
-        });
+            command = newLens.symbol.command;
+        }
+        try {
+            await commandService.executeCommand(command.id, ...(command.arguments || []));
+        }
+        catch (err) {
+            notificationService.error(err);
+        }
     }
 });
diff -urN -x '*.map' a/vs/editor/contrib/codelens/browser/codelensWidget.js b/vs/editor/contrib/codelens/browser/codelensWidget.js
--- a/vs/editor/contrib/codelens/browser/codelensWidget.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/codelens/browser/codelensWidget.js	2023-12-06 14:23:14.375854776 +0000
@@ -176,7 +176,7 @@
     dispose(helper, viewZoneChangeAccessor) {
         this._decorationIds.forEach(helper.removeDecoration, helper);
         this._decorationIds = [];
-        viewZoneChangeAccessor === null || viewZoneChangeAccessor === void 0 ? void 0 : viewZoneChangeAccessor.removeZone(this._viewZoneId);
+        viewZoneChangeAccessor?.removeZone(this._viewZoneId);
         if (this._contentWidget) {
             this._editor.removeContentWidget(this._contentWidget);
             this._contentWidget = undefined;
@@ -236,8 +236,7 @@
         }
     }
     getCommand(link) {
-        var _a;
-        return (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.getCommand(link);
+        return this._contentWidget?.getCommand(link);
     }
     getLineNumber() {
         const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
@@ -259,4 +258,7 @@
             }
         }
     }
+    getItems() {
+        return this._data;
+    }
 }
diff -urN -x '*.map' a/vs/editor/contrib/colorPicker/browser/color.js b/vs/editor/contrib/colorPicker/browser/color.js
--- a/vs/editor/contrib/colorPicker/browser/color.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/colorPicker/browser/color.js	2023-12-06 14:23:14.375854776 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { illegalArgument, onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { URI } from '../../../../base/common/uri.js';
@@ -20,87 +11,77 @@
 import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
 import { DefaultDocumentColorProvider } from './defaultDocumentColorProvider.js';
 import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
-export function getColors(colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled = true) {
-    return __awaiter(this, void 0, void 0, function* () {
-        return _findColorData(new ColorDataCollector(), colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled);
-    });
+export async function getColors(colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled = true) {
+    return _findColorData(new ColorDataCollector(), colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled);
 }
 export function getColorPresentations(model, colorInfo, provider, token) {
     return Promise.resolve(provider.provideColorPresentations(model, colorInfo, token));
 }
 class ColorDataCollector {
     constructor() { }
-    compute(provider, model, token, colors) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const documentColors = yield provider.provideDocumentColors(model, token);
-            if (Array.isArray(documentColors)) {
-                for (const colorInfo of documentColors) {
-                    colors.push({ colorInfo, provider });
-                }
+    async compute(provider, model, token, colors) {
+        const documentColors = await provider.provideDocumentColors(model, token);
+        if (Array.isArray(documentColors)) {
+            for (const colorInfo of documentColors) {
+                colors.push({ colorInfo, provider });
             }
-            return Array.isArray(documentColors);
-        });
+        }
+        return Array.isArray(documentColors);
     }
 }
 class ExtColorDataCollector {
     constructor() { }
-    compute(provider, model, token, colors) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const documentColors = yield provider.provideDocumentColors(model, token);
-            if (Array.isArray(documentColors)) {
-                for (const colorInfo of documentColors) {
-                    colors.push({ range: colorInfo.range, color: [colorInfo.color.red, colorInfo.color.green, colorInfo.color.blue, colorInfo.color.alpha] });
-                }
+    async compute(provider, model, token, colors) {
+        const documentColors = await provider.provideDocumentColors(model, token);
+        if (Array.isArray(documentColors)) {
+            for (const colorInfo of documentColors) {
+                colors.push({ range: colorInfo.range, color: [colorInfo.color.red, colorInfo.color.green, colorInfo.color.blue, colorInfo.color.alpha] });
             }
-            return Array.isArray(documentColors);
-        });
+        }
+        return Array.isArray(documentColors);
     }
 }
 class ColorPresentationsCollector {
     constructor(colorInfo) {
         this.colorInfo = colorInfo;
     }
-    compute(provider, model, _token, colors) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const documentColors = yield provider.provideColorPresentations(model, this.colorInfo, CancellationToken.None);
-            if (Array.isArray(documentColors)) {
-                colors.push(...documentColors);
-            }
-            return Array.isArray(documentColors);
-        });
+    async compute(provider, model, _token, colors) {
+        const documentColors = await provider.provideColorPresentations(model, this.colorInfo, CancellationToken.None);
+        if (Array.isArray(documentColors)) {
+            colors.push(...documentColors);
+        }
+        return Array.isArray(documentColors);
     }
 }
-function _findColorData(collector, colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled) {
-    return __awaiter(this, void 0, void 0, function* () {
-        let validDocumentColorProviderFound = false;
-        let defaultProvider;
-        const colorData = [];
-        const documentColorProviders = colorProviderRegistry.ordered(model);
-        for (let i = documentColorProviders.length - 1; i >= 0; i--) {
-            const provider = documentColorProviders[i];
-            if (provider instanceof DefaultDocumentColorProvider) {
-                defaultProvider = provider;
-            }
-            else {
-                try {
-                    if (yield collector.compute(provider, model, token, colorData)) {
-                        validDocumentColorProviderFound = true;
-                    }
-                }
-                catch (e) {
-                    onUnexpectedExternalError(e);
+async function _findColorData(collector, colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled) {
+    let validDocumentColorProviderFound = false;
+    let defaultProvider;
+    const colorData = [];
+    const documentColorProviders = colorProviderRegistry.ordered(model);
+    for (let i = documentColorProviders.length - 1; i >= 0; i--) {
+        const provider = documentColorProviders[i];
+        if (provider instanceof DefaultDocumentColorProvider) {
+            defaultProvider = provider;
+        }
+        else {
+            try {
+                if (await collector.compute(provider, model, token, colorData)) {
+                    validDocumentColorProviderFound = true;
                 }
             }
+            catch (e) {
+                onUnexpectedExternalError(e);
+            }
         }
-        if (validDocumentColorProviderFound) {
-            return colorData;
-        }
-        if (defaultProvider && isDefaultColorDecoratorsEnabled) {
-            yield collector.compute(defaultProvider, model, token, colorData);
-            return colorData;
-        }
-        return [];
-    });
+    }
+    if (validDocumentColorProviderFound) {
+        return colorData;
+    }
+    if (defaultProvider && isDefaultColorDecoratorsEnabled) {
+        await collector.compute(defaultProvider, model, token, colorData);
+        return colorData;
+    }
+    return [];
 }
 function _setupColorCommand(accessor, resource) {
     const { colorProvider: colorProviderRegistry } = accessor.get(ILanguageFeaturesService);
diff -urN -x '*.map' a/vs/editor/contrib/colorPicker/browser/colorContributions.js b/vs/editor/contrib/colorPicker/browser/colorContributions.js
--- a/vs/editor/contrib/colorPicker/browser/colorContributions.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/colorPicker/browser/colorContributions.js	2023-12-06 14:23:14.375854776 +0000
@@ -46,6 +46,7 @@
         }
     }
 }
-ColorContribution.ID = 'editor.contrib.colorContribution'; // ms
+ColorContribution.ID = 'editor.contrib.colorContribution';
+ColorContribution.RECOMPUTE_TIME = 1000; // ms
 registerEditorContribution(ColorContribution.ID, ColorContribution, 2 /* EditorContributionInstantiation.BeforeFirstInteraction */);
 HoverParticipantRegistry.register(ColorHoverParticipant);
diff -urN -x '*.map' a/vs/editor/contrib/colorPicker/browser/colorDetector.js b/vs/editor/contrib/colorPicker/browser/colorDetector.js
--- a/vs/editor/contrib/colorPicker/browser/colorDetector.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/colorPicker/browser/colorDetector.js	2023-12-06 14:23:14.375854776 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var ColorDetector_1;
 import { createCancelablePromise, TimeoutTimer } from '../../../../base/common/async.js';
 import { RGBA } from '../../../../base/common/color.js';
@@ -94,6 +85,9 @@
         }
         return this._editor.getOption(20 /* EditorOption.colorDecorators */);
     }
+    get limitReporter() {
+        return this._decoratorLimitReporter;
+    }
     static get(editor) {
         return editor.getContribution(this.ID);
     }
@@ -122,28 +116,26 @@
         }));
         this.beginCompute();
     }
-    beginCompute() {
-        return __awaiter(this, void 0, void 0, function* () {
-            this._computePromise = createCancelablePromise((token) => __awaiter(this, void 0, void 0, function* () {
-                const model = this._editor.getModel();
-                if (!model) {
-                    return [];
-                }
-                const sw = new StopWatch(false);
-                const colors = yield getColors(this._languageFeaturesService.colorProvider, model, token, this._isDefaultColorDecoratorsEnabled);
-                this._debounceInformation.update(model, sw.elapsed());
-                return colors;
-            }));
-            try {
-                const colors = yield this._computePromise;
-                this.updateDecorations(colors);
-                this.updateColorDecorators(colors);
-                this._computePromise = null;
-            }
-            catch (e) {
-                onUnexpectedError(e);
+    async beginCompute() {
+        this._computePromise = createCancelablePromise(async (token) => {
+            const model = this._editor.getModel();
+            if (!model) {
+                return [];
             }
+            const sw = new StopWatch(false);
+            const colors = await getColors(this._languageFeaturesService.colorProvider, model, token, this._isDefaultColorDecoratorsEnabled);
+            this._debounceInformation.update(model, sw.elapsed());
+            return colors;
         });
+        try {
+            const colors = await this._computePromise;
+            this.updateDecorations(colors);
+            this.updateColorDecorators(colors);
+            this._computePromise = null;
+        }
+        catch (e) {
+            onUnexpectedError(e);
+        }
     }
     stop() {
         if (this._timeoutTimer) {
@@ -239,9 +231,16 @@
 export class DecoratorLimitReporter {
     constructor() {
         this._onDidChange = new Emitter();
+        this.onDidChange = this._onDidChange.event;
         this._computed = 0;
         this._limited = false;
     }
+    get computed() {
+        return this._computed;
+    }
+    get limited() {
+        return this._limited;
+    }
     update(computed, limited) {
         if (computed !== this._computed || limited !== this._limited) {
             this._computed = computed;
diff -urN -x '*.map' a/vs/editor/contrib/colorPicker/browser/colorHoverParticipant.js b/vs/editor/contrib/colorPicker/browser/colorHoverParticipant.js
--- a/vs/editor/contrib/colorPicker/browser/colorHoverParticipant.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/colorPicker/browser/colorHoverParticipant.js	2023-12-06 14:23:14.375854776 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { AsyncIterableObject } from '../../../../base/common/async.js';
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { Color, RGBA } from '../../../../base/common/color.js';
@@ -61,27 +52,25 @@
     computeAsync(anchor, lineDecorations, token) {
         return AsyncIterableObject.fromPromise(this._computeAsync(anchor, lineDecorations, token));
     }
-    _computeAsync(_anchor, lineDecorations, _token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!this._editor.hasModel()) {
-                return [];
-            }
-            const colorDetector = ColorDetector.get(this._editor);
-            if (!colorDetector) {
-                return [];
-            }
-            for (const d of lineDecorations) {
-                if (!colorDetector.isColorDecoration(d)) {
-                    continue;
-                }
-                const colorData = colorDetector.getColorData(d.range.getStartPosition());
-                if (colorData) {
-                    const colorHover = yield _createColorHover(this, this._editor.getModel(), colorData.colorInfo, colorData.provider);
-                    return [colorHover];
-                }
-            }
+    async _computeAsync(_anchor, lineDecorations, _token) {
+        if (!this._editor.hasModel()) {
             return [];
-        });
+        }
+        const colorDetector = ColorDetector.get(this._editor);
+        if (!colorDetector) {
+            return [];
+        }
+        for (const d of lineDecorations) {
+            if (!colorDetector.isColorDecoration(d)) {
+                continue;
+            }
+            const colorData = colorDetector.getColorData(d.range.getStartPosition());
+            if (colorData) {
+                const colorHover = await _createColorHover(this, this._editor.getModel(), colorData.colorInfo, colorData.provider);
+                return [colorHover];
+            }
+        }
+        return [];
     }
     renderHoverParts(context, hoverParts) {
         return renderHoverParts(this, this._editor, this._themeService, hoverParts, context);
@@ -103,45 +92,42 @@
     constructor(_editor, _themeService) {
         this._editor = _editor;
         this._themeService = _themeService;
+        this.hoverOrdinal = 2;
         this._color = null;
     }
-    createColorHover(defaultColorInfo, defaultColorProvider, colorProviderRegistry) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!this._editor.hasModel()) {
-                return null;
-            }
-            const colorDetector = ColorDetector.get(this._editor);
-            if (!colorDetector) {
-                return null;
-            }
-            const colors = yield getColors(colorProviderRegistry, this._editor.getModel(), CancellationToken.None);
-            let foundColorInfo = null;
-            let foundColorProvider = null;
-            for (const colorData of colors) {
-                const colorInfo = colorData.colorInfo;
-                if (Range.containsRange(colorInfo.range, defaultColorInfo.range)) {
-                    foundColorInfo = colorInfo;
-                    foundColorProvider = colorData.provider;
-                }
-            }
-            const colorInfo = foundColorInfo !== null && foundColorInfo !== void 0 ? foundColorInfo : defaultColorInfo;
-            const colorProvider = foundColorProvider !== null && foundColorProvider !== void 0 ? foundColorProvider : defaultColorProvider;
-            const foundInEditor = !!foundColorInfo;
-            return { colorHover: yield _createColorHover(this, this._editor.getModel(), colorInfo, colorProvider), foundInEditor: foundInEditor };
-        });
-    }
-    updateEditorModel(colorHoverData) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!this._editor.hasModel()) {
-                return;
-            }
-            const colorPickerModel = colorHoverData.model;
-            let range = new Range(colorHoverData.range.startLineNumber, colorHoverData.range.startColumn, colorHoverData.range.endLineNumber, colorHoverData.range.endColumn);
-            if (this._color) {
-                yield _updateColorPresentations(this._editor.getModel(), colorPickerModel, this._color, range, colorHoverData);
-                range = _updateEditorModel(this._editor, range, colorPickerModel);
+    async createColorHover(defaultColorInfo, defaultColorProvider, colorProviderRegistry) {
+        if (!this._editor.hasModel()) {
+            return null;
+        }
+        const colorDetector = ColorDetector.get(this._editor);
+        if (!colorDetector) {
+            return null;
+        }
+        const colors = await getColors(colorProviderRegistry, this._editor.getModel(), CancellationToken.None);
+        let foundColorInfo = null;
+        let foundColorProvider = null;
+        for (const colorData of colors) {
+            const colorInfo = colorData.colorInfo;
+            if (Range.containsRange(colorInfo.range, defaultColorInfo.range)) {
+                foundColorInfo = colorInfo;
+                foundColorProvider = colorData.provider;
             }
-        });
+        }
+        const colorInfo = foundColorInfo ?? defaultColorInfo;
+        const colorProvider = foundColorProvider ?? defaultColorProvider;
+        const foundInEditor = !!foundColorInfo;
+        return { colorHover: await _createColorHover(this, this._editor.getModel(), colorInfo, colorProvider), foundInEditor: foundInEditor };
+    }
+    async updateEditorModel(colorHoverData) {
+        if (!this._editor.hasModel()) {
+            return;
+        }
+        const colorPickerModel = colorHoverData.model;
+        let range = new Range(colorHoverData.range.startLineNumber, colorHoverData.range.startColumn, colorHoverData.range.endLineNumber, colorHoverData.range.endColumn);
+        if (this._color) {
+            await _updateColorPresentations(this._editor.getModel(), colorPickerModel, this._color, range, colorHoverData);
+            range = _updateEditorModel(this._editor, range, colorPickerModel);
+        }
     }
     renderHoverParts(context, hoverParts) {
         return renderHoverParts(this, this._editor, this._themeService, hoverParts, context);
@@ -157,23 +143,21 @@
     __param(1, IThemeService)
 ], StandaloneColorPickerParticipant);
 export { StandaloneColorPickerParticipant };
-function _createColorHover(participant, editorModel, colorInfo, provider) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const originalText = editorModel.getValueInRange(colorInfo.range);
-        const { red, green, blue, alpha } = colorInfo.color;
-        const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
-        const color = new Color(rgba);
-        const colorPresentations = yield getColorPresentations(editorModel, colorInfo, provider, CancellationToken.None);
-        const model = new ColorPickerModel(color, [], 0);
-        model.colorPresentations = colorPresentations || [];
-        model.guessColorPresentation(color, originalText);
-        if (participant instanceof ColorHoverParticipant) {
-            return new ColorHover(participant, Range.lift(colorInfo.range), model, provider);
-        }
-        else {
-            return new StandaloneColorPickerHover(participant, Range.lift(colorInfo.range), model, provider);
-        }
-    });
+async function _createColorHover(participant, editorModel, colorInfo, provider) {
+    const originalText = editorModel.getValueInRange(colorInfo.range);
+    const { red, green, blue, alpha } = colorInfo.color;
+    const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
+    const color = new Color(rgba);
+    const colorPresentations = await getColorPresentations(editorModel, colorInfo, provider, CancellationToken.None);
+    const model = new ColorPickerModel(color, [], 0);
+    model.colorPresentations = colorPresentations || [];
+    model.guessColorPresentation(color, originalText);
+    if (participant instanceof ColorHoverParticipant) {
+        return new ColorHover(participant, Range.lift(colorInfo.range), model, provider);
+    }
+    else {
+        return new StandaloneColorPickerHover(participant, Range.lift(colorInfo.range), model, provider);
+    }
 }
 function renderHoverParts(participant, editor, themeService, hoverParts, context) {
     if (hoverParts.length === 0 || !editor.hasModel()) {
@@ -200,11 +184,11 @@
         }));
     }
     else {
-        disposables.add(model.onColorFlushed((color) => __awaiter(this, void 0, void 0, function* () {
-            yield _updateColorPresentations(editorModel, model, color, range, colorHover);
+        disposables.add(model.onColorFlushed(async (color) => {
+            await _updateColorPresentations(editorModel, model, color, range, colorHover);
             editorUpdatedByColorPicker = true;
             range = _updateEditorModel(editor, range, model, context);
-        })));
+        }));
     }
     disposables.add(model.onDidChangeColor((color) => {
         _updateColorPresentations(editorModel, model, color, range, colorHover);
@@ -247,17 +231,15 @@
     editor.pushUndoStop();
     return newRange;
 }
-function _updateColorPresentations(editorModel, colorPickerModel, color, range, colorHover) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const colorPresentations = yield getColorPresentations(editorModel, {
-            range: range,
-            color: {
-                red: color.rgba.r / 255,
-                green: color.rgba.g / 255,
-                blue: color.rgba.b / 255,
-                alpha: color.rgba.a
-            }
-        }, colorHover.provider, CancellationToken.None);
-        colorPickerModel.colorPresentations = colorPresentations || [];
-    });
+async function _updateColorPresentations(editorModel, colorPickerModel, color, range, colorHover) {
+    const colorPresentations = await getColorPresentations(editorModel, {
+        range: range,
+        color: {
+            red: color.rgba.r / 255,
+            green: color.rgba.g / 255,
+            blue: color.rgba.b / 255,
+            alpha: color.rgba.a
+        }
+    }, colorHover.provider, CancellationToken.None);
+    colorPickerModel.colorPresentations = colorPresentations || [];
 }
diff -urN -x '*.map' a/vs/editor/contrib/colorPicker/browser/colorPickerWidget.js b/vs/editor/contrib/colorPicker/browser/colorPickerWidget.js
--- a/vs/editor/contrib/colorPicker/browser/colorPickerWidget.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/colorPicker/browser/colorPickerWidget.js	2023-12-06 14:23:14.375854776 +0000
@@ -12,7 +12,7 @@
 import { Disposable } from '../../../../base/common/lifecycle.js';
 import { ThemeIcon } from '../../../../base/common/themables.js';
 import './colorPicker.css';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { editorHoverBackground } from '../../../../platform/theme/common/colorRegistry.js';
 import { registerIcon } from '../../../../platform/theme/common/iconRegistry.js';
 const $ = dom.$;
@@ -28,7 +28,7 @@
         dom.append(this._pickedColorNode, $('span.codicon.codicon-color-mode'));
         this._pickedColorPresentation = dom.append(this._pickedColorNode, document.createElement('span'));
         this._pickedColorPresentation.classList.add('picked-color-presentation');
-        const tooltip = localize('clickToToggleColorOptions', "Click to toggle color options (rgb/hsl/hex)");
+        const tooltip = localizeWithPath('vs/editor/contrib/colorPicker/browser/colorPickerWidget', 'clickToToggleColorOptions', "Click to toggle color options (rgb/hsl/hex)");
         this._pickedColorNode.setAttribute('title', tooltip);
         this._originalColorNode = dom.append(this._domNode, $('.original-color'));
         this._originalColorNode.style.backgroundColor = Color.Format.CSS.format(this.model.originalColor) || '';
@@ -52,6 +52,9 @@
             this._closeButton = this._register(new CloseButton(this._domNode));
         }
     }
+    get domNode() {
+        return this._domNode;
+    }
     get closeButton() {
         return this._closeButton;
     }
@@ -81,7 +84,7 @@
         const innerDiv = document.createElement('div');
         innerDiv.classList.add('close-button-inner-div');
         dom.append(this._button, innerDiv);
-        const closeButton = dom.append(innerDiv, $('.button' + ThemeIcon.asCSSSelector(registerIcon('color-picker-close', Codicon.close, localize('closeIcon', 'Icon to close the color picker')))));
+        const closeButton = dom.append(innerDiv, $('.button' + ThemeIcon.asCSSSelector(registerIcon('color-picker-close', Codicon.close, localizeWithPath('vs/editor/contrib/colorPicker/browser/colorPickerWidget', 'closeIcon', 'Icon to close the color picker')))));
         closeButton.classList.add('close-icon');
         this._button.onclick = () => {
             this._onClicked.fire();
@@ -135,6 +138,12 @@
     get saturationBox() {
         return this._saturationBox;
     }
+    get opacityStrip() {
+        return this._opacityStrip;
+    }
+    get hueStrip() {
+        return this._hueStrip;
+    }
     get enterButton() {
         return this._insertButton;
     }
@@ -170,6 +179,9 @@
     get domNode() {
         return this._domNode;
     }
+    get canvas() {
+        return this._canvas;
+    }
     onPointerDown(e) {
         if (!e.target || !(e.target instanceof Element)) {
             return;
@@ -347,7 +359,11 @@
         this.header = this._register(new ColorPickerHeader(element, this.model, themeService, standaloneColorPicker));
         this.body = this._register(new ColorPickerBody(element, this.model, this.pixelRatio, standaloneColorPicker));
     }
+    getId() {
+        return ColorPickerWidget.ID;
+    }
     layout() {
         this.body.layout();
     }
 }
+ColorPickerWidget.ID = 'editor.contrib.colorPickerWidget';
diff -urN -x '*.map' a/vs/editor/contrib/colorPicker/browser/defaultDocumentColorProvider.js b/vs/editor/contrib/colorPicker/browser/defaultDocumentColorProvider.js
--- a/vs/editor/contrib/colorPicker/browser/defaultDocumentColorProvider.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/colorPicker/browser/defaultDocumentColorProvider.js	2023-12-06 14:23:14.375854776 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { Color, RGBA } from '../../../../base/common/color.js';
 import { EditorWorkerClient } from '../../../browser/services/editorWorkerService.js';
 import { IModelService } from '../../../common/services/model.js';
@@ -31,10 +22,8 @@
     constructor(modelService, languageConfigurationService) {
         this._editorWorkerClient = new EditorWorkerClient(modelService, false, 'editorWorkerService', languageConfigurationService);
     }
-    provideDocumentColors(model, _token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            return this._editorWorkerClient.computeDefaultDocumentColors(model.uri);
-        });
+    async provideDocumentColors(model, _token) {
+        return this._editorWorkerClient.computeDefaultDocumentColors(model.uri);
     }
     provideColorPresentations(_model, colorInfo, _token) {
         const range = colorInfo.range;
diff -urN -x '*.map' a/vs/editor/contrib/colorPicker/browser/standaloneColorPickerActions.js b/vs/editor/contrib/colorPicker/browser/standaloneColorPickerActions.js
--- a/vs/editor/contrib/colorPicker/browser/standaloneColorPickerActions.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/colorPicker/browser/standaloneColorPickerActions.js	2023-12-06 14:23:14.375854776 +0000
@@ -3,7 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { EditorAction, EditorAction2, registerEditorAction } from '../../../browser/editorExtensions.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { StandaloneColorPickerController } from './standaloneColorPickerWidget.js';
 import { EditorContextKeys } from '../../../common/editorContextKeys.js';
 import { MenuId, registerAction2 } from '../../../../platform/actions/common/actions.js';
@@ -13,8 +13,8 @@
         super({
             id: 'editor.action.showOrFocusStandaloneColorPicker',
             title: {
-                value: localize('showOrFocusStandaloneColorPicker', "Show or Focus Standalone Color Picker"),
-                mnemonicTitle: localize({ key: 'mishowOrFocusStandaloneColorPicker', comment: ['&& denotes a mnemonic'] }, "&&Show or Focus Standalone Color Picker"),
+                value: localizeWithPath('vs/editor/contrib/colorPicker/browser/standaloneColorPickerActions', 'showOrFocusStandaloneColorPicker', "Show or Focus Standalone Color Picker"),
+                mnemonicTitle: localizeWithPath('vs/editor/contrib/colorPicker/browser/standaloneColorPickerActions', { key: 'mishowOrFocusStandaloneColorPicker', comment: ['&& denotes a mnemonic'] }, "&&Show or Focus Standalone Color Picker"),
                 original: 'Show or Focus Standalone Color Picker',
             },
             precondition: undefined,
@@ -24,15 +24,14 @@
         });
     }
     runEditorCommand(_accessor, editor) {
-        var _a;
-        (_a = StandaloneColorPickerController.get(editor)) === null || _a === void 0 ? void 0 : _a.showOrFocus();
+        StandaloneColorPickerController.get(editor)?.showOrFocus();
     }
 }
 class HideStandaloneColorPicker extends EditorAction {
     constructor() {
         super({
             id: 'editor.action.hideColorPicker',
-            label: localize({
+            label: localizeWithPath('vs/editor/contrib/colorPicker/browser/standaloneColorPickerActions', {
                 key: 'hideColorPicker',
                 comment: [
                     'Action that hides the color picker'
@@ -47,15 +46,14 @@
         });
     }
     run(_accessor, editor) {
-        var _a;
-        (_a = StandaloneColorPickerController.get(editor)) === null || _a === void 0 ? void 0 : _a.hide();
+        StandaloneColorPickerController.get(editor)?.hide();
     }
 }
 class InsertColorWithStandaloneColorPicker extends EditorAction {
     constructor() {
         super({
             id: 'editor.action.insertColorWithStandaloneColorPicker',
-            label: localize({
+            label: localizeWithPath('vs/editor/contrib/colorPicker/browser/standaloneColorPickerActions', {
                 key: 'insertColorWithStandaloneColorPicker',
                 comment: [
                     'Action that inserts color with standalone color picker'
@@ -70,8 +68,7 @@
         });
     }
     run(_accessor, editor) {
-        var _a;
-        (_a = StandaloneColorPickerController.get(editor)) === null || _a === void 0 ? void 0 : _a.insertColor();
+        StandaloneColorPickerController.get(editor)?.insertColor();
     }
 }
 registerEditorAction(HideStandaloneColorPicker);
diff -urN -x '*.map' a/vs/editor/contrib/colorPicker/browser/standaloneColorPickerWidget.js b/vs/editor/contrib/colorPicker/browser/standaloneColorPickerWidget.js
--- a/vs/editor/contrib/colorPicker/browser/standaloneColorPickerWidget.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/colorPicker/browser/standaloneColorPickerWidget.js	2023-12-06 14:23:14.375854776 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var StandaloneColorPickerController_1, StandaloneColorPickerWidget_1;
 import { Disposable } from '../../../../base/common/lifecycle.js';
 import { StandaloneColorPickerParticipant } from './colorHoverParticipant.js';
@@ -50,7 +41,6 @@
         this._standaloneColorPickerFocused = EditorContextKeys.standaloneColorPickerFocused.bindTo(_contextKeyService);
     }
     showOrFocus() {
-        var _a;
         if (!this._editor.hasModel()) {
             return;
         }
@@ -58,19 +48,17 @@
             this._standaloneColorPickerWidget = new StandaloneColorPickerWidget(this._editor, this._standaloneColorPickerVisible, this._standaloneColorPickerFocused, this._instantiationService, this._modelService, this._keybindingService, this._languageFeatureService, this._languageConfigurationService);
         }
         else if (!this._standaloneColorPickerFocused.get()) {
-            (_a = this._standaloneColorPickerWidget) === null || _a === void 0 ? void 0 : _a.focus();
+            this._standaloneColorPickerWidget?.focus();
         }
     }
     hide() {
-        var _a;
         this._standaloneColorPickerFocused.set(false);
         this._standaloneColorPickerVisible.set(false);
-        (_a = this._standaloneColorPickerWidget) === null || _a === void 0 ? void 0 : _a.hide();
+        this._standaloneColorPickerWidget?.hide();
         this._editor.focus();
     }
     insertColor() {
-        var _a;
-        (_a = this._standaloneColorPickerWidget) === null || _a === void 0 ? void 0 : _a.updateEditor();
+        this._standaloneColorPickerWidget?.updateEditor();
         this.hide();
     }
     static get(editor) {
@@ -92,7 +80,6 @@
 const CLOSE_BUTTON_WIDTH = 22;
 let StandaloneColorPickerWidget = StandaloneColorPickerWidget_1 = class StandaloneColorPickerWidget extends Disposable {
     constructor(_editor, _standaloneColorPickerVisible, _standaloneColorPickerFocused, _instantiationService, _modelService, _keybindingService, _languageFeaturesService, _languageConfigurationService) {
-        var _a;
         super();
         this._editor = _editor;
         this._standaloneColorPickerVisible = _standaloneColorPickerVisible;
@@ -110,7 +97,7 @@
         this.onResult = this._onResult.event;
         this._standaloneColorPickerVisible.set(true);
         this._standaloneColorPickerParticipant = _instantiationService.createInstance(StandaloneColorPickerParticipant, this._editor);
-        this._position = (_a = this._editor._getViewModel()) === null || _a === void 0 ? void 0 : _a.getPrimaryCursorState().modelState.position;
+        this._position = this._editor._getViewModel()?.getPrimaryCursorState().modelState.position;
         const editorSelection = this._editor.getSelection();
         const selection = editorSelection ?
             {
@@ -137,8 +124,7 @@
             }
         }));
         this._register(this._editor.onMouseMove((e) => {
-            var _a;
-            const classList = (_a = e.target.element) === null || _a === void 0 ? void 0 : _a.classList;
+            const classList = e.target.element?.classList;
             if (classList && classList.contains('colorpicker-color-decoration')) {
                 this.hide();
             }
@@ -184,30 +170,26 @@
         this._standaloneColorPickerFocused.set(true);
         this._body.focus();
     }
-    _start(selection) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const computeAsyncResult = yield this._computeAsync(selection);
-            if (!computeAsyncResult) {
-                return;
-            }
-            this._onResult.fire(new StandaloneColorPickerResult(computeAsyncResult.result, computeAsyncResult.foundInEditor));
-        });
+    async _start(selection) {
+        const computeAsyncResult = await this._computeAsync(selection);
+        if (!computeAsyncResult) {
+            return;
+        }
+        this._onResult.fire(new StandaloneColorPickerResult(computeAsyncResult.result, computeAsyncResult.foundInEditor));
     }
-    _computeAsync(range) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!this._editor.hasModel()) {
-                return null;
-            }
-            const colorInfo = {
-                range: range,
-                color: { red: 0, green: 0, blue: 0, alpha: 1 }
-            };
-            const colorHoverResult = yield this._standaloneColorPickerParticipant.createColorHover(colorInfo, new DefaultDocumentColorProvider(this._modelService, this._languageConfigurationService), this._languageFeaturesService.colorProvider);
-            if (!colorHoverResult) {
-                return null;
-            }
-            return { result: colorHoverResult.colorHover, foundInEditor: colorHoverResult.foundInEditor };
-        });
+    async _computeAsync(range) {
+        if (!this._editor.hasModel()) {
+            return null;
+        }
+        const colorInfo = {
+            range: range,
+            color: { red: 0, green: 0, blue: 0, alpha: 1 }
+        };
+        const colorHoverResult = await this._standaloneColorPickerParticipant.createColorHover(colorInfo, new DefaultDocumentColorProvider(this._modelService, this._languageConfigurationService), this._languageFeaturesService.colorProvider);
+        if (!colorHoverResult) {
+            return null;
+        }
+        return { result: colorHoverResult.colorHover, foundInEditor: colorHoverResult.foundInEditor };
     }
     _render(colorHover, foundInEditor) {
         const fragment = document.createDocumentFragment();
@@ -235,7 +217,7 @@
         const saturationBoxWidth = colorPickerBody.saturationBox.domNode.clientWidth;
         const widthOfOriginalColorBox = colorPickerBody.domNode.clientWidth - saturationBoxWidth - CLOSE_BUTTON_WIDTH - PADDING;
         const enterButton = colorPickerWidget.body.enterButton;
-        enterButton === null || enterButton === void 0 ? void 0 : enterButton.onClicked(() => {
+        enterButton?.onClicked(() => {
             this.updateEditor();
             this.hide();
         });
@@ -245,7 +227,7 @@
         const originalColorNode = colorPickerHeader.originalColorNode;
         originalColorNode.style.width = widthOfOriginalColorBox + 'px';
         const closeButton = colorPickerWidget.header.closeButton;
-        closeButton === null || closeButton === void 0 ? void 0 : closeButton.onClicked(() => {
+        closeButton?.onClicked(() => {
             this.hide();
         });
         // When found in the editor, highlight the selection in the editor
diff -urN -x '*.map' a/vs/editor/contrib/comment/browser/comment.js b/vs/editor/contrib/comment/browser/comment.js
--- a/vs/editor/contrib/comment/browser/comment.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/comment/browser/comment.js	2023-12-06 14:23:14.375854776 +0000
@@ -56,7 +56,7 @@
     constructor() {
         super(0 /* Type.Toggle */, {
             id: 'editor.action.commentLine',
-            label: nls.localize('comment.line', "Toggle Line Comment"),
+            label: nls.localizeWithPath('vs/editor/contrib/comment/browser/comment', 'comment.line', "Toggle Line Comment"),
             alias: 'Toggle Line Comment',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -67,7 +67,7 @@
             menuOpts: {
                 menuId: MenuId.MenubarEditMenu,
                 group: '5_insert',
-                title: nls.localize({ key: 'miToggleLineComment', comment: ['&& denotes a mnemonic'] }, "&&Toggle Line Comment"),
+                title: nls.localizeWithPath('vs/editor/contrib/comment/browser/comment', { key: 'miToggleLineComment', comment: ['&& denotes a mnemonic'] }, "&&Toggle Line Comment"),
                 order: 1
             }
         });
@@ -77,7 +77,7 @@
     constructor() {
         super(1 /* Type.ForceAdd */, {
             id: 'editor.action.addCommentLine',
-            label: nls.localize('comment.line.add', "Add Line Comment"),
+            label: nls.localizeWithPath('vs/editor/contrib/comment/browser/comment', 'comment.line.add', "Add Line Comment"),
             alias: 'Add Line Comment',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -92,7 +92,7 @@
     constructor() {
         super(2 /* Type.ForceRemove */, {
             id: 'editor.action.removeCommentLine',
-            label: nls.localize('comment.line.remove', "Remove Line Comment"),
+            label: nls.localizeWithPath('vs/editor/contrib/comment/browser/comment', 'comment.line.remove', "Remove Line Comment"),
             alias: 'Remove Line Comment',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -107,7 +107,7 @@
     constructor() {
         super({
             id: 'editor.action.blockComment',
-            label: nls.localize('comment.block', "Toggle Block Comment"),
+            label: nls.localizeWithPath('vs/editor/contrib/comment/browser/comment', 'comment.block', "Toggle Block Comment"),
             alias: 'Toggle Block Comment',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -119,7 +119,7 @@
             menuOpts: {
                 menuId: MenuId.MenubarEditMenu,
                 group: '5_insert',
-                title: nls.localize({ key: 'miToggleBlockComment', comment: ['&& denotes a mnemonic'] }, "Toggle &&Block Comment"),
+                title: nls.localizeWithPath('vs/editor/contrib/comment/browser/comment', { key: 'miToggleBlockComment', comment: ['&& denotes a mnemonic'] }, "Toggle &&Block Comment"),
                 order: 2
             }
         });
diff -urN -x '*.map' a/vs/editor/contrib/contextmenu/browser/contextmenu.js b/vs/editor/contrib/contextmenu/browser/contextmenu.js
--- a/vs/editor/contrib/contextmenu/browser/contextmenu.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/contextmenu/browser/contextmenu.js	2023-12-06 14:23:14.375854776 +0000
@@ -257,7 +257,7 @@
         };
         const actions = [];
         actions.push(createAction({
-            label: nls.localize('context.minimap.minimap', "Minimap"),
+            label: nls.localizeWithPath('vs/editor/contrib/contextmenu/browser/contextmenu', 'context.minimap.minimap', "Minimap"),
             checked: minimapOptions.enabled,
             run: () => {
                 this._configurationService.updateValue(`editor.minimap.enabled`, !minimapOptions.enabled);
@@ -265,28 +265,28 @@
         }));
         actions.push(new Separator());
         actions.push(createAction({
-            label: nls.localize('context.minimap.renderCharacters', "Render Characters"),
+            label: nls.localizeWithPath('vs/editor/contrib/contextmenu/browser/contextmenu', 'context.minimap.renderCharacters', "Render Characters"),
             enabled: minimapOptions.enabled,
             checked: minimapOptions.renderCharacters,
             run: () => {
                 this._configurationService.updateValue(`editor.minimap.renderCharacters`, !minimapOptions.renderCharacters);
             }
         }));
-        actions.push(createEnumAction(nls.localize('context.minimap.size', "Vertical size"), minimapOptions.enabled, 'editor.minimap.size', minimapOptions.size, [{
-                label: nls.localize('context.minimap.size.proportional', "Proportional"),
+        actions.push(createEnumAction(nls.localizeWithPath('vs/editor/contrib/contextmenu/browser/contextmenu', 'context.minimap.size', "Vertical size"), minimapOptions.enabled, 'editor.minimap.size', minimapOptions.size, [{
+                label: nls.localizeWithPath('vs/editor/contrib/contextmenu/browser/contextmenu', 'context.minimap.size.proportional', "Proportional"),
                 value: 'proportional'
             }, {
-                label: nls.localize('context.minimap.size.fill', "Fill"),
+                label: nls.localizeWithPath('vs/editor/contrib/contextmenu/browser/contextmenu', 'context.minimap.size.fill', "Fill"),
                 value: 'fill'
             }, {
-                label: nls.localize('context.minimap.size.fit', "Fit"),
+                label: nls.localizeWithPath('vs/editor/contrib/contextmenu/browser/contextmenu', 'context.minimap.size.fit', "Fit"),
                 value: 'fit'
             }]));
-        actions.push(createEnumAction(nls.localize('context.minimap.slider', "Slider"), minimapOptions.enabled, 'editor.minimap.showSlider', minimapOptions.showSlider, [{
-                label: nls.localize('context.minimap.slider.mouseover', "Mouse Over"),
+        actions.push(createEnumAction(nls.localizeWithPath('vs/editor/contrib/contextmenu/browser/contextmenu', 'context.minimap.slider', "Slider"), minimapOptions.enabled, 'editor.minimap.showSlider', minimapOptions.showSlider, [{
+                label: nls.localizeWithPath('vs/editor/contrib/contextmenu/browser/contextmenu', 'context.minimap.slider.mouseover', "Mouse Over"),
                 value: 'mouseover'
             }, {
-                label: nls.localize('context.minimap.slider.always', "Always"),
+                label: nls.localizeWithPath('vs/editor/contrib/contextmenu/browser/contextmenu', 'context.minimap.slider.always', "Always"),
                 value: 'always'
             }]));
         const useShadowDOM = this._editor.getOption(126 /* EditorOption.useShadowDOM */) && !isIOS; // Do not use shadow dom on IOS #122035
@@ -326,7 +326,7 @@
     constructor() {
         super({
             id: 'editor.action.showContextMenu',
-            label: nls.localize('action.showContextMenu.label', "Show Editor Context Menu"),
+            label: nls.localizeWithPath('vs/editor/contrib/contextmenu/browser/contextmenu', 'action.showContextMenu.label', "Show Editor Context Menu"),
             alias: 'Show Editor Context Menu',
             precondition: undefined,
             kbOpts: {
@@ -337,8 +337,7 @@
         });
     }
     run(accessor, editor) {
-        var _a;
-        (_a = ContextMenuController.get(editor)) === null || _a === void 0 ? void 0 : _a.showContextMenu();
+        ContextMenuController.get(editor)?.showContextMenu();
     }
 }
 registerEditorContribution(ContextMenuController.ID, ContextMenuController, 2 /* EditorContributionInstantiation.BeforeFirstInteraction */);
diff -urN -x '*.map' a/vs/editor/contrib/cursorUndo/browser/cursorUndo.js b/vs/editor/contrib/cursorUndo/browser/cursorUndo.js
--- a/vs/editor/contrib/cursorUndo/browser/cursorUndo.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/cursorUndo/browser/cursorUndo.js	2023-12-06 14:23:14.375854776 +0000
@@ -100,7 +100,7 @@
     constructor() {
         super({
             id: 'cursorUndo',
-            label: nls.localize('cursor.undo', "Cursor Undo"),
+            label: nls.localizeWithPath('vs/editor/contrib/cursorUndo/browser/cursorUndo', 'cursor.undo', "Cursor Undo"),
             alias: 'Cursor Undo',
             precondition: undefined,
             kbOpts: {
@@ -111,22 +111,20 @@
         });
     }
     run(accessor, editor, args) {
-        var _a;
-        (_a = CursorUndoRedoController.get(editor)) === null || _a === void 0 ? void 0 : _a.cursorUndo();
+        CursorUndoRedoController.get(editor)?.cursorUndo();
     }
 }
 export class CursorRedo extends EditorAction {
     constructor() {
         super({
             id: 'cursorRedo',
-            label: nls.localize('cursor.redo', "Cursor Redo"),
+            label: nls.localizeWithPath('vs/editor/contrib/cursorUndo/browser/cursorUndo', 'cursor.redo', "Cursor Redo"),
             alias: 'Cursor Redo',
             precondition: undefined
         });
     }
     run(accessor, editor, args) {
-        var _a;
-        (_a = CursorUndoRedoController.get(editor)) === null || _a === void 0 ? void 0 : _a.cursorRedo();
+        CursorUndoRedoController.get(editor)?.cursorRedo();
     }
 }
 registerEditorContribution(CursorUndoRedoController.ID, CursorUndoRedoController, 0 /* EditorContributionInstantiation.Eager */); // eager because it needs to listen to record cursor state ASAP
diff -urN -x '*.map' a/vs/editor/contrib/dnd/browser/dnd.js b/vs/editor/contrib/dnd/browser/dnd.js
--- a/vs/editor/contrib/dnd/browser/dnd.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/dnd/browser/dnd.js	2023-12-06 14:23:14.375854776 +0000
@@ -20,6 +20,9 @@
     }
 }
 export class DragAndDropController extends Disposable {
+    static get(editor) {
+        return editor.getContribution(DragAndDropController.ID);
+    }
     constructor(editor) {
         super();
         this._editor = editor;
diff -urN -x '*.map' a/vs/editor/contrib/documentSymbols/browser/documentSymbols.js b/vs/editor/contrib/documentSymbols/browser/documentSymbols.js
--- a/vs/editor/contrib/documentSymbols/browser/documentSymbols.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/documentSymbols/browser/documentSymbols.js	2023-12-06 14:23:14.375854776 +0000
@@ -2,33 +2,22 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { assertType } from '../../../../base/common/types.js';
 import { URI } from '../../../../base/common/uri.js';
 import { ITextModelService } from '../../../common/services/resolverService.js';
 import { IOutlineModelService } from './outlineModel.js';
 import { CommandsRegistry } from '../../../../platform/commands/common/commands.js';
-CommandsRegistry.registerCommand('_executeDocumentSymbolProvider', function (accessor, ...args) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const [resource] = args;
-        assertType(URI.isUri(resource));
-        const outlineService = accessor.get(IOutlineModelService);
-        const modelService = accessor.get(ITextModelService);
-        const reference = yield modelService.createModelReference(resource);
-        try {
-            return (yield outlineService.getOrCreate(reference.object.textEditorModel, CancellationToken.None)).getTopLevelSymbols();
-        }
-        finally {
-            reference.dispose();
-        }
-    });
+CommandsRegistry.registerCommand('_executeDocumentSymbolProvider', async function (accessor, ...args) {
+    const [resource] = args;
+    assertType(URI.isUri(resource));
+    const outlineService = accessor.get(IOutlineModelService);
+    const modelService = accessor.get(ITextModelService);
+    const reference = await modelService.createModelReference(resource);
+    try {
+        return (await outlineService.getOrCreate(reference.object.textEditorModel, CancellationToken.None)).getTopLevelSymbols();
+    }
+    finally {
+        reference.dispose();
+    }
 });
diff -urN -x '*.map' a/vs/editor/contrib/documentSymbols/browser/outlineModel.js b/vs/editor/contrib/documentSymbols/browser/outlineModel.js
--- a/vs/editor/contrib/documentSymbols/browser/outlineModel.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/documentSymbols/browser/outlineModel.js	2023-12-06 14:23:14.375854776 +0000
@@ -11,20 +11,12 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-import { equals } from '../../../../base/common/arrays.js';
+import { binarySearch, coalesceInPlace, equals } from '../../../../base/common/arrays.js';
 import { CancellationTokenSource } from '../../../../base/common/cancellation.js';
 import { onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { Iterable } from '../../../../base/common/iterator.js';
 import { LRUCache } from '../../../../base/common/map.js';
+import { commonPrefixLength } from '../../../../base/common/strings.js';
 import { Position } from '../../../common/core/position.js';
 import { Range } from '../../../common/core/range.js';
 import { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';
@@ -35,8 +27,7 @@
 import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
 export class TreeElement {
     remove() {
-        var _a;
-        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.delete(this.id);
+        this.parent?.children.delete(this.id);
     }
     static findId(candidate, container) {
         // complex id-computation which contains the origin/extension,
@@ -57,6 +48,32 @@
         }
         return id;
     }
+    static getElementById(id, element) {
+        if (!id) {
+            return undefined;
+        }
+        const len = commonPrefixLength(id, element.id);
+        if (len === id.length) {
+            return element;
+        }
+        if (len < element.id.length) {
+            return undefined;
+        }
+        for (const [, child] of element.children) {
+            const candidate = TreeElement.getElementById(id, child);
+            if (candidate) {
+                return candidate;
+            }
+        }
+        return undefined;
+    }
+    static size(element) {
+        let res = 1;
+        for (const [, child] of element.children) {
+            res += TreeElement.size(child);
+        }
+        return res;
+    }
     static empty(element) {
         return element.children.size === 0;
     }
@@ -79,6 +96,64 @@
         this.order = order;
         this.children = new Map();
     }
+    getItemEnclosingPosition(position) {
+        return position ? this._getItemEnclosingPosition(position, this.children) : undefined;
+    }
+    _getItemEnclosingPosition(position, children) {
+        for (const [, item] of children) {
+            if (!item.symbol.range || !Range.containsPosition(item.symbol.range, position)) {
+                continue;
+            }
+            return this._getItemEnclosingPosition(position, item.children) || item;
+        }
+        return undefined;
+    }
+    updateMarker(marker) {
+        for (const [, child] of this.children) {
+            this._updateMarker(marker, child);
+        }
+    }
+    _updateMarker(markers, item) {
+        item.marker = undefined;
+        // find the proper start index to check for item/marker overlap.
+        const idx = binarySearch(markers, item.symbol.range, Range.compareRangesUsingStarts);
+        let start;
+        if (idx < 0) {
+            start = ~idx;
+            if (start > 0 && Range.areIntersecting(markers[start - 1], item.symbol.range)) {
+                start -= 1;
+            }
+        }
+        else {
+            start = idx;
+        }
+        const myMarkers = [];
+        let myTopSev;
+        for (; start < markers.length && Range.areIntersecting(item.symbol.range, markers[start]); start++) {
+            // remove markers intersecting with this outline element
+            // and store them in a 'private' array.
+            const marker = markers[start];
+            myMarkers.push(marker);
+            markers[start] = undefined;
+            if (!myTopSev || marker.severity > myTopSev) {
+                myTopSev = marker.severity;
+            }
+        }
+        // Recurse into children and let them match markers that have matched
+        // this outline element. This might remove markers from this element and
+        // therefore we remember that we have had markers. That allows us to render
+        // the dot, saying 'this element has children with markers'
+        for (const [, child] of item.children) {
+            this._updateMarker(myMarkers, child);
+        }
+        if (myTopSev) {
+            item.marker = {
+                count: myMarkers.length,
+                topSev: myTopSev
+            };
+        }
+        coalesceInPlace(markers);
+    }
 }
 export class OutlineModel extends TreeElement {
     static create(registry, textModel, token) {
@@ -86,9 +161,8 @@
         const result = new OutlineModel(textModel.uri);
         const provider = registry.ordered(textModel);
         const promises = provider.map((provider, index) => {
-            var _a;
             const id = TreeElement.findId(`provider_${index}`, result);
-            const group = new OutlineGroup(id, result, (_a = provider.displayName) !== null && _a !== void 0 ? _a : 'Unknown Outline Provider', index);
+            const group = new OutlineGroup(id, result, provider.displayName ?? 'Unknown Outline Provider', index);
             return Promise.resolve(provider.provideDocumentSymbols(textModel, cts.token)).then(result => {
                 for (const info of result || []) {
                     OutlineModel._makeOutlineElement(info, group);
@@ -135,6 +209,15 @@
         }
         container.children.set(res.id, res);
     }
+    static get(element) {
+        while (element) {
+            if (element instanceof OutlineModel) {
+                return element;
+            }
+            element = element.parent;
+        }
+        return undefined;
+    }
     constructor(uri) {
         super();
         this.uri = uri;
@@ -169,6 +252,48 @@
         }
         return this;
     }
+    merge(other) {
+        if (this.uri.toString() !== other.uri.toString()) {
+            return false;
+        }
+        if (this._groups.size !== other._groups.size) {
+            return false;
+        }
+        this._groups = other._groups;
+        this.children = other.children;
+        return true;
+    }
+    getItemEnclosingPosition(position, context) {
+        let preferredGroup;
+        if (context) {
+            let candidate = context.parent;
+            while (candidate && !preferredGroup) {
+                if (candidate instanceof OutlineGroup) {
+                    preferredGroup = candidate;
+                }
+                candidate = candidate.parent;
+            }
+        }
+        let result = undefined;
+        for (const [, group] of this._groups) {
+            result = group.getItemEnclosingPosition(position);
+            if (result && (!preferredGroup || preferredGroup === group)) {
+                break;
+            }
+        }
+        return result;
+    }
+    getItemById(id) {
+        return TreeElement.getElementById(id, this);
+    }
+    updateMarker(marker) {
+        // sort markers by start range so that we can use
+        // outline element starts for quicker look up
+        marker.sort(Range.compareRangesUsingStarts);
+        for (const [, group] of this._groups) {
+            group.updateMarker(marker.slice(0));
+        }
+    }
     getTopLevelSymbols() {
         const roots = [];
         for (const child of this.children.values()) {
@@ -221,50 +346,51 @@
     dispose() {
         this._disposables.dispose();
     }
-    getOrCreate(textModel, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const registry = this._languageFeaturesService.documentSymbolProvider;
-            const provider = registry.ordered(textModel);
-            let data = this._cache.get(textModel.id);
-            if (!data || data.versionId !== textModel.getVersionId() || !equals(data.provider, provider)) {
-                const source = new CancellationTokenSource();
-                data = {
-                    versionId: textModel.getVersionId(),
-                    provider,
-                    promiseCnt: 0,
-                    source,
-                    promise: OutlineModel.create(registry, textModel, source.token),
-                    model: undefined,
-                };
-                this._cache.set(textModel.id, data);
-                const now = Date.now();
-                data.promise.then(outlineModel => {
-                    data.model = outlineModel;
-                    this._debounceInformation.update(textModel, Date.now() - now);
-                }).catch(_err => {
-                    this._cache.delete(textModel.id);
-                });
-            }
-            if (data.model) {
-                // resolved -> return data
-                return data.model;
-            }
-            // increase usage counter
-            data.promiseCnt += 1;
-            const listener = token.onCancellationRequested(() => {
-                // last -> cancel provider request, remove cached promise
-                if (--data.promiseCnt === 0) {
-                    data.source.cancel();
-                    this._cache.delete(textModel.id);
-                }
+    async getOrCreate(textModel, token) {
+        const registry = this._languageFeaturesService.documentSymbolProvider;
+        const provider = registry.ordered(textModel);
+        let data = this._cache.get(textModel.id);
+        if (!data || data.versionId !== textModel.getVersionId() || !equals(data.provider, provider)) {
+            const source = new CancellationTokenSource();
+            data = {
+                versionId: textModel.getVersionId(),
+                provider,
+                promiseCnt: 0,
+                source,
+                promise: OutlineModel.create(registry, textModel, source.token),
+                model: undefined,
+            };
+            this._cache.set(textModel.id, data);
+            const now = Date.now();
+            data.promise.then(outlineModel => {
+                data.model = outlineModel;
+                this._debounceInformation.update(textModel, Date.now() - now);
+            }).catch(_err => {
+                this._cache.delete(textModel.id);
             });
-            try {
-                return yield data.promise;
-            }
-            finally {
-                listener.dispose();
+        }
+        if (data.model) {
+            // resolved -> return data
+            return data.model;
+        }
+        // increase usage counter
+        data.promiseCnt += 1;
+        const listener = token.onCancellationRequested(() => {
+            // last -> cancel provider request, remove cached promise
+            if (--data.promiseCnt === 0) {
+                data.source.cancel();
+                this._cache.delete(textModel.id);
             }
         });
+        try {
+            return await data.promise;
+        }
+        finally {
+            listener.dispose();
+        }
+    }
+    getDebounceValue(textModel) {
+        return this._debounceInformation.get(textModel);
     }
 };
 OutlineModelService = __decorate([
diff -urN -x '*.map' a/vs/editor/contrib/dropOrPasteInto/browser/copyPasteContribution.js b/vs/editor/contrib/dropOrPasteInto/browser/copyPasteContribution.js
--- a/vs/editor/contrib/dropOrPasteInto/browser/copyPasteContribution.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/dropOrPasteInto/browser/copyPasteContribution.js	2023-12-06 14:23:14.375854776 +0000
@@ -21,15 +21,14 @@
         });
     }
     runEditorCommand(_accessor, editor, _args) {
-        var _a;
-        return (_a = CopyPasteController.get(editor)) === null || _a === void 0 ? void 0 : _a.changePasteType();
+        return CopyPasteController.get(editor)?.changePasteType();
     }
 });
 registerEditorAction(class extends EditorAction {
     constructor() {
         super({
             id: 'editor.action.pasteAs',
-            label: nls.localize('pasteAs', "Paste As..."),
+            label: nls.localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/copyPasteContribution', 'pasteAs', "Paste As..."),
             alias: 'Paste As...',
             precondition: undefined,
             description: {
@@ -41,7 +40,7 @@
                             properties: {
                                 'id': {
                                     type: 'string',
-                                    description: nls.localize('pasteAs.id', "The id of the paste edit to try applying. If not provided, the editor will show a picker."),
+                                    description: nls.localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/copyPasteContribution', 'pasteAs.id', "The id of the paste edit to try applying. If not provided, the editor will show a picker."),
                                 }
                             },
                         }
@@ -50,8 +49,7 @@
         });
     }
     run(_accessor, editor, args) {
-        var _a;
-        const id = typeof (args === null || args === void 0 ? void 0 : args.id) === 'string' ? args.id : undefined;
-        return (_a = CopyPasteController.get(editor)) === null || _a === void 0 ? void 0 : _a.pasteAs(id);
+        const id = typeof args?.id === 'string' ? args.id : undefined;
+        return CopyPasteController.get(editor)?.pasteAs(id);
     }
 });
diff -urN -x '*.map' a/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js b/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js
--- a/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js	2023-12-06 14:23:14.375854776 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var CopyPasteController_1;
 import { addDisposableListener, getActiveDocument } from '../../../../base/browser/dom.js';
 import { coalesce } from '../../../../base/common/arrays.js';
@@ -37,7 +28,7 @@
 import { createCombinedWorkspaceEdit, sortEditsByYieldTo } from './edit.js';
 import { EditorStateCancellationTokenSource } from '../../editorState/browser/editorState.js';
 import { InlineProgressManager } from '../../inlineProgress/browser/inlineProgress.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { IClipboardService } from '../../../../platform/clipboard/common/clipboardService.js';
 import { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';
 import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
@@ -45,7 +36,7 @@
 import { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';
 import { PostEditWidgetManager } from './postEditWidget.js';
 export const changePasteTypeCommandId = 'editor.changePasteType';
-export const pasteWidgetVisibleCtx = new RawContextKey('pasteWidgetVisible', false, localize('pasteWidgetVisible', "Whether the paste widget is showing"));
+export const pasteWidgetVisibleCtx = new RawContextKey('pasteWidgetVisible', false, localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/copyPasteController', 'pasteWidgetVisible', "Whether the paste widget is showing"));
 const vscodeClipboardMime = 'application/vnd.code.copyMetadata';
 let CopyPasteController = CopyPasteController_1 = class CopyPasteController extends Disposable {
     static get(editor) {
@@ -64,7 +55,7 @@
         this._register(addDisposableListener(container, 'cut', e => this.handleCopy(e)));
         this._register(addDisposableListener(container, 'paste', e => this.handlePaste(e), true));
         this._pasteProgressManager = this._register(new InlineProgressManager('pasteIntoEditor', editor, instantiationService));
-        this._postPasteWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, 'pasteIntoEditor', editor, pasteWidgetVisibleCtx, { id: changePasteTypeCommandId, label: localize('postPasteWidgetTitle', "Show paste options...") }));
+        this._postPasteWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, 'pasteIntoEditor', editor, pasteWidgetVisibleCtx, { id: changePasteTypeCommandId, label: localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/copyPasteController', 'postPasteWidgetTitle', "Show paste options...") }));
     }
     changePasteType() {
         this._postPasteWidgetManager.tryShowSelector();
@@ -79,12 +70,14 @@
             this._pasteAsActionContext = undefined;
         }
     }
+    clearWidgets() {
+        this._postPasteWidgetManager.clear();
+    }
     isPasteAsEnabled() {
         return this._editor.getOption(84 /* EditorOption.pasteAs */).enabled
             && !this._editor.getOption(90 /* EditorOption.readOnly */);
     }
     handleCopy(e) {
-        var _a, _b;
         if (!this._editor.hasTextFocus()) {
             return;
         }
@@ -99,7 +92,7 @@
         }
         const model = this._editor.getModel();
         const selections = this._editor.getSelections();
-        if (!model || !(selections === null || selections === void 0 ? void 0 : selections.length)) {
+        if (!model || !selections?.length) {
             return;
         }
         const enableEmptySelectionClipboard = this._editor.getOption(37 /* EditorOption.emptySelectionClipboard */);
@@ -111,7 +104,7 @@
             }
             ranges = [new Range(ranges[0].startLineNumber, 1, ranges[0].startLineNumber, 1 + model.getLineLength(ranges[0].startLineNumber))];
         }
-        const toCopy = (_a = this._editor._getViewModel()) === null || _a === void 0 ? void 0 : _a.getPlainTextToCopy(selections, enableEmptySelectionClipboard, platform.isWindows);
+        const toCopy = this._editor._getViewModel()?.getPlainTextToCopy(selections, enableEmptySelectionClipboard, platform.isWindows);
         const multicursorText = Array.isArray(toCopy) ? toCopy : null;
         const defaultPastePayload = {
             multicursorText,
@@ -126,7 +119,7 @@
             return;
         }
         const dataTransfer = toVSDataTransfer(e.clipboardData);
-        const providerCopyMimeTypes = providers.flatMap(x => { var _a; return (_a = x.copyMimeTypes) !== null && _a !== void 0 ? _a : []; });
+        const providerCopyMimeTypes = providers.flatMap(x => x.copyMimeTypes ?? []);
         // Save off a handle pointing to data that VS Code maintains.
         const handle = generateUuid();
         this.setCopyMetadata(e.clipboardData, {
@@ -134,16 +127,16 @@
             providerCopyMimeTypes,
             defaultPastePayload
         });
-        const promise = createCancelablePromise((token) => __awaiter(this, void 0, void 0, function* () {
-            const results = coalesce(yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {
+        const promise = createCancelablePromise(async (token) => {
+            const results = coalesce(await Promise.all(providers.map(async (provider) => {
                 try {
-                    return yield provider.prepareDocumentPaste(model, ranges, dataTransfer, token);
+                    return await provider.prepareDocumentPaste(model, ranges, dataTransfer, token);
                 }
                 catch (err) {
                     console.error(err);
                     return undefined;
                 }
-            }))));
+            })));
             // Values from higher priority providers should overwrite values from lower priority ones.
             // Reverse the array to so that the calls to `replace` below will do this
             results.reverse();
@@ -153,58 +146,55 @@
                 }
             }
             return dataTransfer;
-        }));
-        (_b = this._currentCopyOperation) === null || _b === void 0 ? void 0 : _b.dataTransferPromise.cancel();
+        });
+        this._currentCopyOperation?.dataTransferPromise.cancel();
         this._currentCopyOperation = { handle: handle, dataTransferPromise: promise };
     }
-    handlePaste(e) {
-        var _a, _b;
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!e.clipboardData || !this._editor.hasTextFocus()) {
-                return;
-            }
-            (_a = this._currentPasteOperation) === null || _a === void 0 ? void 0 : _a.cancel();
-            this._currentPasteOperation = undefined;
-            const model = this._editor.getModel();
-            const selections = this._editor.getSelections();
-            if (!(selections === null || selections === void 0 ? void 0 : selections.length) || !model) {
-                return;
-            }
-            if (!this.isPasteAsEnabled()) {
-                return;
-            }
-            const metadata = this.fetchCopyMetadata(e);
-            const dataTransfer = toExternalVSDataTransfer(e.clipboardData);
-            dataTransfer.delete(vscodeClipboardMime);
-            const allPotentialMimeTypes = [
-                ...e.clipboardData.types,
-                ...(_b = metadata === null || metadata === void 0 ? void 0 : metadata.providerCopyMimeTypes) !== null && _b !== void 0 ? _b : [],
-                // TODO: always adds `uri-list` because this get set if there are resources in the system clipboard.
-                // However we can only check the system clipboard async. For this early check, just add it in.
-                // We filter providers again once we have the final dataTransfer we will use.
-                Mimes.uriList,
-            ];
-            const allProviders = this._languageFeaturesService.documentPasteEditProvider
-                .ordered(model)
-                .filter(provider => { var _a; return (_a = provider.pasteMimeTypes) === null || _a === void 0 ? void 0 : _a.some(type => matchesMimeType(type, allPotentialMimeTypes)); });
-            if (!allProviders.length) {
-                return;
-            }
-            // Prevent the editor's default paste handler from running.
-            // Note that after this point, we are fully responsible for handling paste.
-            // If we can't provider a paste for any reason, we need to explicitly delegate pasting back to the editor.
-            e.preventDefault();
-            e.stopImmediatePropagation();
-            if (this._pasteAsActionContext) {
-                this.showPasteAsPick(this._pasteAsActionContext.preferredId, allProviders, selections, dataTransfer, metadata);
-            }
-            else {
-                this.doPasteInline(allProviders, selections, dataTransfer, metadata);
-            }
-        });
+    async handlePaste(e) {
+        if (!e.clipboardData || !this._editor.hasTextFocus()) {
+            return;
+        }
+        this._currentPasteOperation?.cancel();
+        this._currentPasteOperation = undefined;
+        const model = this._editor.getModel();
+        const selections = this._editor.getSelections();
+        if (!selections?.length || !model) {
+            return;
+        }
+        if (!this.isPasteAsEnabled()) {
+            return;
+        }
+        const metadata = this.fetchCopyMetadata(e);
+        const dataTransfer = toExternalVSDataTransfer(e.clipboardData);
+        dataTransfer.delete(vscodeClipboardMime);
+        const allPotentialMimeTypes = [
+            ...e.clipboardData.types,
+            ...metadata?.providerCopyMimeTypes ?? [],
+            // TODO: always adds `uri-list` because this get set if there are resources in the system clipboard.
+            // However we can only check the system clipboard async. For this early check, just add it in.
+            // We filter providers again once we have the final dataTransfer we will use.
+            Mimes.uriList,
+        ];
+        const allProviders = this._languageFeaturesService.documentPasteEditProvider
+            .ordered(model)
+            .filter(provider => provider.pasteMimeTypes?.some(type => matchesMimeType(type, allPotentialMimeTypes)));
+        if (!allProviders.length) {
+            return;
+        }
+        // Prevent the editor's default paste handler from running.
+        // Note that after this point, we are fully responsible for handling paste.
+        // If we can't provider a paste for any reason, we need to explicitly delegate pasting back to the editor.
+        e.preventDefault();
+        e.stopImmediatePropagation();
+        if (this._pasteAsActionContext) {
+            this.showPasteAsPick(this._pasteAsActionContext.preferredId, allProviders, selections, dataTransfer, metadata);
+        }
+        else {
+            this.doPasteInline(allProviders, selections, dataTransfer, metadata);
+        }
     }
     doPasteInline(allProviders, selections, dataTransfer, metadata) {
-        const p = createCancelablePromise((token) => __awaiter(this, void 0, void 0, function* () {
+        const p = createCancelablePromise(async (token) => {
             const editor = this._editor;
             if (!editor.hasModel()) {
                 return;
@@ -212,7 +202,7 @@
             const model = editor.getModel();
             const tokenSource = new EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */ | 2 /* CodeEditorStateFlag.Selection */, undefined, token);
             try {
-                yield this.mergeInDataFromCopy(dataTransfer, metadata, tokenSource.token);
+                await this.mergeInDataFromCopy(dataTransfer, metadata, tokenSource.token);
                 if (tokenSource.token.isCancellationRequested) {
                     return;
                 }
@@ -221,23 +211,23 @@
                 if (!supportedProviders.length
                     || (supportedProviders.length === 1 && supportedProviders[0].id === 'text') // Only our default text provider is active
                 ) {
-                    yield this.applyDefaultPasteHandler(dataTransfer, metadata, tokenSource.token);
+                    await this.applyDefaultPasteHandler(dataTransfer, metadata, tokenSource.token);
                     return;
                 }
-                const providerEdits = yield this.getPasteEdits(supportedProviders, dataTransfer, model, selections, tokenSource.token);
+                const providerEdits = await this.getPasteEdits(supportedProviders, dataTransfer, model, selections, tokenSource.token);
                 if (tokenSource.token.isCancellationRequested) {
                     return;
                 }
                 // If the only edit returned is a text edit, use the default paste handler
                 if (providerEdits.length === 1 && providerEdits[0].providerId === 'text') {
-                    yield this.applyDefaultPasteHandler(dataTransfer, metadata, tokenSource.token);
+                    await this.applyDefaultPasteHandler(dataTransfer, metadata, tokenSource.token);
                     return;
                 }
                 if (providerEdits.length) {
                     const canShowWidget = editor.getOption(84 /* EditorOption.pasteAs */).showPasteSelector === 'afterPaste';
                     return this._postPasteWidgetManager.applyEditAndShowIfNeeded(selections, { activeEditIndex: 0, allEdits: providerEdits }, canShowWidget, tokenSource.token);
                 }
-                yield this.applyDefaultPasteHandler(dataTransfer, metadata, tokenSource.token);
+                await this.applyDefaultPasteHandler(dataTransfer, metadata, tokenSource.token);
             }
             finally {
                 tokenSource.dispose();
@@ -245,12 +235,12 @@
                     this._currentPasteOperation = undefined;
                 }
             }
-        }));
-        this._pasteProgressManager.showWhile(selections[0].getEndPosition(), localize('pasteIntoEditorProgress', "Running paste handlers. Click to cancel"), p);
+        });
+        this._pasteProgressManager.showWhile(selections[0].getEndPosition(), localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/copyPasteController', 'pasteIntoEditorProgress', "Running paste handlers. Click to cancel"), p);
         this._currentPasteOperation = p;
     }
     showPasteAsPick(preferredId, allProviders, selections, dataTransfer, metadata) {
-        const p = createCancelablePromise((token) => __awaiter(this, void 0, void 0, function* () {
+        const p = createCancelablePromise(async (token) => {
             const editor = this._editor;
             if (!editor.hasModel()) {
                 return;
@@ -258,7 +248,7 @@
             const model = editor.getModel();
             const tokenSource = new EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */ | 2 /* CodeEditorStateFlag.Selection */, undefined, token);
             try {
-                yield this.mergeInDataFromCopy(dataTransfer, metadata, tokenSource.token);
+                await this.mergeInDataFromCopy(dataTransfer, metadata, tokenSource.token);
                 if (tokenSource.token.isCancellationRequested) {
                     return;
                 }
@@ -268,7 +258,7 @@
                     // We are looking for a specific edit
                     supportedProviders = supportedProviders.filter(edit => edit.id === preferredId);
                 }
-                const providerEdits = yield this.getPasteEdits(supportedProviders, dataTransfer, model, selections, tokenSource.token);
+                const providerEdits = await this.getPasteEdits(supportedProviders, dataTransfer, model, selections, tokenSource.token);
                 if (tokenSource.token.isCancellationRequested) {
                     return;
                 }
@@ -280,21 +270,21 @@
                     pickedEdit = providerEdits.at(0);
                 }
                 else {
-                    const selected = yield this._quickInputService.pick(providerEdits.map((edit) => ({
+                    const selected = await this._quickInputService.pick(providerEdits.map((edit) => ({
                         label: edit.label,
                         description: edit.providerId,
                         detail: edit.detail,
                         edit,
                     })), {
-                        placeHolder: localize('pasteAsPickerPlaceholder', "Select Paste Action"),
+                        placeHolder: localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/copyPasteController', 'pasteAsPickerPlaceholder', "Select Paste Action"),
                     });
-                    pickedEdit = selected === null || selected === void 0 ? void 0 : selected.edit;
+                    pickedEdit = selected?.edit;
                 }
                 if (!pickedEdit) {
                     return;
                 }
                 const combinedWorkspaceEdit = createCombinedWorkspaceEdit(model.uri, selections, pickedEdit);
-                yield this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor });
+                await this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor });
             }
             finally {
                 tokenSource.dispose();
@@ -302,17 +292,16 @@
                     this._currentPasteOperation = undefined;
                 }
             }
-        }));
+        });
         this._progressService.withProgress({
             location: 10 /* ProgressLocation.Window */,
-            title: localize('pasteAsProgress', "Running paste handlers"),
+            title: localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/copyPasteController', 'pasteAsProgress', "Running paste handlers"),
         }, () => p);
     }
     setCopyMetadata(dataTransfer, metadata) {
         dataTransfer.setData(vscodeClipboardMime, JSON.stringify(metadata));
     }
     fetchCopyMetadata(e) {
-        var _a;
         if (!e.clipboardData) {
             return;
         }
@@ -322,7 +311,7 @@
             try {
                 return JSON.parse(rawMetadata);
             }
-            catch (_b) {
+            catch {
                 return undefined;
             }
         }
@@ -332,74 +321,65 @@
             return {
                 defaultPastePayload: {
                     mode: metadata.mode,
-                    multicursorText: (_a = metadata.multicursorText) !== null && _a !== void 0 ? _a : null,
+                    multicursorText: metadata.multicursorText ?? null,
                     pasteOnNewLine: !!metadata.isFromEmptySelection,
                 },
             };
         }
         return undefined;
     }
-    mergeInDataFromCopy(dataTransfer, metadata, token) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            if ((metadata === null || metadata === void 0 ? void 0 : metadata.id) && ((_a = this._currentCopyOperation) === null || _a === void 0 ? void 0 : _a.handle) === metadata.id) {
-                const toMergeDataTransfer = yield this._currentCopyOperation.dataTransferPromise;
-                if (token.isCancellationRequested) {
-                    return;
-                }
-                for (const [key, value] of toMergeDataTransfer) {
-                    dataTransfer.replace(key, value);
-                }
-            }
-            if (!dataTransfer.has(Mimes.uriList)) {
-                const resources = yield this._clipboardService.readResources();
-                if (token.isCancellationRequested) {
-                    return;
-                }
-                if (resources.length) {
-                    dataTransfer.append(Mimes.uriList, createStringDataTransferItem(UriList.create(resources)));
-                }
-            }
-        });
-    }
-    getPasteEdits(providers, dataTransfer, model, selections, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const results = yield raceCancellation(Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {
-                var _a;
-                try {
-                    const edit = yield ((_a = provider.provideDocumentPasteEdits) === null || _a === void 0 ? void 0 : _a.call(provider, model, selections, dataTransfer, token));
-                    if (edit) {
-                        return Object.assign(Object.assign({}, edit), { providerId: provider.id });
-                    }
-                }
-                catch (err) {
-                    console.error(err);
-                }
-                return undefined;
-            }))), token);
-            const edits = coalesce(results !== null && results !== void 0 ? results : []);
-            return sortEditsByYieldTo(edits);
-        });
-    }
-    applyDefaultPasteHandler(dataTransfer, metadata, token) {
-        var _a, _b, _c;
-        return __awaiter(this, void 0, void 0, function* () {
-            const textDataTransfer = (_a = dataTransfer.get(Mimes.text)) !== null && _a !== void 0 ? _a : dataTransfer.get('text');
-            if (!textDataTransfer) {
+    async mergeInDataFromCopy(dataTransfer, metadata, token) {
+        if (metadata?.id && this._currentCopyOperation?.handle === metadata.id) {
+            const toMergeDataTransfer = await this._currentCopyOperation.dataTransferPromise;
+            if (token.isCancellationRequested) {
                 return;
             }
-            const text = yield textDataTransfer.asString();
+            for (const [key, value] of toMergeDataTransfer) {
+                dataTransfer.replace(key, value);
+            }
+        }
+        if (!dataTransfer.has(Mimes.uriList)) {
+            const resources = await this._clipboardService.readResources();
             if (token.isCancellationRequested) {
                 return;
             }
-            const payload = {
-                text,
-                pasteOnNewLine: (_b = metadata === null || metadata === void 0 ? void 0 : metadata.defaultPastePayload.pasteOnNewLine) !== null && _b !== void 0 ? _b : false,
-                multicursorText: (_c = metadata === null || metadata === void 0 ? void 0 : metadata.defaultPastePayload.multicursorText) !== null && _c !== void 0 ? _c : null,
-                mode: null,
-            };
-            this._editor.trigger('keyboard', "paste" /* Handler.Paste */, payload);
-        });
+            if (resources.length) {
+                dataTransfer.append(Mimes.uriList, createStringDataTransferItem(UriList.create(resources)));
+            }
+        }
+    }
+    async getPasteEdits(providers, dataTransfer, model, selections, token) {
+        const results = await raceCancellation(Promise.all(providers.map(async (provider) => {
+            try {
+                const edit = await provider.provideDocumentPasteEdits?.(model, selections, dataTransfer, token);
+                if (edit) {
+                    return { ...edit, providerId: provider.id };
+                }
+            }
+            catch (err) {
+                console.error(err);
+            }
+            return undefined;
+        })), token);
+        const edits = coalesce(results ?? []);
+        return sortEditsByYieldTo(edits);
+    }
+    async applyDefaultPasteHandler(dataTransfer, metadata, token) {
+        const textDataTransfer = dataTransfer.get(Mimes.text) ?? dataTransfer.get('text');
+        if (!textDataTransfer) {
+            return;
+        }
+        const text = await textDataTransfer.asString();
+        if (token.isCancellationRequested) {
+            return;
+        }
+        const payload = {
+            text,
+            pasteOnNewLine: metadata?.defaultPastePayload.pasteOnNewLine ?? false,
+            multicursorText: metadata?.defaultPastePayload.multicursorText ?? null,
+            mode: null,
+        };
+        this._editor.trigger('keyboard', "paste" /* Handler.Paste */, payload);
     }
 };
 CopyPasteController.ID = 'editor.contrib.copyPasteActionController';
@@ -413,6 +393,5 @@
 ], CopyPasteController);
 export { CopyPasteController };
 function isSupportedPasteProvider(provider, dataTransfer) {
-    var _a;
-    return Boolean((_a = provider.pasteMimeTypes) === null || _a === void 0 ? void 0 : _a.some(type => dataTransfer.matches(type)));
+    return Boolean(provider.pasteMimeTypes?.some(type => dataTransfer.matches(type)));
 }
diff -urN -x '*.map' a/vs/editor/contrib/dropOrPasteInto/browser/defaultProviders.js b/vs/editor/contrib/dropOrPasteInto/browser/defaultProviders.js
--- a/vs/editor/contrib/dropOrPasteInto/browser/defaultProviders.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/dropOrPasteInto/browser/defaultProviders.js	2023-12-06 14:23:14.375854776 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { coalesce } from '../../../../base/common/arrays.js';
 import { UriList } from '../../../../base/common/dataTransfer.js';
 import { Disposable } from '../../../../base/common/lifecycle.js';
@@ -28,21 +19,17 @@
 import { relativePath } from '../../../../base/common/resources.js';
 import { URI } from '../../../../base/common/uri.js';
 import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';
-const builtInLabel = localize('builtIn', 'Built-in');
+const builtInLabel = localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/defaultProviders', 'builtIn', 'Built-in');
 class SimplePasteAndDropProvider {
-    provideDocumentPasteEdits(_model, _ranges, dataTransfer, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const edit = yield this.getEdit(dataTransfer, token);
-            return edit ? { insertText: edit.insertText, label: edit.label, detail: edit.detail, handledMimeType: edit.handledMimeType, yieldTo: edit.yieldTo } : undefined;
-        });
-    }
-    provideDocumentOnDropEdits(_model, _position, dataTransfer, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const edit = yield this.getEdit(dataTransfer, token);
-            return edit ? { insertText: edit.insertText, label: edit.label, handledMimeType: edit.handledMimeType, yieldTo: edit.yieldTo } : undefined;
-        });
+    async provideDocumentPasteEdits(_model, _ranges, dataTransfer, token) {
+        const edit = await this.getEdit(dataTransfer, token);
+        return edit ? { insertText: edit.insertText, label: edit.label, detail: edit.detail, handledMimeType: edit.handledMimeType, yieldTo: edit.yieldTo } : undefined;
+    }
+    async provideDocumentOnDropEdits(_model, _position, dataTransfer, token) {
+        const edit = await this.getEdit(dataTransfer, token);
+        return edit ? { insertText: edit.insertText, label: edit.label, handledMimeType: edit.handledMimeType, yieldTo: edit.yieldTo } : undefined;
     }
 }
 class DefaultTextProvider extends SimplePasteAndDropProvider {
@@ -52,25 +39,23 @@
         this.dropMimeTypes = [Mimes.text];
         this.pasteMimeTypes = [Mimes.text];
     }
-    getEdit(dataTransfer, _token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const textEntry = dataTransfer.get(Mimes.text);
-            if (!textEntry) {
-                return;
-            }
-            // Suppress if there's also a uriList entry.
-            // Typically the uri-list contains the same text as the text entry so showing both is confusing.
-            if (dataTransfer.has(Mimes.uriList)) {
-                return;
-            }
-            const insertText = yield textEntry.asString();
-            return {
-                handledMimeType: Mimes.text,
-                label: localize('text.label', "Insert Plain Text"),
-                detail: builtInLabel,
-                insertText
-            };
-        });
+    async getEdit(dataTransfer, _token) {
+        const textEntry = dataTransfer.get(Mimes.text);
+        if (!textEntry) {
+            return;
+        }
+        // Suppress if there's also a uriList entry.
+        // Typically the uri-list contains the same text as the text entry so showing both is confusing.
+        if (dataTransfer.has(Mimes.uriList)) {
+            return;
+        }
+        const insertText = await textEntry.asString();
+        return {
+            handledMimeType: Mimes.text,
+            label: localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/defaultProviders', 'text.label', "Insert Plain Text"),
+            detail: builtInLabel,
+            insertText
+        };
     }
 }
 class PathProvider extends SimplePasteAndDropProvider {
@@ -80,44 +65,42 @@
         this.dropMimeTypes = [Mimes.uriList];
         this.pasteMimeTypes = [Mimes.uriList];
     }
-    getEdit(dataTransfer, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const entries = yield extractUriList(dataTransfer);
-            if (!entries.length || token.isCancellationRequested) {
-                return;
-            }
-            let uriCount = 0;
-            const insertText = entries
-                .map(({ uri, originalText }) => {
-                if (uri.scheme === Schemas.file) {
-                    return uri.fsPath;
-                }
-                else {
-                    uriCount++;
-                    return originalText;
-                }
-            })
-                .join(' ');
-            let label;
-            if (uriCount > 0) {
-                // Dropping at least one generic uri (such as https) so use most generic label
-                label = entries.length > 1
-                    ? localize('defaultDropProvider.uriList.uris', "Insert Uris")
-                    : localize('defaultDropProvider.uriList.uri', "Insert Uri");
+    async getEdit(dataTransfer, token) {
+        const entries = await extractUriList(dataTransfer);
+        if (!entries.length || token.isCancellationRequested) {
+            return;
+        }
+        let uriCount = 0;
+        const insertText = entries
+            .map(({ uri, originalText }) => {
+            if (uri.scheme === Schemas.file) {
+                return uri.fsPath;
             }
             else {
-                // All the paths are file paths
-                label = entries.length > 1
-                    ? localize('defaultDropProvider.uriList.paths', "Insert Paths")
-                    : localize('defaultDropProvider.uriList.path', "Insert Path");
+                uriCount++;
+                return originalText;
             }
-            return {
-                handledMimeType: Mimes.uriList,
-                insertText,
-                label,
-                detail: builtInLabel,
-            };
-        });
+        })
+            .join(' ');
+        let label;
+        if (uriCount > 0) {
+            // Dropping at least one generic uri (such as https) so use most generic label
+            label = entries.length > 1
+                ? localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/defaultProviders', 'defaultDropProvider.uriList.uris', "Insert Uris")
+                : localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/defaultProviders', 'defaultDropProvider.uriList.uri', "Insert Uri");
+        }
+        else {
+            // All the paths are file paths
+            label = entries.length > 1
+                ? localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/defaultProviders', 'defaultDropProvider.uriList.paths', "Insert Paths")
+                : localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/defaultProviders', 'defaultDropProvider.uriList.path', "Insert Path");
+        }
+        return {
+            handledMimeType: Mimes.uriList,
+            insertText,
+            label,
+            detail: builtInLabel,
+        };
     }
 }
 let RelativePathProvider = class RelativePathProvider extends SimplePasteAndDropProvider {
@@ -128,51 +111,47 @@
         this.dropMimeTypes = [Mimes.uriList];
         this.pasteMimeTypes = [Mimes.uriList];
     }
-    getEdit(dataTransfer, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const entries = yield extractUriList(dataTransfer);
-            if (!entries.length || token.isCancellationRequested) {
-                return;
-            }
-            const relativeUris = coalesce(entries.map(({ uri }) => {
-                const root = this._workspaceContextService.getWorkspaceFolder(uri);
-                return root ? relativePath(root.uri, uri) : undefined;
-            }));
-            if (!relativeUris.length) {
-                return;
-            }
-            return {
-                handledMimeType: Mimes.uriList,
-                insertText: relativeUris.join(' '),
-                label: entries.length > 1
-                    ? localize('defaultDropProvider.uriList.relativePaths', "Insert Relative Paths")
-                    : localize('defaultDropProvider.uriList.relativePath', "Insert Relative Path"),
-                detail: builtInLabel,
-            };
-        });
+    async getEdit(dataTransfer, token) {
+        const entries = await extractUriList(dataTransfer);
+        if (!entries.length || token.isCancellationRequested) {
+            return;
+        }
+        const relativeUris = coalesce(entries.map(({ uri }) => {
+            const root = this._workspaceContextService.getWorkspaceFolder(uri);
+            return root ? relativePath(root.uri, uri) : undefined;
+        }));
+        if (!relativeUris.length) {
+            return;
+        }
+        return {
+            handledMimeType: Mimes.uriList,
+            insertText: relativeUris.join(' '),
+            label: entries.length > 1
+                ? localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/defaultProviders', 'defaultDropProvider.uriList.relativePaths', "Insert Relative Paths")
+                : localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/defaultProviders', 'defaultDropProvider.uriList.relativePath', "Insert Relative Path"),
+            detail: builtInLabel,
+        };
     }
 };
 RelativePathProvider = __decorate([
     __param(0, IWorkspaceContextService)
 ], RelativePathProvider);
-function extractUriList(dataTransfer) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const urlListEntry = dataTransfer.get(Mimes.uriList);
-        if (!urlListEntry) {
-            return [];
-        }
-        const strUriList = yield urlListEntry.asString();
-        const entries = [];
-        for (const entry of UriList.parse(strUriList)) {
-            try {
-                entries.push({ uri: URI.parse(entry), originalText: entry });
-            }
-            catch (_a) {
-                // noop
-            }
+async function extractUriList(dataTransfer) {
+    const urlListEntry = dataTransfer.get(Mimes.uriList);
+    if (!urlListEntry) {
+        return [];
+    }
+    const strUriList = await urlListEntry.asString();
+    const entries = [];
+    for (const entry of UriList.parse(strUriList)) {
+        try {
+            entries.push({ uri: URI.parse(entry), originalText: entry });
         }
-        return entries;
-    });
+        catch {
+            // noop
+        }
+    }
+    return entries;
 }
 let DefaultDropProvidersFeature = class DefaultDropProvidersFeature extends Disposable {
     constructor(languageFeaturesService, workspaceContextService) {
diff -urN -x '*.map' a/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorContribution.js b/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorContribution.js
--- a/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorContribution.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorContribution.js	2023-12-06 14:23:14.375854776 +0000
@@ -23,19 +23,21 @@
         });
     }
     runEditorCommand(_accessor, editor, _args) {
-        var _a;
-        (_a = DropIntoEditorController.get(editor)) === null || _a === void 0 ? void 0 : _a.changeDropType();
+        DropIntoEditorController.get(editor)?.changeDropType();
     }
 });
 registerEditorFeature(DefaultDropProvidersFeature);
-Registry.as(ConfigurationExtensions.Configuration).registerConfiguration(Object.assign(Object.assign({}, editorConfigurationBaseNode), { properties: {
+Registry.as(ConfigurationExtensions.Configuration).registerConfiguration({
+    ...editorConfigurationBaseNode,
+    properties: {
         [defaultProviderConfig]: {
             type: 'object',
             scope: 5 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */,
-            description: nls.localize('defaultProviderDescription', "Configures the default drop provider to use for content of a given mime type."),
+            description: nls.localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorContribution', 'defaultProviderDescription', "Configures the default drop provider to use for content of a given mime type."),
             default: {},
             additionalProperties: {
                 type: 'string',
             },
         },
-    } }));
+    }
+});
diff -urN -x '*.map' a/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController.js b/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController.js
--- a/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController.js	2023-12-06 14:23:14.375854776 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var DropIntoEditorController_1;
 import { coalesce } from '../../../../base/common/arrays.js';
 import { createCancelablePromise, raceCancellation } from '../../../../base/common/async.js';
@@ -32,7 +23,7 @@
 import { ITreeViewsDnDService } from '../../../common/services/treeViewsDndService.js';
 import { EditorStateCancellationTokenSource } from '../../editorState/browser/editorState.js';
 import { InlineProgressManager } from '../../inlineProgress/browser/inlineProgress.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
 import { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';
 import { LocalSelectionTransfer } from '../../../../platform/dnd/browser/dnd.js';
@@ -41,7 +32,7 @@
 import { PostEditWidgetManager } from './postEditWidget.js';
 export const defaultProviderConfig = 'editor.experimental.dropIntoEditor.defaultProvider';
 export const changeDropTypeCommandId = 'editor.changeDropType';
-export const dropWidgetVisibleCtx = new RawContextKey('dropWidgetVisible', false, localize('dropWidgetVisible', "Whether the drop widget is showing"));
+export const dropWidgetVisibleCtx = new RawContextKey('dropWidgetVisible', false, localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController', 'dropWidgetVisible', "Whether the drop widget is showing"));
 let DropIntoEditorController = DropIntoEditorController_1 = class DropIntoEditorController extends Disposable {
     static get(editor) {
         return editor.getContribution(DropIntoEditorController_1.ID);
@@ -53,80 +44,78 @@
         this._treeViewsDragAndDropService = _treeViewsDragAndDropService;
         this.treeItemsTransfer = LocalSelectionTransfer.getInstance();
         this._dropProgressManager = this._register(instantiationService.createInstance(InlineProgressManager, 'dropIntoEditor', editor));
-        this._postDropWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, 'dropIntoEditor', editor, dropWidgetVisibleCtx, { id: changeDropTypeCommandId, label: localize('postDropWidgetTitle', "Show drop options...") }));
+        this._postDropWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, 'dropIntoEditor', editor, dropWidgetVisibleCtx, { id: changeDropTypeCommandId, label: localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController', 'postDropWidgetTitle', "Show drop options...") }));
         this._register(editor.onDropIntoEditor(e => this.onDropIntoEditor(editor, e.position, e.event)));
     }
+    clearWidgets() {
+        this._postDropWidgetManager.clear();
+    }
     changeDropType() {
         this._postDropWidgetManager.tryShowSelector();
     }
-    onDropIntoEditor(editor, position, dragEvent) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!dragEvent.dataTransfer || !editor.hasModel()) {
-                return;
-            }
-            (_a = this._currentOperation) === null || _a === void 0 ? void 0 : _a.cancel();
-            editor.focus();
-            editor.setPosition(position);
-            const p = createCancelablePromise((token) => __awaiter(this, void 0, void 0, function* () {
-                const tokenSource = new EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */, undefined, token);
-                try {
-                    const ourDataTransfer = yield this.extractDataTransferData(dragEvent);
-                    if (ourDataTransfer.size === 0 || tokenSource.token.isCancellationRequested) {
-                        return;
-                    }
-                    const model = editor.getModel();
-                    if (!model) {
-                        return;
-                    }
-                    const providers = this._languageFeaturesService.documentOnDropEditProvider
-                        .ordered(model)
-                        .filter(provider => {
-                        if (!provider.dropMimeTypes) {
-                            // Keep all providers that don't specify mime types
-                            return true;
-                        }
-                        return provider.dropMimeTypes.some(mime => ourDataTransfer.matches(mime));
-                    });
-                    const edits = yield this.getDropEdits(providers, model, position, ourDataTransfer, tokenSource);
-                    if (tokenSource.token.isCancellationRequested) {
-                        return;
-                    }
-                    if (edits.length) {
-                        const activeEditIndex = this.getInitialActiveEditIndex(model, edits);
-                        const canShowWidget = editor.getOption(36 /* EditorOption.dropIntoEditor */).showDropSelector === 'afterDrop';
-                        // Pass in the parent token here as it tracks cancelling the entire drop operation
-                        yield this._postDropWidgetManager.applyEditAndShowIfNeeded([Range.fromPositions(position)], { activeEditIndex, allEdits: edits }, canShowWidget, token);
-                    }
+    async onDropIntoEditor(editor, position, dragEvent) {
+        if (!dragEvent.dataTransfer || !editor.hasModel()) {
+            return;
+        }
+        this._currentOperation?.cancel();
+        editor.focus();
+        editor.setPosition(position);
+        const p = createCancelablePromise(async (token) => {
+            const tokenSource = new EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */, undefined, token);
+            try {
+                const ourDataTransfer = await this.extractDataTransferData(dragEvent);
+                if (ourDataTransfer.size === 0 || tokenSource.token.isCancellationRequested) {
+                    return;
                 }
-                finally {
-                    tokenSource.dispose();
-                    if (this._currentOperation === p) {
-                        this._currentOperation = undefined;
-                    }
+                const model = editor.getModel();
+                if (!model) {
+                    return;
                 }
-            }));
-            this._dropProgressManager.showWhile(position, localize('dropIntoEditorProgress', "Running drop handlers. Click to cancel"), p);
-            this._currentOperation = p;
-        });
-    }
-    getDropEdits(providers, model, position, dataTransfer, tokenSource) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const results = yield raceCancellation(Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {
-                try {
-                    const edit = yield provider.provideDocumentOnDropEdits(model, position, dataTransfer, tokenSource.token);
-                    if (edit) {
-                        return Object.assign(Object.assign({}, edit), { providerId: provider.id });
-                    }
+                const providers = this._languageFeaturesService.documentOnDropEditProvider
+                    .ordered(model)
+                    .filter(provider => {
+                    if (!provider.dropMimeTypes) {
+                        // Keep all providers that don't specify mime types
+                        return true;
+                    }
+                    return provider.dropMimeTypes.some(mime => ourDataTransfer.matches(mime));
+                });
+                const edits = await this.getDropEdits(providers, model, position, ourDataTransfer, tokenSource);
+                if (tokenSource.token.isCancellationRequested) {
+                    return;
+                }
+                if (edits.length) {
+                    const activeEditIndex = this.getInitialActiveEditIndex(model, edits);
+                    const canShowWidget = editor.getOption(36 /* EditorOption.dropIntoEditor */).showDropSelector === 'afterDrop';
+                    // Pass in the parent token here as it tracks cancelling the entire drop operation
+                    await this._postDropWidgetManager.applyEditAndShowIfNeeded([Range.fromPositions(position)], { activeEditIndex, allEdits: edits }, canShowWidget, token);
                 }
-                catch (err) {
-                    console.error(err);
+            }
+            finally {
+                tokenSource.dispose();
+                if (this._currentOperation === p) {
+                    this._currentOperation = undefined;
                 }
-                return undefined;
-            }))), tokenSource.token);
-            const edits = coalesce(results !== null && results !== void 0 ? results : []);
-            return sortEditsByYieldTo(edits);
+            }
         });
+        this._dropProgressManager.showWhile(position, localizeWithPath('vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController', 'dropIntoEditorProgress', "Running drop handlers. Click to cancel"), p);
+        this._currentOperation = p;
+    }
+    async getDropEdits(providers, model, position, dataTransfer, tokenSource) {
+        const results = await raceCancellation(Promise.all(providers.map(async (provider) => {
+            try {
+                const edit = await provider.provideDocumentOnDropEdits(model, position, dataTransfer, tokenSource.token);
+                if (edit) {
+                    return { ...edit, providerId: provider.id };
+                }
+            }
+            catch (err) {
+                console.error(err);
+            }
+            return undefined;
+        })), tokenSource.token);
+        const edits = coalesce(results ?? []);
+        return sortEditsByYieldTo(edits);
     }
     getInitialActiveEditIndex(model, edits) {
         const preferredProviders = this._configService.getValue(defaultProviderConfig, { resource: model.uri });
@@ -139,27 +128,25 @@
         }
         return 0;
     }
-    extractDataTransferData(dragEvent) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!dragEvent.dataTransfer) {
-                return new VSDataTransfer();
-            }
-            const dataTransfer = toExternalVSDataTransfer(dragEvent.dataTransfer);
-            if (this.treeItemsTransfer.hasData(DraggedTreeItemsIdentifier.prototype)) {
-                const data = this.treeItemsTransfer.getData(DraggedTreeItemsIdentifier.prototype);
-                if (Array.isArray(data)) {
-                    for (const id of data) {
-                        const treeDataTransfer = yield this._treeViewsDragAndDropService.removeDragOperationTransfer(id.identifier);
-                        if (treeDataTransfer) {
-                            for (const [type, value] of treeDataTransfer) {
-                                dataTransfer.replace(type, value);
-                            }
+    async extractDataTransferData(dragEvent) {
+        if (!dragEvent.dataTransfer) {
+            return new VSDataTransfer();
+        }
+        const dataTransfer = toExternalVSDataTransfer(dragEvent.dataTransfer);
+        if (this.treeItemsTransfer.hasData(DraggedTreeItemsIdentifier.prototype)) {
+            const data = this.treeItemsTransfer.getData(DraggedTreeItemsIdentifier.prototype);
+            if (Array.isArray(data)) {
+                for (const id of data) {
+                    const treeDataTransfer = await this._treeViewsDragAndDropService.removeDragOperationTransfer(id.identifier);
+                    if (treeDataTransfer) {
+                        for (const [type, value] of treeDataTransfer) {
+                            dataTransfer.replace(type, value);
                         }
                     }
                 }
             }
-            return dataTransfer;
-        });
+        }
+        return dataTransfer;
     }
 };
 DropIntoEditorController.ID = 'editor.contrib.dropIntoEditorController';
diff -urN -x '*.map' a/vs/editor/contrib/dropOrPasteInto/browser/edit.js b/vs/editor/contrib/dropOrPasteInto/browser/edit.js
--- a/vs/editor/contrib/dropOrPasteInto/browser/edit.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/dropOrPasteInto/browser/edit.js	2023-12-06 14:23:14.375854776 +0000
@@ -4,18 +4,16 @@
  *--------------------------------------------------------------------------------------------*/
 import { ResourceTextEdit } from '../../../browser/services/bulkEditService.js';
 export function createCombinedWorkspaceEdit(uri, ranges, edit) {
-    var _a, _b;
     return {
         edits: [
             ...ranges.map(range => new ResourceTextEdit(uri, typeof edit.insertText === 'string'
                 ? { range, text: edit.insertText, insertAsSnippet: false }
                 : { range, text: edit.insertText.snippet, insertAsSnippet: true })),
-            ...((_b = (_a = edit.additionalEdit) === null || _a === void 0 ? void 0 : _a.edits) !== null && _b !== void 0 ? _b : [])
+            ...(edit.additionalEdit?.edits ?? [])
         ]
     };
 }
 export function sortEditsByYieldTo(edits) {
-    var _a;
     function yieldsTo(yTo, other) {
         return ('providerId' in yTo && yTo.providerId === other.providerId)
             || ('mimeType' in yTo && yTo.mimeType === other.handledMimeType);
@@ -23,7 +21,7 @@
     // Build list of nodes each node yields to
     const yieldsToMap = new Map();
     for (const edit of edits) {
-        for (const yTo of (_a = edit.yieldTo) !== null && _a !== void 0 ? _a : []) {
+        for (const yTo of edit.yieldTo ?? []) {
             for (const other of edits) {
                 if (other === edit) {
                     continue;
diff -urN -x '*.map' a/vs/editor/contrib/dropOrPasteInto/browser/postEditWidget.js b/vs/editor/contrib/dropOrPasteInto/browser/postEditWidget.js
--- a/vs/editor/contrib/dropOrPasteInto/browser/postEditWidget.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/dropOrPasteInto/browser/postEditWidget.js	2023-12-06 14:23:14.375854776 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var PostEditWidget_1;
 import * as dom from '../../../../base/browser/dom.js';
 import { Button } from '../../../../base/browser/ui/button/button.js';
@@ -62,8 +53,7 @@
         }));
     }
     _updateButtonTitle() {
-        var _a;
-        const binding = (_a = this._keybindingService.lookupKeybinding(this.showCommand.id)) === null || _a === void 0 ? void 0 : _a.getLabel();
+        const binding = this._keybindingService.lookupKeybinding(this.showCommand.id)?.getLabel();
         this.button.element.title = this.showCommand.label + (binding ? ` (${binding})` : '');
     }
     create() {
@@ -125,59 +115,56 @@
         this._currentWidget = this._register(new MutableDisposable());
         this._register(Event.any(_editor.onDidChangeModel, _editor.onDidChangeModelContent)(() => this.clear()));
     }
-    applyEditAndShowIfNeeded(ranges, edits, canShowWidget, token) {
-        var _a, _b;
-        return __awaiter(this, void 0, void 0, function* () {
-            const model = this._editor.getModel();
-            if (!model || !ranges.length) {
-                return;
-            }
-            const edit = edits.allEdits[edits.activeEditIndex];
-            if (!edit) {
-                return;
-            }
-            let insertTextEdit = [];
-            if (typeof edit.insertText === 'string' ? edit.insertText === '' : edit.insertText.snippet === '') {
-                insertTextEdit = [];
-            }
-            else {
-                insertTextEdit = ranges.map(range => new ResourceTextEdit(model.uri, typeof edit.insertText === 'string'
-                    ? { range, text: edit.insertText, insertAsSnippet: false }
-                    : { range, text: edit.insertText.snippet, insertAsSnippet: true }));
-            }
-            const allEdits = [
-                ...insertTextEdit,
-                ...((_b = (_a = edit.additionalEdit) === null || _a === void 0 ? void 0 : _a.edits) !== null && _b !== void 0 ? _b : [])
-            ];
-            const combinedWorkspaceEdit = {
-                edits: allEdits
-            };
-            // Use a decoration to track edits around the trigger range
-            const primaryRange = ranges[0];
-            const editTrackingDecoration = model.deltaDecorations([], [{
-                    range: primaryRange,
-                    options: { description: 'paste-line-suffix', stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }
-                }]);
-            let editResult;
-            let editRange;
-            try {
-                editResult = yield this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor, token });
-                editRange = model.getDecorationRange(editTrackingDecoration[0]);
-            }
-            finally {
-                model.deltaDecorations(editTrackingDecoration, []);
-            }
-            if (canShowWidget && editResult.isApplied && edits.allEdits.length > 1) {
-                this.show(editRange !== null && editRange !== void 0 ? editRange : primaryRange, edits, (newEditIndex) => __awaiter(this, void 0, void 0, function* () {
-                    const model = this._editor.getModel();
-                    if (!model) {
-                        return;
-                    }
-                    yield model.undo();
-                    this.applyEditAndShowIfNeeded(ranges, { activeEditIndex: newEditIndex, allEdits: edits.allEdits }, canShowWidget, token);
-                }));
-            }
-        });
+    async applyEditAndShowIfNeeded(ranges, edits, canShowWidget, token) {
+        const model = this._editor.getModel();
+        if (!model || !ranges.length) {
+            return;
+        }
+        const edit = edits.allEdits[edits.activeEditIndex];
+        if (!edit) {
+            return;
+        }
+        let insertTextEdit = [];
+        if (typeof edit.insertText === 'string' ? edit.insertText === '' : edit.insertText.snippet === '') {
+            insertTextEdit = [];
+        }
+        else {
+            insertTextEdit = ranges.map(range => new ResourceTextEdit(model.uri, typeof edit.insertText === 'string'
+                ? { range, text: edit.insertText, insertAsSnippet: false }
+                : { range, text: edit.insertText.snippet, insertAsSnippet: true }));
+        }
+        const allEdits = [
+            ...insertTextEdit,
+            ...(edit.additionalEdit?.edits ?? [])
+        ];
+        const combinedWorkspaceEdit = {
+            edits: allEdits
+        };
+        // Use a decoration to track edits around the trigger range
+        const primaryRange = ranges[0];
+        const editTrackingDecoration = model.deltaDecorations([], [{
+                range: primaryRange,
+                options: { description: 'paste-line-suffix', stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }
+            }]);
+        let editResult;
+        let editRange;
+        try {
+            editResult = await this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor, token });
+            editRange = model.getDecorationRange(editTrackingDecoration[0]);
+        }
+        finally {
+            model.deltaDecorations(editTrackingDecoration, []);
+        }
+        if (canShowWidget && editResult.isApplied && edits.allEdits.length > 1) {
+            this.show(editRange ?? primaryRange, edits, async (newEditIndex) => {
+                const model = this._editor.getModel();
+                if (!model) {
+                    return;
+                }
+                await model.undo();
+                this.applyEditAndShowIfNeeded(ranges, { activeEditIndex: newEditIndex, allEdits: edits.allEdits }, canShowWidget, token);
+            });
+        }
     }
     show(range, edits, onDidSelectEdit) {
         this.clear();
@@ -189,8 +176,7 @@
         this._currentWidget.clear();
     }
     tryShowSelector() {
-        var _a;
-        (_a = this._currentWidget.value) === null || _a === void 0 ? void 0 : _a.showSelector();
+        this._currentWidget.value?.showSelector();
     }
 };
 PostEditWidgetManager = __decorate([
diff -urN -x '*.map' a/vs/editor/contrib/editorState/browser/keybindingCancellation.js b/vs/editor/contrib/editorState/browser/keybindingCancellation.js
--- a/vs/editor/contrib/editorState/browser/keybindingCancellation.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/editorState/browser/keybindingCancellation.js	2023-12-06 14:23:14.375854776 +0000
@@ -8,9 +8,9 @@
 import { LinkedList } from '../../../../base/common/linkedList.js';
 import { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';
 import { registerSingleton } from '../../../../platform/instantiation/common/extensions.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 const IEditorCancellationTokens = createDecorator('IEditorCancelService');
-const ctxCancellableOperation = new RawContextKey('cancellableOperation', false, localize('cancellableOperation', 'Whether the editor runs a cancellable operation, e.g. like \'Peek References\''));
+const ctxCancellableOperation = new RawContextKey('cancellableOperation', false, localizeWithPath('vs/editor/contrib/editorState/browser/keybindingCancellation', 'cancellableOperation', 'Whether the editor runs a cancellable operation, e.g. like \'Peek References\''));
 registerSingleton(IEditorCancellationTokens, class {
     constructor() {
         this._tokens = new WeakMap();
diff -urN -x '*.map' a/vs/editor/contrib/find/browser/findController.js b/vs/editor/contrib/find/browser/findController.js
--- a/vs/editor/contrib/find/browser/findController.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/find/browser/findController.js	2023-12-06 14:23:14.375854776 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var CommonFindController_1;
 import { Delayer } from '../../../../base/common/async.js';
 import { Disposable } from '../../../../base/common/lifecycle.js';
@@ -199,8 +190,8 @@
         }
         else {
             if (this._editor.hasModel()) {
-                const selections = this._editor.getSelections();
-                selections.map(selection => {
+                let selections = this._editor.getSelections();
+                selections = selections.map(selection => {
                     if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
                         selection = selection.setEndPosition(selection.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
                     }
@@ -208,7 +199,7 @@
                         return selection;
                     }
                     return null;
-                }).filter(element => !!element);
+                }).filter((element) => !!element);
                 if (selections.length) {
                     this._state.change({ searchScope: selections }, true);
                 }
@@ -224,60 +215,61 @@
     highlightFindOptions(ignoreWhenVisible = false) {
         // overwritten in subclass
     }
-    _start(opts, newState) {
-        return __awaiter(this, void 0, void 0, function* () {
-            this.disposeModel();
-            if (!this._editor.hasModel()) {
-                // cannot do anything with an editor that doesn't have a model...
-                return;
-            }
-            const stateChanges = Object.assign(Object.assign({}, newState), { isRevealed: true });
-            if (opts.seedSearchStringFromSelection === 'single') {
-                const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection, opts.seedSearchStringFromNonEmptySelection);
-                if (selectionSearchString) {
-                    if (this._state.isRegex) {
-                        stateChanges.searchString = strings.escapeRegExpCharacters(selectionSearchString);
-                    }
-                    else {
-                        stateChanges.searchString = selectionSearchString;
-                    }
+    async _start(opts, newState) {
+        this.disposeModel();
+        if (!this._editor.hasModel()) {
+            // cannot do anything with an editor that doesn't have a model...
+            return;
+        }
+        const stateChanges = {
+            ...newState,
+            isRevealed: true
+        };
+        if (opts.seedSearchStringFromSelection === 'single') {
+            const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection, opts.seedSearchStringFromNonEmptySelection);
+            if (selectionSearchString) {
+                if (this._state.isRegex) {
+                    stateChanges.searchString = strings.escapeRegExpCharacters(selectionSearchString);
                 }
-            }
-            else if (opts.seedSearchStringFromSelection === 'multiple' && !opts.updateSearchScope) {
-                const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection);
-                if (selectionSearchString) {
+                else {
                     stateChanges.searchString = selectionSearchString;
                 }
             }
-            if (!stateChanges.searchString && opts.seedSearchStringFromGlobalClipboard) {
-                const selectionSearchString = yield this.getGlobalBufferTerm();
-                if (!this._editor.hasModel()) {
-                    // the editor has lost its model in the meantime
-                    return;
-                }
-                if (selectionSearchString) {
-                    stateChanges.searchString = selectionSearchString;
-                }
+        }
+        else if (opts.seedSearchStringFromSelection === 'multiple' && !opts.updateSearchScope) {
+            const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection);
+            if (selectionSearchString) {
+                stateChanges.searchString = selectionSearchString;
             }
-            // Overwrite isReplaceRevealed
-            if (opts.forceRevealReplace || stateChanges.isReplaceRevealed) {
-                stateChanges.isReplaceRevealed = true;
-            }
-            else if (!this._findWidgetVisible.get()) {
-                stateChanges.isReplaceRevealed = false;
-            }
-            if (opts.updateSearchScope) {
-                const currentSelections = this._editor.getSelections();
-                if (currentSelections.some(selection => !selection.isEmpty())) {
-                    stateChanges.searchScope = currentSelections;
-                }
+        }
+        if (!stateChanges.searchString && opts.seedSearchStringFromGlobalClipboard) {
+            const selectionSearchString = await this.getGlobalBufferTerm();
+            if (!this._editor.hasModel()) {
+                // the editor has lost its model in the meantime
+                return;
             }
-            stateChanges.loop = opts.loop;
-            this._state.change(stateChanges, false);
-            if (!this._model) {
-                this._model = new FindModelBoundToEditorModel(this._editor, this._state);
+            if (selectionSearchString) {
+                stateChanges.searchString = selectionSearchString;
             }
-        });
+        }
+        // Overwrite isReplaceRevealed
+        if (opts.forceRevealReplace || stateChanges.isReplaceRevealed) {
+            stateChanges.isReplaceRevealed = true;
+        }
+        else if (!this._findWidgetVisible.get()) {
+            stateChanges.isReplaceRevealed = false;
+        }
+        if (opts.updateSearchScope) {
+            const currentSelections = this._editor.getSelections();
+            if (currentSelections.some(selection => !selection.isEmpty())) {
+                stateChanges.searchScope = currentSelections;
+            }
+        }
+        stateChanges.loop = opts.loop;
+        this._state.change(stateChanges, false);
+        if (!this._model) {
+            this._model = new FindModelBoundToEditorModel(this._editor, this._state);
+        }
     }
     start(opts, newState) {
         return this._start(opts, newState);
@@ -311,10 +303,9 @@
         return false;
     }
     replaceAll() {
-        var _a;
         if (this._model) {
-            if ((_a = this._editor.getModel()) === null || _a === void 0 ? void 0 : _a.isTooLargeForHeapOperation()) {
-                this._notificationService.warn(nls.localize('too.large.for.replaceall', "The file is too large to perform a replace all operation."));
+            if (this._editor.getModel()?.isTooLargeForHeapOperation()) {
+                this._notificationService.warn(nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'too.large.for.replaceall', "The file is too large to perform a replace all operation."));
                 return false;
             }
             this._model.replaceAll();
@@ -330,15 +321,13 @@
         }
         return false;
     }
-    getGlobalBufferTerm() {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (this._editor.getOption(41 /* EditorOption.find */).globalFindClipboard
-                && this._editor.hasModel()
-                && !this._editor.getModel().isTooLargeForSyncing()) {
-                return this._clipboardService.readFindText();
-            }
-            return '';
-        });
+    async getGlobalBufferTerm() {
+        if (this._editor.getOption(41 /* EditorOption.find */).globalFindClipboard
+            && this._editor.hasModel()
+            && !this._editor.getModel().isTooLargeForSyncing()) {
+            return this._clipboardService.readFindText();
+        }
+        return '';
     }
     setGlobalBufferTerm(text) {
         if (this._editor.getOption(41 /* EditorOption.find */).globalFindClipboard
@@ -366,42 +355,37 @@
         this._widget = null;
         this._findOptionsWidget = null;
     }
-    _start(opts, newState) {
-        const _super = Object.create(null, {
-            _start: { get: () => super._start }
-        });
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!this._widget) {
-                this._createFindWidget();
-            }
-            const selection = this._editor.getSelection();
-            let updateSearchScope = false;
-            switch (this._editor.getOption(41 /* EditorOption.find */).autoFindInSelection) {
-                case 'always':
-                    updateSearchScope = true;
-                    break;
-                case 'never':
-                    updateSearchScope = false;
-                    break;
-                case 'multiline': {
-                    const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
-                    updateSearchScope = isSelectionMultipleLine;
-                    break;
-                }
-                default:
-                    break;
+    async _start(opts, newState) {
+        if (!this._widget) {
+            this._createFindWidget();
+        }
+        const selection = this._editor.getSelection();
+        let updateSearchScope = false;
+        switch (this._editor.getOption(41 /* EditorOption.find */).autoFindInSelection) {
+            case 'always':
+                updateSearchScope = true;
+                break;
+            case 'never':
+                updateSearchScope = false;
+                break;
+            case 'multiline': {
+                const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
+                updateSearchScope = isSelectionMultipleLine;
+                break;
+            }
+            default:
+                break;
+        }
+        opts.updateSearchScope = opts.updateSearchScope || updateSearchScope;
+        await super._start(opts, newState);
+        if (this._widget) {
+            if (opts.shouldFocus === 2 /* FindStartFocusAction.FocusReplaceInput */) {
+                this._widget.focusReplaceInput();
             }
-            opts.updateSearchScope = opts.updateSearchScope || updateSearchScope;
-            yield _super._start.call(this, opts, newState);
-            if (this._widget) {
-                if (opts.shouldFocus === 2 /* FindStartFocusAction.FocusReplaceInput */) {
-                    this._widget.focusReplaceInput();
-                }
-                else if (opts.shouldFocus === 1 /* FindStartFocusAction.FocusFindInput */) {
-                    this._widget.focusFindInput();
-                }
+            else if (opts.shouldFocus === 1 /* FindStartFocusAction.FocusFindInput */) {
+                this._widget.focusFindInput();
             }
-        });
+        }
     }
     highlightFindOptions(ignoreWhenVisible = false) {
         if (!this._widget) {
@@ -418,6 +402,12 @@
         this._widget = this._register(new FindWidget(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService));
         this._findOptionsWidget = this._register(new FindOptionsWidget(this._editor, this._state, this._keybindingService));
     }
+    saveViewState() {
+        return this._widget?.getViewState();
+    }
+    restoreViewState(state) {
+        this._widget?.setViewState(state);
+    }
 };
 FindController = __decorate([
     __param(1, IContextViewService),
@@ -431,7 +421,7 @@
 export { FindController };
 export const StartFindAction = registerMultiEditorAction(new MultiEditorAction({
     id: FIND_IDS.StartFindAction,
-    label: nls.localize('startFindAction', "Find"),
+    label: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'startFindAction', "Find"),
     alias: 'Find',
     precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has('editorIsOpen')),
     kbOpts: {
@@ -442,7 +432,7 @@
     menuOpts: {
         menuId: MenuId.MenubarEditMenu,
         group: '3_find',
-        title: nls.localize({ key: 'miFind', comment: ['&& denotes a mnemonic'] }, "&&Find"),
+        title: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', { key: 'miFind', comment: ['&& denotes a mnemonic'] }, "&&Find"),
         order: 1
     }
 }));
@@ -473,22 +463,22 @@
                     regex: { type: 'boolean' },
                     regexOverride: {
                         type: 'number',
-                        description: nls.localize('actions.find.isRegexOverride', 'Overrides "Use Regular Expression" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
+                        description: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'actions.find.isRegexOverride', 'Overrides "Use Regular Expression" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
                     },
                     wholeWord: { type: 'boolean' },
                     wholeWordOverride: {
                         type: 'number',
-                        description: nls.localize('actions.find.wholeWordOverride', 'Overrides "Match Whole Word" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
+                        description: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'actions.find.wholeWordOverride', 'Overrides "Match Whole Word" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
                     },
                     matchCase: { type: 'boolean' },
                     matchCaseOverride: {
                         type: 'number',
-                        description: nls.localize('actions.find.matchCaseOverride', 'Overrides "Math Case" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
+                        description: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'actions.find.matchCaseOverride', 'Overrides "Math Case" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
                     },
                     preserveCase: { type: 'boolean' },
                     preserveCaseOverride: {
                         type: 'number',
-                        description: nls.localize('actions.find.preserveCaseOverride', 'Overrides "Preserve Case" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
+                        description: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'actions.find.preserveCaseOverride', 'Overrides "Preserve Case" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
                     },
                     findInSelection: { type: 'boolean' },
                 }
@@ -499,7 +489,7 @@
     constructor() {
         super({
             id: FIND_IDS.StartFindWithArgs,
-            label: nls.localize('startFindWithArgsAction', "Find With Arguments"),
+            label: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'startFindWithArgsAction', "Find With Arguments"),
             alias: 'Find With Arguments',
             precondition: undefined,
             kbOpts: {
@@ -510,43 +500,41 @@
             description: findArgDescription
         });
     }
-    run(accessor, editor, args) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const controller = CommonFindController.get(editor);
-            if (controller) {
-                const newState = args ? {
-                    searchString: args.searchString,
-                    replaceString: args.replaceString,
-                    isReplaceRevealed: args.replaceString !== undefined,
-                    isRegex: args.isRegex,
-                    // isRegexOverride: args.regexOverride,
-                    wholeWord: args.matchWholeWord,
-                    // wholeWordOverride: args.wholeWordOverride,
-                    matchCase: args.isCaseSensitive,
-                    // matchCaseOverride: args.matchCaseOverride,
-                    preserveCase: args.preserveCase,
-                    // preserveCaseOverride: args.preserveCaseOverride,
-                } : {};
-                yield controller.start({
-                    forceRevealReplace: false,
-                    seedSearchStringFromSelection: (controller.getState().searchString.length === 0) && editor.getOption(41 /* EditorOption.find */).seedSearchStringFromSelection !== 'never' ? 'single' : 'none',
-                    seedSearchStringFromNonEmptySelection: editor.getOption(41 /* EditorOption.find */).seedSearchStringFromSelection === 'selection',
-                    seedSearchStringFromGlobalClipboard: true,
-                    shouldFocus: 1 /* FindStartFocusAction.FocusFindInput */,
-                    shouldAnimate: true,
-                    updateSearchScope: (args === null || args === void 0 ? void 0 : args.findInSelection) || false,
-                    loop: editor.getOption(41 /* EditorOption.find */).loop
-                }, newState);
-                controller.setGlobalBufferTerm(controller.getState().searchString);
-            }
-        });
+    async run(accessor, editor, args) {
+        const controller = CommonFindController.get(editor);
+        if (controller) {
+            const newState = args ? {
+                searchString: args.searchString,
+                replaceString: args.replaceString,
+                isReplaceRevealed: args.replaceString !== undefined,
+                isRegex: args.isRegex,
+                // isRegexOverride: args.regexOverride,
+                wholeWord: args.matchWholeWord,
+                // wholeWordOverride: args.wholeWordOverride,
+                matchCase: args.isCaseSensitive,
+                // matchCaseOverride: args.matchCaseOverride,
+                preserveCase: args.preserveCase,
+                // preserveCaseOverride: args.preserveCaseOverride,
+            } : {};
+            await controller.start({
+                forceRevealReplace: false,
+                seedSearchStringFromSelection: (controller.getState().searchString.length === 0) && editor.getOption(41 /* EditorOption.find */).seedSearchStringFromSelection !== 'never' ? 'single' : 'none',
+                seedSearchStringFromNonEmptySelection: editor.getOption(41 /* EditorOption.find */).seedSearchStringFromSelection === 'selection',
+                seedSearchStringFromGlobalClipboard: true,
+                shouldFocus: 1 /* FindStartFocusAction.FocusFindInput */,
+                shouldAnimate: true,
+                updateSearchScope: args?.findInSelection || false,
+                loop: editor.getOption(41 /* EditorOption.find */).loop
+            }, newState);
+            controller.setGlobalBufferTerm(controller.getState().searchString);
+        }
     }
 }
 export class StartFindWithSelectionAction extends EditorAction {
     constructor() {
         super({
             id: FIND_IDS.StartFindWithSelection,
-            label: nls.localize('startFindWithSelectionAction', "Find With Selection"),
+            label: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'startFindWithSelectionAction', "Find With Selection"),
             alias: 'Find With Selection',
             precondition: undefined,
             kbOpts: {
@@ -559,50 +547,46 @@
             }
         });
     }
-    run(accessor, editor) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const controller = CommonFindController.get(editor);
-            if (controller) {
-                yield controller.start({
-                    forceRevealReplace: false,
-                    seedSearchStringFromSelection: 'multiple',
-                    seedSearchStringFromNonEmptySelection: false,
-                    seedSearchStringFromGlobalClipboard: false,
-                    shouldFocus: 0 /* FindStartFocusAction.NoFocusChange */,
-                    shouldAnimate: true,
-                    updateSearchScope: false,
-                    loop: editor.getOption(41 /* EditorOption.find */).loop
-                });
-                controller.setGlobalBufferTerm(controller.getState().searchString);
-            }
-        });
+    async run(accessor, editor) {
+        const controller = CommonFindController.get(editor);
+        if (controller) {
+            await controller.start({
+                forceRevealReplace: false,
+                seedSearchStringFromSelection: 'multiple',
+                seedSearchStringFromNonEmptySelection: false,
+                seedSearchStringFromGlobalClipboard: false,
+                shouldFocus: 0 /* FindStartFocusAction.NoFocusChange */,
+                shouldAnimate: true,
+                updateSearchScope: false,
+                loop: editor.getOption(41 /* EditorOption.find */).loop
+            });
+            controller.setGlobalBufferTerm(controller.getState().searchString);
+        }
     }
 }
 export class MatchFindAction extends EditorAction {
-    run(accessor, editor) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const controller = CommonFindController.get(editor);
-            if (controller && !this._run(controller)) {
-                yield controller.start({
-                    forceRevealReplace: false,
-                    seedSearchStringFromSelection: (controller.getState().searchString.length === 0) && editor.getOption(41 /* EditorOption.find */).seedSearchStringFromSelection !== 'never' ? 'single' : 'none',
-                    seedSearchStringFromNonEmptySelection: editor.getOption(41 /* EditorOption.find */).seedSearchStringFromSelection === 'selection',
-                    seedSearchStringFromGlobalClipboard: true,
-                    shouldFocus: 0 /* FindStartFocusAction.NoFocusChange */,
-                    shouldAnimate: true,
-                    updateSearchScope: false,
-                    loop: editor.getOption(41 /* EditorOption.find */).loop
-                });
-                this._run(controller);
-            }
-        });
+    async run(accessor, editor) {
+        const controller = CommonFindController.get(editor);
+        if (controller && !this._run(controller)) {
+            await controller.start({
+                forceRevealReplace: false,
+                seedSearchStringFromSelection: (controller.getState().searchString.length === 0) && editor.getOption(41 /* EditorOption.find */).seedSearchStringFromSelection !== 'never' ? 'single' : 'none',
+                seedSearchStringFromNonEmptySelection: editor.getOption(41 /* EditorOption.find */).seedSearchStringFromSelection === 'selection',
+                seedSearchStringFromGlobalClipboard: true,
+                shouldFocus: 0 /* FindStartFocusAction.NoFocusChange */,
+                shouldAnimate: true,
+                updateSearchScope: false,
+                loop: editor.getOption(41 /* EditorOption.find */).loop
+            });
+            this._run(controller);
+        }
     }
 }
 export class NextMatchFindAction extends MatchFindAction {
     constructor() {
         super({
             id: FIND_IDS.NextMatchFindAction,
-            label: nls.localize('findNextMatchAction', "Find Next"),
+            label: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'findNextMatchAction', "Find Next"),
             alias: 'Find Next',
             precondition: undefined,
             kbOpts: [{
@@ -630,7 +614,7 @@
     constructor() {
         super({
             id: FIND_IDS.PreviousMatchFindAction,
-            label: nls.localize('findPreviousMatchAction', "Find Previous"),
+            label: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'findPreviousMatchAction', "Find Previous"),
             alias: 'Find Previous',
             precondition: undefined,
             kbOpts: [{
@@ -654,7 +638,7 @@
     constructor() {
         super({
             id: FIND_IDS.GoToMatchFindAction,
-            label: nls.localize('findMatchAction.goToMatch', "Go to Match..."),
+            label: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'findMatchAction.goToMatch', "Go to Match..."),
             alias: 'Go to Match...',
             precondition: CONTEXT_FIND_WIDGET_VISIBLE
         });
@@ -670,13 +654,13 @@
             const notificationService = accessor.get(INotificationService);
             notificationService.notify({
                 severity: Severity.Warning,
-                message: nls.localize('findMatchAction.noResults', "No matches. Try searching for something else.")
+                message: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'findMatchAction.noResults', "No matches. Try searching for something else.")
             });
             return;
         }
         const quickInputService = accessor.get(IQuickInputService);
         const inputBox = quickInputService.createInputBox();
-        inputBox.placeholder = nls.localize('findMatchAction.inputPlaceHolder', "Type a number to go to a specific match (between 1 and {0})", matchesCount);
+        inputBox.placeholder = nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'findMatchAction.inputPlaceHolder', "Type a number to go to a specific match (between 1 and {0})", matchesCount);
         const toFindMatchIndex = (value) => {
             const index = parseInt(value);
             if (isNaN(index)) {
@@ -703,7 +687,7 @@
                 }
             }
             else {
-                inputBox.validationMessage = nls.localize('findMatchAction.inputValidationMessage', "Please type a number between 1 and {0}", controller.getState().matchesCount);
+                inputBox.validationMessage = nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'findMatchAction.inputValidationMessage', "Please type a number between 1 and {0}", controller.getState().matchesCount);
                 this.clearDecorations(editor);
             }
         };
@@ -717,7 +701,7 @@
                 inputBox.hide();
             }
             else {
-                inputBox.validationMessage = nls.localize('findMatchAction.inputValidationMessage', "Please type a number between 1 and {0}", controller.getState().matchesCount);
+                inputBox.validationMessage = nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'findMatchAction.inputValidationMessage', "Please type a number between 1 and {0}", controller.getState().matchesCount);
             }
         });
         inputBox.onDidHide(() => {
@@ -757,37 +741,35 @@
     }
 }
 export class SelectionMatchFindAction extends EditorAction {
-    run(accessor, editor) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const controller = CommonFindController.get(editor);
-            if (!controller) {
-                return;
-            }
-            const selectionSearchString = getSelectionSearchString(editor, 'single', false);
-            if (selectionSearchString) {
-                controller.setSearchString(selectionSearchString);
-            }
-            if (!this._run(controller)) {
-                yield controller.start({
-                    forceRevealReplace: false,
-                    seedSearchStringFromSelection: 'none',
-                    seedSearchStringFromNonEmptySelection: false,
-                    seedSearchStringFromGlobalClipboard: false,
-                    shouldFocus: 0 /* FindStartFocusAction.NoFocusChange */,
-                    shouldAnimate: true,
-                    updateSearchScope: false,
-                    loop: editor.getOption(41 /* EditorOption.find */).loop
-                });
-                this._run(controller);
-            }
-        });
+    async run(accessor, editor) {
+        const controller = CommonFindController.get(editor);
+        if (!controller) {
+            return;
+        }
+        const selectionSearchString = getSelectionSearchString(editor, 'single', false);
+        if (selectionSearchString) {
+            controller.setSearchString(selectionSearchString);
+        }
+        if (!this._run(controller)) {
+            await controller.start({
+                forceRevealReplace: false,
+                seedSearchStringFromSelection: 'none',
+                seedSearchStringFromNonEmptySelection: false,
+                seedSearchStringFromGlobalClipboard: false,
+                shouldFocus: 0 /* FindStartFocusAction.NoFocusChange */,
+                shouldAnimate: true,
+                updateSearchScope: false,
+                loop: editor.getOption(41 /* EditorOption.find */).loop
+            });
+            this._run(controller);
+        }
     }
 }
 export class NextSelectionMatchFindAction extends SelectionMatchFindAction {
     constructor() {
         super({
             id: FIND_IDS.NextSelectionMatchFindAction,
-            label: nls.localize('nextSelectionMatchFindAction', "Find Next Selection"),
+            label: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'nextSelectionMatchFindAction', "Find Next Selection"),
             alias: 'Find Next Selection',
             precondition: undefined,
             kbOpts: {
@@ -805,7 +787,7 @@
     constructor() {
         super({
             id: FIND_IDS.PreviousSelectionMatchFindAction,
-            label: nls.localize('previousSelectionMatchFindAction', "Find Previous Selection"),
+            label: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'previousSelectionMatchFindAction', "Find Previous Selection"),
             alias: 'Find Previous Selection',
             precondition: undefined,
             kbOpts: {
@@ -821,7 +803,7 @@
 }
 export const StartFindReplaceAction = registerMultiEditorAction(new MultiEditorAction({
     id: FIND_IDS.StartFindReplaceAction,
-    label: nls.localize('startReplace', "Replace"),
+    label: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', 'startReplace', "Replace"),
     alias: 'Replace',
     precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has('editorIsOpen')),
     kbOpts: {
@@ -833,7 +815,7 @@
     menuOpts: {
         menuId: MenuId.MenubarEditMenu,
         group: '3_find',
-        title: nls.localize({ key: 'miReplace', comment: ['&& denotes a mnemonic'] }, "&&Replace"),
+        title: nls.localizeWithPath('vs/editor/contrib/find/browser/findController', { key: 'miReplace', comment: ['&& denotes a mnemonic'] }, "&&Replace"),
         order: 2
     }
 }));
diff -urN -x '*.map' a/vs/editor/contrib/find/browser/findDecorations.js b/vs/editor/contrib/find/browser/findDecorations.js
--- a/vs/editor/contrib/find/browser/findDecorations.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/find/browser/findDecorations.js	2023-12-06 14:23:14.375854776 +0000
@@ -181,7 +181,7 @@
                 this._findScopeDecorationIds.forEach(findScopeDecorationId => accessor.removeDecoration(findScopeDecorationId));
                 this._findScopeDecorationIds = [];
             }
-            if (findScopes === null || findScopes === void 0 ? void 0 : findScopes.length) {
+            if (findScopes?.length) {
                 this._findScopeDecorationIds = findScopes.map(findScope => accessor.addDecoration(findScope, FindDecorations._FIND_SCOPE_DECORATION));
             }
         });
diff -urN -x '*.map' a/vs/editor/contrib/find/browser/findOptionsWidget.js b/vs/editor/contrib/find/browser/findOptionsWidget.js
--- a/vs/editor/contrib/find/browser/findOptionsWidget.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/find/browser/findOptionsWidget.js	2023-12-06 14:23:14.375854776 +0000
@@ -29,21 +29,33 @@
             inputActiveOptionForeground: asCssVariable(inputActiveOptionForeground),
             inputActiveOptionBackground: asCssVariable(inputActiveOptionBackground),
         };
-        this.caseSensitive = this._register(new CaseSensitiveToggle(Object.assign({ appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand), isChecked: this._state.matchCase }, toggleStyles)));
+        this.caseSensitive = this._register(new CaseSensitiveToggle({
+            appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
+            isChecked: this._state.matchCase,
+            ...toggleStyles
+        }));
         this._domNode.appendChild(this.caseSensitive.domNode);
         this._register(this.caseSensitive.onChange(() => {
             this._state.change({
                 matchCase: this.caseSensitive.checked
             }, false);
         }));
-        this.wholeWords = this._register(new WholeWordsToggle(Object.assign({ appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand), isChecked: this._state.wholeWord }, toggleStyles)));
+        this.wholeWords = this._register(new WholeWordsToggle({
+            appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
+            isChecked: this._state.wholeWord,
+            ...toggleStyles
+        }));
         this._domNode.appendChild(this.wholeWords.domNode);
         this._register(this.wholeWords.onChange(() => {
             this._state.change({
                 wholeWord: this.wholeWords.checked
             }, false);
         }));
-        this.regex = this._register(new RegexToggle(Object.assign({ appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand), isChecked: this._state.isRegex }, toggleStyles)));
+        this.regex = this._register(new RegexToggle({
+            appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
+            isChecked: this._state.isRegex,
+            ...toggleStyles
+        }));
         this._domNode.appendChild(this.regex.domNode);
         this._register(this.regex.onChange(() => {
             this._state.change({
diff -urN -x '*.map' a/vs/editor/contrib/find/browser/findState.js b/vs/editor/contrib/find/browser/findState.js
--- a/vs/editor/contrib/find/browser/findState.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/find/browser/findState.js	2023-12-06 14:23:14.375854776 +0000
@@ -32,6 +32,8 @@
     get matchesPosition() { return this._matchesPosition; }
     get matchesCount() { return this._matchesCount; }
     get currentMatch() { return this._currentMatch; }
+    get isSearching() { return this._isSearching; }
+    get filters() { return this._filters; }
     constructor() {
         super();
         this._onFindReplaceStateChange = this._register(new Emitter());
@@ -105,7 +107,6 @@
         }
     }
     change(newState, moveCursor, updateHistory = true) {
-        var _a;
         const changeEvent = {
             moveCursor: moveCursor,
             updateHistory: updateHistory,
@@ -171,12 +172,11 @@
             this._preserveCase = newState.preserveCase;
         }
         if (typeof newState.searchScope !== 'undefined') {
-            if (!((_a = newState.searchScope) === null || _a === void 0 ? void 0 : _a.every((newSearchScope) => {
-                var _a;
-                return (_a = this._searchScope) === null || _a === void 0 ? void 0 : _a.some(existingSearchScope => {
+            if (!newState.searchScope?.every((newSearchScope) => {
+                return this._searchScope?.some(existingSearchScope => {
                     return !Range.equalsRange(existingSearchScope, newSearchScope);
                 });
-            }))) {
+            })) {
                 this._searchScope = newState.searchScope;
                 changeEvent.searchScope = true;
                 somethingChanged = true;
diff -urN -x '*.map' a/vs/editor/contrib/find/browser/findWidget.js b/vs/editor/contrib/find/browser/findWidget.js
--- a/vs/editor/contrib/find/browser/findWidget.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/find/browser/findWidget.js	2023-12-06 14:23:14.375854776 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import * as dom from '../../../../base/browser/dom.js';
 import { alert as alertFn } from '../../../../base/browser/ui/aria/aria.js';
 import { Toggle } from '../../../../base/browser/ui/toggle/toggle.js';
@@ -35,28 +26,28 @@
 import { isHighContrast } from '../../../../platform/theme/common/theme.js';
 import { assertIsDefined } from '../../../../base/common/types.js';
 import { defaultInputBoxStyles, defaultToggleStyles } from '../../../../platform/theme/browser/defaultStyles.js';
-const findSelectionIcon = registerIcon('find-selection', Codicon.selection, nls.localize('findSelectionIcon', 'Icon for \'Find in Selection\' in the editor find widget.'));
-const findCollapsedIcon = registerIcon('find-collapsed', Codicon.chevronRight, nls.localize('findCollapsedIcon', 'Icon to indicate that the editor find widget is collapsed.'));
-const findExpandedIcon = registerIcon('find-expanded', Codicon.chevronDown, nls.localize('findExpandedIcon', 'Icon to indicate that the editor find widget is expanded.'));
-export const findReplaceIcon = registerIcon('find-replace', Codicon.replace, nls.localize('findReplaceIcon', 'Icon for \'Replace\' in the editor find widget.'));
-export const findReplaceAllIcon = registerIcon('find-replace-all', Codicon.replaceAll, nls.localize('findReplaceAllIcon', 'Icon for \'Replace All\' in the editor find widget.'));
-export const findPreviousMatchIcon = registerIcon('find-previous-match', Codicon.arrowUp, nls.localize('findPreviousMatchIcon', 'Icon for \'Find Previous\' in the editor find widget.'));
-export const findNextMatchIcon = registerIcon('find-next-match', Codicon.arrowDown, nls.localize('findNextMatchIcon', 'Icon for \'Find Next\' in the editor find widget.'));
-const NLS_FIND_DIALOG_LABEL = nls.localize('label.findDialog', "Find / Replace");
-const NLS_FIND_INPUT_LABEL = nls.localize('label.find', "Find");
-const NLS_FIND_INPUT_PLACEHOLDER = nls.localize('placeholder.find', "Find");
-const NLS_PREVIOUS_MATCH_BTN_LABEL = nls.localize('label.previousMatchButton', "Previous Match");
-const NLS_NEXT_MATCH_BTN_LABEL = nls.localize('label.nextMatchButton', "Next Match");
-const NLS_TOGGLE_SELECTION_FIND_TITLE = nls.localize('label.toggleSelectionFind', "Find in Selection");
-const NLS_CLOSE_BTN_LABEL = nls.localize('label.closeButton', "Close");
-const NLS_REPLACE_INPUT_LABEL = nls.localize('label.replace', "Replace");
-const NLS_REPLACE_INPUT_PLACEHOLDER = nls.localize('placeholder.replace', "Replace");
-const NLS_REPLACE_BTN_LABEL = nls.localize('label.replaceButton', "Replace");
-const NLS_REPLACE_ALL_BTN_LABEL = nls.localize('label.replaceAllButton', "Replace All");
-const NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = nls.localize('label.toggleReplaceButton', "Toggle Replace");
-const NLS_MATCHES_COUNT_LIMIT_TITLE = nls.localize('title.matchesCountLimit', "Only the first {0} results are highlighted, but all find operations work on the entire text.", MATCHES_LIMIT);
-export const NLS_MATCHES_LOCATION = nls.localize('label.matchesLocation', "{0} of {1}");
-export const NLS_NO_RESULTS = nls.localize('label.noResults', "No results");
+const findSelectionIcon = registerIcon('find-selection', Codicon.selection, nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'findSelectionIcon', 'Icon for \'Find in Selection\' in the editor find widget.'));
+const findCollapsedIcon = registerIcon('find-collapsed', Codicon.chevronRight, nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'findCollapsedIcon', 'Icon to indicate that the editor find widget is collapsed.'));
+const findExpandedIcon = registerIcon('find-expanded', Codicon.chevronDown, nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'findExpandedIcon', 'Icon to indicate that the editor find widget is expanded.'));
+export const findReplaceIcon = registerIcon('find-replace', Codicon.replace, nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'findReplaceIcon', 'Icon for \'Replace\' in the editor find widget.'));
+export const findReplaceAllIcon = registerIcon('find-replace-all', Codicon.replaceAll, nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'findReplaceAllIcon', 'Icon for \'Replace All\' in the editor find widget.'));
+export const findPreviousMatchIcon = registerIcon('find-previous-match', Codicon.arrowUp, nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'findPreviousMatchIcon', 'Icon for \'Find Previous\' in the editor find widget.'));
+export const findNextMatchIcon = registerIcon('find-next-match', Codicon.arrowDown, nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'findNextMatchIcon', 'Icon for \'Find Next\' in the editor find widget.'));
+const NLS_FIND_DIALOG_LABEL = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'label.findDialog', "Find / Replace");
+const NLS_FIND_INPUT_LABEL = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'label.find', "Find");
+const NLS_FIND_INPUT_PLACEHOLDER = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'placeholder.find', "Find");
+const NLS_PREVIOUS_MATCH_BTN_LABEL = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'label.previousMatchButton', "Previous Match");
+const NLS_NEXT_MATCH_BTN_LABEL = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'label.nextMatchButton', "Next Match");
+const NLS_TOGGLE_SELECTION_FIND_TITLE = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'label.toggleSelectionFind', "Find in Selection");
+const NLS_CLOSE_BTN_LABEL = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'label.closeButton', "Close");
+const NLS_REPLACE_INPUT_LABEL = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'label.replace', "Replace");
+const NLS_REPLACE_INPUT_PLACEHOLDER = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'placeholder.replace', "Replace");
+const NLS_REPLACE_BTN_LABEL = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'label.replaceButton', "Replace");
+const NLS_REPLACE_ALL_BTN_LABEL = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'label.replaceAllButton', "Replace All");
+const NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'label.toggleReplaceButton', "Toggle Replace");
+const NLS_MATCHES_COUNT_LIMIT_TITLE = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'title.matchesCountLimit', "Only the first {0} results are highlighted, but all find operations work on the entire text.", MATCHES_LIMIT);
+export const NLS_MATCHES_LOCATION = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'label.matchesLocation', "{0} of {1}");
+export const NLS_NO_RESULTS = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'label.noResults', "No results");
 const FIND_WIDGET_INITIAL_WIDTH = 419;
 const PART_WIDTH = 275;
 const FIND_INPUT_AREA_WIDTH = PART_WIDTH - 54;
@@ -145,15 +136,15 @@
                 this._updateToggleSelectionFindButton();
             }
         }));
-        this._register(this._codeEditor.onDidFocusEditorWidget(() => __awaiter(this, void 0, void 0, function* () {
+        this._register(this._codeEditor.onDidFocusEditorWidget(async () => {
             if (this._isVisible) {
-                const globalBufferTerm = yield this._controller.getGlobalBufferTerm();
+                const globalBufferTerm = await this._controller.getGlobalBufferTerm();
                 if (globalBufferTerm && globalBufferTerm !== this._state.searchString) {
                     this._state.change({ searchString: globalBufferTerm }, false);
                     this._findInput.select();
                 }
             }
-        })));
+        }));
         this._findInputFocused = CONTEXT_FIND_INPUT_FOCUSED.bindTo(contextKeyService);
         this._findFocusTracker = this._register(dom.trackFocus(this._findInput.inputBox.inputElement));
         this._register(this._findFocusTracker.onDidFocus(() => {
@@ -335,11 +326,11 @@
     _getAriaLabel(label, currentMatch, searchString) {
         if (label === NLS_NO_RESULTS) {
             return searchString === ''
-                ? nls.localize('ariaSearchNoResultEmpty', "{0} found", label)
-                : nls.localize('ariaSearchNoResult', "{0} found for '{1}'", label, searchString);
+                ? nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'ariaSearchNoResultEmpty', "{0} found", label)
+                : nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'ariaSearchNoResult', "{0} found for '{1}'", label, searchString);
         }
         if (currentMatch) {
-            const ariaLabel = nls.localize('ariaSearchNoResultWithLineNum', "{0} found for '{1}', at {2}", label, searchString, currentMatch.startLineNumber + ':' + currentMatch.startColumn);
+            const ariaLabel = nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'ariaSearchNoResultWithLineNum', "{0} found for '{1}', at {2}", label, searchString, currentMatch.startLineNumber + ':' + currentMatch.startColumn);
             const model = this._codeEditor.getModel();
             if (model && (currentMatch.startLineNumber <= model.getLineCount()) && (currentMatch.startLineNumber >= 1)) {
                 const lineContent = model.getLineContent(currentMatch.startLineNumber);
@@ -347,7 +338,7 @@
             }
             return ariaLabel;
         }
-        return nls.localize('ariaSearchNoResultWithLineNumNoCurrentMatch', "{0} found for '{1}'", label, searchString);
+        return nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'ariaSearchNoResultWithLineNumNoCurrentMatch', "{0} found for '{1}'", label, searchString);
     }
     /**
      * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').
@@ -702,7 +693,7 @@
             else {
                 if (platform.isWindows && platform.isNative && !this._ctrlEnterReplaceAllWarningPrompted) {
                     // this is the first time when users press Ctrl + Enter to replace all
-                    this._notificationService.info(nls.localize('ctrlEnter.keybindingChanged', 'Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior.'));
+                    this._notificationService.info(nls.localizeWithPath('vs/editor/contrib/find/browser/findWidget', 'ctrlEnter.keybindingChanged', 'Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior.'));
                     this._ctrlEnterReplaceAllWarningPrompted = true;
                     this._storageService.store(ctrlEnterReplaceAllWarningPromptedKey, true, 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);
                 }
@@ -858,8 +849,8 @@
         this._register(this._toggleSelectionFind.onChange(() => {
             if (this._toggleSelectionFind.checked) {
                 if (this._codeEditor.hasModel()) {
-                    const selections = this._codeEditor.getSelections();
-                    selections.map(selection => {
+                    let selections = this._codeEditor.getSelections();
+                    selections = selections.map(selection => {
                         if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
                             selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
                         }
@@ -867,7 +858,7 @@
                             return selection;
                         }
                         return null;
-                    }).filter(element => !!element);
+                    }).filter((element) => !!element);
                     if (selections.length) {
                         this._state.change({ searchScope: selections }, true);
                     }
@@ -1055,6 +1046,25 @@
         const value = this._codeEditor.getOption(2 /* EditorOption.accessibilitySupport */);
         this._findInput.setFocusInputOnOptionClick(value !== 2 /* AccessibilitySupport.Enabled */);
     }
+    getViewState() {
+        let widgetViewZoneVisible = false;
+        if (this._viewZone && this._viewZoneId) {
+            widgetViewZoneVisible = this._viewZone.heightInPx > this._codeEditor.getScrollTop();
+        }
+        return {
+            widgetViewZoneVisible,
+            scrollTop: this._codeEditor.getScrollTop()
+        };
+    }
+    setViewState(state) {
+        if (!state) {
+            return;
+        }
+        if (state.widgetViewZoneVisible) {
+            // we should add the view zone
+            this._layoutViewZone(state.scrollTop);
+        }
+    }
 }
 FindWidget.ID = 'editor.contrib.findWidget';
 export class SimpleButton extends Widget {
@@ -1079,13 +1089,12 @@
             e.preventDefault();
         });
         this.onkeydown(this._domNode, (e) => {
-            var _a, _b;
             if (e.equals(10 /* KeyCode.Space */) || e.equals(3 /* KeyCode.Enter */)) {
                 this._opts.onTrigger();
                 e.preventDefault();
                 return;
             }
-            (_b = (_a = this._opts).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, e);
+            this._opts.onKeyDown?.(e);
         });
     }
     get domNode() {
diff -urN -x '*.map' a/vs/editor/contrib/find/browser/replacePattern.js b/vs/editor/contrib/find/browser/replacePattern.js
--- a/vs/editor/contrib/find/browser/replacePattern.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/find/browser/replacePattern.js	2023-12-06 14:23:14.375854776 +0000
@@ -119,6 +119,9 @@
     static staticValue(value) {
         return new ReplacePiece(value, -1, null);
     }
+    static matchIndex(index) {
+        return new ReplacePiece(null, index, null);
+    }
     static caseOps(index, caseOps) {
         return new ReplacePiece(null, index, caseOps);
     }
diff -urN -x '*.map' a/vs/editor/contrib/folding/browser/folding.js b/vs/editor/contrib/folding/browser/folding.js
--- a/vs/editor/contrib/folding/browser/folding.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/folding/browser/folding.js	2023-12-06 14:23:14.375854776 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var FoldingController_1;
 import { createCancelablePromise, Delayer, RunOnceScheduler } from '../../../../base/common/async.js';
 import { CancellationToken } from '../../../../base/common/cancellation.js';
@@ -57,9 +48,12 @@
         return editor.getContribution(FoldingController_1.ID);
     }
     static getFoldingRangeProviders(languageFeaturesService, model) {
-        var _a, _b;
         const foldingRangeProviders = languageFeaturesService.foldingRangeProvider.ordered(model);
-        return (_b = ((_a = FoldingController_1._foldingRangeSelector) === null || _a === void 0 ? void 0 : _a.call(FoldingController_1, foldingRangeProviders, model))) !== null && _b !== void 0 ? _b : foldingRangeProviders;
+        return (FoldingController_1._foldingRangeSelector?.(foldingRangeProviders, model)) ?? foldingRangeProviders;
+    }
+    static setFoldingRangeProviderSelector(foldingRangeSelector) {
+        FoldingController_1._foldingRangeSelector = foldingRangeSelector;
+        return { dispose: () => { FoldingController_1._foldingRangeSelector = undefined; } };
     }
     constructor(editor, contextKeyService, languageConfigurationService, notificationService, languageFeatureDebounceService, languageFeaturesService) {
         super();
@@ -119,6 +113,9 @@
         }));
         this.onModelChanged();
     }
+    get limitReporter() {
+        return this._foldingLimitReporter;
+    }
     /**
      * Store view state.
      */
@@ -180,26 +177,24 @@
         this.localToDispose.add(this.editor.onMouseUp(e => this.onEditorMouseUp(e)));
         this.localToDispose.add({
             dispose: () => {
-                var _a, _b;
                 if (this.foldingRegionPromise) {
                     this.foldingRegionPromise.cancel();
                     this.foldingRegionPromise = null;
                 }
-                (_a = this.updateScheduler) === null || _a === void 0 ? void 0 : _a.cancel();
+                this.updateScheduler?.cancel();
                 this.updateScheduler = null;
                 this.foldingModel = null;
                 this.foldingModelPromise = null;
                 this.hiddenRangeModel = null;
                 this.cursorChangedScheduler = null;
-                (_b = this.rangeProvider) === null || _b === void 0 ? void 0 : _b.dispose();
+                this.rangeProvider?.dispose();
                 this.rangeProvider = null;
             }
         });
         this.triggerFoldingModelChanged();
     }
     onFoldingStrategyChanged() {
-        var _a;
-        (_a = this.rangeProvider) === null || _a === void 0 ? void 0 : _a.dispose();
+        this.rangeProvider?.dispose();
         this.rangeProvider = null;
         this.triggerFoldingModelChanged();
     }
@@ -221,8 +216,7 @@
         return this.foldingModelPromise;
     }
     onDidChangeModelContent(e) {
-        var _a;
-        (_a = this.hiddenRangeModel) === null || _a === void 0 ? void 0 : _a.notifyChangeModelContent(e);
+        this.hiddenRangeModel?.notifyChangeModelContent(e);
         this.triggerFoldingModelChanged();
     }
     triggerFoldingModelChanged() {
@@ -253,7 +247,7 @@
                         const selections = this.editor.getSelections();
                         const selectionLineNumbers = selections ? selections.map(s => s.startLineNumber) : [];
                         foldingModel.update(foldingRanges, selectionLineNumbers);
-                        scrollState === null || scrollState === void 0 ? void 0 : scrollState.restore(this.editor);
+                        scrollState?.restore(this.editor);
                         // update debounce info
                         const newValue = this.updateDebounceInfo.update(foldingModel.textModel, sw.elapsed());
                         if (this.updateScheduler) {
@@ -431,12 +425,19 @@
     constructor(editor) {
         this.editor = editor;
         this._onDidChange = new Emitter();
+        this.onDidChange = this._onDidChange.event;
         this._computed = 0;
         this._limited = false;
     }
     get limit() {
         return this.editor.getOptions().get(47 /* EditorOption.foldingMaximumRegions */);
     }
+    get computed() {
+        return this._computed;
+    }
+    get limited() {
+        return this._limited;
+    }
     update(computed, limited) {
         if (computed !== this._computed || limited !== this._limited) {
             this._computed = computed;
@@ -501,7 +502,7 @@
     constructor() {
         super({
             id: 'editor.unfold',
-            label: nls.localize('unfoldAction.label', "Unfold"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'unfoldAction.label', "Unfold"),
             alias: 'Unfold',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -563,7 +564,7 @@
     constructor() {
         super({
             id: 'editor.unfoldRecursively',
-            label: nls.localize('unFoldRecursivelyAction.label', "Unfold Recursively"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'unFoldRecursivelyAction.label', "Unfold Recursively"),
             alias: 'Unfold Recursively',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -581,7 +582,7 @@
     constructor() {
         super({
             id: 'editor.fold',
-            label: nls.localize('foldAction.label', "Fold"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'foldAction.label', "Fold"),
             alias: 'Fold',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -649,7 +650,7 @@
     constructor() {
         super({
             id: 'editor.toggleFold',
-            label: nls.localize('toggleFoldAction.label', "Toggle Fold"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'toggleFoldAction.label', "Toggle Fold"),
             alias: 'Toggle Fold',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -668,7 +669,7 @@
     constructor() {
         super({
             id: 'editor.foldRecursively',
-            label: nls.localize('foldRecursivelyAction.label', "Fold Recursively"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'foldRecursivelyAction.label', "Fold Recursively"),
             alias: 'Fold Recursively',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -687,7 +688,7 @@
     constructor() {
         super({
             id: 'editor.foldAllBlockComments',
-            label: nls.localize('foldAllBlockComments.label', "Fold All Block Comments"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'foldAllBlockComments.label', "Fold All Block Comments"),
             alias: 'Fold All Block Comments',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -718,7 +719,7 @@
     constructor() {
         super({
             id: 'editor.foldAllMarkerRegions',
-            label: nls.localize('foldAllMarkerRegions.label', "Fold All Regions"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'foldAllMarkerRegions.label', "Fold All Regions"),
             alias: 'Fold All Regions',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -749,7 +750,7 @@
     constructor() {
         super({
             id: 'editor.unfoldAllMarkerRegions',
-            label: nls.localize('unfoldAllMarkerRegions.label', "Unfold All Regions"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'unfoldAllMarkerRegions.label', "Unfold All Regions"),
             alias: 'Unfold All Regions',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -780,7 +781,7 @@
     constructor() {
         super({
             id: 'editor.foldAllExcept',
-            label: nls.localize('foldAllExcept.label', "Fold All Except Selected"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'foldAllExcept.label', "Fold All Except Selected"),
             alias: 'Fold All Except Selected',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -799,7 +800,7 @@
     constructor() {
         super({
             id: 'editor.unfoldAllExcept',
-            label: nls.localize('unfoldAllExcept.label', "Unfold All Except Selected"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'unfoldAllExcept.label', "Unfold All Except Selected"),
             alias: 'Unfold All Except Selected',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -818,7 +819,7 @@
     constructor() {
         super({
             id: 'editor.foldAll',
-            label: nls.localize('foldAllAction.label', "Fold All"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'foldAllAction.label', "Fold All"),
             alias: 'Fold All',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -836,7 +837,7 @@
     constructor() {
         super({
             id: 'editor.unfoldAll',
-            label: nls.localize('unfoldAllAction.label', "Unfold All"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'unfoldAllAction.label', "Unfold All"),
             alias: 'Unfold All',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -865,7 +866,7 @@
     constructor() {
         super({
             id: 'editor.gotoParentFold',
-            label: nls.localize('gotoParentFold.label', "Go to Parent Fold"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'gotoParentFold.label', "Go to Parent Fold"),
             alias: 'Go to Parent Fold',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -894,7 +895,7 @@
     constructor() {
         super({
             id: 'editor.gotoPreviousFold',
-            label: nls.localize('gotoPreviousFold.label', "Go to Previous Folding Range"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'gotoPreviousFold.label', "Go to Previous Folding Range"),
             alias: 'Go to Previous Folding Range',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -923,7 +924,7 @@
     constructor() {
         super({
             id: 'editor.gotoNextFold',
-            label: nls.localize('gotoNextFold.label', "Go to Next Folding Range"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'gotoNextFold.label', "Go to Next Folding Range"),
             alias: 'Go to Next Folding Range',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -951,7 +952,7 @@
     constructor() {
         super({
             id: 'editor.createFoldingRangeFromSelection',
-            label: nls.localize('createManualFoldRange.label', "Create Folding Range from Selection"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'createManualFoldRange.label', "Create Folding Range from Selection"),
             alias: 'Create Folding Range from Selection',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -962,7 +963,6 @@
         });
     }
     invoke(_foldingController, foldingModel, editor) {
-        var _a;
         const collapseRanges = [];
         const selections = editor.getSelections();
         if (selections) {
@@ -991,7 +991,7 @@
                 collapseRanges.sort((a, b) => {
                     return a.startLineNumber - b.startLineNumber;
                 });
-                const newRanges = FoldingRegions.sanitizeAndMerge(foldingModel.regions, collapseRanges, (_a = editor.getModel()) === null || _a === void 0 ? void 0 : _a.getLineCount());
+                const newRanges = FoldingRegions.sanitizeAndMerge(foldingModel.regions, collapseRanges, editor.getModel()?.getLineCount());
                 foldingModel.updatePost(FoldingRegions.fromFoldRanges(newRanges));
             }
         }
@@ -1001,7 +1001,7 @@
     constructor() {
         super({
             id: 'editor.removeManualFoldingRanges',
-            label: nls.localize('removeManualFoldingRanges.label', "Remove Manual Folding Ranges"),
+            label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'removeManualFoldingRanges.label', "Remove Manual Folding Ranges"),
             alias: 'Remove Manual Folding Ranges',
             precondition: CONTEXT_FOLDING_ENABLED,
             kbOpts: {
@@ -1045,7 +1045,7 @@
 for (let i = 1; i <= 7; i++) {
     registerInstantiatedEditorAction(new FoldLevelAction({
         id: FoldLevelAction.ID(i),
-        label: nls.localize('foldLevelAction.label', "Fold Level {0}", i),
+        label: nls.localizeWithPath('vs/editor/contrib/folding/browser/folding', 'foldLevelAction.label', "Fold Level {0}", i),
         alias: `Fold Level ${i}`,
         precondition: CONTEXT_FOLDING_ENABLED,
         kbOpts: {
@@ -1055,50 +1055,48 @@
         }
     }));
 }
-CommandsRegistry.registerCommand('_executeFoldingRangeProvider', function (accessor, ...args) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const [resource] = args;
-        if (!(resource instanceof URI)) {
-            throw illegalArgument();
-        }
-        const languageFeaturesService = accessor.get(ILanguageFeaturesService);
-        const model = accessor.get(IModelService).getModel(resource);
-        if (!model) {
-            throw illegalArgument();
-        }
-        const configurationService = accessor.get(IConfigurationService);
-        if (!configurationService.getValue('editor.folding', { resource })) {
-            return [];
-        }
-        const languageConfigurationService = accessor.get(ILanguageConfigurationService);
-        const strategy = configurationService.getValue('editor.foldingStrategy', { resource });
-        const foldingLimitReporter = {
-            get limit() {
-                return configurationService.getValue('editor.foldingMaximumRegions', { resource });
-            },
-            update: (computed, limited) => { }
-        };
-        const indentRangeProvider = new IndentRangeProvider(model, languageConfigurationService, foldingLimitReporter);
-        let rangeProvider = indentRangeProvider;
-        if (strategy !== 'indentation') {
-            const providers = FoldingController.getFoldingRangeProviders(languageFeaturesService, model);
-            if (providers.length) {
-                rangeProvider = new SyntaxRangeProvider(model, providers, () => { }, foldingLimitReporter, indentRangeProvider);
-            }
-        }
-        const ranges = yield rangeProvider.compute(CancellationToken.None);
-        const result = [];
-        try {
-            if (ranges) {
-                for (let i = 0; i < ranges.length; i++) {
-                    const type = ranges.getType(i);
-                    result.push({ start: ranges.getStartLineNumber(i), end: ranges.getEndLineNumber(i), kind: type ? FoldingRangeKind.fromValue(type) : undefined });
-                }
+CommandsRegistry.registerCommand('_executeFoldingRangeProvider', async function (accessor, ...args) {
+    const [resource] = args;
+    if (!(resource instanceof URI)) {
+        throw illegalArgument();
+    }
+    const languageFeaturesService = accessor.get(ILanguageFeaturesService);
+    const model = accessor.get(IModelService).getModel(resource);
+    if (!model) {
+        throw illegalArgument();
+    }
+    const configurationService = accessor.get(IConfigurationService);
+    if (!configurationService.getValue('editor.folding', { resource })) {
+        return [];
+    }
+    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
+    const strategy = configurationService.getValue('editor.foldingStrategy', { resource });
+    const foldingLimitReporter = {
+        get limit() {
+            return configurationService.getValue('editor.foldingMaximumRegions', { resource });
+        },
+        update: (computed, limited) => { }
+    };
+    const indentRangeProvider = new IndentRangeProvider(model, languageConfigurationService, foldingLimitReporter);
+    let rangeProvider = indentRangeProvider;
+    if (strategy !== 'indentation') {
+        const providers = FoldingController.getFoldingRangeProviders(languageFeaturesService, model);
+        if (providers.length) {
+            rangeProvider = new SyntaxRangeProvider(model, providers, () => { }, foldingLimitReporter, indentRangeProvider);
+        }
+    }
+    const ranges = await rangeProvider.compute(CancellationToken.None);
+    const result = [];
+    try {
+        if (ranges) {
+            for (let i = 0; i < ranges.length; i++) {
+                const type = ranges.getType(i);
+                result.push({ start: ranges.getStartLineNumber(i), end: ranges.getEndLineNumber(i), kind: type ? FoldingRangeKind.fromValue(type) : undefined });
             }
-            return result;
         }
-        finally {
-            rangeProvider.dispose();
-        }
-    });
+        return result;
+    }
+    finally {
+        rangeProvider.dispose();
+    }
 });
diff -urN -x '*.map' a/vs/editor/contrib/folding/browser/foldingDecorations.js b/vs/editor/contrib/folding/browser/foldingDecorations.js
--- a/vs/editor/contrib/folding/browser/foldingDecorations.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/folding/browser/foldingDecorations.js	2023-12-06 14:23:14.375854776 +0000
@@ -5,17 +5,17 @@
 import { Codicon } from '../../../../base/common/codicons.js';
 import { MinimapPosition } from '../../../common/model.js';
 import { ModelDecorationOptions } from '../../../common/model/textModel.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { editorSelectionBackground, iconForeground, registerColor, transparent } from '../../../../platform/theme/common/colorRegistry.js';
 import { registerIcon } from '../../../../platform/theme/common/iconRegistry.js';
 import { themeColorFromId } from '../../../../platform/theme/common/themeService.js';
 import { ThemeIcon } from '../../../../base/common/themables.js';
-const foldBackground = registerColor('editor.foldBackground', { light: transparent(editorSelectionBackground, 0.3), dark: transparent(editorSelectionBackground, 0.3), hcDark: null, hcLight: null }, localize('foldBackgroundBackground', "Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations."), true);
-registerColor('editorGutter.foldingControlForeground', { dark: iconForeground, light: iconForeground, hcDark: iconForeground, hcLight: iconForeground }, localize('editorGutter.foldingControlForeground', 'Color of the folding control in the editor gutter.'));
-export const foldingExpandedIcon = registerIcon('folding-expanded', Codicon.chevronDown, localize('foldingExpandedIcon', 'Icon for expanded ranges in the editor glyph margin.'));
-export const foldingCollapsedIcon = registerIcon('folding-collapsed', Codicon.chevronRight, localize('foldingCollapsedIcon', 'Icon for collapsed ranges in the editor glyph margin.'));
-export const foldingManualCollapsedIcon = registerIcon('folding-manual-collapsed', foldingCollapsedIcon, localize('foldingManualCollapedIcon', 'Icon for manually collapsed ranges in the editor glyph margin.'));
-export const foldingManualExpandedIcon = registerIcon('folding-manual-expanded', foldingExpandedIcon, localize('foldingManualExpandedIcon', 'Icon for manually expanded ranges in the editor glyph margin.'));
+const foldBackground = registerColor('editor.foldBackground', { light: transparent(editorSelectionBackground, 0.3), dark: transparent(editorSelectionBackground, 0.3), hcDark: null, hcLight: null }, localizeWithPath('vs/editor/contrib/folding/browser/foldingDecorations', 'foldBackgroundBackground', "Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations."), true);
+registerColor('editorGutter.foldingControlForeground', { dark: iconForeground, light: iconForeground, hcDark: iconForeground, hcLight: iconForeground }, localizeWithPath('vs/editor/contrib/folding/browser/foldingDecorations', 'editorGutter.foldingControlForeground', 'Color of the folding control in the editor gutter.'));
+export const foldingExpandedIcon = registerIcon('folding-expanded', Codicon.chevronDown, localizeWithPath('vs/editor/contrib/folding/browser/foldingDecorations', 'foldingExpandedIcon', 'Icon for expanded ranges in the editor glyph margin.'));
+export const foldingCollapsedIcon = registerIcon('folding-collapsed', Codicon.chevronRight, localizeWithPath('vs/editor/contrib/folding/browser/foldingDecorations', 'foldingCollapsedIcon', 'Icon for collapsed ranges in the editor glyph margin.'));
+export const foldingManualCollapsedIcon = registerIcon('folding-manual-collapsed', foldingCollapsedIcon, localizeWithPath('vs/editor/contrib/folding/browser/foldingDecorations', 'foldingManualCollapedIcon', 'Icon for manually collapsed ranges in the editor glyph margin.'));
+export const foldingManualExpandedIcon = registerIcon('folding-manual-expanded', foldingExpandedIcon, localizeWithPath('vs/editor/contrib/folding/browser/foldingDecorations', 'foldingManualExpandedIcon', 'Icon for manually expanded ranges in the editor glyph margin.'));
 const foldedBackgroundMinimap = { color: themeColorFromId(foldBackground), position: MinimapPosition.Inline };
 export class FoldingDecorationProvider {
     constructor(editor) {
diff -urN -x '*.map' a/vs/editor/contrib/folding/browser/foldingModel.js b/vs/editor/contrib/folding/browser/foldingModel.js
--- a/vs/editor/contrib/folding/browser/foldingModel.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/folding/browser/foldingModel.js	2023-12-06 14:23:14.375854776 +0000
@@ -8,6 +8,7 @@
 export class FoldingModel {
     get regions() { return this._regions; }
     get textModel() { return this._textModel; }
+    get decorationProvider() { return this._decorationProvider; }
     constructor(textModel, decorationProvider) {
         this._updateEventEmitter = new Emitter();
         this.onDidChange = this._updateEventEmitter.event;
@@ -160,7 +161,6 @@
      * Apply persisted state, for persistence only
      */
     applyMemento(state) {
-        var _a, _b;
         if (!Array.isArray(state)) {
             return;
         }
@@ -176,8 +176,8 @@
                     startLineNumber: range.startLineNumber,
                     endLineNumber: range.endLineNumber,
                     type: undefined,
-                    isCollapsed: (_a = range.isCollapsed) !== null && _a !== void 0 ? _a : true,
-                    source: (_b = range.source) !== null && _b !== void 0 ? _b : 0 /* FoldSource.provider */
+                    isCollapsed: range.isCollapsed ?? true,
+                    source: range.source ?? 0 /* FoldSource.provider */
                 });
             }
         }
diff -urN -x '*.map' a/vs/editor/contrib/folding/browser/foldingRanges.js b/vs/editor/contrib/folding/browser/foldingRanges.js
--- a/vs/editor/contrib/folding/browser/foldingRanges.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/folding/browser/foldingRanges.js	2023-12-06 14:23:14.375854776 +0000
@@ -241,7 +241,7 @@
      * 		it overlaps a preceding entry and is not fully contained by that entry.
      */
     static sanitizeAndMerge(rangesA, rangesB, maxLineNumber) {
-        maxLineNumber = maxLineNumber !== null && maxLineNumber !== void 0 ? maxLineNumber : Number.MAX_VALUE;
+        maxLineNumber = maxLineNumber ?? Number.MAX_VALUE;
         const getIndexedFunction = (r, limit) => {
             return Array.isArray(r)
                 ? ((i) => { return (i < limit) ? r[i] : undefined; })
@@ -348,4 +348,7 @@
     containsLine(lineNumber) {
         return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;
     }
+    hidesLine(lineNumber) {
+        return this.startLineNumber < lineNumber && lineNumber <= this.endLineNumber;
+    }
 }
diff -urN -x '*.map' a/vs/editor/contrib/folding/browser/syntaxRangeProvider.js b/vs/editor/contrib/folding/browser/syntaxRangeProvider.js
--- a/vs/editor/contrib/folding/browser/syntaxRangeProvider.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/folding/browser/syntaxRangeProvider.js	2023-12-06 14:23:14.375854776 +0000
@@ -28,12 +28,11 @@
     }
     compute(cancellationToken) {
         return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(ranges => {
-            var _a, _b;
             if (ranges) {
                 const res = sanitizeRanges(ranges, this.foldingRangesLimit);
                 return res;
             }
-            return (_b = (_a = this.fallbackRangeProvider) === null || _a === void 0 ? void 0 : _a.compute(cancellationToken)) !== null && _b !== void 0 ? _b : null;
+            return this.fallbackRangeProvider?.compute(cancellationToken) ?? null;
         });
     }
     dispose() {
diff -urN -x '*.map' a/vs/editor/contrib/fontZoom/browser/fontZoom.js b/vs/editor/contrib/fontZoom/browser/fontZoom.js
--- a/vs/editor/contrib/fontZoom/browser/fontZoom.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/fontZoom/browser/fontZoom.js	2023-12-06 14:23:14.375854776 +0000
@@ -9,7 +9,7 @@
     constructor() {
         super({
             id: 'editor.action.fontZoomIn',
-            label: nls.localize('EditorFontZoomIn.label', "Editor Font Zoom In"),
+            label: nls.localizeWithPath('vs/editor/contrib/fontZoom/browser/fontZoom', 'EditorFontZoomIn.label', "Editor Font Zoom In"),
             alias: 'Editor Font Zoom In',
             precondition: undefined
         });
@@ -22,7 +22,7 @@
     constructor() {
         super({
             id: 'editor.action.fontZoomOut',
-            label: nls.localize('EditorFontZoomOut.label', "Editor Font Zoom Out"),
+            label: nls.localizeWithPath('vs/editor/contrib/fontZoom/browser/fontZoom', 'EditorFontZoomOut.label', "Editor Font Zoom Out"),
             alias: 'Editor Font Zoom Out',
             precondition: undefined
         });
@@ -35,7 +35,7 @@
     constructor() {
         super({
             id: 'editor.action.fontZoomReset',
-            label: nls.localize('EditorFontZoomReset.label', "Editor Font Zoom Reset"),
+            label: nls.localizeWithPath('vs/editor/contrib/fontZoom/browser/fontZoom', 'EditorFontZoomReset.label', "Editor Font Zoom Reset"),
             alias: 'Editor Font Zoom Reset',
             precondition: undefined
         });
diff -urN -x '*.map' a/vs/editor/contrib/format/browser/format.js b/vs/editor/contrib/format/browser/format.js
--- a/vs/editor/contrib/format/browser/format.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/format/browser/format.js	2023-12-06 14:23:14.379854783 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { alert } from '../../../../base/browser/ui/aria/aria.js';
 import { asArray, isNonEmptyArray } from '../../../../base/common/arrays.js';
 import { CancellationToken } from '../../../../base/common/cancellation.js';
@@ -45,18 +36,18 @@
     const { startLineNumber, endLineNumber } = range;
     if (startLineNumber === endLineNumber) {
         if (edits.length === 1) {
-            alert(nls.localize('hint11', "Made 1 formatting edit on line {0}", startLineNumber));
+            alert(nls.localizeWithPath('vs/editor/contrib/format/browser/format', 'hint11', "Made 1 formatting edit on line {0}", startLineNumber));
         }
         else {
-            alert(nls.localize('hintn1', "Made {0} formatting edits on line {1}", edits.length, startLineNumber));
+            alert(nls.localizeWithPath('vs/editor/contrib/format/browser/format', 'hintn1', "Made {0} formatting edits on line {1}", edits.length, startLineNumber));
         }
     }
     else {
         if (edits.length === 1) {
-            alert(nls.localize('hint1n', "Made 1 formatting edit between lines {0} and {1}", startLineNumber, endLineNumber));
+            alert(nls.localizeWithPath('vs/editor/contrib/format/browser/format', 'hint1n', "Made 1 formatting edit between lines {0} and {1}", startLineNumber, endLineNumber));
         }
         else {
-            alert(nls.localize('hintnn', "Made {0} formatting edits between lines {1} and {2}", edits.length, startLineNumber, endLineNumber));
+            alert(nls.localizeWithPath('vs/editor/contrib/format/browser/format', 'hintnn', "Made {0} formatting edits between lines {1} and {2}", edits.length, startLineNumber, endLineNumber));
         }
     }
 }
@@ -95,260 +86,244 @@
         const remove = FormattingConflicts._selectors.unshift(selector);
         return { dispose: remove };
     }
-    static select(formatter, document, mode) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (formatter.length === 0) {
-                return undefined;
-            }
-            const selector = Iterable.first(FormattingConflicts._selectors);
-            if (selector) {
-                return yield selector(formatter, document, mode);
-            }
+    static async select(formatter, document, mode) {
+        if (formatter.length === 0) {
             return undefined;
-        });
+        }
+        const selector = Iterable.first(FormattingConflicts._selectors);
+        if (selector) {
+            return await selector(formatter, document, mode);
+        }
+        return undefined;
     }
 }
 FormattingConflicts._selectors = new LinkedList();
-export function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const instaService = accessor.get(IInstantiationService);
-        const { documentRangeFormattingEditProvider: documentRangeFormattingEditProviderRegistry } = accessor.get(ILanguageFeaturesService);
-        const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;
-        const provider = documentRangeFormattingEditProviderRegistry.ordered(model);
-        const selected = yield FormattingConflicts.select(provider, model, mode);
-        if (selected) {
-            progress.report(selected);
-            yield instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token);
-        }
-    });
+export async function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token) {
+    const instaService = accessor.get(IInstantiationService);
+    const { documentRangeFormattingEditProvider: documentRangeFormattingEditProviderRegistry } = accessor.get(ILanguageFeaturesService);
+    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;
+    const provider = documentRangeFormattingEditProviderRegistry.ordered(model);
+    const selected = await FormattingConflicts.select(provider, model, mode);
+    if (selected) {
+        progress.report(selected);
+        await instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token);
+    }
 }
-export function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token) {
-    var _a, _b;
-    return __awaiter(this, void 0, void 0, function* () {
-        const workerService = accessor.get(IEditorWorkerService);
-        const logService = accessor.get(ILogService);
-        let model;
-        let cts;
-        if (isCodeEditor(editorOrModel)) {
-            model = editorOrModel.getModel();
-            cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);
+export async function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token) {
+    const workerService = accessor.get(IEditorWorkerService);
+    const logService = accessor.get(ILogService);
+    let model;
+    let cts;
+    if (isCodeEditor(editorOrModel)) {
+        model = editorOrModel.getModel();
+        cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);
+    }
+    else {
+        model = editorOrModel;
+        cts = new TextModelCancellationTokenSource(editorOrModel, token);
+    }
+    // make sure that ranges don't overlap nor touch each other
+    const ranges = [];
+    let len = 0;
+    for (const range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {
+        if (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {
+            ranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());
         }
         else {
-            model = editorOrModel;
-            cts = new TextModelCancellationTokenSource(editorOrModel, token);
+            len = ranges.push(range);
         }
-        // make sure that ranges don't overlap nor touch each other
-        const ranges = [];
-        let len = 0;
-        for (const range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {
-            if (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {
-                ranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());
-            }
-            else {
-                len = ranges.push(range);
-            }
+    }
+    const computeEdits = async (range) => {
+        logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, provider.extensionId?.value, range);
+        const result = (await provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token)) || [];
+        logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, provider.extensionId?.value, result);
+        return result;
+    };
+    const hasIntersectingEdit = (a, b) => {
+        if (!a.length || !b.length) {
+            return false;
         }
-        const computeEdits = (range) => __awaiter(this, void 0, void 0, function* () {
-            var _c, _d;
-            logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, (_c = provider.extensionId) === null || _c === void 0 ? void 0 : _c.value, range);
-            const result = (yield provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token)) || [];
-            logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, (_d = provider.extensionId) === null || _d === void 0 ? void 0 : _d.value, result);
-            return result;
-        });
-        const hasIntersectingEdit = (a, b) => {
-            if (!a.length || !b.length) {
-                return false;
-            }
-            // quick exit if the list of ranges are completely unrelated [O(n)]
-            const mergedA = a.reduce((acc, val) => { return Range.plusRange(acc, val.range); }, a[0].range);
-            if (!b.some(x => { return Range.intersectRanges(mergedA, x.range); })) {
-                return false;
-            }
-            // fallback to a complete check [O(n^2)]
-            for (const edit of a) {
-                for (const otherEdit of b) {
-                    if (Range.intersectRanges(edit.range, otherEdit.range)) {
-                        return true;
-                    }
-                }
-            }
+        // quick exit if the list of ranges are completely unrelated [O(n)]
+        const mergedA = a.reduce((acc, val) => { return Range.plusRange(acc, val.range); }, a[0].range);
+        if (!b.some(x => { return Range.intersectRanges(mergedA, x.range); })) {
             return false;
-        };
-        const allEdits = [];
-        const rawEditsList = [];
-        try {
-            if (typeof provider.provideDocumentRangesFormattingEdits === 'function') {
-                logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, (_a = provider.extensionId) === null || _a === void 0 ? void 0 : _a.value, ranges);
-                const result = (yield provider.provideDocumentRangesFormattingEdits(model, ranges, model.getFormattingOptions(), cts.token)) || [];
-                logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, (_b = provider.extensionId) === null || _b === void 0 ? void 0 : _b.value, result);
-                rawEditsList.push(result);
-            }
-            else {
-                for (const range of ranges) {
-                    if (cts.token.isCancellationRequested) {
-                        return true;
-                    }
-                    rawEditsList.push(yield computeEdits(range));
-                }
-                for (let i = 0; i < ranges.length; ++i) {
-                    for (let j = i + 1; j < ranges.length; ++j) {
-                        if (cts.token.isCancellationRequested) {
-                            return true;
-                        }
-                        if (hasIntersectingEdit(rawEditsList[i], rawEditsList[j])) {
-                            // Merge ranges i and j into a single range, recompute the associated edits
-                            const mergedRange = Range.plusRange(ranges[i], ranges[j]);
-                            const edits = yield computeEdits(mergedRange);
-                            ranges.splice(j, 1);
-                            ranges.splice(i, 1);
-                            ranges.push(mergedRange);
-                            rawEditsList.splice(j, 1);
-                            rawEditsList.splice(i, 1);
-                            rawEditsList.push(edits);
-                            // Restart scanning
-                            i = 0;
-                            j = 0;
-                        }
-                    }
-                }
-            }
-            for (const rawEdits of rawEditsList) {
-                if (cts.token.isCancellationRequested) {
+        }
+        // fallback to a complete check [O(n^2)]
+        for (const edit of a) {
+            for (const otherEdit of b) {
+                if (Range.intersectRanges(edit.range, otherEdit.range)) {
                     return true;
                 }
-                const minimalEdits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);
-                if (minimalEdits) {
-                    allEdits.push(...minimalEdits);
-                }
             }
         }
-        finally {
-            cts.dispose();
-        }
-        if (allEdits.length === 0) {
-            return false;
-        }
-        if (isCodeEditor(editorOrModel)) {
-            // use editor to apply edits
-            FormattingEdit.execute(editorOrModel, allEdits, true);
-            alertFormattingEdits(allEdits);
-            editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);
+        return false;
+    };
+    const allEdits = [];
+    const rawEditsList = [];
+    try {
+        if (typeof provider.provideDocumentRangesFormattingEdits === 'function') {
+            logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, provider.extensionId?.value, ranges);
+            const result = (await provider.provideDocumentRangesFormattingEdits(model, ranges, model.getFormattingOptions(), cts.token)) || [];
+            logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, provider.extensionId?.value, result);
+            rawEditsList.push(result);
         }
         else {
-            // use model to apply edits
-            const [{ range }] = allEdits;
-            const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
-            model.pushEditOperations([initialSelection], allEdits.map(edit => {
-                return {
-                    text: edit.text,
-                    range: Range.lift(edit.range),
-                    forceMoveMarkers: true
-                };
-            }), undoEdits => {
-                for (const { range } of undoEdits) {
-                    if (Range.areIntersectingOrTouching(range, initialSelection)) {
-                        return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];
+            for (const range of ranges) {
+                if (cts.token.isCancellationRequested) {
+                    return true;
+                }
+                rawEditsList.push(await computeEdits(range));
+            }
+            for (let i = 0; i < ranges.length; ++i) {
+                for (let j = i + 1; j < ranges.length; ++j) {
+                    if (cts.token.isCancellationRequested) {
+                        return true;
+                    }
+                    if (hasIntersectingEdit(rawEditsList[i], rawEditsList[j])) {
+                        // Merge ranges i and j into a single range, recompute the associated edits
+                        const mergedRange = Range.plusRange(ranges[i], ranges[j]);
+                        const edits = await computeEdits(mergedRange);
+                        ranges.splice(j, 1);
+                        ranges.splice(i, 1);
+                        ranges.push(mergedRange);
+                        rawEditsList.splice(j, 1);
+                        rawEditsList.splice(i, 1);
+                        rawEditsList.push(edits);
+                        // Restart scanning
+                        i = 0;
+                        j = 0;
                     }
                 }
-                return null;
-            });
-        }
-        return true;
-    });
-}
-export function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const instaService = accessor.get(IInstantiationService);
-        const languageFeaturesService = accessor.get(ILanguageFeaturesService);
-        const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;
-        const provider = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);
-        const selected = yield FormattingConflicts.select(provider, model, mode);
-        if (selected) {
-            progress.report(selected);
-            yield instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token);
-        }
-    });
-}
-export function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const workerService = accessor.get(IEditorWorkerService);
-        let model;
-        let cts;
-        if (isCodeEditor(editorOrModel)) {
-            model = editorOrModel.getModel();
-            cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);
-        }
-        else {
-            model = editorOrModel;
-            cts = new TextModelCancellationTokenSource(editorOrModel, token);
+            }
         }
-        let edits;
-        try {
-            const rawEdits = yield provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);
-            edits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);
+        for (const rawEdits of rawEditsList) {
             if (cts.token.isCancellationRequested) {
                 return true;
             }
-        }
-        finally {
-            cts.dispose();
-        }
-        if (!edits || edits.length === 0) {
-            return false;
-        }
-        if (isCodeEditor(editorOrModel)) {
-            // use editor to apply edits
-            FormattingEdit.execute(editorOrModel, edits, mode !== 2 /* FormattingMode.Silent */);
-            if (mode !== 2 /* FormattingMode.Silent */) {
-                alertFormattingEdits(edits);
-                editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);
+            const minimalEdits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);
+            if (minimalEdits) {
+                allEdits.push(...minimalEdits);
             }
         }
-        else {
-            // use model to apply edits
-            const [{ range }] = edits;
-            const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
-            model.pushEditOperations([initialSelection], edits.map(edit => {
-                return {
-                    text: edit.text,
-                    range: Range.lift(edit.range),
-                    forceMoveMarkers: true
-                };
-            }), undoEdits => {
-                for (const { range } of undoEdits) {
-                    if (Range.areIntersectingOrTouching(range, initialSelection)) {
-                        return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];
-                    }
+    }
+    finally {
+        cts.dispose();
+    }
+    if (allEdits.length === 0) {
+        return false;
+    }
+    if (isCodeEditor(editorOrModel)) {
+        // use editor to apply edits
+        FormattingEdit.execute(editorOrModel, allEdits, true);
+        alertFormattingEdits(allEdits);
+        editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);
+    }
+    else {
+        // use model to apply edits
+        const [{ range }] = allEdits;
+        const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
+        model.pushEditOperations([initialSelection], allEdits.map(edit => {
+            return {
+                text: edit.text,
+                range: Range.lift(edit.range),
+                forceMoveMarkers: true
+            };
+        }), undoEdits => {
+            for (const { range } of undoEdits) {
+                if (Range.areIntersectingOrTouching(range, initialSelection)) {
+                    return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];
                 }
-                return null;
-            });
-        }
-        return true;
-    });
+            }
+            return null;
+        });
+    }
+    return true;
+}
+export async function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token) {
+    const instaService = accessor.get(IInstantiationService);
+    const languageFeaturesService = accessor.get(ILanguageFeaturesService);
+    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;
+    const provider = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);
+    const selected = await FormattingConflicts.select(provider, model, mode);
+    if (selected) {
+        progress.report(selected);
+        await instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token);
+    }
 }
-export function getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, model, range, options, token) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const providers = languageFeaturesService.documentRangeFormattingEditProvider.ordered(model);
-        for (const provider of providers) {
-            const rawEdits = yield Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);
-            if (isNonEmptyArray(rawEdits)) {
-                return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);
+export async function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token) {
+    const workerService = accessor.get(IEditorWorkerService);
+    let model;
+    let cts;
+    if (isCodeEditor(editorOrModel)) {
+        model = editorOrModel.getModel();
+        cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);
+    }
+    else {
+        model = editorOrModel;
+        cts = new TextModelCancellationTokenSource(editorOrModel, token);
+    }
+    let edits;
+    try {
+        const rawEdits = await provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);
+        edits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);
+        if (cts.token.isCancellationRequested) {
+            return true;
+        }
+    }
+    finally {
+        cts.dispose();
+    }
+    if (!edits || edits.length === 0) {
+        return false;
+    }
+    if (isCodeEditor(editorOrModel)) {
+        // use editor to apply edits
+        FormattingEdit.execute(editorOrModel, edits, mode !== 2 /* FormattingMode.Silent */);
+        if (mode !== 2 /* FormattingMode.Silent */) {
+            alertFormattingEdits(edits);
+            editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);
+        }
+    }
+    else {
+        // use model to apply edits
+        const [{ range }] = edits;
+        const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
+        model.pushEditOperations([initialSelection], edits.map(edit => {
+            return {
+                text: edit.text,
+                range: Range.lift(edit.range),
+                forceMoveMarkers: true
+            };
+        }), undoEdits => {
+            for (const { range } of undoEdits) {
+                if (Range.areIntersectingOrTouching(range, initialSelection)) {
+                    return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];
+                }
             }
+            return null;
+        });
+    }
+    return true;
+}
+export async function getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, model, range, options, token) {
+    const providers = languageFeaturesService.documentRangeFormattingEditProvider.ordered(model);
+    for (const provider of providers) {
+        const rawEdits = await Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);
+        if (isNonEmptyArray(rawEdits)) {
+            return await workerService.computeMoreMinimalEdits(model.uri, rawEdits);
         }
-        return undefined;
-    });
+    }
+    return undefined;
 }
-export function getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, model, options, token) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const providers = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);
-        for (const provider of providers) {
-            const rawEdits = yield Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);
-            if (isNonEmptyArray(rawEdits)) {
-                return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);
-            }
+export async function getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, model, options, token) {
+    const providers = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);
+    for (const provider of providers) {
+        const rawEdits = await Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);
+        if (isNonEmptyArray(rawEdits)) {
+            return await workerService.computeMoreMinimalEdits(model.uri, rawEdits);
         }
-        return undefined;
-    });
+    }
+    return undefined;
 }
 export function getOnTypeFormattingEdits(workerService, languageFeaturesService, model, position, ch, options, token) {
     const providers = languageFeaturesService.onTypeFormattingEditProvider.ordered(model);
@@ -362,54 +337,48 @@
         return workerService.computeMoreMinimalEdits(model.uri, edits);
     });
 }
-CommandsRegistry.registerCommand('_executeFormatRangeProvider', function (accessor, ...args) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const [resource, range, options] = args;
-        assertType(URI.isUri(resource));
-        assertType(Range.isIRange(range));
-        const resolverService = accessor.get(ITextModelService);
-        const workerService = accessor.get(IEditorWorkerService);
-        const languageFeaturesService = accessor.get(ILanguageFeaturesService);
-        const reference = yield resolverService.createModelReference(resource);
-        try {
-            return getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, Range.lift(range), options, CancellationToken.None);
-        }
-        finally {
-            reference.dispose();
-        }
-    });
+CommandsRegistry.registerCommand('_executeFormatRangeProvider', async function (accessor, ...args) {
+    const [resource, range, options] = args;
+    assertType(URI.isUri(resource));
+    assertType(Range.isIRange(range));
+    const resolverService = accessor.get(ITextModelService);
+    const workerService = accessor.get(IEditorWorkerService);
+    const languageFeaturesService = accessor.get(ILanguageFeaturesService);
+    const reference = await resolverService.createModelReference(resource);
+    try {
+        return getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, Range.lift(range), options, CancellationToken.None);
+    }
+    finally {
+        reference.dispose();
+    }
 });
-CommandsRegistry.registerCommand('_executeFormatDocumentProvider', function (accessor, ...args) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const [resource, options] = args;
-        assertType(URI.isUri(resource));
-        const resolverService = accessor.get(ITextModelService);
-        const workerService = accessor.get(IEditorWorkerService);
-        const languageFeaturesService = accessor.get(ILanguageFeaturesService);
-        const reference = yield resolverService.createModelReference(resource);
-        try {
-            return getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, options, CancellationToken.None);
-        }
-        finally {
-            reference.dispose();
-        }
-    });
+CommandsRegistry.registerCommand('_executeFormatDocumentProvider', async function (accessor, ...args) {
+    const [resource, options] = args;
+    assertType(URI.isUri(resource));
+    const resolverService = accessor.get(ITextModelService);
+    const workerService = accessor.get(IEditorWorkerService);
+    const languageFeaturesService = accessor.get(ILanguageFeaturesService);
+    const reference = await resolverService.createModelReference(resource);
+    try {
+        return getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, options, CancellationToken.None);
+    }
+    finally {
+        reference.dispose();
+    }
 });
-CommandsRegistry.registerCommand('_executeFormatOnTypeProvider', function (accessor, ...args) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const [resource, position, ch, options] = args;
-        assertType(URI.isUri(resource));
-        assertType(Position.isIPosition(position));
-        assertType(typeof ch === 'string');
-        const resolverService = accessor.get(ITextModelService);
-        const workerService = accessor.get(IEditorWorkerService);
-        const languageFeaturesService = accessor.get(ILanguageFeaturesService);
-        const reference = yield resolverService.createModelReference(resource);
-        try {
-            return getOnTypeFormattingEdits(workerService, languageFeaturesService, reference.object.textEditorModel, Position.lift(position), ch, options, CancellationToken.None);
-        }
-        finally {
-            reference.dispose();
-        }
-    });
+CommandsRegistry.registerCommand('_executeFormatOnTypeProvider', async function (accessor, ...args) {
+    const [resource, position, ch, options] = args;
+    assertType(URI.isUri(resource));
+    assertType(Position.isIPosition(position));
+    assertType(typeof ch === 'string');
+    const resolverService = accessor.get(ITextModelService);
+    const workerService = accessor.get(IEditorWorkerService);
+    const languageFeaturesService = accessor.get(ILanguageFeaturesService);
+    const reference = await resolverService.createModelReference(resource);
+    try {
+        return getOnTypeFormattingEdits(workerService, languageFeaturesService, reference.object.textEditorModel, Position.lift(position), ch, options, CancellationToken.None);
+    }
+    finally {
+        reference.dispose();
+    }
 });
diff -urN -x '*.map' a/vs/editor/contrib/format/browser/formatActions.js b/vs/editor/contrib/format/browser/formatActions.js
--- a/vs/editor/contrib/format/browser/formatActions.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/format/browser/formatActions.js	2023-12-06 14:23:14.379854783 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { isNonEmptyArray } from '../../../../base/common/arrays.js';
 import { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';
 import { onUnexpectedError } from '../../../../base/common/errors.js';
@@ -191,7 +182,7 @@
     constructor() {
         super({
             id: 'editor.action.formatDocument',
-            label: nls.localize('formatDocument.label', "Format Document"),
+            label: nls.localizeWithPath('vs/editor/contrib/format/browser/formatActions', 'formatDocument.label', "Format Document"),
             alias: 'Format Document',
             precondition: ContextKeyExpr.and(EditorContextKeys.notInCompositeEditor, EditorContextKeys.writable, EditorContextKeys.hasDocumentFormattingProvider),
             kbOpts: {
@@ -206,21 +197,19 @@
             }
         });
     }
-    run(accessor, editor) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (editor.hasModel()) {
-                const instaService = accessor.get(IInstantiationService);
-                const progressService = accessor.get(IEditorProgressService);
-                yield progressService.showWhile(instaService.invokeFunction(formatDocumentWithSelectedProvider, editor, 1 /* FormattingMode.Explicit */, Progress.None, CancellationToken.None), 250);
-            }
-        });
+    async run(accessor, editor) {
+        if (editor.hasModel()) {
+            const instaService = accessor.get(IInstantiationService);
+            const progressService = accessor.get(IEditorProgressService);
+            await progressService.showWhile(instaService.invokeFunction(formatDocumentWithSelectedProvider, editor, 1 /* FormattingMode.Explicit */, Progress.None, CancellationToken.None), 250);
+        }
     }
 }
 class FormatSelectionAction extends EditorAction {
     constructor() {
         super({
             id: 'editor.action.formatSelection',
-            label: nls.localize('formatSelection.label', "Format Selection"),
+            label: nls.localizeWithPath('vs/editor/contrib/format/browser/formatActions', 'formatSelection.label', "Format Selection"),
             alias: 'Format Selection',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasDocumentSelectionFormattingProvider),
             kbOpts: {
@@ -235,21 +224,19 @@
             }
         });
     }
-    run(accessor, editor) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!editor.hasModel()) {
-                return;
-            }
-            const instaService = accessor.get(IInstantiationService);
-            const model = editor.getModel();
-            const ranges = editor.getSelections().map(range => {
-                return range.isEmpty()
-                    ? new Range(range.startLineNumber, 1, range.startLineNumber, model.getLineMaxColumn(range.startLineNumber))
-                    : range;
-            });
-            const progressService = accessor.get(IEditorProgressService);
-            yield progressService.showWhile(instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor, ranges, 1 /* FormattingMode.Explicit */, Progress.None, CancellationToken.None), 250);
+    async run(accessor, editor) {
+        if (!editor.hasModel()) {
+            return;
+        }
+        const instaService = accessor.get(IInstantiationService);
+        const model = editor.getModel();
+        const ranges = editor.getSelections().map(range => {
+            return range.isEmpty()
+                ? new Range(range.startLineNumber, 1, range.startLineNumber, model.getLineMaxColumn(range.startLineNumber))
+                : range;
         });
+        const progressService = accessor.get(IEditorProgressService);
+        await progressService.showWhile(instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor, ranges, 1 /* FormattingMode.Explicit */, Progress.None, CancellationToken.None), 250);
     }
 }
 registerEditorContribution(FormatOnType.ID, FormatOnType, 2 /* EditorContributionInstantiation.BeforeFirstInteraction */);
@@ -258,16 +245,16 @@
 registerEditorAction(FormatSelectionAction);
 // this is the old format action that does both (format document OR format selection)
 // and we keep it here such that existing keybinding configurations etc will still work
-CommandsRegistry.registerCommand('editor.action.format', (accessor) => __awaiter(void 0, void 0, void 0, function* () {
+CommandsRegistry.registerCommand('editor.action.format', async (accessor) => {
     const editor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
     if (!editor || !editor.hasModel()) {
         return;
     }
     const commandService = accessor.get(ICommandService);
     if (editor.getSelection().isEmpty()) {
-        yield commandService.executeCommand('editor.action.formatDocument');
+        await commandService.executeCommand('editor.action.formatDocument');
     }
     else {
-        yield commandService.executeCommand('editor.action.formatSelection');
+        await commandService.executeCommand('editor.action.formatSelection');
     }
-}));
+});
diff -urN -x '*.map' a/vs/editor/contrib/gotoError/browser/gotoError.js b/vs/editor/contrib/gotoError/browser/gotoError.js
--- a/vs/editor/contrib/gotoError/browser/gotoError.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/gotoError/browser/gotoError.js	2023-12-06 14:23:14.379854783 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var MarkerController_1;
 import { Codicon } from '../../../../base/common/codicons.js';
 import { DisposableStore } from '../../../../base/common/lifecycle.js';
@@ -78,9 +69,8 @@
         this._sessionDispoables.add(this._widget);
         // follow cursor
         this._sessionDispoables.add(this._editor.onDidChangeCursorPosition(e => {
-            var _a, _b, _c;
-            if (!((_a = this._model) === null || _a === void 0 ? void 0 : _a.selected) || !Range.containsPosition((_b = this._model) === null || _b === void 0 ? void 0 : _b.selected.marker, e.position)) {
-                (_c = this._model) === null || _c === void 0 ? void 0 : _c.resetIndex();
+            if (!this._model?.selected || !Range.containsPosition(this._model?.selected.marker, e.position)) {
+                this._model?.resetIndex();
             }
         }));
         // update markers
@@ -123,33 +113,30 @@
             }
         }
     }
-    nagivate(next, multiFile) {
-        var _a, _b;
-        return __awaiter(this, void 0, void 0, function* () {
-            if (this._editor.hasModel()) {
-                const model = this._getOrCreateModel(multiFile ? undefined : this._editor.getModel().uri);
-                model.move(next, this._editor.getModel(), this._editor.getPosition());
-                if (!model.selected) {
-                    return;
-                }
-                if (model.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
-                    // show in different editor
-                    this._cleanUp();
-                    const otherEditor = yield this._editorService.openCodeEditor({
-                        resource: model.selected.marker.resource,
-                        options: { pinned: false, revealIfOpened: true, selectionRevealType: 2 /* TextEditorSelectionRevealType.NearTop */, selection: model.selected.marker }
-                    }, this._editor);
-                    if (otherEditor) {
-                        (_a = MarkerController_1.get(otherEditor)) === null || _a === void 0 ? void 0 : _a.close();
-                        (_b = MarkerController_1.get(otherEditor)) === null || _b === void 0 ? void 0 : _b.nagivate(next, multiFile);
-                    }
-                }
-                else {
-                    // show in this editor
-                    this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
+    async nagivate(next, multiFile) {
+        if (this._editor.hasModel()) {
+            const model = this._getOrCreateModel(multiFile ? undefined : this._editor.getModel().uri);
+            model.move(next, this._editor.getModel(), this._editor.getPosition());
+            if (!model.selected) {
+                return;
+            }
+            if (model.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
+                // show in different editor
+                this._cleanUp();
+                const otherEditor = await this._editorService.openCodeEditor({
+                    resource: model.selected.marker.resource,
+                    options: { pinned: false, revealIfOpened: true, selectionRevealType: 2 /* TextEditorSelectionRevealType.NearTop */, selection: model.selected.marker }
+                }, this._editor);
+                if (otherEditor) {
+                    MarkerController_1.get(otherEditor)?.close();
+                    MarkerController_1.get(otherEditor)?.nagivate(next, multiFile);
                 }
             }
-        });
+            else {
+                // show in this editor
+                this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
+            }
+        }
     }
 };
 MarkerController.ID = 'editor.contrib.markerController';
@@ -166,13 +153,10 @@
         this._next = _next;
         this._multiFile = _multiFile;
     }
-    run(_accessor, editor) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            if (editor.hasModel()) {
-                (_a = MarkerController.get(editor)) === null || _a === void 0 ? void 0 : _a.nagivate(this._next, this._multiFile);
-            }
-        });
+    async run(_accessor, editor) {
+        if (editor.hasModel()) {
+            MarkerController.get(editor)?.nagivate(this._next, this._multiFile);
+        }
     }
 }
 export class NextMarkerAction extends MarkerNavigationAction {
@@ -190,7 +174,7 @@
             menuOpts: {
                 menuId: MarkerNavigationWidget.TitleMenu,
                 title: NextMarkerAction.LABEL,
-                icon: registerIcon('marker-navigation-next', Codicon.arrowDown, nls.localize('nextMarkerIcon', 'Icon for goto next marker.')),
+                icon: registerIcon('marker-navigation-next', Codicon.arrowDown, nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoError', 'nextMarkerIcon', 'Icon for goto next marker.')),
                 group: 'navigation',
                 order: 1
             }
@@ -198,7 +182,7 @@
     }
 }
 NextMarkerAction.ID = 'editor.action.marker.next';
-NextMarkerAction.LABEL = nls.localize('markerAction.next.label', "Go to Next Problem (Error, Warning, Info)");
+NextMarkerAction.LABEL = nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoError', 'markerAction.next.label', "Go to Next Problem (Error, Warning, Info)");
 class PrevMarkerAction extends MarkerNavigationAction {
     constructor() {
         super(false, false, {
@@ -214,7 +198,7 @@
             menuOpts: {
                 menuId: MarkerNavigationWidget.TitleMenu,
                 title: PrevMarkerAction.LABEL,
-                icon: registerIcon('marker-navigation-previous', Codicon.arrowUp, nls.localize('previousMarkerIcon', 'Icon for goto previous marker.')),
+                icon: registerIcon('marker-navigation-previous', Codicon.arrowUp, nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoError', 'previousMarkerIcon', 'Icon for goto previous marker.')),
                 group: 'navigation',
                 order: 2
             }
@@ -222,12 +206,12 @@
     }
 }
 PrevMarkerAction.ID = 'editor.action.marker.prev';
-PrevMarkerAction.LABEL = nls.localize('markerAction.previous.label', "Go to Previous Problem (Error, Warning, Info)");
+PrevMarkerAction.LABEL = nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoError', 'markerAction.previous.label', "Go to Previous Problem (Error, Warning, Info)");
 class NextMarkerInFilesAction extends MarkerNavigationAction {
     constructor() {
         super(true, true, {
             id: 'editor.action.marker.nextInFiles',
-            label: nls.localize('markerAction.nextInFiles.label', "Go to Next Problem in Files (Error, Warning, Info)"),
+            label: nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoError', 'markerAction.nextInFiles.label', "Go to Next Problem in Files (Error, Warning, Info)"),
             alias: 'Go to Next Problem in Files (Error, Warning, Info)',
             precondition: undefined,
             kbOpts: {
@@ -237,7 +221,7 @@
             },
             menuOpts: {
                 menuId: MenuId.MenubarGoMenu,
-                title: nls.localize({ key: 'miGotoNextProblem', comment: ['&& denotes a mnemonic'] }, "Next &&Problem"),
+                title: nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoError', { key: 'miGotoNextProblem', comment: ['&& denotes a mnemonic'] }, "Next &&Problem"),
                 group: '6_problem_nav',
                 order: 1
             }
@@ -248,7 +232,7 @@
     constructor() {
         super(false, true, {
             id: 'editor.action.marker.prevInFiles',
-            label: nls.localize('markerAction.previousInFiles.label', "Go to Previous Problem in Files (Error, Warning, Info)"),
+            label: nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoError', 'markerAction.previousInFiles.label', "Go to Previous Problem in Files (Error, Warning, Info)"),
             alias: 'Go to Previous Problem in Files (Error, Warning, Info)',
             precondition: undefined,
             kbOpts: {
@@ -258,7 +242,7 @@
             },
             menuOpts: {
                 menuId: MenuId.MenubarGoMenu,
-                title: nls.localize({ key: 'miGotoPreviousProblem', comment: ['&& denotes a mnemonic'] }, "Previous &&Problem"),
+                title: nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoError', { key: 'miGotoPreviousProblem', comment: ['&& denotes a mnemonic'] }, "Previous &&Problem"),
                 group: '6_problem_nav',
                 order: 2
             }
diff -urN -x '*.map' a/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js b/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js
--- a/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js	2023-12-06 14:23:14.379854783 +0000
@@ -78,7 +78,7 @@
     }
     update(marker) {
         const { source, message, relatedInformation, code } = marker;
-        let sourceAndCodeLength = ((source === null || source === void 0 ? void 0 : source.length) || 0) + '()'.length;
+        let sourceAndCodeLength = (source?.length || 0) + '()'.length;
         if (code) {
             if (typeof code === 'string') {
                 sourceAndCodeLength += code.length;
@@ -174,19 +174,19 @@
         let severityLabel = '';
         switch (marker.severity) {
             case MarkerSeverity.Error:
-                severityLabel = nls.localize('Error', "Error");
+                severityLabel = nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'Error', "Error");
                 break;
             case MarkerSeverity.Warning:
-                severityLabel = nls.localize('Warning', "Warning");
+                severityLabel = nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'Warning', "Warning");
                 break;
             case MarkerSeverity.Info:
-                severityLabel = nls.localize('Info', "Info");
+                severityLabel = nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'Info', "Info");
                 break;
             case MarkerSeverity.Hint:
-                severityLabel = nls.localize('Hint', "Hint");
+                severityLabel = nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'Hint', "Hint");
                 break;
         }
-        let ariaLabel = nls.localize('marker aria', "{0} at {1}. ", severityLabel, marker.startLineNumber + ':' + marker.startColumn);
+        let ariaLabel = nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'marker aria', "{0} at {1}. ", severityLabel, marker.startLineNumber + ':' + marker.startColumn);
         const model = this._editor.getModel();
         if (model && (marker.startLineNumber <= model.getLineCount()) && (marker.startLineNumber >= 1)) {
             const lineContent = model.getLineContent(marker.startLineNumber);
@@ -244,6 +244,9 @@
         this._callOnDispose.dispose();
         super.dispose();
     }
+    focus() {
+        this._parentContainer.focus();
+    }
     _fillHead(container) {
         super._fillHead(container);
         this._disposables.add(this._actionbarWidget.actionRunner.onWillRun(e => this.editor.focus()));
@@ -286,8 +289,8 @@
         const model = this.editor.getModel();
         if (model) {
             const detail = markerCount > 1
-                ? nls.localize('problems', "{0} of {1} problems", markerIdx, markerCount)
-                : nls.localize('change', "{0} of {1} problem", markerIdx, markerCount);
+                ? nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'problems', "{0} of {1} problems", markerIdx, markerCount)
+                : nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'change', "{0} of {1} problem", markerIdx, markerCount);
             this.setTitle(basename(model.uri), detail);
         }
         this._icon.className = `codicon ${SeverityIcon.className(MarkerSeverity.toSeverity(this._severity))}`;
@@ -332,10 +335,10 @@
 const errorDefault = oneOf(editorErrorForeground, editorErrorBorder);
 const warningDefault = oneOf(editorWarningForeground, editorWarningBorder);
 const infoDefault = oneOf(editorInfoForeground, editorInfoBorder);
-const editorMarkerNavigationError = registerColor('editorMarkerNavigationError.background', { dark: errorDefault, light: errorDefault, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorMarkerNavigationError', 'Editor marker navigation widget error color.'));
-const editorMarkerNavigationErrorHeader = registerColor('editorMarkerNavigationError.headerBackground', { dark: transparent(editorMarkerNavigationError, .1), light: transparent(editorMarkerNavigationError, .1), hcDark: null, hcLight: null }, nls.localize('editorMarkerNavigationErrorHeaderBackground', 'Editor marker navigation widget error heading background.'));
-const editorMarkerNavigationWarning = registerColor('editorMarkerNavigationWarning.background', { dark: warningDefault, light: warningDefault, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorMarkerNavigationWarning', 'Editor marker navigation widget warning color.'));
-const editorMarkerNavigationWarningHeader = registerColor('editorMarkerNavigationWarning.headerBackground', { dark: transparent(editorMarkerNavigationWarning, .1), light: transparent(editorMarkerNavigationWarning, .1), hcDark: '#0C141F', hcLight: transparent(editorMarkerNavigationWarning, .2) }, nls.localize('editorMarkerNavigationWarningBackground', 'Editor marker navigation widget warning heading background.'));
-const editorMarkerNavigationInfo = registerColor('editorMarkerNavigationInfo.background', { dark: infoDefault, light: infoDefault, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorMarkerNavigationInfo', 'Editor marker navigation widget info color.'));
-const editorMarkerNavigationInfoHeader = registerColor('editorMarkerNavigationInfo.headerBackground', { dark: transparent(editorMarkerNavigationInfo, .1), light: transparent(editorMarkerNavigationInfo, .1), hcDark: null, hcLight: null }, nls.localize('editorMarkerNavigationInfoHeaderBackground', 'Editor marker navigation widget info heading background.'));
-const editorMarkerNavigationBackground = registerColor('editorMarkerNavigation.background', { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('editorMarkerNavigationBackground', 'Editor marker navigation widget background.'));
+const editorMarkerNavigationError = registerColor('editorMarkerNavigationError.background', { dark: errorDefault, light: errorDefault, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'editorMarkerNavigationError', 'Editor marker navigation widget error color.'));
+const editorMarkerNavigationErrorHeader = registerColor('editorMarkerNavigationError.headerBackground', { dark: transparent(editorMarkerNavigationError, .1), light: transparent(editorMarkerNavigationError, .1), hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'editorMarkerNavigationErrorHeaderBackground', 'Editor marker navigation widget error heading background.'));
+const editorMarkerNavigationWarning = registerColor('editorMarkerNavigationWarning.background', { dark: warningDefault, light: warningDefault, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'editorMarkerNavigationWarning', 'Editor marker navigation widget warning color.'));
+const editorMarkerNavigationWarningHeader = registerColor('editorMarkerNavigationWarning.headerBackground', { dark: transparent(editorMarkerNavigationWarning, .1), light: transparent(editorMarkerNavigationWarning, .1), hcDark: '#0C141F', hcLight: transparent(editorMarkerNavigationWarning, .2) }, nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'editorMarkerNavigationWarningBackground', 'Editor marker navigation widget warning heading background.'));
+const editorMarkerNavigationInfo = registerColor('editorMarkerNavigationInfo.background', { dark: infoDefault, light: infoDefault, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'editorMarkerNavigationInfo', 'Editor marker navigation widget info color.'));
+const editorMarkerNavigationInfoHeader = registerColor('editorMarkerNavigationInfo.headerBackground', { dark: transparent(editorMarkerNavigationInfo, .1), light: transparent(editorMarkerNavigationInfo, .1), hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'editorMarkerNavigationInfoHeaderBackground', 'Editor marker navigation widget info heading background.'));
+const editorMarkerNavigationBackground = registerColor('editorMarkerNavigation.background', { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localizeWithPath('vs/editor/contrib/gotoError/browser/gotoErrorWidget', 'editorMarkerNavigationBackground', 'Editor marker navigation widget background.'));
diff -urN -x '*.map' a/vs/editor/contrib/gotoError/browser/markerNavigationService.js b/vs/editor/contrib/gotoError/browser/markerNavigationService.js
--- a/vs/editor/contrib/gotoError/browser/markerNavigationService.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/gotoError/browser/markerNavigationService.js	2023-12-06 14:23:14.379854783 +0000
@@ -13,7 +13,7 @@
 };
 import { binarySearch } from '../../../../base/common/arrays.js';
 import { Emitter } from '../../../../base/common/event.js';
-import { DisposableStore } from '../../../../base/common/lifecycle.js';
+import { DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';
 import { LinkedList } from '../../../../base/common/linkedList.js';
 import { compare } from '../../../../base/common/strings.js';
 import { URI } from '../../../../base/common/uri.js';
@@ -174,6 +174,10 @@
         this._configService = _configService;
         this._provider = new LinkedList();
     }
+    registerProvider(provider) {
+        const remove = this._provider.unshift(provider);
+        return toDisposable(() => remove());
+    }
     getMarkerList(resource) {
         for (const provider of this._provider) {
             const result = provider.getMarkerList(resource);
diff -urN -x '*.map' a/vs/editor/contrib/gotoSymbol/browser/goToCommands.js b/vs/editor/contrib/gotoSymbol/browser/goToCommands.js
--- a/vs/editor/contrib/gotoSymbol/browser/goToCommands.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/gotoSymbol/browser/goToCommands.js	2023-12-06 14:23:14.379854783 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var _a, _b, _c, _d, _e, _f, _g, _h;
 import { alert } from '../../../../base/browser/ui/aria/aria.js';
 import { createCancelablePromise, raceCancellation } from '../../../../base/common/async.js';
@@ -44,7 +35,7 @@
 import { IsWebContext } from '../../../../platform/contextkey/common/contextkeys.js';
 MenuRegistry.appendMenuItem(MenuId.EditorContext, {
     submenu: MenuId.EditorContextPeek,
-    title: nls.localize('peek.submenu', "Peek"),
+    title: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'peek.submenu', "Peek"),
     group: 'navigation',
     order: 100
 });
@@ -71,7 +62,7 @@
         return SymbolNavigationAction._allSymbolNavigationCommands.values();
     }
     static _patchConfig(opts) {
-        const result = Object.assign(Object.assign({}, opts), { f1: true });
+        const result = { ...opts, f1: true };
         // patch context menu when clause
         if (result.menu) {
             for (const item of Iterable.wrap(result.menu)) {
@@ -101,8 +92,7 @@
         const position = editor.getPosition();
         const anchor = SymbolNavigationAnchor.is(arg) ? arg : new SymbolNavigationAnchor(model, position);
         const cts = new EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */);
-        const promise = raceCancellation(this._getLocationModel(languageFeaturesService, anchor.model, anchor.position, cts.token), cts.token).then((references) => __awaiter(this, void 0, void 0, function* () {
-            var _j;
+        const promise = raceCancellation(this._getLocationModel(languageFeaturesService, anchor.model, anchor.position, cts.token), cts.token).then(async (references) => {
             if (!references || cts.token.isCancellationRequested) {
                 return;
             }
@@ -119,7 +109,7 @@
                 // no result -> show message
                 if (!this.configuration.muteMessage) {
                     const info = model.getWordAtPosition(position);
-                    (_j = MessageController.get(editor)) === null || _j === void 0 ? void 0 : _j.showMessage(this._getNoResultFoundMessage(info), position);
+                    MessageController.get(editor)?.showMessage(this._getNoResultFoundMessage(info), position);
                 }
             }
             else if (referenceCount === 1 && altAction) {
@@ -133,7 +123,7 @@
                 // normal results handling
                 return this._onResult(editorService, symbolNavService, editor, references, range);
             }
-        }), (err) => {
+        }, (err) => {
             // report an error
             notificationService.error(err);
         }).finally(() => {
@@ -142,71 +132,67 @@
         progressService.showWhile(promise, 250);
         return promise;
     }
-    _onResult(editorService, symbolNavService, editor, model, range) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const gotoLocation = this._getGoToPreference(editor);
-            if (!(editor instanceof EmbeddedCodeEditorWidget) && (this.configuration.openInPeek || (gotoLocation === 'peek' && model.references.length > 1))) {
-                this._openInPeek(editor, model, range);
+    async _onResult(editorService, symbolNavService, editor, model, range) {
+        const gotoLocation = this._getGoToPreference(editor);
+        if (!(editor instanceof EmbeddedCodeEditorWidget) && (this.configuration.openInPeek || (gotoLocation === 'peek' && model.references.length > 1))) {
+            this._openInPeek(editor, model, range);
+        }
+        else {
+            const next = model.firstReference();
+            const peek = model.references.length > 1 && gotoLocation === 'gotoAndPeek';
+            const targetEditor = await this._openReference(editor, editorService, next, this.configuration.openToSide, !peek);
+            if (peek && targetEditor) {
+                this._openInPeek(targetEditor, model, range);
             }
             else {
-                const next = model.firstReference();
-                const peek = model.references.length > 1 && gotoLocation === 'gotoAndPeek';
-                const targetEditor = yield this._openReference(editor, editorService, next, this.configuration.openToSide, !peek);
-                if (peek && targetEditor) {
-                    this._openInPeek(targetEditor, model, range);
-                }
-                else {
-                    model.dispose();
-                }
-                // keep remaining locations around when using
-                // 'goto'-mode
-                if (gotoLocation === 'goto') {
-                    symbolNavService.put(next);
-                }
-            }
-        });
-    }
-    _openReference(editor, editorService, reference, sideBySide, highlight) {
-        return __awaiter(this, void 0, void 0, function* () {
-            // range is the target-selection-range when we have one
-            // and the fallback is the 'full' range
-            let range = undefined;
-            if (isLocationLink(reference)) {
-                range = reference.targetSelectionRange;
-            }
-            if (!range) {
-                range = reference.range;
+                model.dispose();
             }
-            if (!range) {
-                return undefined;
+            // keep remaining locations around when using
+            // 'goto'-mode
+            if (gotoLocation === 'goto') {
+                symbolNavService.put(next);
             }
-            const targetEditor = yield editorService.openCodeEditor({
-                resource: reference.uri,
-                options: {
-                    selection: Range.collapseToStart(range),
-                    selectionRevealType: 3 /* TextEditorSelectionRevealType.NearTopIfOutsideViewport */,
-                    selectionSource: "code.jump" /* TextEditorSelectionSource.JUMP */
+        }
+    }
+    async _openReference(editor, editorService, reference, sideBySide, highlight) {
+        // range is the target-selection-range when we have one
+        // and the fallback is the 'full' range
+        let range = undefined;
+        if (isLocationLink(reference)) {
+            range = reference.targetSelectionRange;
+        }
+        if (!range) {
+            range = reference.range;
+        }
+        if (!range) {
+            return undefined;
+        }
+        const targetEditor = await editorService.openCodeEditor({
+            resource: reference.uri,
+            options: {
+                selection: Range.collapseToStart(range),
+                selectionRevealType: 3 /* TextEditorSelectionRevealType.NearTopIfOutsideViewport */,
+                selectionSource: "code.jump" /* TextEditorSelectionSource.JUMP */
+            }
+        }, editor, sideBySide);
+        if (!targetEditor) {
+            return undefined;
+        }
+        if (highlight) {
+            const modelNow = targetEditor.getModel();
+            const decorations = targetEditor.createDecorationsCollection([{ range, options: { description: 'symbol-navigate-action-highlight', className: 'symbolHighlight' } }]);
+            setTimeout(() => {
+                if (targetEditor.getModel() === modelNow) {
+                    decorations.clear();
                 }
-            }, editor, sideBySide);
-            if (!targetEditor) {
-                return undefined;
-            }
-            if (highlight) {
-                const modelNow = targetEditor.getModel();
-                const decorations = targetEditor.createDecorationsCollection([{ range, options: { description: 'symbol-navigate-action-highlight', className: 'symbolHighlight' } }]);
-                setTimeout(() => {
-                    if (targetEditor.getModel() === modelNow) {
-                        decorations.clear();
-                    }
-                }, 350);
-            }
-            return targetEditor;
-        });
+            }, 350);
+        }
+        return targetEditor;
     }
     _openInPeek(target, model, range) {
         const controller = ReferencesController.get(target);
         if (controller && target.hasModel()) {
-            controller.toggleWidget(range !== null && range !== void 0 ? range : target.getSelection(), createCancelablePromise(_ => Promise.resolve(model)), this.configuration.openInPeek);
+            controller.toggleWidget(range ?? target.getSelection(), createCancelablePromise(_ => Promise.resolve(model)), this.configuration.openInPeek);
         }
         else {
             model.dispose();
@@ -217,15 +203,13 @@
 SymbolNavigationAction._activeAlternativeCommands = new Set();
 //#region --- DEFINITION
 export class DefinitionAction extends SymbolNavigationAction {
-    _getLocationModel(languageFeaturesService, model, position, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            return new ReferencesModel(yield getDefinitionsAtPosition(languageFeaturesService.definitionProvider, model, position, token), nls.localize('def.title', 'Definitions'));
-        });
+    async _getLocationModel(languageFeaturesService, model, position, token) {
+        return new ReferencesModel(await getDefinitionsAtPosition(languageFeaturesService.definitionProvider, model, position, token), nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'def.title', 'Definitions'));
     }
     _getNoResultFoundMessage(info) {
         return info && info.word
-            ? nls.localize('noResultWord', "No definition found for '{0}'", info.word)
-            : nls.localize('generic.noResults', "No definition found");
+            ? nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'noResultWord', "No definition found for '{0}'", info.word)
+            : nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'generic.noResults', "No definition found");
     }
     _getAlternativeCommand(editor) {
         return editor.getOption(58 /* EditorOption.gotoLocation */).alternativeDefinitionCommand;
@@ -243,9 +227,9 @@
             }, {
                 id: _a.id,
                 title: {
-                    value: nls.localize('actions.goToDecl.label', "Go to Definition"),
+                    value: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'actions.goToDecl.label', "Go to Definition"),
                     original: 'Go to Definition',
-                    mnemonicTitle: nls.localize({ key: 'miGotoDefinition', comment: ['&& denotes a mnemonic'] }, "Go to &&Definition")
+                    mnemonicTitle: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', { key: 'miGotoDefinition', comment: ['&& denotes a mnemonic'] }, "Go to &&Definition")
                 },
                 precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
                 keybinding: [{
@@ -282,7 +266,7 @@
             }, {
                 id: _b.id,
                 title: {
-                    value: nls.localize('actions.goToDeclToSide.label', "Open Definition to the Side"),
+                    value: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'actions.goToDeclToSide.label', "Open Definition to the Side"),
                     original: 'Open Definition to the Side'
                 },
                 precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
@@ -310,7 +294,7 @@
             }, {
                 id: _c.id,
                 title: {
-                    value: nls.localize('actions.previewDecl.label', "Peek Definition"),
+                    value: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'actions.previewDecl.label', "Peek Definition"),
                     original: 'Peek Definition'
                 },
                 precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
@@ -334,15 +318,13 @@
 //#endregion
 //#region --- DECLARATION
 class DeclarationAction extends SymbolNavigationAction {
-    _getLocationModel(languageFeaturesService, model, position, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            return new ReferencesModel(yield getDeclarationsAtPosition(languageFeaturesService.declarationProvider, model, position, token), nls.localize('decl.title', 'Declarations'));
-        });
+    async _getLocationModel(languageFeaturesService, model, position, token) {
+        return new ReferencesModel(await getDeclarationsAtPosition(languageFeaturesService.declarationProvider, model, position, token), nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'decl.title', 'Declarations'));
     }
     _getNoResultFoundMessage(info) {
         return info && info.word
-            ? nls.localize('decl.noResultWord', "No declaration found for '{0}'", info.word)
-            : nls.localize('decl.generic.noResults', "No declaration found");
+            ? nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'decl.noResultWord', "No declaration found for '{0}'", info.word)
+            : nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'decl.generic.noResults', "No declaration found");
     }
     _getAlternativeCommand(editor) {
         return editor.getOption(58 /* EditorOption.gotoLocation */).alternativeDeclarationCommand;
@@ -360,9 +342,9 @@
             }, {
                 id: _d.id,
                 title: {
-                    value: nls.localize('actions.goToDeclaration.label', "Go to Declaration"),
+                    value: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'actions.goToDeclaration.label', "Go to Declaration"),
                     original: 'Go to Declaration',
-                    mnemonicTitle: nls.localize({ key: 'miGotoDeclaration', comment: ['&& denotes a mnemonic'] }, "Go to &&Declaration")
+                    mnemonicTitle: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', { key: 'miGotoDeclaration', comment: ['&& denotes a mnemonic'] }, "Go to &&Declaration")
                 },
                 precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
                 menu: [{
@@ -379,8 +361,8 @@
         }
         _getNoResultFoundMessage(info) {
             return info && info.word
-                ? nls.localize('decl.noResultWord', "No declaration found for '{0}'", info.word)
-                : nls.localize('decl.generic.noResults', "No declaration found");
+                ? nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'decl.noResultWord', "No declaration found for '{0}'", info.word)
+                : nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'decl.generic.noResults', "No declaration found");
         }
     },
     _d.id = 'editor.action.revealDeclaration',
@@ -394,7 +376,7 @@
         }, {
             id: 'editor.action.peekDeclaration',
             title: {
-                value: nls.localize('actions.peekDecl.label', "Peek Declaration"),
+                value: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'actions.peekDecl.label', "Peek Declaration"),
                 original: 'Peek Declaration'
             },
             precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
@@ -409,15 +391,13 @@
 //#endregion
 //#region --- TYPE DEFINITION
 class TypeDefinitionAction extends SymbolNavigationAction {
-    _getLocationModel(languageFeaturesService, model, position, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            return new ReferencesModel(yield getTypeDefinitionsAtPosition(languageFeaturesService.typeDefinitionProvider, model, position, token), nls.localize('typedef.title', 'Type Definitions'));
-        });
+    async _getLocationModel(languageFeaturesService, model, position, token) {
+        return new ReferencesModel(await getTypeDefinitionsAtPosition(languageFeaturesService.typeDefinitionProvider, model, position, token), nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'typedef.title', 'Type Definitions'));
     }
     _getNoResultFoundMessage(info) {
         return info && info.word
-            ? nls.localize('goToTypeDefinition.noResultWord', "No type definition found for '{0}'", info.word)
-            : nls.localize('goToTypeDefinition.generic.noResults', "No type definition found");
+            ? nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'goToTypeDefinition.noResultWord', "No type definition found for '{0}'", info.word)
+            : nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'goToTypeDefinition.generic.noResults', "No type definition found");
     }
     _getAlternativeCommand(editor) {
         return editor.getOption(58 /* EditorOption.gotoLocation */).alternativeTypeDefinitionCommand;
@@ -435,9 +415,9 @@
             }, {
                 id: _e.ID,
                 title: {
-                    value: nls.localize('actions.goToTypeDefinition.label', "Go to Type Definition"),
+                    value: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'actions.goToTypeDefinition.label', "Go to Type Definition"),
                     original: 'Go to Type Definition',
-                    mnemonicTitle: nls.localize({ key: 'miGotoTypeDefinition', comment: ['&& denotes a mnemonic'] }, "Go to &&Type Definition")
+                    mnemonicTitle: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', { key: 'miGotoTypeDefinition', comment: ['&& denotes a mnemonic'] }, "Go to &&Type Definition")
                 },
                 precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
                 keybinding: {
@@ -469,7 +449,7 @@
             }, {
                 id: _f.ID,
                 title: {
-                    value: nls.localize('actions.peekTypeDefinition.label', "Peek Type Definition"),
+                    value: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'actions.peekTypeDefinition.label', "Peek Type Definition"),
                     original: 'Peek Type Definition'
                 },
                 precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
@@ -486,15 +466,13 @@
 //#endregion
 //#region --- IMPLEMENTATION
 class ImplementationAction extends SymbolNavigationAction {
-    _getLocationModel(languageFeaturesService, model, position, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            return new ReferencesModel(yield getImplementationsAtPosition(languageFeaturesService.implementationProvider, model, position, token), nls.localize('impl.title', 'Implementations'));
-        });
+    async _getLocationModel(languageFeaturesService, model, position, token) {
+        return new ReferencesModel(await getImplementationsAtPosition(languageFeaturesService.implementationProvider, model, position, token), nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'impl.title', 'Implementations'));
     }
     _getNoResultFoundMessage(info) {
         return info && info.word
-            ? nls.localize('goToImplementation.noResultWord', "No implementation found for '{0}'", info.word)
-            : nls.localize('goToImplementation.generic.noResults', "No implementation found");
+            ? nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'goToImplementation.noResultWord', "No implementation found for '{0}'", info.word)
+            : nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'goToImplementation.generic.noResults', "No implementation found");
     }
     _getAlternativeCommand(editor) {
         return editor.getOption(58 /* EditorOption.gotoLocation */).alternativeImplementationCommand;
@@ -512,9 +490,9 @@
             }, {
                 id: _g.ID,
                 title: {
-                    value: nls.localize('actions.goToImplementation.label', "Go to Implementations"),
+                    value: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'actions.goToImplementation.label', "Go to Implementations"),
                     original: 'Go to Implementations',
-                    mnemonicTitle: nls.localize({ key: 'miGotoImplementation', comment: ['&& denotes a mnemonic'] }, "Go to &&Implementations")
+                    mnemonicTitle: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', { key: 'miGotoImplementation', comment: ['&& denotes a mnemonic'] }, "Go to &&Implementations")
                 },
                 precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
                 keybinding: {
@@ -546,7 +524,7 @@
             }, {
                 id: _h.ID,
                 title: {
-                    value: nls.localize('actions.peekImplementation.label', "Peek Implementations"),
+                    value: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'actions.peekImplementation.label', "Peek Implementations"),
                     original: 'Peek Implementations'
                 },
                 precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
@@ -570,8 +548,8 @@
 class ReferencesAction extends SymbolNavigationAction {
     _getNoResultFoundMessage(info) {
         return info
-            ? nls.localize('references.no', "No references found for '{0}'", info.word)
-            : nls.localize('references.noGeneric', "No references found");
+            ? nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'references.no', "No references found for '{0}'", info.word)
+            : nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'references.noGeneric', "No references found");
     }
     _getAlternativeCommand(editor) {
         return editor.getOption(58 /* EditorOption.gotoLocation */).alternativeReferenceCommand;
@@ -589,9 +567,9 @@
         }, {
             id: 'editor.action.goToReferences',
             title: {
-                value: nls.localize('goToReferences.label', "Go to References"),
+                value: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'goToReferences.label', "Go to References"),
                 original: 'Go to References',
-                mnemonicTitle: nls.localize({ key: 'miGotoReference', comment: ['&& denotes a mnemonic'] }, "Go to &&References")
+                mnemonicTitle: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', { key: 'miGotoReference', comment: ['&& denotes a mnemonic'] }, "Go to &&References")
             },
             precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
             keybinding: {
@@ -611,10 +589,8 @@
                 }]
         });
     }
-    _getLocationModel(languageFeaturesService, model, position, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            return new ReferencesModel(yield getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, true, token), nls.localize('ref.title', 'References'));
-        });
+    async _getLocationModel(languageFeaturesService, model, position, token) {
+        return new ReferencesModel(await getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, true, token), nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'ref.title', 'References'));
     }
 });
 registerAction2(class PeekReferencesAction extends ReferencesAction {
@@ -626,7 +602,7 @@
         }, {
             id: 'editor.action.referenceSearch.trigger',
             title: {
-                value: nls.localize('references.action.label', "Peek References"),
+                value: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'references.action.label', "Peek References"),
                 original: 'Peek References'
             },
             precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
@@ -637,10 +613,8 @@
             }
         });
     }
-    _getLocationModel(languageFeaturesService, model, position, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            return new ReferencesModel(yield getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, false, token), nls.localize('ref.title', 'References'));
-        });
+    async _getLocationModel(languageFeaturesService, model, position, token) {
+        return new ReferencesModel(await getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, false, token), nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'ref.title', 'References'));
     }
 });
 //#endregion
@@ -650,7 +624,7 @@
         super(config, {
             id: 'editor.action.goToLocation',
             title: {
-                value: nls.localize('label.generic', "Go to Any Symbol"),
+                value: nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'label.generic', "Go to Any Symbol"),
                 original: 'Go to Any Symbol'
             },
             precondition: ContextKeyExpr.and(PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
@@ -658,17 +632,14 @@
         this._references = _references;
         this._gotoMultipleBehaviour = _gotoMultipleBehaviour;
     }
-    _getLocationModel(languageFeaturesService, _model, _position, _token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            return new ReferencesModel(this._references, nls.localize('generic.title', 'Locations'));
-        });
+    async _getLocationModel(languageFeaturesService, _model, _position, _token) {
+        return new ReferencesModel(this._references, nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'generic.title', 'Locations'));
     }
     _getNoResultFoundMessage(info) {
-        return info && nls.localize('generic.noResult', "No results for '{0}'", info.word) || '';
+        return info && nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'generic.noResult', "No results for '{0}'", info.word) || '';
     }
     _getGoToPreference(editor) {
-        var _j;
-        return (_j = this._gotoMultipleBehaviour) !== null && _j !== void 0 ? _j : editor.getOption(58 /* EditorOption.gotoLocation */).multipleReferences;
+        return this._gotoMultipleBehaviour ?? editor.getOption(58 /* EditorOption.gotoLocation */).multipleReferences;
     }
     _getAlternativeCommand() { return ''; }
 }
@@ -684,14 +655,14 @@
             { name: 'noResultsMessage', description: 'Human readable message that shows when locations is empty.' },
         ]
     },
-    handler: (accessor, resource, position, references, multiple, noResultsMessage, openInPeek) => __awaiter(void 0, void 0, void 0, function* () {
+    handler: async (accessor, resource, position, references, multiple, noResultsMessage, openInPeek) => {
         assertType(URI.isUri(resource));
         assertType(corePosition.Position.isIPosition(position));
         assertType(Array.isArray(references));
         assertType(typeof multiple === 'undefined' || typeof multiple === 'string');
         assertType(typeof openInPeek === 'undefined' || typeof openInPeek === 'boolean');
         const editorService = accessor.get(ICodeEditorService);
-        const editor = yield editorService.openCodeEditor({ resource }, editorService.getFocusedCodeEditor());
+        const editor = await editorService.openCodeEditor({ resource }, editorService.getFocusedCodeEditor());
         if (isCodeEditor(editor)) {
             editor.setPosition(position);
             editor.revealPositionInCenterIfOutsideViewport(position, 0 /* ScrollType.Smooth */);
@@ -708,7 +679,7 @@
                 accessor.get(IInstantiationService).invokeFunction(command.run.bind(command), editor);
             });
         }
-    })
+    }
 });
 CommandsRegistry.registerCommand({
     id: 'editor.action.peekLocations',
@@ -721,9 +692,9 @@
             { name: 'multiple', description: 'Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto' },
         ]
     },
-    handler: (accessor, resource, position, references, multiple) => __awaiter(void 0, void 0, void 0, function* () {
+    handler: async (accessor, resource, position, references, multiple) => {
         accessor.get(ICommandService).executeCommand('editor.action.goToLocations', resource, position, references, multiple, undefined, true);
-    })
+    }
 });
 //#endregion
 //#region --- REFERENCE search special commands
@@ -742,7 +713,7 @@
             if (!controller) {
                 return undefined;
             }
-            const references = createCancelablePromise(token => getReferencesAtPosition(languageFeaturesService.referenceProvider, control.getModel(), corePosition.Position.lift(position), false, token).then(references => new ReferencesModel(references, nls.localize('ref.title', 'References'))));
+            const references = createCancelablePromise(token => getReferencesAtPosition(languageFeaturesService.referenceProvider, control.getModel(), corePosition.Position.lift(position), false, token).then(references => new ReferencesModel(references, nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/goToCommands', 'ref.title', 'References'))));
             const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
             return Promise.resolve(controller.toggleWidget(range, references, false));
         });
diff -urN -x '*.map' a/vs/editor/contrib/gotoSymbol/browser/goToSymbol.js b/vs/editor/contrib/gotoSymbol/browser/goToSymbol.js
--- a/vs/editor/contrib/gotoSymbol/browser/goToSymbol.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/gotoSymbol/browser/goToSymbol.js	2023-12-06 14:23:14.379854783 +0000
@@ -2,34 +2,23 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { coalesce } from '../../../../base/common/arrays.js';
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { registerModelAndPositionCommand } from '../../../browser/editorExtensions.js';
 import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
 import { ReferencesModel } from './referencesModel.js';
-function getLocationLinks(model, position, registry, provide) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const provider = registry.ordered(model);
-        // get results
-        const promises = provider.map((provider) => {
-            return Promise.resolve(provide(provider, model, position)).then(undefined, err => {
-                onUnexpectedExternalError(err);
-                return undefined;
-            });
+async function getLocationLinks(model, position, registry, provide) {
+    const provider = registry.ordered(model);
+    // get results
+    const promises = provider.map((provider) => {
+        return Promise.resolve(provide(provider, model, position)).then(undefined, err => {
+            onUnexpectedExternalError(err);
+            return undefined;
         });
-        const values = yield Promise.all(promises);
-        return coalesce(values.flat());
     });
+    const values = await Promise.all(promises);
+    return coalesce(values.flat());
 }
 export function getDefinitionsAtPosition(registry, model, position, token) {
     return getLocationLinks(model, position, registry, (provider, model, position) => {
@@ -52,27 +41,25 @@
     });
 }
 export function getReferencesAtPosition(registry, model, position, compact, token) {
-    return getLocationLinks(model, position, registry, (provider, model, position) => __awaiter(this, void 0, void 0, function* () {
-        const result = yield provider.provideReferences(model, position, { includeDeclaration: true }, token);
+    return getLocationLinks(model, position, registry, async (provider, model, position) => {
+        const result = await provider.provideReferences(model, position, { includeDeclaration: true }, token);
         if (!compact || !result || result.length !== 2) {
             return result;
         }
-        const resultWithoutDeclaration = yield provider.provideReferences(model, position, { includeDeclaration: false }, token);
+        const resultWithoutDeclaration = await provider.provideReferences(model, position, { includeDeclaration: false }, token);
         if (resultWithoutDeclaration && resultWithoutDeclaration.length === 1) {
             return resultWithoutDeclaration;
         }
         return result;
-    }));
+    });
 }
 // -- API commands ----
-function _sortedAndDeduped(callback) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const rawLinks = yield callback();
-        const model = new ReferencesModel(rawLinks, '');
-        const modelLinks = model.references.map(ref => ref.link);
-        model.dispose();
-        return modelLinks;
-    });
+async function _sortedAndDeduped(callback) {
+    const rawLinks = await callback();
+    const model = new ReferencesModel(rawLinks, '');
+    const modelLinks = model.references.map(ref => ref.link);
+    model.dispose();
+    return modelLinks;
 }
 registerModelAndPositionCommand('_executeDefinitionProvider', (accessor, model, position) => {
     const languageFeaturesService = accessor.get(ILanguageFeaturesService);
diff -urN -x '*.map' a/vs/editor/contrib/gotoSymbol/browser/link/clickLinkGesture.js b/vs/editor/contrib/gotoSymbol/browser/link/clickLinkGesture.js
--- a/vs/editor/contrib/gotoSymbol/browser/link/clickLinkGesture.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/gotoSymbol/browser/link/clickLinkGesture.js	2023-12-06 14:23:14.379854783 +0000
@@ -60,7 +60,6 @@
 }
 export class ClickLinkGesture extends Disposable {
     constructor(editor, opts) {
-        var _a;
         super();
         this._onMouseMoveOrRelevantKeyDown = this._register(new Emitter());
         this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event;
@@ -69,7 +68,7 @@
         this._onCancel = this._register(new Emitter());
         this.onCancel = this._onCancel.event;
         this._editor = editor;
-        this._extractLineNumberFromMouseEvent = (_a = opts === null || opts === void 0 ? void 0 : opts.extractLineNumberFromMouseEvent) !== null && _a !== void 0 ? _a : ((e) => e.target.position ? e.target.position.lineNumber : 0);
+        this._extractLineNumberFromMouseEvent = opts?.extractLineNumberFromMouseEvent ?? ((e) => e.target.position ? e.target.position.lineNumber : 0);
         this._opts = createOptions(this._editor.getOption(77 /* EditorOption.multiCursorModifier */));
         this._lastMouseMoveEvent = null;
         this._hasTriggerKeyOnMouseDown = false;
diff -urN -x '*.map' a/vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.js b/vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.js
--- a/vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.js	2023-12-06 14:23:14.379854783 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var GotoDefinitionAtPositionEditorContribution_1;
 import { createCancelablePromise } from '../../../../../base/common/async.js';
 import { onUnexpectedError } from '../../../../../base/common/errors.js';
@@ -53,7 +44,7 @@
         const linkGesture = new ClickLinkGesture(editor);
         this.toUnhook.add(linkGesture);
         this.toUnhook.add(linkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
-            this.startFindDefinitionFromMouse(mouseEvent, keyboardEvent !== null && keyboardEvent !== void 0 ? keyboardEvent : undefined);
+            this.startFindDefinitionFromMouse(mouseEvent, keyboardEvent ?? undefined);
         }));
         this.toUnhook.add(linkGesture.onExecute((mouseEvent) => {
             if (this.isEnabled(mouseEvent)) {
@@ -74,31 +65,29 @@
     static get(editor) {
         return editor.getContribution(GotoDefinitionAtPositionEditorContribution_1.ID);
     }
-    startFindDefinitionFromCursor(position) {
-        return __awaiter(this, void 0, void 0, function* () {
-            // For issue: https://github.com/microsoft/vscode/issues/46257
-            // equivalent to mouse move with meta/ctrl key
-            // First find the definition and add decorations
-            // to the editor to be shown with the content hover widget
-            yield this.startFindDefinition(position);
-            // Add listeners for editor cursor move and key down events
-            // Dismiss the "extended" editor decorations when the user hides
-            // the hover widget. There is no event for the widget itself so these
-            // serve as a best effort. After removing the link decorations, the hover
-            // widget is clean and will only show declarations per next request.
-            this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
+    async startFindDefinitionFromCursor(position) {
+        // For issue: https://github.com/microsoft/vscode/issues/46257
+        // equivalent to mouse move with meta/ctrl key
+        // First find the definition and add decorations
+        // to the editor to be shown with the content hover widget
+        await this.startFindDefinition(position);
+        // Add listeners for editor cursor move and key down events
+        // Dismiss the "extended" editor decorations when the user hides
+        // the hover widget. There is no event for the widget itself so these
+        // serve as a best effort. After removing the link decorations, the hover
+        // widget is clean and will only show declarations per next request.
+        this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
+            this.currentWordAtPosition = null;
+            this.removeLinkDecorations();
+            this.toUnhookForKeyboard.clear();
+        }));
+        this.toUnhookForKeyboard.add(this.editor.onKeyDown((e) => {
+            if (e) {
                 this.currentWordAtPosition = null;
                 this.removeLinkDecorations();
                 this.toUnhookForKeyboard.clear();
-            }));
-            this.toUnhookForKeyboard.add(this.editor.onKeyDown((e) => {
-                if (e) {
-                    this.currentWordAtPosition = null;
-                    this.removeLinkDecorations();
-                    this.toUnhookForKeyboard.clear();
-                }
-            }));
-        });
+            }
+        }));
     }
     startFindDefinitionFromMouse(mouseEvent, withKey) {
         // check if we are active and on a content widget
@@ -113,80 +102,77 @@
         const position = mouseEvent.target.position;
         this.startFindDefinition(position);
     }
-    startFindDefinition(position) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            // Dispose listeners for updating decorations when using keyboard to show definition hover
-            this.toUnhookForKeyboard.clear();
-            // Find word at mouse position
-            const word = position ? (_a = this.editor.getModel()) === null || _a === void 0 ? void 0 : _a.getWordAtPosition(position) : null;
-            if (!word) {
-                this.currentWordAtPosition = null;
-                this.removeLinkDecorations();
-                return;
-            }
-            // Return early if word at position is still the same
-            if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === word.startColumn && this.currentWordAtPosition.endColumn === word.endColumn && this.currentWordAtPosition.word === word.word) {
-                return;
-            }
-            this.currentWordAtPosition = word;
-            // Find definition and decorate word if found
-            const state = new EditorState(this.editor, 4 /* CodeEditorStateFlag.Position */ | 1 /* CodeEditorStateFlag.Value */ | 2 /* CodeEditorStateFlag.Selection */ | 8 /* CodeEditorStateFlag.Scroll */);
-            if (this.previousPromise) {
-                this.previousPromise.cancel();
-                this.previousPromise = null;
-            }
-            this.previousPromise = createCancelablePromise(token => this.findDefinition(position, token));
-            let results;
-            try {
-                results = yield this.previousPromise;
-            }
-            catch (error) {
-                onUnexpectedError(error);
-                return;
+    async startFindDefinition(position) {
+        // Dispose listeners for updating decorations when using keyboard to show definition hover
+        this.toUnhookForKeyboard.clear();
+        // Find word at mouse position
+        const word = position ? this.editor.getModel()?.getWordAtPosition(position) : null;
+        if (!word) {
+            this.currentWordAtPosition = null;
+            this.removeLinkDecorations();
+            return;
+        }
+        // Return early if word at position is still the same
+        if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === word.startColumn && this.currentWordAtPosition.endColumn === word.endColumn && this.currentWordAtPosition.word === word.word) {
+            return;
+        }
+        this.currentWordAtPosition = word;
+        // Find definition and decorate word if found
+        const state = new EditorState(this.editor, 4 /* CodeEditorStateFlag.Position */ | 1 /* CodeEditorStateFlag.Value */ | 2 /* CodeEditorStateFlag.Selection */ | 8 /* CodeEditorStateFlag.Scroll */);
+        if (this.previousPromise) {
+            this.previousPromise.cancel();
+            this.previousPromise = null;
+        }
+        this.previousPromise = createCancelablePromise(token => this.findDefinition(position, token));
+        let results;
+        try {
+            results = await this.previousPromise;
+        }
+        catch (error) {
+            onUnexpectedError(error);
+            return;
+        }
+        if (!results || !results.length || !state.validate(this.editor)) {
+            this.removeLinkDecorations();
+            return;
+        }
+        const linkRange = results[0].originSelectionRange
+            ? Range.lift(results[0].originSelectionRange)
+            : new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
+        // Multiple results
+        if (results.length > 1) {
+            let combinedRange = linkRange;
+            for (const { originSelectionRange } of results) {
+                if (originSelectionRange) {
+                    combinedRange = Range.plusRange(combinedRange, originSelectionRange);
+                }
             }
-            if (!results || !results.length || !state.validate(this.editor)) {
-                this.removeLinkDecorations();
+            this.addDecoration(combinedRange, new MarkdownString().appendText(nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition', 'multipleResults', "Click to show {0} definitions.", results.length)));
+        }
+        else {
+            // Single result
+            const result = results[0];
+            if (!result.uri) {
                 return;
             }
-            const linkRange = results[0].originSelectionRange
-                ? Range.lift(results[0].originSelectionRange)
-                : new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
-            // Multiple results
-            if (results.length > 1) {
-                let combinedRange = linkRange;
-                for (const { originSelectionRange } of results) {
-                    if (originSelectionRange) {
-                        combinedRange = Range.plusRange(combinedRange, originSelectionRange);
-                    }
-                }
-                this.addDecoration(combinedRange, new MarkdownString().appendText(nls.localize('multipleResults', "Click to show {0} definitions.", results.length)));
-            }
-            else {
-                // Single result
-                const result = results[0];
-                if (!result.uri) {
+            this.textModelResolverService.createModelReference(result.uri).then(ref => {
+                if (!ref.object || !ref.object.textEditorModel) {
+                    ref.dispose();
                     return;
                 }
-                this.textModelResolverService.createModelReference(result.uri).then(ref => {
-                    if (!ref.object || !ref.object.textEditorModel) {
-                        ref.dispose();
-                        return;
-                    }
-                    const { object: { textEditorModel } } = ref;
-                    const { startLineNumber } = result.range;
-                    if (startLineNumber < 1 || startLineNumber > textEditorModel.getLineCount()) {
-                        // invalid range
-                        ref.dispose();
-                        return;
-                    }
-                    const previewValue = this.getPreviewValue(textEditorModel, startLineNumber, result);
-                    const languageId = this.languageService.guessLanguageIdByFilepathOrFirstLine(textEditorModel.uri);
-                    this.addDecoration(linkRange, previewValue ? new MarkdownString().appendCodeblock(languageId ? languageId : '', previewValue) : undefined);
+                const { object: { textEditorModel } } = ref;
+                const { startLineNumber } = result.range;
+                if (startLineNumber < 1 || startLineNumber > textEditorModel.getLineCount()) {
+                    // invalid range
                     ref.dispose();
-                });
-            }
-        });
+                    return;
+                }
+                const previewValue = this.getPreviewValue(textEditorModel, startLineNumber, result);
+                const languageId = this.languageService.guessLanguageIdByFilepathOrFirstLine(textEditorModel.uri);
+                this.addDecoration(linkRange, previewValue ? new MarkdownString().appendCodeblock(languageId ? languageId : '', previewValue) : undefined);
+                ref.dispose();
+            });
+        }
     }
     getPreviewValue(textEditorModel, startLineNumber, result) {
         let rangeToUse = result.range;
@@ -234,12 +220,11 @@
         this.linkDecorations.clear();
     }
     isEnabled(mouseEvent, withKey) {
-        var _a;
         return this.editor.hasModel()
             && mouseEvent.isLeftClick
             && mouseEvent.isNoneOrSingleMouseDown
             && mouseEvent.target.type === 6 /* MouseTargetType.CONTENT_TEXT */
-            && !(((_a = mouseEvent.target.detail.injectedText) === null || _a === void 0 ? void 0 : _a.options) instanceof ModelDecorationInjectedTextOptions)
+            && !(mouseEvent.target.detail.injectedText?.options instanceof ModelDecorationInjectedTextOptions)
             && (mouseEvent.hasTriggerModifier || (withKey ? withKey.keyCodeIsTriggerKey : false))
             && this.languageFeaturesService.definitionProvider.has(this.editor.getModel());
     }
diff -urN -x '*.map' a/vs/editor/contrib/gotoSymbol/browser/peek/referencesController.js b/vs/editor/contrib/gotoSymbol/browser/peek/referencesController.js
--- a/vs/editor/contrib/gotoSymbol/browser/peek/referencesController.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/gotoSymbol/browser/peek/referencesController.js	2023-12-06 14:23:14.379854783 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var ReferencesController_1;
 import { createCancelablePromise } from '../../../../../base/common/async.js';
 import { onUnexpectedError } from '../../../../../base/common/errors.js';
@@ -40,7 +31,7 @@
 import { IStorageService } from '../../../../../platform/storage/common/storage.js';
 import { OneReference } from '../referencesModel.js';
 import { LayoutData, ReferenceWidget } from './referencesWidget.js';
-export const ctxReferenceSearchVisible = new RawContextKey('referenceSearchVisible', false, nls.localize('referenceSearchVisible', "Whether reference peek is visible, like 'Peek References' or 'Peek Definition'"));
+export const ctxReferenceSearchVisible = new RawContextKey('referenceSearchVisible', false, nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/peek/referencesController', 'referenceSearchVisible', "Whether reference peek is visible, like 'Peek References' or 'Peek Definition'"));
 let ReferencesController = ReferencesController_1 = class ReferencesController {
     static get(editor) {
         return editor.getContribution(ReferencesController_1.ID);
@@ -59,11 +50,10 @@
         this._referenceSearchVisible = ctxReferenceSearchVisible.bindTo(contextKeyService);
     }
     dispose() {
-        var _a, _b;
         this._referenceSearchVisible.reset();
         this._disposables.dispose();
-        (_a = this._widget) === null || _a === void 0 ? void 0 : _a.dispose();
-        (_b = this._model) === null || _b === void 0 ? void 0 : _b.dispose();
+        this._widget?.dispose();
+        this._model?.dispose();
         this._widget = undefined;
         this._model = undefined;
     }
@@ -89,7 +79,7 @@
         const storageKey = 'peekViewLayout';
         const data = LayoutData.fromJSON(this._storageService.get(storageKey, 0 /* StorageScope.PROFILE */, '{}'));
         this._widget = this._instantiationService.createInstance(ReferenceWidget, this._editor, this._defaultTreeKeyboardSupport, data);
-        this._widget.setTitle(nls.localize('labelLoading', "Loading..."));
+        this._widget.setTitle(nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/peek/referencesController', 'labelLoading', "Loading..."));
         this._widget.show(range);
         this._disposables.add(this._widget.onDidClose(() => {
             modelPromise.cancel();
@@ -127,20 +117,19 @@
         }));
         const requestId = ++this._requestIdPool;
         modelPromise.then(model => {
-            var _a;
             // still current request? widget still open?
             if (requestId !== this._requestIdPool || !this._widget) {
                 model.dispose();
                 return undefined;
             }
-            (_a = this._model) === null || _a === void 0 ? void 0 : _a.dispose();
+            this._model?.dispose();
             this._model = model;
             // show widget
             return this._widget.setModel(this._model).then(() => {
                 if (this._widget && this._model && this._editor.hasModel()) { // might have been closed
                     // set title
                     if (!this._model.isEmpty) {
-                        this._widget.setMetaTitle(nls.localize('metaTitle.N', "{0} ({1})", this._model.title, this._model.references.length));
+                        this._widget.setMetaTitle(nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/peek/referencesController', 'metaTitle.N', "{0} ({1})", this._model.title, this._model.references.length));
                     }
                     else {
                         this._widget.setMetaTitle('');
@@ -175,46 +164,41 @@
             this._widget.focusOnPreviewEditor();
         }
     }
-    goToNextOrPreviousReference(fwd) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!this._editor.hasModel() || !this._model || !this._widget) {
-                // can be called while still resolving...
-                return;
-            }
-            const currentPosition = this._widget.position;
-            if (!currentPosition) {
-                return;
-            }
-            const source = this._model.nearestReference(this._editor.getModel().uri, currentPosition);
-            if (!source) {
-                return;
-            }
-            const target = this._model.nextOrPreviousReference(source, fwd);
-            const editorFocus = this._editor.hasTextFocus();
-            const previewEditorFocus = this._widget.isPreviewEditorFocused();
-            yield this._widget.setSelection(target);
-            yield this._gotoReference(target, false);
-            if (editorFocus) {
-                this._editor.focus();
-            }
-            else if (this._widget && previewEditorFocus) {
-                this._widget.focusOnPreviewEditor();
-            }
-        });
+    async goToNextOrPreviousReference(fwd) {
+        if (!this._editor.hasModel() || !this._model || !this._widget) {
+            // can be called while still resolving...
+            return;
+        }
+        const currentPosition = this._widget.position;
+        if (!currentPosition) {
+            return;
+        }
+        const source = this._model.nearestReference(this._editor.getModel().uri, currentPosition);
+        if (!source) {
+            return;
+        }
+        const target = this._model.nextOrPreviousReference(source, fwd);
+        const editorFocus = this._editor.hasTextFocus();
+        const previewEditorFocus = this._widget.isPreviewEditorFocused();
+        await this._widget.setSelection(target);
+        await this._gotoReference(target, false);
+        if (editorFocus) {
+            this._editor.focus();
+        }
+        else if (this._widget && previewEditorFocus) {
+            this._widget.focusOnPreviewEditor();
+        }
     }
-    revealReference(reference) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!this._editor.hasModel() || !this._model || !this._widget) {
-                // can be called while still resolving...
-                return;
-            }
-            yield this._widget.revealReference(reference);
-        });
+    async revealReference(reference) {
+        if (!this._editor.hasModel() || !this._model || !this._widget) {
+            // can be called while still resolving...
+            return;
+        }
+        await this._widget.revealReference(reference);
     }
     closeWidget(focusEditor = true) {
-        var _a, _b;
-        (_a = this._widget) === null || _a === void 0 ? void 0 : _a.dispose();
-        (_b = this._model) === null || _b === void 0 ? void 0 : _b.dispose();
+        this._widget?.dispose();
+        this._model?.dispose();
         this._referenceSearchVisible.reset();
         this._disposables.clear();
         this._widget = undefined;
@@ -225,15 +209,13 @@
         this._requestIdPool += 1; // Cancel pending requests
     }
     _gotoReference(ref, pinned) {
-        var _a;
-        (_a = this._widget) === null || _a === void 0 ? void 0 : _a.hide();
+        this._widget?.hide();
         this._ignoreModelChangeEvent = true;
         const range = Range.lift(ref.range).collapseToStart();
         return this._editorService.openCodeEditor({
             resource: ref.uri,
             options: { selection: range, selectionSource: "code.jump" /* TextEditorSelectionSource.JUMP */, pinned }
         }, this._editor).then(openedEditor => {
-            var _a;
             this._ignoreModelChangeEvent = false;
             if (!openedEditor || !this._widget) {
                 // something went wrong...
@@ -252,7 +234,7 @@
                 const model = this._model.clone();
                 this.closeWidget();
                 openedEditor.focus();
-                other === null || other === void 0 ? void 0 : other.toggleWidget(range, createCancelablePromise(_ => Promise.resolve(model)), (_a = this._peekMode) !== null && _a !== void 0 ? _a : false);
+                other?.toggleWidget(range, createCancelablePromise(_ => Promise.resolve(model)), this._peekMode ?? false);
             }
         }, (err) => {
             this._ignoreModelChangeEvent = false;
@@ -356,9 +338,8 @@
     },
     when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey, WorkbenchTreeElementCanCollapse.negate(), WorkbenchTreeElementCanExpand.negate()),
     handler(accessor) {
-        var _a;
         const listService = accessor.get(IListService);
-        const focus = (_a = listService.lastFocusedList) === null || _a === void 0 ? void 0 : _a.getFocus();
+        const focus = listService.lastFocusedList?.getFocus();
         if (Array.isArray(focus) && focus[0] instanceof OneReference) {
             withController(accessor, controller => controller.revealReference(focus[0]));
         }
@@ -373,18 +354,16 @@
     },
     when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey, WorkbenchTreeElementCanCollapse.negate(), WorkbenchTreeElementCanExpand.negate()),
     handler(accessor) {
-        var _a;
         const listService = accessor.get(IListService);
-        const focus = (_a = listService.lastFocusedList) === null || _a === void 0 ? void 0 : _a.getFocus();
+        const focus = listService.lastFocusedList?.getFocus();
         if (Array.isArray(focus) && focus[0] instanceof OneReference) {
             withController(accessor, controller => controller.openReference(focus[0], true, true));
         }
     }
 });
 CommandsRegistry.registerCommand('openReference', (accessor) => {
-    var _a;
     const listService = accessor.get(IListService);
-    const focus = (_a = listService.lastFocusedList) === null || _a === void 0 ? void 0 : _a.getFocus();
+    const focus = listService.lastFocusedList?.getFocus();
     if (Array.isArray(focus) && focus[0] instanceof OneReference) {
         withController(accessor, controller => controller.openReference(focus[0], false, true));
     }
diff -urN -x '*.map' a/vs/editor/contrib/gotoSymbol/browser/peek/referencesTree.js b/vs/editor/contrib/gotoSymbol/browser/peek/referencesTree.js
--- a/vs/editor/contrib/gotoSymbol/browser/peek/referencesTree.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/gotoSymbol/browser/peek/referencesTree.js	2023-12-06 14:23:14.379854783 +0000
@@ -20,7 +20,7 @@
 import { Disposable } from '../../../../../base/common/lifecycle.js';
 import { basename, dirname } from '../../../../../base/common/resources.js';
 import { ITextModelService } from '../../../../common/services/resolverService.js';
-import { localize } from '../../../../../nls.js';
+import { localizeWithPath } from '../../../../../nls.js';
 import { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';
 import { IKeybindingService } from '../../../../../platform/keybinding/common/keybinding.js';
 import { ILabelService } from '../../../../../platform/label/common/label.js';
@@ -79,9 +79,8 @@
         this._keybindingService = _keybindingService;
     }
     getKeyboardNavigationLabel(element) {
-        var _a;
         if (element instanceof OneReference) {
-            const parts = (_a = element.parent.getPreview(element)) === null || _a === void 0 ? void 0 : _a.preview(element.range);
+            const parts = element.parent.getPreview(element)?.preview(element.range);
             if (parts) {
                 return parts.value;
             }
@@ -89,6 +88,9 @@
         // FileReferences or unresolved OneReference
         return basename(element.uri);
     }
+    mightProducePrintableCharacter(event) {
+        return this._keybindingService.mightProducePrintableCharacter(event);
+    }
 };
 StringRepresentationProvider = __decorate([
     __param(0, IKeybindingService)
@@ -116,10 +118,10 @@
         const len = element.children.length;
         this.badge.setCount(len);
         if (len > 1) {
-            this.badge.setTitleFormat(localize('referencesCount', "{0} references", len));
+            this.badge.setTitleFormat(localizeWithPath('vs/editor/contrib/gotoSymbol/browser/peek/referencesTree', 'referencesCount', "{0} references", len));
         }
         else {
-            this.badge.setTitleFormat(localize('referenceCount', "{0} reference", len));
+            this.badge.setTitleFormat(localizeWithPath('vs/editor/contrib/gotoSymbol/browser/peek/referencesTree', 'referenceCount', "{0} reference", len));
         }
     }
 };
@@ -153,8 +155,7 @@
         this.label = new HighlightedLabel(container);
     }
     set(element, score) {
-        var _a;
-        const preview = (_a = element.parent.getPreview(element)) === null || _a === void 0 ? void 0 : _a.preview(element.range);
+        const preview = element.parent.getPreview(element)?.preview(element.range);
         if (!preview || !preview.value) {
             // this means we FAILED to resolve the document or the value is the empty string
             this.label.set(`${basename(element.uri)}:${element.range.startLineNumber + 1}:${element.range.startColumn + 1}`);
@@ -191,7 +192,7 @@
 //#endregion
 export class AccessibilityProvider {
     getWidgetAriaLabel() {
-        return localize('treeAriaLabel', "References");
+        return localizeWithPath('vs/editor/contrib/gotoSymbol/browser/peek/referencesTree', 'treeAriaLabel', "References");
     }
     getAriaLabel(element) {
         return element.ariaMessage;
diff -urN -x '*.map' a/vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget.js b/vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget.js
--- a/vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget.js	2023-12-06 14:23:14.379854783 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import * as dom from '../../../../../base/browser/dom.js';
 import { Sizing, SplitView } from '../../../../../base/browser/ui/splitview/splitview.js';
 import { Color } from '../../../../../base/common/color.js';
@@ -163,7 +154,7 @@
             ratio = data.ratio;
             heightInLines = data.heightInLines;
         }
-        catch (_a) {
+        catch {
             //
         }
         return {
@@ -268,7 +259,7 @@
         };
         this._preview = this._instantiationService.createInstance(EmbeddedCodeEditorWidget, this._previewContainer, options, {}, this.editor);
         dom.hide(this._previewContainer);
-        this._previewNotAvailableMessage = new TextModel(nls.localize('missingPreviewMessage', "no preview available"), PLAINTEXT_LANGUAGE_ID, TextModel.DEFAULT_CREATION_OPTIONS, null, this._undoRedoService, this._languageService, this._languageConfigurationService);
+        this._previewNotAvailableMessage = new TextModel(nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget', 'missingPreviewMessage', "no preview available"), PLAINTEXT_LANGUAGE_ID, TextModel.DEFAULT_CREATION_OPTIONS, null, this._undoRedoService, this._languageService, this._languageConfigurationService);
         // tree
         this._treeContainer = dom.append(containerElement, dom.$('div.ref-tree.inline'));
         const treeOptions = {
@@ -381,7 +372,7 @@
         }
         if (this._model.isEmpty) {
             this.setTitle('');
-            this._messageContainer.innerText = nls.localize('noResults', "No results");
+            this._messageContainer.innerText = nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget', 'noResults', "No results");
             dom.show(this._messageContainer);
             return Promise.resolve(undefined);
         }
@@ -427,59 +418,55 @@
         }
         return undefined;
     }
-    revealReference(reference) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield this._revealReference(reference, false);
-            this._onDidSelectReference.fire({ element: reference, kind: 'goto', source: 'tree' });
-        });
-    }
-    _revealReference(reference, revealParent) {
-        return __awaiter(this, void 0, void 0, function* () {
-            // check if there is anything to do...
-            if (this._revealedReference === reference) {
-                return;
-            }
-            this._revealedReference = reference;
-            // Update widget header
-            if (reference.uri.scheme !== Schemas.inMemory) {
-                this.setTitle(basenameOrAuthority(reference.uri), this._uriLabel.getUriLabel(dirname(reference.uri)));
-            }
-            else {
-                this.setTitle(nls.localize('peekView.alternateTitle', "References"));
-            }
-            const promise = this._textModelResolverService.createModelReference(reference.uri);
-            if (this._tree.getInput() === reference.parent) {
-                this._tree.reveal(reference);
-            }
-            else {
-                if (revealParent) {
-                    this._tree.reveal(reference.parent);
-                }
-                yield this._tree.expand(reference.parent);
-                this._tree.reveal(reference);
-            }
-            const ref = yield promise;
-            if (!this._model) {
-                // disposed
-                ref.dispose();
-                return;
-            }
-            dispose(this._previewModelReference);
-            // show in editor
-            const model = ref.object;
-            if (model) {
-                const scrollType = this._preview.getModel() === model.textEditorModel ? 0 /* ScrollType.Smooth */ : 1 /* ScrollType.Immediate */;
-                const sel = Range.lift(reference.range).collapseToStart();
-                this._previewModelReference = ref;
-                this._preview.setModel(model.textEditorModel);
-                this._preview.setSelection(sel);
-                this._preview.revealRangeInCenter(sel, scrollType);
-            }
-            else {
-                this._preview.setModel(this._previewNotAvailableMessage);
-                ref.dispose();
+    async revealReference(reference) {
+        await this._revealReference(reference, false);
+        this._onDidSelectReference.fire({ element: reference, kind: 'goto', source: 'tree' });
+    }
+    async _revealReference(reference, revealParent) {
+        // check if there is anything to do...
+        if (this._revealedReference === reference) {
+            return;
+        }
+        this._revealedReference = reference;
+        // Update widget header
+        if (reference.uri.scheme !== Schemas.inMemory) {
+            this.setTitle(basenameOrAuthority(reference.uri), this._uriLabel.getUriLabel(dirname(reference.uri)));
+        }
+        else {
+            this.setTitle(nls.localizeWithPath('vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget', 'peekView.alternateTitle', "References"));
+        }
+        const promise = this._textModelResolverService.createModelReference(reference.uri);
+        if (this._tree.getInput() === reference.parent) {
+            this._tree.reveal(reference);
+        }
+        else {
+            if (revealParent) {
+                this._tree.reveal(reference.parent);
             }
-        });
+            await this._tree.expand(reference.parent);
+            this._tree.reveal(reference);
+        }
+        const ref = await promise;
+        if (!this._model) {
+            // disposed
+            ref.dispose();
+            return;
+        }
+        dispose(this._previewModelReference);
+        // show in editor
+        const model = ref.object;
+        if (model) {
+            const scrollType = this._preview.getModel() === model.textEditorModel ? 0 /* ScrollType.Smooth */ : 1 /* ScrollType.Immediate */;
+            const sel = Range.lift(reference.range).collapseToStart();
+            this._previewModelReference = ref;
+            this._preview.setModel(model.textEditorModel);
+            this._preview.setSelection(sel);
+            this._preview.revealRangeInCenter(sel, scrollType);
+        }
+        else {
+            this._preview.setModel(this._previewNotAvailableMessage);
+            ref.dispose();
+        }
     }
 };
 ReferenceWidget = __decorate([
diff -urN -x '*.map' a/vs/editor/contrib/gotoSymbol/browser/referencesModel.js b/vs/editor/contrib/gotoSymbol/browser/referencesModel.js
--- a/vs/editor/contrib/gotoSymbol/browser/referencesModel.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/gotoSymbol/browser/referencesModel.js	2023-12-06 14:23:14.379854783 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { onUnexpectedError } from '../../../../base/common/errors.js';
 import { Emitter } from '../../../../base/common/event.js';
 import { defaultGenerator } from '../../../../base/common/idGenerator.js';
@@ -19,7 +10,7 @@
 import { basename, extUri } from '../../../../base/common/resources.js';
 import * as strings from '../../../../base/common/strings.js';
 import { Range } from '../../../common/core/range.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 export class OneReference {
     constructor(isProviderFirst, parent, link, _rangeCallback) {
         this.isProviderFirst = isProviderFirst;
@@ -32,21 +23,19 @@
         return this.link.uri;
     }
     get range() {
-        var _a, _b;
-        return (_b = (_a = this._range) !== null && _a !== void 0 ? _a : this.link.targetSelectionRange) !== null && _b !== void 0 ? _b : this.link.range;
+        return this._range ?? this.link.targetSelectionRange ?? this.link.range;
     }
     set range(value) {
         this._range = value;
         this._rangeCallback(this);
     }
     get ariaMessage() {
-        var _a;
-        const preview = (_a = this.parent.getPreview(this)) === null || _a === void 0 ? void 0 : _a.preview(this.range);
+        const preview = this.parent.getPreview(this)?.preview(this.range);
         if (!preview) {
-            return localize('aria.oneReference', "in {0} on line {1} at column {2}", basename(this.uri), this.range.startLineNumber, this.range.startColumn);
+            return localizeWithPath('vs/editor/contrib/gotoSymbol/browser/referencesModel', 'aria.oneReference', "in {0} on line {1} at column {2}", basename(this.uri), this.range.startLineNumber, this.range.startColumn);
         }
         else {
-            return localize({ key: 'aria.oneReference.preview', comment: ['Placeholders are: 0: filename, 1:line number, 2: column number, 3: preview snippet of source code'] }, "{0} in {1} on line {2} at column {3}", preview.value, basename(this.uri), this.range.startLineNumber, this.range.startColumn);
+            return localizeWithPath('vs/editor/contrib/gotoSymbol/browser/referencesModel', { key: 'aria.oneReference.preview', comment: ['Placeholders are: 0: filename, 1:line number, 2: column number, 3: preview snippet of source code'] }, "{0} in {1} on line {2} at column {3}", preview.value, basename(this.uri), this.range.startLineNumber, this.range.startColumn);
         }
     }
 }
@@ -92,31 +81,29 @@
     get ariaMessage() {
         const len = this.children.length;
         if (len === 1) {
-            return localize('aria.fileReferences.1', "1 symbol in {0}, full path {1}", basename(this.uri), this.uri.fsPath);
+            return localizeWithPath('vs/editor/contrib/gotoSymbol/browser/referencesModel', 'aria.fileReferences.1', "1 symbol in {0}, full path {1}", basename(this.uri), this.uri.fsPath);
         }
         else {
-            return localize('aria.fileReferences.N', "{0} symbols in {1}, full path {2}", len, basename(this.uri), this.uri.fsPath);
+            return localizeWithPath('vs/editor/contrib/gotoSymbol/browser/referencesModel', 'aria.fileReferences.N', "{0} symbols in {1}, full path {2}", len, basename(this.uri), this.uri.fsPath);
         }
     }
-    resolve(textModelResolverService) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (this._previews.size !== 0) {
-                return this;
+    async resolve(textModelResolverService) {
+        if (this._previews.size !== 0) {
+            return this;
+        }
+        for (const child of this.children) {
+            if (this._previews.has(child.uri)) {
+                continue;
             }
-            for (const child of this.children) {
-                if (this._previews.has(child.uri)) {
-                    continue;
-                }
-                try {
-                    const ref = yield textModelResolverService.createModelReference(child.uri);
-                    this._previews.set(child.uri, new FilePreview(ref));
-                }
-                catch (err) {
-                    onUnexpectedError(err);
-                }
+            try {
+                const ref = await textModelResolverService.createModelReference(child.uri);
+                this._previews.set(child.uri, new FilePreview(ref));
             }
-            return this;
-        });
+            catch (err) {
+                onUnexpectedError(err);
+            }
+        }
+        return this;
     }
 }
 export class ReferencesModel {
@@ -161,16 +148,16 @@
     }
     get ariaMessage() {
         if (this.isEmpty) {
-            return localize('aria.result.0', "No results found");
+            return localizeWithPath('vs/editor/contrib/gotoSymbol/browser/referencesModel', 'aria.result.0', "No results found");
         }
         else if (this.references.length === 1) {
-            return localize('aria.result.1', "Found 1 symbol in {0}", this.references[0].uri.fsPath);
+            return localizeWithPath('vs/editor/contrib/gotoSymbol/browser/referencesModel', 'aria.result.1', "Found 1 symbol in {0}", this.references[0].uri.fsPath);
         }
         else if (this.groups.length === 1) {
-            return localize('aria.result.n1', "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath);
+            return localizeWithPath('vs/editor/contrib/gotoSymbol/browser/referencesModel', 'aria.result.n1', "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath);
         }
         else {
-            return localize('aria.result.nm', "Found {0} symbols in {1} files", this.references.length, this.groups.length);
+            return localizeWithPath('vs/editor/contrib/gotoSymbol/browser/referencesModel', 'aria.result.nm', "Found {0} symbols in {1} files", this.references.length, this.groups.length);
         }
     }
     nextOrPreviousReference(reference, next) {
diff -urN -x '*.map' a/vs/editor/contrib/gotoSymbol/browser/symbolNavigation.js b/vs/editor/contrib/gotoSymbol/browser/symbolNavigation.js
--- a/vs/editor/contrib/gotoSymbol/browser/symbolNavigation.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/gotoSymbol/browser/symbolNavigation.js	2023-12-06 14:23:14.379854783 +0000
@@ -17,14 +17,14 @@
 import { EditorCommand, registerEditorCommand } from '../../../browser/editorExtensions.js';
 import { ICodeEditorService } from '../../../browser/services/codeEditorService.js';
 import { Range } from '../../../common/core/range.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';
 import { registerSingleton } from '../../../../platform/instantiation/common/extensions.js';
 import { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';
 import { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';
 import { KeybindingsRegistry } from '../../../../platform/keybinding/common/keybindingsRegistry.js';
 import { INotificationService } from '../../../../platform/notification/common/notification.js';
-export const ctxHasSymbols = new RawContextKey('hasSymbols', false, localize('hasSymbols', "Whether there are symbol locations that can be navigated via keyboard-only."));
+export const ctxHasSymbols = new RawContextKey('hasSymbols', false, localizeWithPath('vs/editor/contrib/gotoSymbol/browser/symbolNavigation', 'hasSymbols', "Whether there are symbol locations that can be navigated via keyboard-only."));
 export const ISymbolNavigationService = createDecorator('ISymbolNavigationService');
 let SymbolNavigationService = class SymbolNavigationService {
     constructor(contextKeyService, _editorService, _notificationService, _keybindingService) {
@@ -37,10 +37,9 @@
         this._ctxHasSymbols = ctxHasSymbols.bindTo(contextKeyService);
     }
     reset() {
-        var _a, _b;
         this._ctxHasSymbols.reset();
-        (_a = this._currentState) === null || _a === void 0 ? void 0 : _a.dispose();
-        (_b = this._currentMessage) === null || _b === void 0 ? void 0 : _b.dispose();
+        this._currentState?.dispose();
+        this._currentMessage?.dispose();
         this._currentModel = undefined;
         this._currentIdx = -1;
     }
@@ -108,12 +107,11 @@
         });
     }
     _showMessage() {
-        var _a;
-        (_a = this._currentMessage) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._currentMessage?.dispose();
         const kb = this._keybindingService.lookupKeybinding('editor.gotoNextSymbolFromResult');
         const message = kb
-            ? localize('location.kb', "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, kb.getLabel())
-            : localize('location', "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
+            ? localizeWithPath('vs/editor/contrib/gotoSymbol/browser/symbolNavigation', 'location.kb', "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, kb.getLabel())
+            : localizeWithPath('vs/editor/contrib/gotoSymbol/browser/symbolNavigation', 'location', "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
         this._currentMessage = this._notificationService.status(message);
     }
 };
@@ -168,8 +166,7 @@
         this._listener.set(editor, combinedDisposable(editor.onDidChangeCursorPosition(_ => this._onDidChange.fire({ editor })), editor.onDidChangeModelContent(_ => this._onDidChange.fire({ editor }))));
     }
     _onDidRemoveEditor(editor) {
-        var _a;
-        (_a = this._listener.get(editor)) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._listener.get(editor)?.dispose();
         this._listener.delete(editor);
     }
 };
diff -urN -x '*.map' a/vs/editor/contrib/hover/browser/contentHover.js b/vs/editor/contrib/hover/browser/contentHover.js
--- a/vs/editor/contrib/hover/browser/contentHover.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/hover/browser/contentHover.js	2023-12-06 14:23:14.379854783 +0000
@@ -32,6 +32,13 @@
 import { IAccessibilityService } from '../../../../platform/accessibility/common/accessibility.js';
 const $ = dom.$;
 let ContentHoverController = ContentHoverController_1 = class ContentHoverController extends Disposable {
+    getWidgetContent() {
+        const node = this._widget.getDomNode();
+        if (!node.textContent) {
+            return undefined;
+        }
+        return node.textContent;
+    }
     constructor(_editor, _instantiationService, _keybindingService) {
         super();
         this._editor = _editor;
@@ -378,20 +385,16 @@
 const CONTAINER_HEIGHT_PADDING = 6;
 let ContentHoverWidget = ContentHoverWidget_1 = class ContentHoverWidget extends ResizableContentWidget {
     get isColorPickerVisible() {
-        var _a;
-        return Boolean((_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.colorPicker);
+        return Boolean(this._visibleData?.colorPicker);
     }
     get isVisibleFromKeyboard() {
-        var _a;
-        return (((_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.source) === 1 /* HoverStartSource.Keyboard */);
+        return (this._visibleData?.source === 1 /* HoverStartSource.Keyboard */);
     }
     get isVisible() {
-        var _a;
-        return (_a = this._hoverVisibleKey.get()) !== null && _a !== void 0 ? _a : false;
+        return this._hoverVisibleKey.get() ?? false;
     }
     get isFocused() {
-        var _a;
-        return (_a = this._hoverFocusedKey.get()) !== null && _a !== void 0 ? _a : false;
+        return this._hoverFocusedKey.get() ?? false;
     }
     constructor(editor, contextKeyService, _configurationService, _accessibilityService, _keybindingService) {
         const minimumHeight = editor.getOption(66 /* EditorOption.lineHeight */) + 8;
@@ -425,9 +428,8 @@
         this._editor.addContentWidget(this);
     }
     dispose() {
-        var _a;
         super.dispose();
-        (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.disposables.dispose();
+        this._visibleData?.disposables.dispose();
         this._editor.removeContentWidget(this);
     }
     getId() {
@@ -488,25 +490,22 @@
         }
     }
     _updateResizableNodeMaxDimensions() {
-        var _a, _b;
-        const maxRenderingWidth = (_a = this._findMaximumRenderingWidth()) !== null && _a !== void 0 ? _a : Infinity;
-        const maxRenderingHeight = (_b = this._findMaximumRenderingHeight()) !== null && _b !== void 0 ? _b : Infinity;
+        const maxRenderingWidth = this._findMaximumRenderingWidth() ?? Infinity;
+        const maxRenderingHeight = this._findMaximumRenderingHeight() ?? Infinity;
         this._resizableNode.maxSize = new dom.Dimension(maxRenderingWidth, maxRenderingHeight);
         this._setHoverWidgetMaxDimensions(maxRenderingWidth, maxRenderingHeight);
     }
     _resize(size) {
-        var _a, _b;
         ContentHoverWidget_1._lastDimensions = new dom.Dimension(size.width, size.height);
         this._setAdjustedHoverWidgetDimensions(size);
         this._resizableNode.layout(size.height, size.width);
         this._updateResizableNodeMaxDimensions();
         this._hover.scrollbar.scanDomNode();
         this._editor.layoutContentWidget(this);
-        (_b = (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.colorPicker) === null || _b === void 0 ? void 0 : _b.layout();
+        this._visibleData?.colorPicker?.layout();
     }
     _findAvailableSpaceVertically() {
-        var _a;
-        const position = (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.showAtPosition;
+        const position = this._visibleData?.showAtPosition;
         if (!position) {
             return;
         }
@@ -578,8 +577,7 @@
         return true;
     }
     _setHoverData(hoverData) {
-        var _a;
-        (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.disposables.dispose();
+        this._visibleData?.disposables.dispose();
         this._visibleData = hoverData;
         this._hoverVisibleKey.set(!!hoverData);
         this._hover.containerDomNode.classList.toggle('hidden', !hoverData);
@@ -621,7 +619,6 @@
         this._editor.render();
     }
     getPosition() {
-        var _a;
         if (!this._visibleData) {
             return null;
         }
@@ -629,27 +626,26 @@
             position: this._visibleData.showAtPosition,
             secondaryPosition: this._visibleData.showAtSecondaryPosition,
             positionAffinity: this._visibleData.isBeforeContent ? 3 /* PositionAffinity.LeftOfInjectedText */ : undefined,
-            preference: [(_a = this._positionPreference) !== null && _a !== void 0 ? _a : 1 /* ContentWidgetPositionPreference.ABOVE */]
+            preference: [this._positionPreference ?? 1 /* ContentWidgetPositionPreference.ABOVE */]
         };
     }
     showAt(node, hoverData) {
-        var _a, _b, _c, _d;
         if (!this._editor || !this._editor.hasModel()) {
             return;
         }
         this._render(node, hoverData);
         const widgetHeight = dom.getTotalHeight(this._hover.containerDomNode);
         const widgetPosition = hoverData.showAtPosition;
-        this._positionPreference = (_a = this._findPositionPreference(widgetHeight, widgetPosition)) !== null && _a !== void 0 ? _a : 1 /* ContentWidgetPositionPreference.ABOVE */;
+        this._positionPreference = this._findPositionPreference(widgetHeight, widgetPosition) ?? 1 /* ContentWidgetPositionPreference.ABOVE */;
         // See https://github.com/microsoft/vscode/issues/140339
         // TODO: Doing a second layout of the hover after force rendering the editor
         this.onContentsChanged();
         if (hoverData.stoleFocus) {
             this._hover.containerDomNode.focus();
         }
-        (_b = hoverData.colorPicker) === null || _b === void 0 ? void 0 : _b.layout();
+        hoverData.colorPicker?.layout();
         // The aria label overrides the label, so if we add to it, add the contents of the hover
-        const accessibleViewHint = getHoverAccessibleViewHint(this._configurationService.getValue('accessibility.verbosity.hover') === true && this._accessibilityService.isScreenReaderOptimized(), (_d = (_c = this._keybindingService.lookupKeybinding('editor.action.accessibleView')) === null || _c === void 0 ? void 0 : _c.getAriaLabel()) !== null && _d !== void 0 ? _d : '');
+        const accessibleViewHint = getHoverAccessibleViewHint(this._configurationService.getValue('accessibility.verbosity.hover') === true && this._accessibilityService.isScreenReaderOptimized(), this._keybindingService.lookupKeybinding('editor.action.accessibleView')?.getAriaLabel() ?? '');
         if (accessibleViewHint) {
             this._hover.contentsDomNode.ariaLabel = this._hover.contentsDomNode.textContent + ', ' + accessibleViewHint;
         }
@@ -675,10 +671,9 @@
         this._setHoverWidgetDimensions('auto', 'auto');
     }
     _adjustHoverHeightForScrollbar(height) {
-        var _a;
         const containerDomNode = this._hover.containerDomNode;
         const contentsDomNode = this._hover.contentsDomNode;
-        const maxRenderingHeight = (_a = this._findMaximumRenderingHeight()) !== null && _a !== void 0 ? _a : Infinity;
+        const maxRenderingHeight = this._findMaximumRenderingHeight() ?? Infinity;
         this._setContainerDomNodeDimensions(dom.getTotalWidth(containerDomNode), Math.min(maxRenderingHeight, height));
         this._setContentsDomNodeDimensions(dom.getTotalWidth(contentsDomNode), Math.min(maxRenderingHeight, height - SCROLLBAR_WIDTH));
     }
@@ -695,7 +690,6 @@
         this._resizableNode.minSize = new dom.Dimension(width, this._minimumSize.height);
     }
     onContentsChanged() {
-        var _a;
         this._removeConstraintsRenderNormally();
         const containerDomNode = this._hover.containerDomNode;
         let height = dom.getTotalHeight(containerDomNode);
@@ -711,7 +705,7 @@
             this._adjustContentsBottomPadding();
             this._adjustHoverHeightForScrollbar(height);
         }
-        if ((_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.showAtPosition) {
+        if (this._visibleData?.showAtPosition) {
             const widgetHeight = dom.getTotalHeight(this._hover.containerDomNode);
             this._positionPreference = this._findPositionPreference(widgetHeight, this._visibleData.showAtPosition);
         }
diff -urN -x '*.map' a/vs/editor/contrib/hover/browser/getHover.js b/vs/editor/contrib/hover/browser/getHover.js
--- a/vs/editor/contrib/hover/browser/getHover.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/hover/browser/getHover.js	2023-12-06 14:23:14.379854783 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { AsyncIterableObject } from '../../../../base/common/async.js';
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { onUnexpectedExternalError } from '../../../../base/common/errors.js';
@@ -23,19 +14,17 @@
         this.ordinal = ordinal;
     }
 }
-function executeProvider(provider, ordinal, model, position, token) {
-    return __awaiter(this, void 0, void 0, function* () {
-        try {
-            const result = yield Promise.resolve(provider.provideHover(model, position, token));
-            if (result && isValid(result)) {
-                return new HoverProviderResult(provider, result, ordinal);
-            }
+async function executeProvider(provider, ordinal, model, position, token) {
+    try {
+        const result = await Promise.resolve(provider.provideHover(model, position, token));
+        if (result && isValid(result)) {
+            return new HoverProviderResult(provider, result, ordinal);
         }
-        catch (err) {
-            onUnexpectedExternalError(err);
-        }
-        return undefined;
-    });
+    }
+    catch (err) {
+        onUnexpectedExternalError(err);
+    }
+    return undefined;
 }
 export function getHover(registry, model, position, token) {
     const providers = registry.ordered(model);
diff -urN -x '*.map' a/vs/editor/contrib/hover/browser/hover.js b/vs/editor/contrib/hover/browser/hover.js
--- a/vs/editor/contrib/hover/browser/hover.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/hover/browser/hover.js	2023-12-06 14:23:14.379854783 +0000
@@ -36,6 +36,7 @@
 // sticky hover widget which doesn't disappear on focus out and such
 const _sticky = false;
 let ModesHoverController = ModesHoverController_1 = class ModesHoverController extends Disposable {
+    getWidgetContent() { return this._contentWidget?.getWidgetContent(); }
     static get(editor) {
         return editor.getContribution(ModesHoverController_1.ID);
     }
@@ -94,7 +95,6 @@
         }
     }
     _onEditorMouseDown(mouseEvent) {
-        var _a;
         this._isMouseDown = true;
         const target = mouseEvent.target;
         if (target.type === 9 /* MouseTargetType.CONTENT_WIDGET */ && target.detail === ContentHoverWidget.ID) {
@@ -109,7 +109,7 @@
         if (target.type !== 12 /* MouseTargetType.OVERLAY_WIDGET */) {
             this._hoverClicked = false;
         }
-        if (!((_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.widget.isResizing)) {
+        if (!this._contentWidget?.widget.isResizing) {
             this._hideWidgets();
         }
     }
@@ -117,9 +117,8 @@
         this._isMouseDown = false;
     }
     _onEditorMouseLeave(mouseEvent) {
-        var _a, _b;
         const targetEm = (mouseEvent.event.browserEvent.relatedTarget);
-        if (((_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.widget.isResizing) || ((_b = this._contentWidget) === null || _b === void 0 ? void 0 : _b.containsNode(targetEm))) {
+        if (this._contentWidget?.widget.isResizing || this._contentWidget?.containsNode(targetEm)) {
             // When the content widget is resizing
             // when the mouse is inside hover widget
             return;
@@ -129,7 +128,6 @@
         }
     }
     _isMouseOverWidget(mouseEvent) {
-        var _a, _b, _c, _d, _e;
         const target = mouseEvent.target;
         if (this._isHoverSticky
             && target.type === 9 /* MouseTargetType.CONTENT_WIDGET */
@@ -138,15 +136,15 @@
             return true;
         }
         if (this._isHoverSticky
-            && ((_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.containsNode((_b = mouseEvent.event.browserEvent.view) === null || _b === void 0 ? void 0 : _b.document.activeElement))
-            && !((_d = (_c = mouseEvent.event.browserEvent.view) === null || _c === void 0 ? void 0 : _c.getSelection()) === null || _d === void 0 ? void 0 : _d.isCollapsed)) {
+            && this._contentWidget?.containsNode(mouseEvent.event.browserEvent.view?.document.activeElement)
+            && !mouseEvent.event.browserEvent.view?.getSelection()?.isCollapsed) {
             // selected text within content hover widget
             return true;
         }
         if (!this._isHoverSticky
             && target.type === 9 /* MouseTargetType.CONTENT_WIDGET */
             && target.detail === ContentHoverWidget.ID
-            && ((_e = this._contentWidget) === null || _e === void 0 ? void 0 : _e.isColorPickerVisible)) {
+            && this._contentWidget?.isColorPickerVisible) {
             // though the hover is not sticky, the color picker needs to.
             return true;
         }
@@ -159,15 +157,14 @@
         return false;
     }
     _onEditorMouseMove(mouseEvent) {
-        var _a, _b, _c, _d;
         this._mouseMoveEvent = mouseEvent;
-        if (((_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.isFocused) || ((_b = this._contentWidget) === null || _b === void 0 ? void 0 : _b.isResizing)) {
+        if (this._contentWidget?.isFocused || this._contentWidget?.isResizing) {
             return;
         }
         if (this._isMouseDown && this._hoverClicked) {
             return;
         }
-        if (this._isHoverSticky && ((_c = this._contentWidget) === null || _c === void 0 ? void 0 : _c.isVisibleFromKeyboard)) {
+        if (this._isHoverSticky && this._contentWidget?.isVisibleFromKeyboard) {
             // Sticky mode is on and the hover has been shown via keyboard
             // so moving the mouse has no effect
             return;
@@ -180,7 +177,7 @@
         }
         // If the mouse is not over the widget, and if sticky is on,
         // then give it a grace period before reacting to the mouse event
-        if (((_d = this._contentWidget) === null || _d === void 0 ? void 0 : _d.isVisible) && this._isHoverSticky && this._hidingDelay > 0) {
+        if (this._contentWidget?.isVisible && this._isHoverSticky && this._hidingDelay > 0) {
             if (!this._reactToEditorMouseMoveRunner.isScheduled()) {
                 this._reactToEditorMouseMoveRunner.schedule(this._hidingDelay);
             }
@@ -189,12 +186,11 @@
         this._reactToEditorMouseMove(mouseEvent);
     }
     _reactToEditorMouseMove(mouseEvent) {
-        var _a, _b, _c;
         if (!mouseEvent) {
             return;
         }
         const target = mouseEvent.target;
-        const mouseOnDecorator = (_a = target.element) === null || _a === void 0 ? void 0 : _a.classList.contains('colorpicker-color-decoration');
+        const mouseOnDecorator = target.element?.classList.contains('colorpicker-color-decoration');
         const decoratorActivatedOn = this._editor.getOption(146 /* EditorOption.colorDecoratorsActivatedOn */);
         if ((mouseOnDecorator && ((decoratorActivatedOn === 'click' && !this._hoverActivatedByColorDecoratorClick) ||
             (decoratorActivatedOn === 'hover' && !this._isHoverEnabled && !_sticky) ||
@@ -205,11 +201,11 @@
         }
         const contentWidget = this._getOrCreateContentWidget();
         if (contentWidget.maybeShowAt(mouseEvent)) {
-            (_b = this._glyphWidget) === null || _b === void 0 ? void 0 : _b.hide();
+            this._glyphWidget?.hide();
             return;
         }
         if (target.type === 2 /* MouseTargetType.GUTTER_GLYPH_MARGIN */ && target.position) {
-            (_c = this._contentWidget) === null || _c === void 0 ? void 0 : _c.hide();
+            this._contentWidget?.hide();
             if (!this._glyphWidget) {
                 this._glyphWidget = new MarginHoverWidget(this._editor, this._languageService, this._openerService);
             }
@@ -222,13 +218,12 @@
         this._hideWidgets();
     }
     _onKeyDown(e) {
-        var _a;
         if (!this._editor.hasModel()) {
             return;
         }
         const resolvedKeyboardEvent = this._keybindingService.softDispatch(e, this._editor.getDomNode());
         // If the beginning of a multi-chord keybinding is pressed, or the command aims to focus the hover, set the variable to true, otherwise false
-        const mightTriggerFocus = (resolvedKeyboardEvent.kind === 1 /* ResultKind.MoreChordsNeeded */ || (resolvedKeyboardEvent.kind === 2 /* ResultKind.KbFound */ && resolvedKeyboardEvent.commandId === 'editor.action.showHover' && ((_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.isVisible)));
+        const mightTriggerFocus = (resolvedKeyboardEvent.kind === 1 /* ResultKind.MoreChordsNeeded */ || (resolvedKeyboardEvent.kind === 2 /* ResultKind.KbFound */ && resolvedKeyboardEvent.commandId === 'editor.action.showHover' && this._contentWidget?.isVisible));
         if (e.keyCode !== 5 /* KeyCode.Ctrl */ && e.keyCode !== 6 /* KeyCode.Alt */ && e.keyCode !== 57 /* KeyCode.Meta */ && e.keyCode !== 4 /* KeyCode.Shift */
             && !mightTriggerFocus) {
             // Do not hide hover when a modifier key is pressed
@@ -236,17 +231,16 @@
         }
     }
     _hideWidgets() {
-        var _a, _b, _c;
         if (_sticky) {
             return;
         }
-        if ((this._isMouseDown && this._hoverClicked && ((_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.isColorPickerVisible)) || InlineSuggestionHintsContentWidget.dropDownVisible) {
+        if ((this._isMouseDown && this._hoverClicked && this._contentWidget?.isColorPickerVisible) || InlineSuggestionHintsContentWidget.dropDownVisible) {
             return;
         }
         this._hoverActivatedByColorDecoratorClick = false;
         this._hoverClicked = false;
-        (_b = this._glyphWidget) === null || _b === void 0 ? void 0 : _b.hide();
-        (_c = this._contentWidget) === null || _c === void 0 ? void 0 : _c.hide();
+        this._glyphWidget?.hide();
+        this._contentWidget?.hide();
     }
     _getOrCreateContentWidget() {
         if (!this._contentWidget) {
@@ -259,56 +253,44 @@
         this._getOrCreateContentWidget().startShowingAtRange(range, mode, source, focus);
     }
     focus() {
-        var _a;
-        (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.focus();
+        this._contentWidget?.focus();
     }
     scrollUp() {
-        var _a;
-        (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.scrollUp();
+        this._contentWidget?.scrollUp();
     }
     scrollDown() {
-        var _a;
-        (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.scrollDown();
+        this._contentWidget?.scrollDown();
     }
     scrollLeft() {
-        var _a;
-        (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.scrollLeft();
+        this._contentWidget?.scrollLeft();
     }
     scrollRight() {
-        var _a;
-        (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.scrollRight();
+        this._contentWidget?.scrollRight();
     }
     pageUp() {
-        var _a;
-        (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.pageUp();
+        this._contentWidget?.pageUp();
     }
     pageDown() {
-        var _a;
-        (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.pageDown();
+        this._contentWidget?.pageDown();
     }
     goToTop() {
-        var _a;
-        (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.goToTop();
+        this._contentWidget?.goToTop();
     }
     goToBottom() {
-        var _a;
-        (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.goToBottom();
+        this._contentWidget?.goToBottom();
     }
     get isColorPickerVisible() {
-        var _a;
-        return (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.isColorPickerVisible;
+        return this._contentWidget?.isColorPickerVisible;
     }
     get isHoverVisible() {
-        var _a;
-        return (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.isVisible;
+        return this._contentWidget?.isVisible;
     }
     dispose() {
-        var _a, _b;
         super.dispose();
         this._unhookEvents();
         this._toUnhook.dispose();
-        (_a = this._glyphWidget) === null || _a === void 0 ? void 0 : _a.dispose();
-        (_b = this._contentWidget) === null || _b === void 0 ? void 0 : _b.dispose();
+        this._glyphWidget?.dispose();
+        this._contentWidget?.dispose();
     }
 };
 ModesHoverController.ID = 'editor.contrib.hover';
@@ -323,7 +305,7 @@
     constructor() {
         super({
             id: 'editor.action.showHover',
-            label: nls.localize({
+            label: nls.localizeWithPath('vs/editor/contrib/hover/browser/hover', {
                 key: 'showOrFocusHover',
                 comment: [
                     'Label for action that will trigger the showing/focusing of a hover in the editor.',
@@ -367,7 +349,7 @@
         }
         const position = editor.getPosition();
         const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
-        const focus = editor.getOption(2 /* EditorOption.accessibilitySupport */) === 2 /* AccessibilitySupport.Enabled */ || !!(args === null || args === void 0 ? void 0 : args.focus);
+        const focus = editor.getOption(2 /* EditorOption.accessibilitySupport */) === 2 /* AccessibilitySupport.Enabled */ || !!args?.focus;
         if (controller.isHoverVisible) {
             controller.focus();
         }
@@ -380,7 +362,7 @@
     constructor() {
         super({
             id: 'editor.action.showDefinitionPreviewHover',
-            label: nls.localize({
+            label: nls.localizeWithPath('vs/editor/contrib/hover/browser/hover', {
                 key: 'showDefinitionPreviewHover',
                 comment: [
                     'Label for action that will trigger the showing of definition preview hover in the editor.',
@@ -415,7 +397,7 @@
     constructor() {
         super({
             id: 'editor.action.scrollUpHover',
-            label: nls.localize({
+            label: nls.localizeWithPath('vs/editor/contrib/hover/browser/hover', {
                 key: 'scrollUpHover',
                 comment: [
                     'Action that allows to scroll up in the hover widget with the up arrow when the hover widget is focused.'
@@ -442,7 +424,7 @@
     constructor() {
         super({
             id: 'editor.action.scrollDownHover',
-            label: nls.localize({
+            label: nls.localizeWithPath('vs/editor/contrib/hover/browser/hover', {
                 key: 'scrollDownHover',
                 comment: [
                     'Action that allows to scroll down in the hover widget with the up arrow when the hover widget is focused.'
@@ -469,7 +451,7 @@
     constructor() {
         super({
             id: 'editor.action.scrollLeftHover',
-            label: nls.localize({
+            label: nls.localizeWithPath('vs/editor/contrib/hover/browser/hover', {
                 key: 'scrollLeftHover',
                 comment: [
                     'Action that allows to scroll left in the hover widget with the left arrow when the hover widget is focused.'
@@ -496,7 +478,7 @@
     constructor() {
         super({
             id: 'editor.action.scrollRightHover',
-            label: nls.localize({
+            label: nls.localizeWithPath('vs/editor/contrib/hover/browser/hover', {
                 key: 'scrollRightHover',
                 comment: [
                     'Action that allows to scroll right in the hover widget with the right arrow when the hover widget is focused.'
@@ -523,7 +505,7 @@
     constructor() {
         super({
             id: 'editor.action.pageUpHover',
-            label: nls.localize({
+            label: nls.localizeWithPath('vs/editor/contrib/hover/browser/hover', {
                 key: 'pageUpHover',
                 comment: [
                     'Action that allows to page up in the hover widget with the page up command when the hover widget is focused.'
@@ -551,7 +533,7 @@
     constructor() {
         super({
             id: 'editor.action.pageDownHover',
-            label: nls.localize({
+            label: nls.localizeWithPath('vs/editor/contrib/hover/browser/hover', {
                 key: 'pageDownHover',
                 comment: [
                     'Action that allows to page down in the hover widget with the page down command when the hover widget is focused.'
@@ -579,7 +561,7 @@
     constructor() {
         super({
             id: 'editor.action.goToTopHover',
-            label: nls.localize({
+            label: nls.localizeWithPath('vs/editor/contrib/hover/browser/hover', {
                 key: 'goToTopHover',
                 comment: [
                     'Action that allows to go to the top of the hover widget with the home command when the hover widget is focused.'
@@ -607,7 +589,7 @@
     constructor() {
         super({
             id: 'editor.action.goToBottomHover',
-            label: nls.localize({
+            label: nls.localizeWithPath('vs/editor/contrib/hover/browser/hover', {
                 key: 'goToBottomHover',
                 comment: [
                     'Action that allows to go to the bottom in the hover widget with the end command when the hover widget is focused.'
diff -urN -x '*.map' a/vs/editor/contrib/hover/browser/hoverOperation.js b/vs/editor/contrib/hover/browser/hoverOperation.js
--- a/vs/editor/contrib/hover/browser/hoverOperation.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/hover/browser/hoverOperation.js	2023-12-06 14:23:14.379854783 +0000
@@ -2,22 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __asyncValues = (this && this.__asyncValues) || function (o) {
-    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
-    var m = o[Symbol.asyncIterator], i;
-    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
-    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
-    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
-};
 import { createCancelableAsyncIterable, RunOnceScheduler } from '../../../../base/common/async.js';
 import { onUnexpectedError } from '../../../../base/common/errors.js';
 import { Emitter } from '../../../../base/common/event.js';
@@ -85,27 +69,14 @@
         if (this._computer.computeAsync) {
             this._asyncIterableDone = false;
             this._asyncIterable = createCancelableAsyncIterable(token => this._computer.computeAsync(token));
-            (() => __awaiter(this, void 0, void 0, function* () {
-                var _a, e_1, _b, _c;
+            (async () => {
                 try {
-                    try {
-                        for (var _d = true, _e = __asyncValues(this._asyncIterable), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
-                            _c = _f.value;
-                            _d = false;
-                            const item = _c;
-                            if (item) {
-                                this._result.push(item);
-                                this._fireResult();
-                            }
+                    for await (const item of this._asyncIterable) {
+                        if (item) {
+                            this._result.push(item);
+                            this._fireResult();
                         }
                     }
-                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
-                    finally {
-                        try {
-                            if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
-                        }
-                        finally { if (e_1) throw e_1.error; }
-                    }
                     this._asyncIterableDone = true;
                     if (this._state === 3 /* HoverOperationState.WaitingForAsync */ || this._state === 4 /* HoverOperationState.WaitingForAsyncShowingLoading */) {
                         this._setState(0 /* HoverOperationState.Idle */);
@@ -114,7 +85,7 @@
                 catch (e) {
                     onUnexpectedError(e);
                 }
-            }))();
+            })();
         }
         else {
             this._asyncIterableDone = true;
diff -urN -x '*.map' a/vs/editor/contrib/hover/browser/markdownHoverParticipant.js b/vs/editor/contrib/hover/browser/markdownHoverParticipant.js
--- a/vs/editor/contrib/hover/browser/markdownHoverParticipant.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/hover/browser/markdownHoverParticipant.js	2023-12-06 14:23:14.379854783 +0000
@@ -50,7 +50,7 @@
         this.hoverOrdinal = 3;
     }
     createLoadingMessage(anchor) {
-        return new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(nls.localize('modesContentHover.loading', "Loading..."))], false, 2000);
+        return new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(nls.localizeWithPath('vs/editor/contrib/hover/browser/markdownHoverParticipant', 'modesContentHover.loading', "Loading..."))], false, 2000);
     }
     computeSync(anchor, lineDecorations) {
         if (!this._editor.hasModel() || anchor.type !== 1 /* HoverAnchorType.Range */) {
@@ -71,12 +71,12 @@
         if (stopRenderingLineAfter >= 0 && lineLength > stopRenderingLineAfter && anchor.range.startColumn >= stopRenderingLineAfter) {
             stopRenderingMessage = true;
             result.push(new MarkdownHover(this, anchor.range, [{
-                    value: nls.localize('stopped rendering', "Rendering paused for long line for performance reasons. This can be configured via `editor.stopRenderingLineAfter`.")
+                    value: nls.localizeWithPath('vs/editor/contrib/hover/browser/markdownHoverParticipant', 'stopped rendering', "Rendering paused for long line for performance reasons. This can be configured via `editor.stopRenderingLineAfter`.")
                 }], false, index++));
         }
         if (!stopRenderingMessage && typeof maxTokenizationLineLength === 'number' && lineLength >= maxTokenizationLineLength) {
             result.push(new MarkdownHover(this, anchor.range, [{
-                    value: nls.localize('too many characters', "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")
+                    value: nls.localizeWithPath('vs/editor/contrib/hover/browser/markdownHoverParticipant', 'too many characters', "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")
                 }], false, index++));
         }
         let isBeforeContent = false;
diff -urN -x '*.map' a/vs/editor/contrib/hover/browser/markerHoverParticipant.js b/vs/editor/contrib/hover/browser/markerHoverParticipant.js
--- a/vs/editor/contrib/hover/browser/markerHoverParticipant.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/hover/browser/markerHoverParticipant.js	2023-12-06 14:23:14.379854783 +0000
@@ -148,12 +148,11 @@
     renderMarkerStatusbar(context, markerHover, disposables) {
         if (markerHover.marker.severity === MarkerSeverity.Error || markerHover.marker.severity === MarkerSeverity.Warning || markerHover.marker.severity === MarkerSeverity.Info) {
             context.statusBar.addAction({
-                label: nls.localize('view problem', "View Problem"),
+                label: nls.localizeWithPath('vs/editor/contrib/hover/browser/markerHoverParticipant', 'view problem', "View Problem"),
                 commandId: NextMarkerAction.ID,
                 run: () => {
-                    var _a;
                     context.hide();
-                    (_a = MarkerController.get(this._editor)) === null || _a === void 0 ? void 0 : _a.showAtMarker(markerHover.marker);
+                    MarkerController.get(this._editor)?.showAtMarker(markerHover.marker);
                     this._editor.focus();
                 }
             });
@@ -163,14 +162,14 @@
             if (this.recentMarkerCodeActionsInfo) {
                 if (IMarkerData.makeKey(this.recentMarkerCodeActionsInfo.marker) === IMarkerData.makeKey(markerHover.marker)) {
                     if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
-                        quickfixPlaceholderElement.textContent = nls.localize('noQuickFixes', "No quick fixes available");
+                        quickfixPlaceholderElement.textContent = nls.localizeWithPath('vs/editor/contrib/hover/browser/markerHoverParticipant', 'noQuickFixes', "No quick fixes available");
                     }
                 }
                 else {
                     this.recentMarkerCodeActionsInfo = undefined;
                 }
             }
-            const updatePlaceholderDisposable = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? Disposable.None : disposables.add(disposableTimeout(() => quickfixPlaceholderElement.textContent = nls.localize('checkingForQuickFixes', "Checking for quick fixes..."), 200));
+            const updatePlaceholderDisposable = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? Disposable.None : disposables.add(disposableTimeout(() => quickfixPlaceholderElement.textContent = nls.localizeWithPath('vs/editor/contrib/hover/browser/markerHoverParticipant', 'checkingForQuickFixes', "Checking for quick fixes..."), 200));
             if (!quickfixPlaceholderElement.textContent) {
                 // Have some content in here to avoid flickering
                 quickfixPlaceholderElement.textContent = String.fromCharCode(0xA0); // &nbsp;
@@ -182,7 +181,7 @@
                 this.recentMarkerCodeActionsInfo = { marker: markerHover.marker, hasCodeActions: actions.validActions.length > 0 };
                 if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
                     actions.dispose();
-                    quickfixPlaceholderElement.textContent = nls.localize('noQuickFixes', "No quick fixes available");
+                    quickfixPlaceholderElement.textContent = nls.localizeWithPath('vs/editor/contrib/hover/browser/markerHoverParticipant', 'noQuickFixes', "No quick fixes available");
                     return;
                 }
                 quickfixPlaceholderElement.style.display = 'none';
@@ -193,7 +192,7 @@
                     }
                 }));
                 context.statusBar.addAction({
-                    label: nls.localize('quick fixes', "Quick Fix..."),
+                    label: nls.localizeWithPath('vs/editor/contrib/hover/browser/markerHoverParticipant', 'quick fixes', "Quick Fix..."),
                     commandId: quickFixCommandId,
                     run: (target) => {
                         showing = true;
@@ -202,7 +201,7 @@
                         // Hide the hover pre-emptively, otherwise the editor can close the code actions
                         // context menu as well when using keyboard navigation
                         context.hide();
-                        controller === null || controller === void 0 ? void 0 : controller.showCodeActions(markerCodeActionTrigger, actions, {
+                        controller?.showCodeActions(markerCodeActionTrigger, actions, {
                             x: elementPosition.left,
                             y: elementPosition.top,
                             width: elementPosition.width,
diff -urN -x '*.map' a/vs/editor/contrib/hover/browser/resizableContentWidget.js b/vs/editor/contrib/hover/browser/resizableContentWidget.js
--- a/vs/editor/contrib/hover/browser/resizableContentWidget.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/hover/browser/resizableContentWidget.js	2023-12-06 14:23:14.379854783 +0000
@@ -41,8 +41,7 @@
         return this._contentPosition;
     }
     get position() {
-        var _a;
-        return ((_a = this._contentPosition) === null || _a === void 0 ? void 0 : _a.position) ? Position.lift(this._contentPosition.position) : undefined;
+        return this._contentPosition?.position ? Position.lift(this._contentPosition.position) : undefined;
     }
     _availableVerticalSpaceAbove(position) {
         const editorDomNode = this._editor.getDomNode();
@@ -65,9 +64,8 @@
         return bodyBox.height - mouseBottom - BOTTOM_HEIGHT;
     }
     _findPositionPreference(widgetHeight, showAtPosition) {
-        var _a, _b;
-        const maxHeightBelow = Math.min((_a = this._availableVerticalSpaceBelow(showAtPosition)) !== null && _a !== void 0 ? _a : Infinity, widgetHeight);
-        const maxHeightAbove = Math.min((_b = this._availableVerticalSpaceAbove(showAtPosition)) !== null && _b !== void 0 ? _b : Infinity, widgetHeight);
+        const maxHeightBelow = Math.min(this._availableVerticalSpaceBelow(showAtPosition) ?? Infinity, widgetHeight);
+        const maxHeightAbove = Math.min(this._availableVerticalSpaceAbove(showAtPosition) ?? Infinity, widgetHeight);
         const maxHeight = Math.min(Math.max(maxHeightAbove, maxHeightBelow), widgetHeight);
         const height = Math.min(widgetHeight, maxHeight);
         let renderingAbove;
diff -urN -x '*.map' a/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.js b/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.js
--- a/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.js	2023-12-06 14:23:14.379854783 +0000
@@ -36,9 +36,8 @@
     dispose() {
     }
     run(source, up) {
-        var _a;
         // cancel any pending request
-        (_a = this.currentRequest) === null || _a === void 0 ? void 0 : _a.cancel();
+        this.currentRequest?.cancel();
         const editorSelection = this.editor.getSelection();
         const model = this.editor.getModel();
         if (!model || !editorSelection) {
@@ -56,7 +55,6 @@
         }
         this.currentRequest = createCancelablePromise(token => this.editorWorkerService.navigateValueSet(modelURI, selection, up));
         return this.currentRequest.then(result => {
-            var _a;
             if (!result || !result.range || !result.value) {
                 // No proper result
                 return;
@@ -90,7 +88,7 @@
                     options: InPlaceReplaceController_1.DECORATION
                 }]);
             // remove decoration after delay
-            (_a = this.decorationRemover) === null || _a === void 0 ? void 0 : _a.cancel();
+            this.decorationRemover?.cancel();
             this.decorationRemover = timeout(350);
             this.decorationRemover.then(() => this.decorations.clear()).catch(onUnexpectedError);
         }).catch(onUnexpectedError);
@@ -108,7 +106,7 @@
     constructor() {
         super({
             id: 'editor.action.inPlaceReplace.up',
-            label: nls.localize('InPlaceReplaceAction.previous.label', "Replace with Previous Value"),
+            label: nls.localizeWithPath('vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace', 'InPlaceReplaceAction.previous.label', "Replace with Previous Value"),
             alias: 'Replace with Previous Value',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -130,7 +128,7 @@
     constructor() {
         super({
             id: 'editor.action.inPlaceReplace.down',
-            label: nls.localize('InPlaceReplaceAction.next.label', "Replace with Next Value"),
+            label: nls.localizeWithPath('vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace', 'InPlaceReplaceAction.next.label', "Replace with Next Value"),
             alias: 'Replace with Next Value',
             precondition: EditorContextKeys.writable,
             kbOpts: {
diff -urN -x '*.map' a/vs/editor/contrib/indentation/browser/indentation.js b/vs/editor/contrib/indentation/browser/indentation.js
--- a/vs/editor/contrib/indentation/browser/indentation.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/indentation/browser/indentation.js	2023-12-06 14:23:14.379854783 +0000
@@ -126,7 +126,7 @@
     constructor() {
         super({
             id: IndentationToSpacesAction.ID,
-            label: nls.localize('indentationToSpaces', "Convert Indentation to Spaces"),
+            label: nls.localizeWithPath('vs/editor/contrib/indentation/browser/indentation', 'indentationToSpaces', "Convert Indentation to Spaces"),
             alias: 'Convert Indentation to Spaces',
             precondition: EditorContextKeys.writable
         });
@@ -155,7 +155,7 @@
     constructor() {
         super({
             id: IndentationToTabsAction.ID,
-            label: nls.localize('indentationToTabs', "Convert Indentation to Tabs"),
+            label: nls.localizeWithPath('vs/editor/contrib/indentation/browser/indentation', 'indentationToTabs', "Convert Indentation to Tabs"),
             alias: 'Convert Indentation to Tabs',
             precondition: EditorContextKeys.writable
         });
@@ -200,17 +200,17 @@
             label: n.toString(),
             // add description for tabSize value set in the configuration
             description: (n === creationOpts.tabSize && n === modelOpts.tabSize
-                ? nls.localize('configuredTabSize', "Configured Tab Size")
+                ? nls.localizeWithPath('vs/editor/contrib/indentation/browser/indentation', 'configuredTabSize', "Configured Tab Size")
                 : n === creationOpts.tabSize
-                    ? nls.localize('defaultTabSize', "Default Tab Size")
+                    ? nls.localizeWithPath('vs/editor/contrib/indentation/browser/indentation', 'defaultTabSize', "Default Tab Size")
                     : n === modelOpts.tabSize
-                        ? nls.localize('currentTabSize', "Current Tab Size")
+                        ? nls.localizeWithPath('vs/editor/contrib/indentation/browser/indentation', 'currentTabSize', "Current Tab Size")
                         : undefined)
         }));
         // auto focus the tabSize set for the current editor
         const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);
         setTimeout(() => {
-            quickInputService.pick(picks, { placeHolder: nls.localize({ key: 'selectTabWidth', comment: ['Tab corresponds to the tab key'] }, "Select Tab Size for Current File"), activeItem: picks[autoFocusIndex] }).then(pick => {
+            quickInputService.pick(picks, { placeHolder: nls.localizeWithPath('vs/editor/contrib/indentation/browser/indentation', { key: 'selectTabWidth', comment: ['Tab corresponds to the tab key'] }, "Select Tab Size for Current File"), activeItem: picks[autoFocusIndex] }).then(pick => {
                 if (pick) {
                     if (model && !model.isDisposed()) {
                         const pickedVal = parseInt(pick.label, 10);
@@ -236,7 +236,7 @@
     constructor() {
         super(false, false, {
             id: IndentUsingTabs.ID,
-            label: nls.localize('indentUsingTabs', "Indent Using Tabs"),
+            label: nls.localizeWithPath('vs/editor/contrib/indentation/browser/indentation', 'indentUsingTabs', "Indent Using Tabs"),
             alias: 'Indent Using Tabs',
             precondition: undefined
         });
@@ -247,7 +247,7 @@
     constructor() {
         super(true, false, {
             id: IndentUsingSpaces.ID,
-            label: nls.localize('indentUsingSpaces', "Indent Using Spaces"),
+            label: nls.localizeWithPath('vs/editor/contrib/indentation/browser/indentation', 'indentUsingSpaces', "Indent Using Spaces"),
             alias: 'Indent Using Spaces',
             precondition: undefined
         });
@@ -258,7 +258,7 @@
     constructor() {
         super(true, true, {
             id: ChangeTabDisplaySize.ID,
-            label: nls.localize('changeTabDisplaySize', "Change Tab Display Size"),
+            label: nls.localizeWithPath('vs/editor/contrib/indentation/browser/indentation', 'changeTabDisplaySize', "Change Tab Display Size"),
             alias: 'Change Tab Display Size',
             precondition: undefined
         });
@@ -269,7 +269,7 @@
     constructor() {
         super({
             id: DetectIndentation.ID,
-            label: nls.localize('detectIndentation', "Detect Indentation from Content"),
+            label: nls.localizeWithPath('vs/editor/contrib/indentation/browser/indentation', 'detectIndentation', "Detect Indentation from Content"),
             alias: 'Detect Indentation from Content',
             precondition: undefined
         });
@@ -289,7 +289,7 @@
     constructor() {
         super({
             id: 'editor.action.reindentlines',
-            label: nls.localize('editor.reindentlines', "Reindent Lines"),
+            label: nls.localizeWithPath('vs/editor/contrib/indentation/browser/indentation', 'editor.reindentlines', "Reindent Lines"),
             alias: 'Reindent Lines',
             precondition: EditorContextKeys.writable
         });
@@ -312,7 +312,7 @@
     constructor() {
         super({
             id: 'editor.action.reindentselectedlines',
-            label: nls.localize('editor.reindentselectedlines', "Reindent Selected Lines"),
+            label: nls.localizeWithPath('vs/editor/contrib/indentation/browser/indentation', 'editor.reindentselectedlines', "Reindent Selected Lines"),
             alias: 'Reindent Selected Lines',
             precondition: EditorContextKeys.writable
         });
diff -urN -x '*.map' a/vs/editor/contrib/inlayHints/browser/inlayHints.js b/vs/editor/contrib/inlayHints/browser/inlayHints.js
--- a/vs/editor/contrib/inlayHints/browser/inlayHints.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/inlayHints/browser/inlayHints.js	2023-12-06 14:23:14.379854783 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { CancellationError, onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { DisposableStore } from '../../../../base/common/lifecycle.js';
 import { Position } from '../../../common/core/position.js';
@@ -36,64 +27,57 @@
         result._currentResolve = this._currentResolve;
         return result;
     }
-    resolve(token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (typeof this.provider.resolveInlayHint !== 'function') {
+    async resolve(token) {
+        if (typeof this.provider.resolveInlayHint !== 'function') {
+            return;
+        }
+        if (this._currentResolve) {
+            // wait for an active resolve operation and try again
+            // when that's done.
+            await this._currentResolve;
+            if (token.isCancellationRequested) {
                 return;
             }
-            if (this._currentResolve) {
-                // wait for an active resolve operation and try again
-                // when that's done.
-                yield this._currentResolve;
-                if (token.isCancellationRequested) {
-                    return;
-                }
-                return this.resolve(token);
-            }
-            if (!this._isResolved) {
-                this._currentResolve = this._doResolve(token)
-                    .finally(() => this._currentResolve = undefined);
-            }
-            yield this._currentResolve;
-        });
+            return this.resolve(token);
+        }
+        if (!this._isResolved) {
+            this._currentResolve = this._doResolve(token)
+                .finally(() => this._currentResolve = undefined);
+        }
+        await this._currentResolve;
+    }
+    async _doResolve(token) {
+        try {
+            const newHint = await Promise.resolve(this.provider.resolveInlayHint(this.hint, token));
+            this.hint.tooltip = newHint?.tooltip ?? this.hint.tooltip;
+            this.hint.label = newHint?.label ?? this.hint.label;
+            this._isResolved = true;
+        }
+        catch (err) {
+            onUnexpectedExternalError(err);
+            this._isResolved = false;
+        }
     }
-    _doResolve(token) {
-        var _a, _b;
-        return __awaiter(this, void 0, void 0, function* () {
+}
+export class InlayHintsFragments {
+    static async create(registry, model, ranges, token) {
+        const data = [];
+        const promises = registry.ordered(model).reverse().map(provider => ranges.map(async (range) => {
             try {
-                const newHint = yield Promise.resolve(this.provider.resolveInlayHint(this.hint, token));
-                this.hint.tooltip = (_a = newHint === null || newHint === void 0 ? void 0 : newHint.tooltip) !== null && _a !== void 0 ? _a : this.hint.tooltip;
-                this.hint.label = (_b = newHint === null || newHint === void 0 ? void 0 : newHint.label) !== null && _b !== void 0 ? _b : this.hint.label;
-                this._isResolved = true;
+                const result = await provider.provideInlayHints(model, range, token);
+                if (result?.hints.length) {
+                    data.push([result, provider]);
+                }
             }
             catch (err) {
                 onUnexpectedExternalError(err);
-                this._isResolved = false;
-            }
-        });
-    }
-}
-export class InlayHintsFragments {
-    static create(registry, model, ranges, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const data = [];
-            const promises = registry.ordered(model).reverse().map(provider => ranges.map((range) => __awaiter(this, void 0, void 0, function* () {
-                try {
-                    const result = yield provider.provideInlayHints(model, range, token);
-                    if (result === null || result === void 0 ? void 0 : result.hints.length) {
-                        data.push([result, provider]);
-                    }
-                }
-                catch (err) {
-                    onUnexpectedExternalError(err);
-                }
-            })));
-            yield Promise.all(promises.flat());
-            if (token.isCancellationRequested || model.isDisposed()) {
-                throw new CancellationError();
             }
-            return new InlayHintsFragments(ranges, data, model);
-        });
+        }));
+        await Promise.all(promises.flat());
+        if (token.isCancellationRequested || model.isDisposed()) {
+            throw new CancellationError();
+        }
+        return new InlayHintsFragments(ranges, data, model);
     }
     constructor(ranges, data, model) {
         this._disposables = new DisposableStore();
diff -urN -x '*.map' a/vs/editor/contrib/inlayHints/browser/inlayHintsController.js b/vs/editor/contrib/inlayHints/browser/inlayHintsController.js
--- a/vs/editor/contrib/inlayHints/browser/inlayHintsController.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/inlayHints/browser/inlayHintsController.js	2023-12-06 14:23:14.379854783 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var InlayHintsController_1;
 import { ModifierKeyEmitter } from '../../../../base/browser/dom.js';
 import { isNonEmptyArray } from '../../../../base/common/arrays.js';
@@ -94,8 +85,7 @@
 // --- controller
 let InlayHintsController = InlayHintsController_1 = class InlayHintsController {
     static get(editor) {
-        var _a;
-        return (_a = editor.getContribution(InlayHintsController_1.ID)) !== null && _a !== void 0 ? _a : undefined;
+        return editor.getContribution(InlayHintsController_1.ID) ?? undefined;
     }
     constructor(_editor, _languageFeaturesService, _featureDebounce, _inlayHintsCache, _commandService, _notificationService, _instaService) {
         this._editor = _editor;
@@ -149,14 +139,14 @@
         }));
         let cts;
         const watchedProviders = new Set();
-        const scheduler = new RunOnceScheduler(() => __awaiter(this, void 0, void 0, function* () {
+        const scheduler = new RunOnceScheduler(async () => {
             const t1 = Date.now();
-            cts === null || cts === void 0 ? void 0 : cts.dispose(true);
+            cts?.dispose(true);
             cts = new CancellationTokenSource();
-            const listener = model.onWillDispose(() => cts === null || cts === void 0 ? void 0 : cts.cancel());
+            const listener = model.onWillDispose(() => cts?.cancel());
             try {
                 const myToken = cts.token;
-                const inlayHints = yield InlayHintsFragments.create(this._languageFeaturesService.inlayHintsProvider, model, this._getHintsRanges(), myToken);
+                const inlayHints = await InlayHintsFragments.create(this._languageFeaturesService.inlayHintsProvider, model, this._getHintsRanges(), myToken);
                 scheduler.delay = this._debounceInfo.update(model, Date.now() - t1);
                 if (myToken.isCancellationRequested) {
                     inlayHints.dispose();
@@ -184,9 +174,9 @@
                 cts.dispose();
                 listener.dispose();
             }
-        }), this._debounceInfo.get(model));
+        }, this._debounceInfo.get(model));
         this._sessionDisposables.add(scheduler);
-        this._sessionDisposables.add(toDisposable(() => cts === null || cts === void 0 ? void 0 : cts.dispose(true)));
+        this._sessionDisposables.add(toDisposable(() => cts?.dispose(true)));
         scheduler.schedule(0);
         this._sessionDisposables.add(this._editor.onDidScrollChange((e) => {
             // update when scroll position changes
@@ -269,7 +259,7 @@
             }));
         }));
         store.add(gesture.onCancel(() => sessionStore.clear()));
-        store.add(gesture.onExecute((e) => __awaiter(this, void 0, void 0, function* () {
+        store.add(gesture.onExecute(async (e) => {
             const label = this._getInlayHintLabelPart(e);
             if (label) {
                 const part = label.part;
@@ -279,10 +269,10 @@
                 }
                 else if (languages.Command.is(part.command)) {
                     // command -> execute it
-                    yield this._invokeCommand(part.command, label.item);
+                    await this._invokeCommand(part.command, label.item);
                 }
             }
-        })));
+        }));
         return store;
     }
     _getInlineHintsForRange(range) {
@@ -295,7 +285,7 @@
         return Array.from(lineHints);
     }
     _installDblClickGesture(updateInlayHints) {
-        return this._editor.onMouseUp((e) => __awaiter(this, void 0, void 0, function* () {
+        return this._editor.onMouseUp(async (e) => {
             if (e.event.detail !== 2) {
                 return;
             }
@@ -304,50 +294,46 @@
                 return;
             }
             e.event.preventDefault();
-            yield part.item.resolve(CancellationToken.None);
+            await part.item.resolve(CancellationToken.None);
             if (isNonEmptyArray(part.item.hint.textEdits)) {
                 const edits = part.item.hint.textEdits.map(edit => EditOperation.replace(Range.lift(edit.range), edit.text));
                 this._editor.executeEdits('inlayHint.default', edits);
                 updateInlayHints();
             }
-        }));
+        });
     }
     _installContextMenu() {
-        return this._editor.onContextMenu((e) => __awaiter(this, void 0, void 0, function* () {
+        return this._editor.onContextMenu(async (e) => {
             if (!(e.event.target instanceof HTMLElement)) {
                 return;
             }
             const part = this._getInlayHintLabelPart(e);
             if (part) {
-                yield this._instaService.invokeFunction(showGoToContextMenu, this._editor, e.event.target, part);
+                await this._instaService.invokeFunction(showGoToContextMenu, this._editor, e.event.target, part);
             }
-        }));
+        });
     }
     _getInlayHintLabelPart(e) {
-        var _a;
         if (e.target.type !== 6 /* MouseTargetType.CONTENT_TEXT */) {
             return undefined;
         }
-        const options = (_a = e.target.detail.injectedText) === null || _a === void 0 ? void 0 : _a.options;
-        if (options instanceof ModelDecorationInjectedTextOptions && (options === null || options === void 0 ? void 0 : options.attachedData) instanceof RenderedInlayHintLabelPart) {
+        const options = e.target.detail.injectedText?.options;
+        if (options instanceof ModelDecorationInjectedTextOptions && options?.attachedData instanceof RenderedInlayHintLabelPart) {
             return options.attachedData;
         }
         return undefined;
     }
-    _invokeCommand(command, item) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            try {
-                yield this._commandService.executeCommand(command.id, ...((_a = command.arguments) !== null && _a !== void 0 ? _a : []));
-            }
-            catch (err) {
-                this._notificationService.notify({
-                    severity: Severity.Error,
-                    source: item.provider.displayName,
-                    message: err
-                });
-            }
-        });
+    async _invokeCommand(command, item) {
+        try {
+            await this._commandService.executeCommand(command.id, ...(command.arguments ?? []));
+        }
+        catch (err) {
+            this._notificationService.notify({
+                severity: Severity.Error,
+                source: item.provider.displayName,
+                message: err
+            });
+        }
     }
     _cacheHintsForFastRestore(model) {
         const hints = this._copyInlayHintsWithCurrentAnchor(model);
@@ -390,7 +376,6 @@
         return result;
     }
     _updateHintsDecorators(ranges, items) {
-        var _a, _b;
         // utils to collect/create injected text decorations
         const newDecorationsData = [];
         const addInjectedText = (item, ref, content, cursorStops, attachedData) => {
@@ -451,7 +436,7 @@
                     cssProperties.cursor = 'default';
                 }
                 this._fillInColors(cssProperties, item.hint);
-                if ((part.command || part.location) && ((_a = this._activeInlayHintPart) === null || _a === void 0 ? void 0 : _a.part.item) === item && this._activeInlayHintPart.part.index === i) {
+                if ((part.command || part.location) && this._activeInlayHintPart?.part.item === item && this._activeInlayHintPart.part.index === i) {
                     // active link!
                     cssProperties.textDecoration = 'underline';
                     if (this._activeInlayHintPart.hasTriggerModifier) {
@@ -493,7 +478,7 @@
         // and only update those decorations
         const decorationIdsToReplace = [];
         for (const range of ranges) {
-            for (const { id } of (_b = this._editor.getDecorationsInRange(range)) !== null && _b !== void 0 ? _b : []) {
+            for (const { id } of this._editor.getDecorationsInRange(range) ?? []) {
                 const metadata = this._decorationsMetadata.get(id);
                 if (metadata) {
                     decorationIdsToReplace.push(id);
@@ -548,6 +533,22 @@
         }
         this._decorationsMetadata.clear();
     }
+    // --- accessibility
+    getInlayHintsForLine(line) {
+        if (!this._editor.hasModel()) {
+            return [];
+        }
+        const set = new Set();
+        const result = [];
+        for (const deco of this._editor.getLineDecorations(line)) {
+            const data = this._decorationsMetadata.get(deco.id);
+            if (data && !set.has(data.item.hint)) {
+                set.add(data.item.hint);
+                result.push(data.item);
+            }
+        }
+        return result;
+    }
 };
 InlayHintsController.ID = 'editor.contrib.InlayHints';
 InlayHintsController._MAX_DECORATORS = 1500;
@@ -565,14 +566,14 @@
     const noBreakWhitespace = '\xa0';
     return str.replace(/[ \t]/g, noBreakWhitespace);
 }
-CommandsRegistry.registerCommand('_executeInlayHintProvider', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {
+CommandsRegistry.registerCommand('_executeInlayHintProvider', async (accessor, ...args) => {
     const [uri, range] = args;
     assertType(URI.isUri(uri));
     assertType(Range.isIRange(range));
     const { inlayHintsProvider } = accessor.get(ILanguageFeaturesService);
-    const ref = yield accessor.get(ITextModelService).createModelReference(uri);
+    const ref = await accessor.get(ITextModelService).createModelReference(uri);
     try {
-        const model = yield InlayHintsFragments.create(inlayHintsProvider, ref.object.textEditorModel, [Range.lift(range)], CancellationToken.None);
+        const model = await InlayHintsFragments.create(inlayHintsProvider, ref.object.textEditorModel, [Range.lift(range)], CancellationToken.None);
         const result = model.items.map(i => i.hint);
         setTimeout(() => model.dispose(), 0); // dispose after sending to ext host
         return result;
@@ -580,4 +581,4 @@
     finally {
         ref.dispose();
     }
-}));
+});
diff -urN -x '*.map' a/vs/editor/contrib/inlayHints/browser/inlayHintsHover.js b/vs/editor/contrib/inlayHints/browser/inlayHintsHover.js
--- a/vs/editor/contrib/inlayHints/browser/inlayHintsHover.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/inlayHints/browser/inlayHintsHover.js	2023-12-06 14:23:14.379854783 +0000
@@ -11,22 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __asyncValues = (this && this.__asyncValues) || function (o) {
-    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
-    var m = o[Symbol.asyncIterator], i;
-    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
-    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
-    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
-};
 import { AsyncIterableObject } from '../../../../base/common/async.js';
 import { isEmptyMarkdownString, MarkdownString } from '../../../../base/common/htmlContent.js';
 import { Position } from '../../../common/core/position.js';
@@ -40,7 +24,7 @@
 import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
 import { IOpenerService } from '../../../../platform/opener/common/opener.js';
 import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import * as platform from '../../../../base/common/platform.js';
 import { asCommandLink } from './inlayHints.js';
 import { isNonEmptyArray } from '../../../../base/common/arrays.js';
@@ -57,7 +41,6 @@
         this.hoverOrdinal = 6;
     }
     suggestHoverAnchor(mouseEvent) {
-        var _a;
         const controller = InlayHintsController.get(this._editor);
         if (!controller) {
             return null;
@@ -65,7 +48,7 @@
         if (mouseEvent.target.type !== 6 /* MouseTargetType.CONTENT_TEXT */) {
             return null;
         }
-        const options = (_a = mouseEvent.target.detail.injectedText) === null || _a === void 0 ? void 0 : _a.options;
+        const options = mouseEvent.target.detail.injectedText?.options;
         if (!(options instanceof ModelDecorationInjectedTextOptions && options.attachedData instanceof RenderedInlayHintLabelPart)) {
             return null;
         }
@@ -78,10 +61,9 @@
         if (!(anchor instanceof InlayHintsHoverAnchor)) {
             return AsyncIterableObject.EMPTY;
         }
-        return new AsyncIterableObject((executor) => __awaiter(this, void 0, void 0, function* () {
-            var _a, e_1, _b, _c;
+        return new AsyncIterableObject(async (executor) => {
             const { part } = anchor;
-            yield part.item.resolve(token);
+            await part.item.resolve(token);
             if (token.isCancellationRequested) {
                 return;
             }
@@ -98,7 +80,7 @@
             }
             // (1.2) Inlay dbl-click gesture
             if (isNonEmptyArray(part.item.hint.textEdits)) {
-                executor.emitOne(new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localize('hint.dbl', "Double-click to insert"))], false, 10001));
+                executor.emitOne(new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localizeWithPath('vs/editor/contrib/inlayHints/browser/inlayHintsHover', 'hint.dbl', "Double-click to insert"))], false, 10001));
             }
             // (2) Inlay Label Part Tooltip
             let partTooltip;
@@ -117,63 +99,49 @@
                 const useMetaKey = this._editor.getOption(77 /* EditorOption.multiCursorModifier */) === 'altKey';
                 const kb = useMetaKey
                     ? platform.isMacintosh
-                        ? localize('links.navigate.kb.meta.mac', "cmd + click")
-                        : localize('links.navigate.kb.meta', "ctrl + click")
+                        ? localizeWithPath('vs/editor/contrib/inlayHints/browser/inlayHintsHover', 'links.navigate.kb.meta.mac', "cmd + click")
+                        : localizeWithPath('vs/editor/contrib/inlayHints/browser/inlayHintsHover', 'links.navigate.kb.meta', "ctrl + click")
                     : platform.isMacintosh
-                        ? localize('links.navigate.kb.alt.mac', "option + click")
-                        : localize('links.navigate.kb.alt', "alt + click");
+                        ? localizeWithPath('vs/editor/contrib/inlayHints/browser/inlayHintsHover', 'links.navigate.kb.alt.mac', "option + click")
+                        : localizeWithPath('vs/editor/contrib/inlayHints/browser/inlayHintsHover', 'links.navigate.kb.alt', "alt + click");
                 if (part.part.location && part.part.command) {
-                    linkHint = new MarkdownString().appendText(localize('hint.defAndCommand', 'Go to Definition ({0}), right click for more', kb));
+                    linkHint = new MarkdownString().appendText(localizeWithPath('vs/editor/contrib/inlayHints/browser/inlayHintsHover', 'hint.defAndCommand', 'Go to Definition ({0}), right click for more', kb));
                 }
                 else if (part.part.location) {
-                    linkHint = new MarkdownString().appendText(localize('hint.def', 'Go to Definition ({0})', kb));
+                    linkHint = new MarkdownString().appendText(localizeWithPath('vs/editor/contrib/inlayHints/browser/inlayHintsHover', 'hint.def', 'Go to Definition ({0})', kb));
                 }
                 else if (part.part.command) {
-                    linkHint = new MarkdownString(`[${localize('hint.cmd', "Execute Command")}](${asCommandLink(part.part.command)} "${part.part.command.title}") (${kb})`, { isTrusted: true });
+                    linkHint = new MarkdownString(`[${localizeWithPath('vs/editor/contrib/inlayHints/browser/inlayHintsHover', 'hint.cmd', "Execute Command")}](${asCommandLink(part.part.command)} "${part.part.command.title}") (${kb})`, { isTrusted: true });
                 }
                 if (linkHint) {
                     executor.emitOne(new MarkdownHover(this, anchor.range, [linkHint], false, 10000));
                 }
             }
             // (3) Inlay Label Part Location tooltip
-            const iterable = yield this._resolveInlayHintLabelPartHover(part, token);
-            try {
-                for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield iterable_1.next(), _a = iterable_1_1.done, !_a; _d = true) {
-                    _c = iterable_1_1.value;
-                    _d = false;
-                    const item = _c;
-                    executor.emitOne(item);
-                }
+            const iterable = await this._resolveInlayHintLabelPartHover(part, token);
+            for await (const item of iterable) {
+                executor.emitOne(item);
             }
-            catch (e_1_1) { e_1 = { error: e_1_1 }; }
-            finally {
-                try {
-                    if (!_d && !_a && (_b = iterable_1.return)) yield _b.call(iterable_1);
-                }
-                finally { if (e_1) throw e_1.error; }
-            }
-        }));
+        });
     }
-    _resolveInlayHintLabelPartHover(part, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!part.part.location) {
+    async _resolveInlayHintLabelPartHover(part, token) {
+        if (!part.part.location) {
+            return AsyncIterableObject.EMPTY;
+        }
+        const { uri, range } = part.part.location;
+        const ref = await this._resolverService.createModelReference(uri);
+        try {
+            const model = ref.object.textEditorModel;
+            if (!this._languageFeaturesService.hoverProvider.has(model)) {
                 return AsyncIterableObject.EMPTY;
             }
-            const { uri, range } = part.part.location;
-            const ref = yield this._resolverService.createModelReference(uri);
-            try {
-                const model = ref.object.textEditorModel;
-                if (!this._languageFeaturesService.hoverProvider.has(model)) {
-                    return AsyncIterableObject.EMPTY;
-                }
-                return getHover(this._languageFeaturesService.hoverProvider, model, new Position(range.startLineNumber, range.startColumn), token)
-                    .filter(item => !isEmptyMarkdownString(item.hover.contents))
-                    .map(item => new MarkdownHover(this, part.item.anchor.range, item.hover.contents, false, 2 + item.ordinal));
-            }
-            finally {
-                ref.dispose();
-            }
-        });
+            return getHover(this._languageFeaturesService.hoverProvider, model, new Position(range.startLineNumber, range.startColumn), token)
+                .filter(item => !isEmptyMarkdownString(item.hover.contents))
+                .map(item => new MarkdownHover(this, part.item.anchor.range, item.hover.contents, false, 2 + item.ordinal));
+        }
+        finally {
+            ref.dispose();
+        }
     }
 };
 InlayHintsHover = __decorate([
diff -urN -x '*.map' a/vs/editor/contrib/inlayHints/browser/inlayHintsLocations.js b/vs/editor/contrib/inlayHints/browser/inlayHintsLocations.js
--- a/vs/editor/contrib/inlayHints/browser/inlayHintsLocations.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/inlayHints/browser/inlayHintsLocations.js	2023-12-06 14:23:14.379854783 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import * as dom from '../../../../base/browser/dom.js';
 import { Action, Separator } from '../../../../base/common/actions.js';
 import { CancellationToken } from '../../../../base/common/cancellation.js';
@@ -25,84 +16,78 @@
 import { IContextMenuService } from '../../../../platform/contextview/browser/contextView.js';
 import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
 import { INotificationService, Severity } from '../../../../platform/notification/common/notification.js';
-export function showGoToContextMenu(accessor, editor, anchor, part) {
-    var _a;
-    return __awaiter(this, void 0, void 0, function* () {
-        const resolverService = accessor.get(ITextModelService);
-        const contextMenuService = accessor.get(IContextMenuService);
-        const commandService = accessor.get(ICommandService);
-        const instaService = accessor.get(IInstantiationService);
-        const notificationService = accessor.get(INotificationService);
-        yield part.item.resolve(CancellationToken.None);
-        if (!part.part.location) {
-            return;
-        }
-        const location = part.part.location;
-        const menuActions = [];
-        // from all registered (not active) context menu actions select those
-        // that are a symbol navigation actions
-        const filter = new Set(MenuRegistry.getMenuItems(MenuId.EditorContext)
-            .map(item => isIMenuItem(item) ? item.command.id : generateUuid()));
-        for (const delegate of SymbolNavigationAction.all()) {
-            if (filter.has(delegate.desc.id)) {
-                menuActions.push(new Action(delegate.desc.id, MenuItemAction.label(delegate.desc, { renderShortTitle: true }), undefined, true, () => __awaiter(this, void 0, void 0, function* () {
-                    const ref = yield resolverService.createModelReference(location.uri);
-                    try {
-                        const symbolAnchor = new SymbolNavigationAnchor(ref.object.textEditorModel, Range.getStartPosition(location.range));
-                        const range = part.item.anchor.range;
-                        yield instaService.invokeFunction(delegate.runEditorCommand.bind(delegate), editor, symbolAnchor, range);
-                    }
-                    finally {
-                        ref.dispose();
-                    }
-                })));
-            }
-        }
-        if (part.part.command) {
-            const { command } = part.part;
-            menuActions.push(new Separator());
-            menuActions.push(new Action(command.id, command.title, undefined, true, () => __awaiter(this, void 0, void 0, function* () {
-                var _b;
+export async function showGoToContextMenu(accessor, editor, anchor, part) {
+    const resolverService = accessor.get(ITextModelService);
+    const contextMenuService = accessor.get(IContextMenuService);
+    const commandService = accessor.get(ICommandService);
+    const instaService = accessor.get(IInstantiationService);
+    const notificationService = accessor.get(INotificationService);
+    await part.item.resolve(CancellationToken.None);
+    if (!part.part.location) {
+        return;
+    }
+    const location = part.part.location;
+    const menuActions = [];
+    // from all registered (not active) context menu actions select those
+    // that are a symbol navigation actions
+    const filter = new Set(MenuRegistry.getMenuItems(MenuId.EditorContext)
+        .map(item => isIMenuItem(item) ? item.command.id : generateUuid()));
+    for (const delegate of SymbolNavigationAction.all()) {
+        if (filter.has(delegate.desc.id)) {
+            menuActions.push(new Action(delegate.desc.id, MenuItemAction.label(delegate.desc, { renderShortTitle: true }), undefined, true, async () => {
+                const ref = await resolverService.createModelReference(location.uri);
                 try {
-                    yield commandService.executeCommand(command.id, ...((_b = command.arguments) !== null && _b !== void 0 ? _b : []));
+                    const symbolAnchor = new SymbolNavigationAnchor(ref.object.textEditorModel, Range.getStartPosition(location.range));
+                    const range = part.item.anchor.range;
+                    await instaService.invokeFunction(delegate.runEditorCommand.bind(delegate), editor, symbolAnchor, range);
                 }
-                catch (err) {
-                    notificationService.notify({
-                        severity: Severity.Error,
-                        source: part.item.provider.displayName,
-                        message: err
-                    });
+                finally {
+                    ref.dispose();
                 }
-            })));
+            }));
         }
-        // show context menu
-        const useShadowDOM = editor.getOption(126 /* EditorOption.useShadowDOM */);
-        contextMenuService.showContextMenu({
-            domForShadowRoot: useShadowDOM ? (_a = editor.getDomNode()) !== null && _a !== void 0 ? _a : undefined : undefined,
-            getAnchor: () => {
-                const box = dom.getDomNodePagePosition(anchor);
-                return { x: box.left, y: box.top + box.height + 8 };
-            },
-            getActions: () => menuActions,
-            onHide: () => {
-                editor.focus();
-            },
-            autoSelectFirstItem: true,
-        });
+    }
+    if (part.part.command) {
+        const { command } = part.part;
+        menuActions.push(new Separator());
+        menuActions.push(new Action(command.id, command.title, undefined, true, async () => {
+            try {
+                await commandService.executeCommand(command.id, ...(command.arguments ?? []));
+            }
+            catch (err) {
+                notificationService.notify({
+                    severity: Severity.Error,
+                    source: part.item.provider.displayName,
+                    message: err
+                });
+            }
+        }));
+    }
+    // show context menu
+    const useShadowDOM = editor.getOption(126 /* EditorOption.useShadowDOM */);
+    contextMenuService.showContextMenu({
+        domForShadowRoot: useShadowDOM ? editor.getDomNode() ?? undefined : undefined,
+        getAnchor: () => {
+            const box = dom.getDomNodePagePosition(anchor);
+            return { x: box.left, y: box.top + box.height + 8 };
+        },
+        getActions: () => menuActions,
+        onHide: () => {
+            editor.focus();
+        },
+        autoSelectFirstItem: true,
     });
 }
-export function goToDefinitionWithLocation(accessor, event, editor, location) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const resolverService = accessor.get(ITextModelService);
-        const ref = yield resolverService.createModelReference(location.uri);
-        yield editor.invokeWithinContext((accessor) => __awaiter(this, void 0, void 0, function* () {
-            const openToSide = event.hasSideBySideModifier;
-            const contextKeyService = accessor.get(IContextKeyService);
-            const isInPeek = PeekContext.inPeekEditor.getValue(contextKeyService);
-            const canPeek = !openToSide && editor.getOption(87 /* EditorOption.definitionLinkOpensInPeek */) && !isInPeek;
-            const action = new DefinitionAction({ openToSide, openInPeek: canPeek, muteMessage: true }, { title: { value: '', original: '' }, id: '', precondition: undefined });
-            return action.run(accessor, new SymbolNavigationAnchor(ref.object.textEditorModel, Range.getStartPosition(location.range)), Range.lift(location.range));
-        }));
-        ref.dispose();
+export async function goToDefinitionWithLocation(accessor, event, editor, location) {
+    const resolverService = accessor.get(ITextModelService);
+    const ref = await resolverService.createModelReference(location.uri);
+    await editor.invokeWithinContext(async (accessor) => {
+        const openToSide = event.hasSideBySideModifier;
+        const contextKeyService = accessor.get(IContextKeyService);
+        const isInPeek = PeekContext.inPeekEditor.getValue(contextKeyService);
+        const canPeek = !openToSide && editor.getOption(87 /* EditorOption.definitionLinkOpensInPeek */) && !isInPeek;
+        const action = new DefinitionAction({ openToSide, openInPeek: canPeek, muteMessage: true }, { title: { value: '', original: '' }, id: '', precondition: undefined });
+        return action.run(accessor, new SymbolNavigationAnchor(ref.object.textEditorModel, Range.getStartPosition(location.range)), Range.lift(location.range));
     });
+    ref.dispose();
 }
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/commands.js b/vs/editor/contrib/inlineCompletions/browser/commands.js
--- a/vs/editor/contrib/inlineCompletions/browser/commands.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/commands.js	2023-12-06 14:23:14.379854783 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { transaction } from '../../../../base/common/observable.js';
 import { EditorAction } from '../../../browser/editorExtensions.js';
 import { EditorContextKeys } from '../../../common/editorContextKeys.js';
@@ -26,7 +17,7 @@
     constructor() {
         super({
             id: ShowNextInlineSuggestionAction.ID,
-            label: nls.localize('action.inlineSuggest.showNext', "Show Next Inline Suggestion"),
+            label: nls.localizeWithPath('vs/editor/contrib/inlineCompletions/browser/commands', 'action.inlineSuggest.showNext', "Show Next Inline Suggestion"),
             alias: 'Show Next Inline Suggestion',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
             kbOpts: {
@@ -35,12 +26,9 @@
             },
         });
     }
-    run(accessor, editor) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            const controller = InlineCompletionsController.get(editor);
-            (_a = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a === void 0 ? void 0 : _a.next();
-        });
+    async run(accessor, editor) {
+        const controller = InlineCompletionsController.get(editor);
+        controller?.model.get()?.next();
     }
 }
 ShowNextInlineSuggestionAction.ID = showNextInlineSuggestionActionId;
@@ -48,7 +36,7 @@
     constructor() {
         super({
             id: ShowPreviousInlineSuggestionAction.ID,
-            label: nls.localize('action.inlineSuggest.showPrevious', "Show Previous Inline Suggestion"),
+            label: nls.localizeWithPath('vs/editor/contrib/inlineCompletions/browser/commands', 'action.inlineSuggest.showPrevious', "Show Previous Inline Suggestion"),
             alias: 'Show Previous Inline Suggestion',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
             kbOpts: {
@@ -57,12 +45,9 @@
             },
         });
     }
-    run(accessor, editor) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            const controller = InlineCompletionsController.get(editor);
-            (_a = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a === void 0 ? void 0 : _a.previous();
-        });
+    async run(accessor, editor) {
+        const controller = InlineCompletionsController.get(editor);
+        controller?.model.get()?.previous();
     }
 }
 ShowPreviousInlineSuggestionAction.ID = showPreviousInlineSuggestionActionId;
@@ -70,24 +55,21 @@
     constructor() {
         super({
             id: 'editor.action.inlineSuggest.trigger',
-            label: nls.localize('action.inlineSuggest.trigger', "Trigger Inline Suggestion"),
+            label: nls.localizeWithPath('vs/editor/contrib/inlineCompletions/browser/commands', 'action.inlineSuggest.trigger', "Trigger Inline Suggestion"),
             alias: 'Trigger Inline Suggestion',
             precondition: EditorContextKeys.writable
         });
     }
-    run(accessor, editor) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            const controller = InlineCompletionsController.get(editor);
-            (_a = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a === void 0 ? void 0 : _a.triggerExplicitly();
-        });
+    async run(accessor, editor) {
+        const controller = InlineCompletionsController.get(editor);
+        controller?.model.get()?.triggerExplicitly();
     }
 }
 export class AcceptNextWordOfInlineCompletion extends EditorAction {
     constructor() {
         super({
             id: 'editor.action.inlineSuggest.acceptNextWord',
-            label: nls.localize('action.inlineSuggest.acceptNextWord', "Accept Next Word Of Inline Suggestion"),
+            label: nls.localizeWithPath('vs/editor/contrib/inlineCompletions/browser/commands', 'action.inlineSuggest.acceptNextWord', "Accept Next Word Of Inline Suggestion"),
             alias: 'Accept Next Word Of Inline Suggestion',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
             kbOpts: {
@@ -97,25 +79,22 @@
             },
             menuOpts: [{
                     menuId: MenuId.InlineSuggestionToolbar,
-                    title: nls.localize('acceptWord', 'Accept Word'),
+                    title: nls.localizeWithPath('vs/editor/contrib/inlineCompletions/browser/commands', 'acceptWord', 'Accept Word'),
                     group: 'primary',
                     order: 2,
                 }],
         });
     }
-    run(accessor, editor) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            const controller = InlineCompletionsController.get(editor);
-            yield ((_a = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a === void 0 ? void 0 : _a.acceptNextWord(controller.editor));
-        });
+    async run(accessor, editor) {
+        const controller = InlineCompletionsController.get(editor);
+        await controller?.model.get()?.acceptNextWord(controller.editor);
     }
 }
 export class AcceptNextLineOfInlineCompletion extends EditorAction {
     constructor() {
         super({
             id: 'editor.action.inlineSuggest.acceptNextLine',
-            label: nls.localize('action.inlineSuggest.acceptNextLine', "Accept Next Line Of Inline Suggestion"),
+            label: nls.localizeWithPath('vs/editor/contrib/inlineCompletions/browser/commands', 'action.inlineSuggest.acceptNextLine', "Accept Next Line Of Inline Suggestion"),
             alias: 'Accept Next Line Of Inline Suggestion',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
             kbOpts: {
@@ -123,30 +102,27 @@
             },
             menuOpts: [{
                     menuId: MenuId.InlineSuggestionToolbar,
-                    title: nls.localize('acceptLine', 'Accept Line'),
+                    title: nls.localizeWithPath('vs/editor/contrib/inlineCompletions/browser/commands', 'acceptLine', 'Accept Line'),
                     group: 'secondary',
                     order: 2,
                 }],
         });
     }
-    run(accessor, editor) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            const controller = InlineCompletionsController.get(editor);
-            yield ((_a = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a === void 0 ? void 0 : _a.acceptNextLine(controller.editor));
-        });
+    async run(accessor, editor) {
+        const controller = InlineCompletionsController.get(editor);
+        await controller?.model.get()?.acceptNextLine(controller.editor);
     }
 }
 export class AcceptInlineCompletion extends EditorAction {
     constructor() {
         super({
             id: inlineSuggestCommitId,
-            label: nls.localize('action.inlineSuggest.accept', "Accept Inline Suggestion"),
+            label: nls.localizeWithPath('vs/editor/contrib/inlineCompletions/browser/commands', 'action.inlineSuggest.accept', "Accept Inline Suggestion"),
             alias: 'Accept Inline Suggestion',
             precondition: InlineCompletionContextKeys.inlineSuggestionVisible,
             menuOpts: [{
                     menuId: MenuId.InlineSuggestionToolbar,
-                    title: nls.localize('accept', "Accept"),
+                    title: nls.localizeWithPath('vs/editor/contrib/inlineCompletions/browser/commands', 'accept', "Accept"),
                     group: 'primary',
                     order: 1,
                 }],
@@ -157,22 +133,19 @@
             }
         });
     }
-    run(accessor, editor) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            const controller = InlineCompletionsController.get(editor);
-            if (controller) {
-                (_a = controller.model.get()) === null || _a === void 0 ? void 0 : _a.accept(controller.editor);
-                controller.editor.focus();
-            }
-        });
+    async run(accessor, editor) {
+        const controller = InlineCompletionsController.get(editor);
+        if (controller) {
+            controller.model.get()?.accept(controller.editor);
+            controller.editor.focus();
+        }
     }
 }
 export class HideInlineCompletion extends EditorAction {
     constructor() {
         super({
             id: HideInlineCompletion.ID,
-            label: nls.localize('action.inlineSuggest.hide', "Hide Inline Suggestion"),
+            label: nls.localizeWithPath('vs/editor/contrib/inlineCompletions/browser/commands', 'action.inlineSuggest.hide', "Hide Inline Suggestion"),
             alias: 'Hide Inline Suggestion',
             precondition: InlineCompletionContextKeys.inlineSuggestionVisible,
             kbOpts: {
@@ -181,13 +154,10 @@
             }
         });
     }
-    run(accessor, editor) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const controller = InlineCompletionsController.get(editor);
-            transaction(tx => {
-                var _a;
-                (_a = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a === void 0 ? void 0 : _a.stop(tx);
-            });
+    async run(accessor, editor) {
+        const controller = InlineCompletionsController.get(editor);
+        transaction(tx => {
+            controller?.model.get()?.stop(tx);
         });
     }
 }
@@ -196,7 +166,7 @@
     constructor() {
         super({
             id: ToggleAlwaysShowInlineSuggestionToolbar.ID,
-            title: nls.localize('action.inlineSuggest.alwaysShowToolbar', "Always Show Toolbar"),
+            title: nls.localizeWithPath('vs/editor/contrib/inlineCompletions/browser/commands', 'action.inlineSuggest.alwaysShowToolbar', "Always Show Toolbar"),
             f1: false,
             precondition: undefined,
             menu: [{
@@ -207,13 +177,11 @@
             toggled: ContextKeyExpr.equals('config.editor.inlineSuggest.showToolbar', 'always')
         });
     }
-    run(accessor, editor) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const configService = accessor.get(IConfigurationService);
-            const currentValue = configService.getValue('editor.inlineSuggest.showToolbar');
-            const newValue = currentValue === 'always' ? 'onHover' : 'always';
-            configService.updateValue('editor.inlineSuggest.showToolbar', newValue);
-        });
+    async run(accessor, editor) {
+        const configService = accessor.get(IConfigurationService);
+        const currentValue = configService.getValue('editor.inlineSuggest.showToolbar');
+        const newValue = currentValue === 'always' ? 'onHover' : 'always';
+        configService.updateValue('editor.inlineSuggest.showToolbar', newValue);
     }
 }
 ToggleAlwaysShowInlineSuggestionToolbar.ID = 'editor.action.inlineSuggest.toggleAlwaysShowToolbar';
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/ghostText.js b/vs/editor/contrib/inlineCompletions/browser/ghostText.js
--- a/vs/editor/contrib/inlineCompletions/browser/ghostText.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/ghostText.js	2023-12-06 14:23:14.379854783 +0000
@@ -1,3 +1,8 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { Range } from '../../../common/core/range.js';
 import { applyEdits } from './utils.js';
 export class GhostText {
     constructor(lineNumber, parts) {
@@ -9,6 +14,18 @@
             this.parts.length === other.parts.length &&
             this.parts.every((part, index) => part.equals(other.parts[index]));
     }
+    /**
+     * Only used for testing/debugging.
+    */
+    render(documentText, debug = false) {
+        const l = this.lineNumber;
+        return applyEdits(documentText, [
+            ...this.parts.map(p => ({
+                range: { startLineNumber: l, endLineNumber: l, startColumn: p.column, endColumn: p.column },
+                text: debug ? `[${p.lines.join('\n')}]` : p.lines.join('\n')
+            })),
+        ]);
+    }
     renderForScreenReader(lineText) {
         if (this.parts.length === 0) {
             return '';
@@ -57,6 +74,20 @@
     renderForScreenReader(_lineText) {
         return this.newLines.join('\n');
     }
+    render(documentText, debug = false) {
+        const replaceRange = this.columnRange.toRange(this.lineNumber);
+        if (debug) {
+            return applyEdits(documentText, [
+                { range: Range.fromPositions(replaceRange.getStartPosition()), text: `(` },
+                { range: Range.fromPositions(replaceRange.getEndPosition()), text: `)[${this.newLines.join('\n')}]` }
+            ]);
+        }
+        else {
+            return applyEdits(documentText, [
+                { range: replaceRange, text: this.newLines.join('\n') }
+            ]);
+        }
+    }
     get lineCount() {
         return this.newLines.length;
     }
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/hoverParticipant.js b/vs/editor/contrib/inlineCompletions/browser/hoverParticipant.js
--- a/vs/editor/contrib/inlineCompletions/browser/hoverParticipant.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/hoverParticipant.js	2023-12-06 14:23:14.379854783 +0000
@@ -94,7 +94,7 @@
             this.renderScreenReaderText(context, part, disposableStore);
         }
         const model = part.controller.model.get();
-        const w = this._instantiationService.createInstance(InlineSuggestionHintsContentWidget, this._editor, false, constObservable(null), model.selectedInlineCompletionIndex, model.inlineCompletionsCount, model.selectedInlineCompletion.map(v => { var _a; return (_a = v === null || v === void 0 ? void 0 : v.inlineCompletion.source.inlineCompletions.commands) !== null && _a !== void 0 ? _a : []; }));
+        const w = this._instantiationService.createInstance(InlineSuggestionHintsContentWidget, this._editor, false, constObservable(null), model.selectedInlineCompletionIndex, model.inlineCompletionsCount, model.selectedInlineCompletion.map(v => v?.inlineCompletion.source.inlineCompletions.commands ?? []));
         context.fragment.appendChild(w.getDomNode());
         model.triggerExplicitly();
         disposableStore.add(w);
@@ -110,14 +110,13 @@
                 hoverContentsElement.className = 'hover-contents code-hover-contents';
                 context.onContentsChanged();
             }));
-            const inlineSuggestionAvailable = nls.localize('inlineSuggestionFollows', "Suggestion:");
+            const inlineSuggestionAvailable = nls.localizeWithPath('vs/editor/contrib/inlineCompletions/browser/hoverParticipant', 'inlineSuggestionFollows', "Suggestion:");
             const renderedContents = disposableStore.add(renderer.render(new MarkdownString().appendText(inlineSuggestionAvailable).appendCodeblock('text', code)));
             hoverContentsElement.replaceChildren(renderedContents.element);
         };
         disposableStore.add(autorun(reader => {
-            var _a;
             /** @description update hover */
-            const ghostText = (_a = part.controller.model.read(reader)) === null || _a === void 0 ? void 0 : _a.ghostText.read(reader);
+            const ghostText = part.controller.model.read(reader)?.ghostText.read(reader);
             if (ghostText) {
                 const lineText = this._editor.getModel().getLineContent(ghostText.lineNumber);
                 render(ghostText.renderForScreenReader(lineText));
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/inlineCompletionContextKeys.js b/vs/editor/contrib/inlineCompletions/browser/inlineCompletionContextKeys.js
--- a/vs/editor/contrib/inlineCompletions/browser/inlineCompletionContextKeys.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/inlineCompletionContextKeys.js	2023-12-06 14:23:14.379854783 +0000
@@ -7,7 +7,7 @@
 import { CursorColumns } from '../../../common/core/cursorColumns.js';
 import { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';
 import { Disposable } from '../../../../base/common/lifecycle.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 export class InlineCompletionContextKeys extends Disposable {
     constructor(contextKeyService, model) {
         super();
@@ -20,10 +20,10 @@
         this._register(autorun(reader => {
             /** @description update context key: inlineCompletionVisible, suppressSuggestions */
             const model = this.model.read(reader);
-            const state = model === null || model === void 0 ? void 0 : model.state.read(reader);
-            const isInlineCompletionVisible = !!(state === null || state === void 0 ? void 0 : state.inlineCompletion) && (state === null || state === void 0 ? void 0 : state.ghostText) !== undefined && !(state === null || state === void 0 ? void 0 : state.ghostText.isEmpty());
+            const state = model?.state.read(reader);
+            const isInlineCompletionVisible = !!state?.inlineCompletion && state?.ghostText !== undefined && !state?.ghostText.isEmpty();
             this.inlineCompletionVisible.set(isInlineCompletionVisible);
-            if ((state === null || state === void 0 ? void 0 : state.ghostText) && (state === null || state === void 0 ? void 0 : state.inlineCompletion)) {
+            if (state?.ghostText && state?.inlineCompletion) {
                 this.suppressSuggestions.set(state.inlineCompletion.inlineCompletion.source.inlineCompletions.suppressSuggestions);
             }
         }));
@@ -32,8 +32,8 @@
             const model = this.model.read(reader);
             let startsWithIndentation = false;
             let startsWithIndentationLessThanTabSize = true;
-            const ghostText = model === null || model === void 0 ? void 0 : model.ghostText.read(reader);
-            if (!!(model === null || model === void 0 ? void 0 : model.selectedSuggestItem) && ghostText && ghostText.parts.length > 0) {
+            const ghostText = model?.ghostText.read(reader);
+            if (!!model?.selectedSuggestItem && ghostText && ghostText.parts.length > 0) {
                 const { column, lines } = ghostText.parts[0];
                 const firstLine = lines[0];
                 const indentationEndColumn = model.textModel.getLineIndentColumn(ghostText.lineNumber);
@@ -54,7 +54,7 @@
         }));
     }
 }
-InlineCompletionContextKeys.inlineSuggestionVisible = new RawContextKey('inlineSuggestionVisible', false, localize('inlineSuggestionVisible', "Whether an inline suggestion is visible"));
-InlineCompletionContextKeys.inlineSuggestionHasIndentation = new RawContextKey('inlineSuggestionHasIndentation', false, localize('inlineSuggestionHasIndentation', "Whether the inline suggestion starts with whitespace"));
-InlineCompletionContextKeys.inlineSuggestionHasIndentationLessThanTabSize = new RawContextKey('inlineSuggestionHasIndentationLessThanTabSize', true, localize('inlineSuggestionHasIndentationLessThanTabSize', "Whether the inline suggestion starts with whitespace that is less than what would be inserted by tab"));
-InlineCompletionContextKeys.suppressSuggestions = new RawContextKey('inlineSuggestionSuppressSuggestions', undefined, localize('suppressSuggestions', "Whether suggestions should be suppressed for the current suggestion"));
+InlineCompletionContextKeys.inlineSuggestionVisible = new RawContextKey('inlineSuggestionVisible', false, localizeWithPath('vs/editor/contrib/inlineCompletions/browser/inlineCompletionContextKeys', 'inlineSuggestionVisible', "Whether an inline suggestion is visible"));
+InlineCompletionContextKeys.inlineSuggestionHasIndentation = new RawContextKey('inlineSuggestionHasIndentation', false, localizeWithPath('vs/editor/contrib/inlineCompletions/browser/inlineCompletionContextKeys', 'inlineSuggestionHasIndentation', "Whether the inline suggestion starts with whitespace"));
+InlineCompletionContextKeys.inlineSuggestionHasIndentationLessThanTabSize = new RawContextKey('inlineSuggestionHasIndentationLessThanTabSize', true, localizeWithPath('vs/editor/contrib/inlineCompletions/browser/inlineCompletionContextKeys', 'inlineSuggestionHasIndentationLessThanTabSize', "Whether the inline suggestion starts with whitespace that is less than what would be inserted by tab"));
+InlineCompletionContextKeys.suppressSuggestions = new RawContextKey('inlineSuggestionSuppressSuggestions', undefined, localizeWithPath('vs/editor/contrib/inlineCompletions/browser/inlineCompletionContextKeys', 'suppressSuggestions', "Whether suggestions should be suppressed for the current suggestion"));
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsController.js b/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsController.js
--- a/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsController.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsController.js	2023-12-06 14:23:14.379854783 +0000
@@ -26,7 +26,7 @@
 import { InlineCompletionsHintsWidget, InlineSuggestionHintsContentWidget } from './inlineCompletionsHintsWidget.js';
 import { InlineCompletionsModel, VersionIdChangeReason } from './inlineCompletionsModel.js';
 import { SuggestWidgetAdaptor } from './suggestWidgetInlineCompletionProvider.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { AudioCue, IAudioCueService } from '../../../../platform/audioCues/browser/audioCueService.js';
 import { ICommandService } from '../../../../platform/commands/common/commands.js';
 import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
@@ -51,19 +51,18 @@
         this.model = disposableObservableValue('inlineCompletionModel', undefined);
         this.textModelVersionId = observableValue(this, -1);
         this.cursorPosition = observableValue(this, new Position(1, 1));
-        this.suggestWidgetAdaptor = this._register(new SuggestWidgetAdaptor(this.editor, () => { var _a, _b; return (_b = (_a = this.model.get()) === null || _a === void 0 ? void 0 : _a.selectedInlineCompletion.get()) === null || _b === void 0 ? void 0 : _b.toSingleTextEdit(undefined); }, (tx) => this.updateObservables(tx, VersionIdChangeReason.Other), (item) => {
+        this.suggestWidgetAdaptor = this._register(new SuggestWidgetAdaptor(this.editor, () => this.model.get()?.selectedInlineCompletion.get()?.toSingleTextEdit(undefined), (tx) => this.updateObservables(tx, VersionIdChangeReason.Other), (item) => {
             transaction(tx => {
-                var _a;
                 /** @description handleSuggestAccepted */
                 this.updateObservables(tx, VersionIdChangeReason.Other);
-                (_a = this.model.get()) === null || _a === void 0 ? void 0 : _a.handleSuggestAccepted(item);
+                this.model.get()?.handleSuggestAccepted(item);
             });
         }));
         this._enabled = observableFromEvent(this.editor.onDidChangeConfiguration, () => this.editor.getOption(62 /* EditorOption.inlineSuggest */).enabled);
         this.ghostTextWidget = this._register(this.instantiationService.createInstance(GhostTextWidget, this.editor, {
-            ghostText: this.model.map((v, reader) => v === null || v === void 0 ? void 0 : v.ghostText.read(reader)),
+            ghostText: this.model.map((v, reader) => v?.ghostText.read(reader)),
             minReservedLineCount: constObservable(0),
-            targetTextModel: this.model.map(v => v === null || v === void 0 ? void 0 : v.textModel),
+            targetTextModel: this.model.map(v => v?.textModel),
         }));
         this._debounceValue = this.debounceService.for(this.languageFeaturesService.inlineCompletionsProvider, 'InlineCompletionsDebounce', { min: 50, max: 50 });
         this._register(new InlineCompletionContextKeys(this.contextKeyService, this.model));
@@ -78,14 +77,13 @@
             }
         })));
         const getReason = (e) => {
-            var _a;
             if (e.isUndoing) {
                 return VersionIdChangeReason.Undo;
             }
             if (e.isRedoing) {
                 return VersionIdChangeReason.Redo;
             }
-            if ((_a = this.model.get()) === null || _a === void 0 ? void 0 : _a.isAcceptingPartially) {
+            if (this.model.get()?.isAcceptingPartially) {
                 return VersionIdChangeReason.AcceptWord;
             }
             return VersionIdChangeReason.Other;
@@ -94,19 +92,17 @@
         /** @description onDidChangeModelContent */
         this.updateObservables(tx, getReason(e)))));
         this._register(editor.onDidChangeCursorPosition(e => transaction(tx => {
-            var _a;
             /** @description onDidChangeCursorPosition */
             this.updateObservables(tx, VersionIdChangeReason.Other);
             if (e.reason === 3 /* CursorChangeReason.Explicit */ || e.source === 'api') {
-                (_a = this.model.get()) === null || _a === void 0 ? void 0 : _a.stop(tx);
+                this.model.get()?.stop(tx);
             }
         })));
         this._register(editor.onDidType(() => transaction(tx => {
-            var _a;
             /** @description onDidType */
             this.updateObservables(tx, VersionIdChangeReason.Other);
             if (this._enabled.get()) {
-                (_a = this.model.get()) === null || _a === void 0 ? void 0 : _a.trigger(tx);
+                this.model.get()?.trigger(tx);
             }
         })));
         this._register(this.commandService.onDidExecuteCommand((e) => {
@@ -120,9 +116,8 @@
             ]);
             if (commands.has(e.commandId) && editor.hasTextFocus() && this._enabled.get()) {
                 transaction(tx => {
-                    var _a;
                     /** @description onDidExecuteCommand */
-                    (_a = this.model.get()) === null || _a === void 0 ? void 0 : _a.trigger(tx);
+                    this.model.get()?.trigger(tx);
                 });
             }
         }));
@@ -136,16 +131,14 @@
                 return;
             }
             transaction(tx => {
-                var _a;
                 /** @description onDidBlurEditorWidget */
-                (_a = this.model.get()) === null || _a === void 0 ? void 0 : _a.stop(tx);
+                this.model.get()?.stop(tx);
             });
         }));
         this._register(autorun(reader => {
-            var _a;
             /** @description forceRenderingAbove */
-            const state = (_a = this.model.read(reader)) === null || _a === void 0 ? void 0 : _a.state.read(reader);
-            if (state === null || state === void 0 ? void 0 : state.suggestItem) {
+            const state = this.model.read(reader)?.state.read(reader);
+            if (state?.suggestItem) {
                 if (state.ghostText.lineCount >= 2) {
                     this.suggestWidgetAdaptor.forceRenderingAbove();
                 }
@@ -161,7 +154,7 @@
         this._register(autorun(reader => {
             /** @description play audio cue & read suggestion */
             const model = this.model.read(reader);
-            const state = model === null || model === void 0 ? void 0 : model.state.read(reader);
+            const state = model?.state.read(reader);
             if (!model || !state || !state.inlineCompletion) {
                 lastInlineCompletionId = undefined;
                 return;
@@ -189,7 +182,7 @@
         const accessibleViewKeybinding = this._keybindingService.lookupKeybinding('editor.action.accessibleView');
         let hint;
         if (!accessibleViewShowing && accessibleViewKeybinding && this.editor.getOption(147 /* EditorOption.inlineCompletionsAccessibilityVerbose */)) {
-            hint = localize('showAccessibleViewHint', "Inspect this in the accessible view ({0})", accessibleViewKeybinding.getAriaLabel());
+            hint = localizeWithPath('vs/editor/contrib/inlineCompletions/browser/inlineCompletionsController', 'showAccessibleViewHint', "Inspect this in the accessible view ({0})", accessibleViewKeybinding.getAriaLabel());
         }
         hint ? alert(content + ', ' + hint) : alert(content);
     }
@@ -199,14 +192,12 @@
      * regardless of who calls into us.
      */
     updateObservables(tx, changeReason) {
-        var _a, _b;
         const newModel = this.editor.getModel();
-        this.textModelVersionId.set((_a = newModel === null || newModel === void 0 ? void 0 : newModel.getVersionId()) !== null && _a !== void 0 ? _a : -1, tx, changeReason);
-        this.cursorPosition.set((_b = this.editor.getPosition()) !== null && _b !== void 0 ? _b : new Position(1, 1), tx);
+        this.textModelVersionId.set(newModel?.getVersionId() ?? -1, tx, changeReason);
+        this.cursorPosition.set(this.editor.getPosition() ?? new Position(1, 1), tx);
     }
     shouldShowHoverAt(range) {
-        var _a;
-        const ghostText = (_a = this.model.get()) === null || _a === void 0 ? void 0 : _a.ghostText.get();
+        const ghostText = this.model.get()?.ghostText.get();
         if (ghostText) {
             return ghostText.parts.some(p => range.containsPosition(new Position(ghostText.lineNumber, p.column)));
         }
@@ -215,6 +206,11 @@
     shouldShowHoverAtViewZone(viewZoneId) {
         return this.ghostTextWidget.ownsViewZone(viewZoneId);
     }
+    hide() {
+        transaction(tx => {
+            this.model.get()?.stop(tx);
+        });
+    }
 };
 InlineCompletionsController.ID = 'editor.contrib.inlineCompletionsController';
 InlineCompletionsController = InlineCompletionsController_1 = __decorate([
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsHintsWidget.js b/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsHintsWidget.js
--- a/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsHintsWidget.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsHintsWidget.js	2023-12-06 14:23:14.379854783 +0000
@@ -27,7 +27,7 @@
 import { Position } from '../../../common/core/position.js';
 import { InlineCompletionTriggerKind } from '../../../common/languages.js';
 import { showNextInlineSuggestionActionId, showPreviousInlineSuggestionActionId } from './commandIds.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { MenuEntryActionViewItem, createAndFillInActionBarActions } from '../../../../platform/actions/browser/menuEntryActionViewItem.js';
 import { WorkbenchToolBar } from '../../../../platform/actions/browser/toolbar.js';
 import { IMenuService, MenuId, MenuItemAction } from '../../../../platform/actions/common/actions.js';
@@ -47,8 +47,7 @@
         this.alwaysShowToolbar = observableFromEvent(this.editor.onDidChangeConfiguration, () => this.editor.getOption(62 /* EditorOption.inlineSuggest */).showToolbar === 'always');
         this.sessionPosition = undefined;
         this.position = derived(this, reader => {
-            var _a, _b, _c;
-            const ghostText = (_a = this.model.read(reader)) === null || _a === void 0 ? void 0 : _a.ghostText.read(reader);
+            const ghostText = this.model.read(reader)?.ghostText.read(reader);
             if (!this.alwaysShowToolbar.read(reader) || !ghostText || ghostText.parts.length === 0) {
                 this.sessionPosition = undefined;
                 return null;
@@ -57,7 +56,7 @@
             if (this.sessionPosition && this.sessionPosition.lineNumber !== ghostText.lineNumber) {
                 this.sessionPosition = undefined;
             }
-            const position = new Position(ghostText.lineNumber, Math.min(firstColumn, (_c = (_b = this.sessionPosition) === null || _b === void 0 ? void 0 : _b.column) !== null && _c !== void 0 ? _c : Number.MAX_SAFE_INTEGER));
+            const position = new Position(ghostText.lineNumber, Math.min(firstColumn, this.sessionPosition?.column ?? Number.MAX_SAFE_INTEGER));
             this.sessionPosition = position;
             return position;
         });
@@ -67,7 +66,7 @@
             if (!model || !this.alwaysShowToolbar.read(reader)) {
                 return;
             }
-            const contentWidget = store.add(this.instantiationService.createInstance(InlineSuggestionHintsContentWidget, this.editor, true, this.position, model.selectedInlineCompletionIndex, model.inlineCompletionsCount, model.selectedInlineCompletion.map(v => { var _a; return (_a = v === null || v === void 0 ? void 0 : v.inlineCompletion.source.inlineCompletions.commands) !== null && _a !== void 0 ? _a : []; })));
+            const contentWidget = store.add(this.instantiationService.createInstance(InlineSuggestionHintsContentWidget, this.editor, true, this.position, model.selectedInlineCompletionIndex, model.inlineCompletionsCount, model.selectedInlineCompletion.map(v => v?.inlineCompletion.source.inlineCompletions.commands ?? [])));
             editor.addContentWidget(contentWidget);
             store.add(toDisposable(() => editor.removeContentWidget(contentWidget)));
             store.add(autorun(reader => {
@@ -87,8 +86,8 @@
     __param(2, IInstantiationService)
 ], InlineCompletionsHintsWidget);
 export { InlineCompletionsHintsWidget };
-const inlineSuggestionHintsNextIcon = registerIcon('inline-suggestion-hints-next', Codicon.chevronRight, localize('parameterHintsNextIcon', 'Icon for show next parameter hint.'));
-const inlineSuggestionHintsPreviousIcon = registerIcon('inline-suggestion-hints-previous', Codicon.chevronLeft, localize('parameterHintsPreviousIcon', 'Icon for show previous parameter hint.'));
+const inlineSuggestionHintsNextIcon = registerIcon('inline-suggestion-hints-next', Codicon.chevronRight, localizeWithPath('vs/editor/contrib/inlineCompletions/browser/inlineCompletionsHintsWidget', 'parameterHintsNextIcon', 'Icon for show next parameter hint.'));
+const inlineSuggestionHintsPreviousIcon = registerIcon('inline-suggestion-hints-previous', Codicon.chevronLeft, localizeWithPath('vs/editor/contrib/inlineCompletions/browser/inlineCompletionsHintsWidget', 'parameterHintsPreviousIcon', 'Icon for show previous parameter hint.'));
 let InlineSuggestionHintsContentWidget = InlineSuggestionHintsContentWidget_1 = class InlineSuggestionHintsContentWidget extends Disposable {
     static get dropDownVisible() { return this._dropDownVisible; }
     createCommandAction(commandId, label, iconClassName) {
@@ -96,7 +95,7 @@
         const kb = this.keybindingService.lookupKeybinding(commandId, this._contextKeyService);
         let tooltip = label;
         if (kb) {
-            tooltip = localize({ key: 'content', comment: ['A label', 'A keybinding'] }, '{0} ({1})', label, kb.getLabel());
+            tooltip = localizeWithPath('vs/editor/contrib/inlineCompletions/browser/inlineCompletionsHintsWidget', { key: 'content', comment: ['A label', 'A keybinding'] }, '{0} ({1})', label, kb.getLabel());
         }
         action.tooltip = tooltip;
         return action;
@@ -119,9 +118,9 @@
         this.nodes = h('div.inlineSuggestionsHints', { className: this.withBorder ? '.withBorder' : '' }, [
             h('div@toolBar'),
         ]);
-        this.previousAction = this.createCommandAction(showPreviousInlineSuggestionActionId, localize('previous', 'Previous'), ThemeIcon.asClassName(inlineSuggestionHintsPreviousIcon));
+        this.previousAction = this.createCommandAction(showPreviousInlineSuggestionActionId, localizeWithPath('vs/editor/contrib/inlineCompletions/browser/inlineCompletionsHintsWidget', 'previous', 'Previous'), ThemeIcon.asClassName(inlineSuggestionHintsPreviousIcon));
         this.availableSuggestionCountAction = new Action('inlineSuggestionHints.availableSuggestionCount', '', undefined, false);
-        this.nextAction = this.createCommandAction(showNextInlineSuggestionActionId, localize('next', 'Next'), ThemeIcon.asClassName(inlineSuggestionHintsNextIcon));
+        this.nextAction = this.createCommandAction(showNextInlineSuggestionActionId, localizeWithPath('vs/editor/contrib/inlineCompletions/browser/inlineCompletionsHintsWidget', 'next', 'Next'), ThemeIcon.asClassName(inlineSuggestionHintsNextIcon));
         // TODO@hediet: deprecate MenuId.InlineCompletionsActions
         this.inlineCompletionsActionsMenus = this._register(this._menuService.createMenu(MenuId.InlineCompletionsActions, this._contextKeyService));
         this.clearAvailableSuggestionCountLabelDebounced = this._register(new RunOnceScheduler(() => {
@@ -255,7 +254,7 @@
         }
         if (this.label) {
             const div = h('div.keybinding').root;
-            const k = new KeybindingLabel(div, OS, Object.assign({ disableTitle: true }, unthemedKeybindingLabelOptions));
+            const k = new KeybindingLabel(div, OS, { disableTitle: true, ...unthemedKeybindingLabelOptions });
             k.set(kb);
             this.label.textContent = this._action.label;
             this.label.appendChild(div);
@@ -265,7 +264,7 @@
 }
 let CustomizedMenuWorkbenchToolBar = class CustomizedMenuWorkbenchToolBar extends WorkbenchToolBar {
     constructor(container, menuId, options2, menuService, contextKeyService, contextMenuService, keybindingService, telemetryService) {
-        super(container, Object.assign({ resetMenu: menuId }, options2), menuService, contextKeyService, contextMenuService, keybindingService, telemetryService);
+        super(container, { resetMenu: menuId, ...options2 }, menuService, contextKeyService, contextMenuService, keybindingService, telemetryService);
         this.menuId = menuId;
         this.options2 = options2;
         this.menuService = menuService;
@@ -277,10 +276,9 @@
         this.updateToolbar();
     }
     updateToolbar() {
-        var _a, _b, _c, _d, _e, _f, _g;
         const primary = [];
         const secondary = [];
-        createAndFillInActionBarActions(this.menu, (_a = this.options2) === null || _a === void 0 ? void 0 : _a.menuOptions, { primary, secondary }, (_c = (_b = this.options2) === null || _b === void 0 ? void 0 : _b.toolbarOptions) === null || _c === void 0 ? void 0 : _c.primaryGroup, (_e = (_d = this.options2) === null || _d === void 0 ? void 0 : _d.toolbarOptions) === null || _e === void 0 ? void 0 : _e.shouldInlineSubmenu, (_g = (_f = this.options2) === null || _f === void 0 ? void 0 : _f.toolbarOptions) === null || _g === void 0 ? void 0 : _g.useSeparatorsInPrimaryActions);
+        createAndFillInActionBarActions(this.menu, this.options2?.menuOptions, { primary, secondary }, this.options2?.toolbarOptions?.primaryGroup, this.options2?.toolbarOptions?.shouldInlineSubmenu, this.options2?.toolbarOptions?.useSeparatorsInPrimaryActions);
         secondary.push(...this.additionalActions);
         primary.unshift(...this.prependedPrimaryActions);
         this.setActions(primary, secondary);
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsModel.js b/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsModel.js
--- a/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsModel.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsModel.js	2023-12-06 14:23:14.379854783 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { mapFindFirst } from '../../../../base/common/arraysFind.js';
 import { BugIndicatingError, onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { Disposable } from '../../../../base/common/lifecycle.js';
@@ -95,7 +86,7 @@
             }
             this.textModelVersionId.read(reader); // Refetch on text change
             const itemToPreserveCandidate = this.selectedInlineCompletion.get();
-            const itemToPreserve = changeSummary.preserveCurrentCompletion || (itemToPreserveCandidate === null || itemToPreserveCandidate === void 0 ? void 0 : itemToPreserveCandidate.forwardStable)
+            const itemToPreserve = changeSummary.preserveCurrentCompletion || itemToPreserveCandidate?.forwardStable
                 ? itemToPreserveCandidate : undefined;
             const suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.get();
             const suggestItem = this.selectedSuggestItem.read(reader);
@@ -112,7 +103,7 @@
             const cursorPosition = this.cursorPosition.read(reader);
             const context = {
                 triggerKind: changeSummary.inlineCompletionTriggerKind,
-                selectedSuggestionInfo: suggestItem === null || suggestItem === void 0 ? void 0 : suggestItem.toSelectedSuggestionInfo(),
+                selectedSuggestionInfo: suggestItem?.toSelectedSuggestionInfo(),
             };
             return this._source.fetch(cursorPosition, context, itemToPreserve);
         });
@@ -142,7 +133,7 @@
             const idx = this.selectedInlineCompletionIndex.read(reader);
             return filteredCompletions[idx];
         });
-        this.lastTriggerKind = this._source.inlineCompletions.map(v => /** @description lastTriggerKind */ v === null || v === void 0 ? void 0 : v.request.context.triggerKind);
+        this.lastTriggerKind = this._source.inlineCompletions.map(v => /** @description lastTriggerKind */ v?.request.context.triggerKind);
         this.inlineCompletionsCount = derived(this, reader => {
             if (this.lastTriggerKind.read(reader) === InlineCompletionTriggerKind.Explicit) {
                 return this._filteredInlineCompletionItems.read(reader).length;
@@ -162,7 +153,6 @@
                     && a.suggestItem === b.suggestItem;
             }
         }, (reader) => {
-            var _a;
             const model = this.textModel;
             const suggestItem = this.selectedSuggestItem.read(reader);
             if (suggestItem) {
@@ -172,14 +162,14 @@
                 if (!isSuggestionPreviewEnabled && !augmentedCompletion) {
                     return undefined;
                 }
-                const edit = (_a = augmentedCompletion === null || augmentedCompletion === void 0 ? void 0 : augmentedCompletion.edit) !== null && _a !== void 0 ? _a : suggestCompletion;
+                const edit = augmentedCompletion?.edit ?? suggestCompletion;
                 const editPreviewLength = augmentedCompletion ? augmentedCompletion.edit.text.length - suggestCompletion.text.length : 0;
                 const mode = this._suggestPreviewMode.read(reader);
                 const cursor = this.cursorPosition.read(reader);
                 const newGhostText = edit.computeGhostText(model, mode, cursor, editPreviewLength);
                 // Show an invisible ghost text to reserve space
-                const ghostText = newGhostText !== null && newGhostText !== void 0 ? newGhostText : new GhostText(edit.range.endLineNumber, []);
-                return { ghostText, inlineCompletion: augmentedCompletion === null || augmentedCompletion === void 0 ? void 0 : augmentedCompletion.completion, suggestItem };
+                const ghostText = newGhostText ?? new GhostText(edit.range.endLineNumber, []);
+                return { ghostText, inlineCompletion: augmentedCompletion?.completion, suggestItem };
             }
             else {
                 if (!this._isActive.read(reader)) {
@@ -209,34 +199,29 @@
         this._register(recomputeInitiallyAndOnChange(this._fetchInlineCompletions));
         let lastItem = undefined;
         this._register(autorun(reader => {
-            var _a, _b;
             /** @description call handleItemDidShow */
             const item = this.state.read(reader);
-            const completion = item === null || item === void 0 ? void 0 : item.inlineCompletion;
-            if ((completion === null || completion === void 0 ? void 0 : completion.semanticId) !== (lastItem === null || lastItem === void 0 ? void 0 : lastItem.semanticId)) {
+            const completion = item?.inlineCompletion;
+            if (completion?.semanticId !== lastItem?.semanticId) {
                 lastItem = completion;
                 if (completion) {
                     const i = completion.inlineCompletion;
                     const src = i.source;
-                    (_b = (_a = src.provider).handleItemDidShow) === null || _b === void 0 ? void 0 : _b.call(_a, src.inlineCompletions, i.sourceInlineCompletion, i.insertText);
+                    src.provider.handleItemDidShow?.(src.inlineCompletions, i.sourceInlineCompletion, i.insertText);
                 }
             }
         }));
     }
-    trigger(tx) {
-        return __awaiter(this, void 0, void 0, function* () {
-            this._isActive.set(true, tx);
-            yield this._fetchInlineCompletions.get();
-        });
+    async trigger(tx) {
+        this._isActive.set(true, tx);
+        await this._fetchInlineCompletions.get();
     }
-    triggerExplicitly(tx) {
-        return __awaiter(this, void 0, void 0, function* () {
-            subtransaction(tx, tx => {
-                this._isActive.set(true, tx);
-                this._forceUpdate.trigger(tx, InlineCompletionTriggerKind.Explicit);
-            });
-            yield this._fetchInlineCompletions.get();
+    async triggerExplicitly(tx) {
+        subtransaction(tx, tx => {
+            this._isActive.set(true, tx);
+            this._forceUpdate.trigger(tx, InlineCompletionTriggerKind.Explicit);
         });
+        await this._fetchInlineCompletions.get();
     }
     stop(tx) {
         subtransaction(tx, tx => {
@@ -257,169 +242,153 @@
         });
         return augmentedCompletion;
     }
-    _deltaSelectedInlineCompletionIndex(delta) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield this.triggerExplicitly();
-            const completions = this._filteredInlineCompletionItems.get() || [];
-            if (completions.length > 0) {
-                const newIdx = (this.selectedInlineCompletionIndex.get() + delta + completions.length) % completions.length;
-                this._selectedInlineCompletionId.set(completions[newIdx].semanticId, undefined);
-            }
-            else {
-                this._selectedInlineCompletionId.set(undefined, undefined);
-            }
-        });
+    async _deltaSelectedInlineCompletionIndex(delta) {
+        await this.triggerExplicitly();
+        const completions = this._filteredInlineCompletionItems.get() || [];
+        if (completions.length > 0) {
+            const newIdx = (this.selectedInlineCompletionIndex.get() + delta + completions.length) % completions.length;
+            this._selectedInlineCompletionId.set(completions[newIdx].semanticId, undefined);
+        }
+        else {
+            this._selectedInlineCompletionId.set(undefined, undefined);
+        }
     }
-    next() {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield this._deltaSelectedInlineCompletionIndex(1);
-        });
+    async next() {
+        await this._deltaSelectedInlineCompletionIndex(1);
     }
-    previous() {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield this._deltaSelectedInlineCompletionIndex(-1);
-        });
+    async previous() {
+        await this._deltaSelectedInlineCompletionIndex(-1);
     }
-    accept(editor) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            if (editor.getModel() !== this.textModel) {
-                throw new BugIndicatingError();
-            }
-            const state = this.state.get();
-            if (!state || state.ghostText.isEmpty() || !state.inlineCompletion) {
-                return;
-            }
-            const completion = state.inlineCompletion.toInlineCompletion(undefined);
-            editor.pushUndoStop();
-            if (completion.snippetInfo) {
-                editor.executeEdits('inlineSuggestion.accept', [
-                    EditOperation.replaceMove(completion.range, ''),
-                    ...completion.additionalTextEdits
-                ]);
-                editor.setPosition(completion.snippetInfo.range.getStartPosition());
-                (_a = SnippetController2.get(editor)) === null || _a === void 0 ? void 0 : _a.insert(completion.snippetInfo.snippet, { undoStopBefore: false });
-            }
-            else {
-                editor.executeEdits('inlineSuggestion.accept', [
-                    EditOperation.replaceMove(completion.range, completion.insertText),
-                    ...completion.additionalTextEdits
-                ]);
-            }
-            if (completion.command) {
-                // Make sure the completion list will not be disposed.
-                completion.source.addRef();
-            }
-            // Reset before invoking the command, since the command might cause a follow up trigger.
-            transaction(tx => {
-                this._source.clear(tx);
-                // Potentially, isActive will get set back to true by the typing or accept inline suggest event
-                // if automatic inline suggestions are enabled.
-                this._isActive.set(false, tx);
-            });
-            if (completion.command) {
-                yield this._commandService
-                    .executeCommand(completion.command.id, ...(completion.command.arguments || []))
-                    .then(undefined, onUnexpectedExternalError);
-                completion.source.removeRef();
-            }
+    async accept(editor) {
+        if (editor.getModel() !== this.textModel) {
+            throw new BugIndicatingError();
+        }
+        const state = this.state.get();
+        if (!state || state.ghostText.isEmpty() || !state.inlineCompletion) {
+            return;
+        }
+        const completion = state.inlineCompletion.toInlineCompletion(undefined);
+        editor.pushUndoStop();
+        if (completion.snippetInfo) {
+            editor.executeEdits('inlineSuggestion.accept', [
+                EditOperation.replaceMove(completion.range, ''),
+                ...completion.additionalTextEdits
+            ]);
+            editor.setPosition(completion.snippetInfo.range.getStartPosition());
+            SnippetController2.get(editor)?.insert(completion.snippetInfo.snippet, { undoStopBefore: false });
+        }
+        else {
+            editor.executeEdits('inlineSuggestion.accept', [
+                EditOperation.replaceMove(completion.range, completion.insertText),
+                ...completion.additionalTextEdits
+            ]);
+        }
+        if (completion.command) {
+            // Make sure the completion list will not be disposed.
+            completion.source.addRef();
+        }
+        // Reset before invoking the command, since the command might cause a follow up trigger.
+        transaction(tx => {
+            this._source.clear(tx);
+            // Potentially, isActive will get set back to true by the typing or accept inline suggest event
+            // if automatic inline suggestions are enabled.
+            this._isActive.set(false, tx);
         });
+        if (completion.command) {
+            await this._commandService
+                .executeCommand(completion.command.id, ...(completion.command.arguments || []))
+                .then(undefined, onUnexpectedExternalError);
+            completion.source.removeRef();
+        }
     }
-    acceptNextWord(editor) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield this._acceptNext(editor, (pos, text) => {
-                const langId = this.textModel.getLanguageIdAtPosition(pos.lineNumber, pos.column);
-                const config = this._languageConfigurationService.getLanguageConfiguration(langId);
-                const wordRegExp = new RegExp(config.wordDefinition.source, config.wordDefinition.flags.replace('g', ''));
-                const m1 = text.match(wordRegExp);
-                let acceptUntilIndexExclusive = 0;
-                if (m1 && m1.index !== undefined) {
-                    if (m1.index === 0) {
-                        acceptUntilIndexExclusive = m1[0].length;
-                    }
-                    else {
-                        acceptUntilIndexExclusive = m1.index;
-                    }
+    async acceptNextWord(editor) {
+        await this._acceptNext(editor, (pos, text) => {
+            const langId = this.textModel.getLanguageIdAtPosition(pos.lineNumber, pos.column);
+            const config = this._languageConfigurationService.getLanguageConfiguration(langId);
+            const wordRegExp = new RegExp(config.wordDefinition.source, config.wordDefinition.flags.replace('g', ''));
+            const m1 = text.match(wordRegExp);
+            let acceptUntilIndexExclusive = 0;
+            if (m1 && m1.index !== undefined) {
+                if (m1.index === 0) {
+                    acceptUntilIndexExclusive = m1[0].length;
                 }
                 else {
-                    acceptUntilIndexExclusive = text.length;
-                }
-                const wsRegExp = /\s+/g;
-                const m2 = wsRegExp.exec(text);
-                if (m2 && m2.index !== undefined) {
-                    if (m2.index + m2[0].length < acceptUntilIndexExclusive) {
-                        acceptUntilIndexExclusive = m2.index + m2[0].length;
-                    }
+                    acceptUntilIndexExclusive = m1.index;
                 }
-                return acceptUntilIndexExclusive;
-            });
-        });
-    }
-    acceptNextLine(editor) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield this._acceptNext(editor, (pos, text) => {
-                const m = text.match(/\n/);
-                if (m && m.index !== undefined) {
-                    return m.index + 1;
+            }
+            else {
+                acceptUntilIndexExclusive = text.length;
+            }
+            const wsRegExp = /\s+/g;
+            const m2 = wsRegExp.exec(text);
+            if (m2 && m2.index !== undefined) {
+                if (m2.index + m2[0].length < acceptUntilIndexExclusive) {
+                    acceptUntilIndexExclusive = m2.index + m2[0].length;
                 }
-                return text.length;
-            });
+            }
+            return acceptUntilIndexExclusive;
         });
     }
-    _acceptNext(editor, getAcceptUntilIndex) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (editor.getModel() !== this.textModel) {
-                throw new BugIndicatingError();
-            }
-            const state = this.state.get();
-            if (!state || state.ghostText.isEmpty() || !state.inlineCompletion) {
-                return;
-            }
-            const ghostText = state.ghostText;
-            const completion = state.inlineCompletion.toInlineCompletion(undefined);
-            if (completion.snippetInfo || completion.filterText !== completion.insertText) {
-                // not in WYSIWYG mode, partial commit might change completion, thus it is not supported
-                yield this.accept(editor);
-                return;
-            }
-            const firstPart = ghostText.parts[0];
-            const position = new Position(ghostText.lineNumber, firstPart.column);
-            const line = firstPart.lines.join('\n');
-            const acceptUntilIndexExclusive = getAcceptUntilIndex(position, line);
-            if (acceptUntilIndexExclusive === line.length && ghostText.parts.length === 1) {
-                this.accept(editor);
-                return;
-            }
-            const partialText = line.substring(0, acceptUntilIndexExclusive);
-            this._isAcceptingPartially = true;
-            try {
-                editor.pushUndoStop();
-                editor.executeEdits('inlineSuggestion.accept', [
-                    EditOperation.replace(Range.fromPositions(position), partialText),
-                ]);
-                const length = lengthOfText(partialText);
-                editor.setPosition(addPositions(position, length));
-            }
-            finally {
-                this._isAcceptingPartially = false;
-            }
-            if (completion.source.provider.handlePartialAccept) {
-                const acceptedRange = Range.fromPositions(completion.range.getStartPosition(), addPositions(position, lengthOfText(partialText)));
-                // This assumes that the inline completion and the model use the same EOL style.
-                const text = editor.getModel().getValueInRange(acceptedRange, 1 /* EndOfLinePreference.LF */);
-                completion.source.provider.handlePartialAccept(completion.source.inlineCompletions, completion.sourceInlineCompletion, text.length);
+    async acceptNextLine(editor) {
+        await this._acceptNext(editor, (pos, text) => {
+            const m = text.match(/\n/);
+            if (m && m.index !== undefined) {
+                return m.index + 1;
             }
+            return text.length;
         });
     }
+    async _acceptNext(editor, getAcceptUntilIndex) {
+        if (editor.getModel() !== this.textModel) {
+            throw new BugIndicatingError();
+        }
+        const state = this.state.get();
+        if (!state || state.ghostText.isEmpty() || !state.inlineCompletion) {
+            return;
+        }
+        const ghostText = state.ghostText;
+        const completion = state.inlineCompletion.toInlineCompletion(undefined);
+        if (completion.snippetInfo || completion.filterText !== completion.insertText) {
+            // not in WYSIWYG mode, partial commit might change completion, thus it is not supported
+            await this.accept(editor);
+            return;
+        }
+        const firstPart = ghostText.parts[0];
+        const position = new Position(ghostText.lineNumber, firstPart.column);
+        const line = firstPart.lines.join('\n');
+        const acceptUntilIndexExclusive = getAcceptUntilIndex(position, line);
+        if (acceptUntilIndexExclusive === line.length && ghostText.parts.length === 1) {
+            this.accept(editor);
+            return;
+        }
+        const partialText = line.substring(0, acceptUntilIndexExclusive);
+        this._isAcceptingPartially = true;
+        try {
+            editor.pushUndoStop();
+            editor.executeEdits('inlineSuggestion.accept', [
+                EditOperation.replace(Range.fromPositions(position), partialText),
+            ]);
+            const length = lengthOfText(partialText);
+            editor.setPosition(addPositions(position, length));
+        }
+        finally {
+            this._isAcceptingPartially = false;
+        }
+        if (completion.source.provider.handlePartialAccept) {
+            const acceptedRange = Range.fromPositions(completion.range.getStartPosition(), addPositions(position, lengthOfText(partialText)));
+            // This assumes that the inline completion and the model use the same EOL style.
+            const text = editor.getModel().getValueInRange(acceptedRange, 1 /* EndOfLinePreference.LF */);
+            completion.source.provider.handlePartialAccept(completion.source.inlineCompletions, completion.sourceInlineCompletion, text.length);
+        }
+    }
     handleSuggestAccepted(item) {
-        var _a, _b;
         const itemEdit = item.toSingleTextEdit().removeCommonPrefix(this.textModel);
         const augmentedCompletion = this._computeAugmentedCompletion(itemEdit, undefined);
         if (!augmentedCompletion) {
             return;
         }
         const inlineCompletion = augmentedCompletion.completion.inlineCompletion;
-        (_b = (_a = inlineCompletion.source.provider).handlePartialAccept) === null || _b === void 0 ? void 0 : _b.call(_a, inlineCompletion.source.inlineCompletions, inlineCompletion.sourceInlineCompletion, itemEdit.text.length);
+        inlineCompletion.source.provider.handlePartialAccept?.(inlineCompletion.source.inlineCompletions, inlineCompletion.sourceInlineCompletion, itemEdit.text.length);
     }
 };
 InlineCompletionsModel = __decorate([
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsSource.js b/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsSource.js
--- a/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsSource.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsSource.js	2023-12-06 14:23:14.379854783 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { CancellationTokenSource } from '../../../../base/common/cancellation.js';
 import { matchesSubString } from '../../../../base/common/filters.js';
 import { Disposable, MutableDisposable } from '../../../../base/common/lifecycle.js';
@@ -46,29 +37,28 @@
         }));
     }
     fetch(position, context, activeInlineCompletion) {
-        var _a, _b;
         const request = new UpdateRequest(position, context, this.textModel.getVersionId());
         const target = context.selectedSuggestionInfo ? this.suggestWidgetInlineCompletions : this.inlineCompletions;
-        if ((_a = this._updateOperation.value) === null || _a === void 0 ? void 0 : _a.request.satisfies(request)) {
+        if (this._updateOperation.value?.request.satisfies(request)) {
             return this._updateOperation.value.promise;
         }
-        else if ((_b = target.get()) === null || _b === void 0 ? void 0 : _b.request.satisfies(request)) {
+        else if (target.get()?.request.satisfies(request)) {
             return Promise.resolve(true);
         }
         const updateOngoing = !!this._updateOperation.value;
         this._updateOperation.clear();
         const source = new CancellationTokenSource();
-        const promise = (() => __awaiter(this, void 0, void 0, function* () {
+        const promise = (async () => {
             const shouldDebounce = updateOngoing || context.triggerKind === InlineCompletionTriggerKind.Automatic;
             if (shouldDebounce) {
                 // This debounces the operation
-                yield wait(this._debounceValue.get(this.textModel));
+                await wait(this._debounceValue.get(this.textModel));
             }
             if (source.token.isCancellationRequested || this.textModel.getVersionId() !== request.versionId) {
                 return false;
             }
             const startTime = new Date();
-            const updatedCompletions = yield provideInlineCompletions(this.languageFeaturesService.inlineCompletionsProvider, position, this.textModel, context, source.token, this.languageConfigurationService);
+            const updatedCompletions = await provideInlineCompletions(this.languageFeaturesService.inlineCompletionsProvider, position, this.textModel, context, source.token, this.languageConfigurationService);
             if (source.token.isCancellationRequested || this.textModel.getVersionId() !== request.versionId) {
                 return false;
             }
@@ -87,7 +77,7 @@
                 target.set(completions, tx);
             });
             return true;
-        }))();
+        })();
         const updateOperation = new UpdateOperation(request, source, promise);
         this._updateOperation.value = updateOperation;
         return promise;
@@ -98,8 +88,7 @@
         this.suggestWidgetInlineCompletions.set(undefined, tx);
     }
     clearSuggestWidgetInlineCompletions(tx) {
-        var _a;
-        if ((_a = this._updateOperation.value) === null || _a === void 0 ? void 0 : _a.request.context.selectedSuggestionInfo) {
+        if (this._updateOperation.value?.request.context.selectedSuggestionInfo) {
             this._updateOperation.clear();
         }
         this.suggestWidgetInlineCompletions.set(undefined, tx);
@@ -228,8 +217,7 @@
 }
 export class InlineCompletionWithUpdatedRange {
     get forwardStable() {
-        var _a;
-        return (_a = this.inlineCompletion.source.inlineCompletions.enableForwardStability) !== null && _a !== void 0 ? _a : false;
+        return this.inlineCompletion.source.inlineCompletions.enableForwardStability ?? false;
     }
     constructor(inlineCompletion, decorationId, rangeVersion, initialRange) {
         this.inlineCompletion = inlineCompletion;
@@ -241,7 +229,7 @@
             this.inlineCompletion.range.getStartPosition().toString()
         ]);
         this._isValid = true;
-        this._updatedRange = initialRange !== null && initialRange !== void 0 ? initialRange : inlineCompletion.range;
+        this._updatedRange = initialRange ?? inlineCompletion.range;
     }
     toInlineCompletion(reader) {
         return this.inlineCompletion.withRange(this._getUpdatedRange(reader));
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/provideInlineCompletions.js b/vs/editor/contrib/inlineCompletions/browser/provideInlineCompletions.js
--- a/vs/editor/contrib/inlineCompletions/browser/provideInlineCompletions.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/provideInlineCompletions.js	2023-12-06 14:23:14.379854783 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { assertNever } from '../../../../base/common/assert.js';
 import { DeferredPromise } from '../../../../base/common/async.js';
 import { CancellationToken } from '../../../../base/common/cancellation.js';
@@ -18,104 +9,103 @@
 import { onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { Range } from '../../../common/core/range.js';
 import { fixBracketsInLine } from '../../../common/model/bracketPairsTextModelPart/fixBrackets.js';
+import { SingleTextEdit } from './singleTextEdit.js';
 import { getReadonlyEmptyArray } from './utils.js';
 import { SnippetParser, Text } from '../../snippet/browser/snippetParser.js';
-export function provideInlineCompletions(registry, position, model, context, token = CancellationToken.None, languageConfigurationService) {
-    return __awaiter(this, void 0, void 0, function* () {
-        // Important: Don't use position after the await calls, as the model could have been changed in the meantime!
-        const defaultReplaceRange = getDefaultRange(position, model);
-        const providers = registry.all(model);
-        const multiMap = new SetMap();
-        for (const provider of providers) {
-            if (provider.groupId) {
-                multiMap.add(provider.groupId, provider);
-            }
-        }
-        function getPreferredProviders(provider) {
-            if (!provider.yieldsToGroupIds) {
-                return [];
-            }
-            const result = [];
-            for (const groupId of provider.yieldsToGroupIds || []) {
-                const providers = multiMap.get(groupId);
-                for (const p of providers) {
-                    result.push(p);
+export async function provideInlineCompletions(registry, position, model, context, token = CancellationToken.None, languageConfigurationService) {
+    // Important: Don't use position after the await calls, as the model could have been changed in the meantime!
+    const defaultReplaceRange = getDefaultRange(position, model);
+    const providers = registry.all(model);
+    const multiMap = new SetMap();
+    for (const provider of providers) {
+        if (provider.groupId) {
+            multiMap.add(provider.groupId, provider);
+        }
+    }
+    function getPreferredProviders(provider) {
+        if (!provider.yieldsToGroupIds) {
+            return [];
+        }
+        const result = [];
+        for (const groupId of provider.yieldsToGroupIds || []) {
+            const providers = multiMap.get(groupId);
+            for (const p of providers) {
+                result.push(p);
+            }
+        }
+        return result;
+    }
+    const states = new Map();
+    const seen = new Set();
+    function findPreferredProviderCircle(provider, stack) {
+        stack = [...stack, provider];
+        if (seen.has(provider)) {
+            return stack;
+        }
+        seen.add(provider);
+        try {
+            const preferred = getPreferredProviders(provider);
+            for (const p of preferred) {
+                const c = findPreferredProviderCircle(p, stack);
+                if (c) {
+                    return c;
                 }
             }
-            return result;
         }
-        const states = new Map();
-        const seen = new Set();
-        function findPreferredProviderCircle(provider, stack) {
-            stack = [...stack, provider];
-            if (seen.has(provider)) {
-                return stack;
-            }
-            seen.add(provider);
-            try {
+        finally {
+            seen.delete(provider);
+        }
+        return undefined;
+    }
+    function processProvider(provider) {
+        const state = states.get(provider);
+        if (state) {
+            return state;
+        }
+        const circle = findPreferredProviderCircle(provider, []);
+        if (circle) {
+            onUnexpectedExternalError(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${circle.map(s => s.toString ? s.toString() : ('' + s)).join(' -> ')}`));
+        }
+        const deferredPromise = new DeferredPromise();
+        states.set(provider, deferredPromise.p);
+        (async () => {
+            if (!circle) {
                 const preferred = getPreferredProviders(provider);
                 for (const p of preferred) {
-                    const c = findPreferredProviderCircle(p, stack);
-                    if (c) {
-                        return c;
+                    const result = await processProvider(p);
+                    if (result && result.items.length > 0) {
+                        // Skip provider
+                        return undefined;
                     }
                 }
             }
-            finally {
-                seen.delete(provider);
-            }
-            return undefined;
-        }
-        function processProvider(provider) {
-            const state = states.get(provider);
-            if (state) {
-                return state;
-            }
-            const circle = findPreferredProviderCircle(provider, []);
-            if (circle) {
-                onUnexpectedExternalError(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${circle.map(s => s.toString ? s.toString() : ('' + s)).join(' -> ')}`));
-            }
-            const deferredPromise = new DeferredPromise();
-            states.set(provider, deferredPromise.p);
-            (() => __awaiter(this, void 0, void 0, function* () {
-                if (!circle) {
-                    const preferred = getPreferredProviders(provider);
-                    for (const p of preferred) {
-                        const result = yield processProvider(p);
-                        if (result && result.items.length > 0) {
-                            // Skip provider
-                            return undefined;
-                        }
-                    }
-                }
-                try {
-                    const completions = yield provider.provideInlineCompletions(model, position, context, token);
-                    return completions;
-                }
-                catch (e) {
-                    onUnexpectedExternalError(e);
-                    return undefined;
-                }
-            }))().then(c => deferredPromise.complete(c), e => deferredPromise.error(e));
-            return deferredPromise.p;
-        }
-        const providerResults = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () { return ({ provider, completions: yield processProvider(provider) }); })));
-        const itemsByHash = new Map();
-        const lists = [];
-        for (const result of providerResults) {
-            const completions = result.completions;
-            if (!completions) {
-                continue;
-            }
-            const list = new InlineCompletionList(completions, result.provider);
-            lists.push(list);
-            for (const item of completions.items) {
-                const inlineCompletionItem = InlineCompletionItem.from(item, list, defaultReplaceRange, model, languageConfigurationService);
-                itemsByHash.set(inlineCompletionItem.hash(), inlineCompletionItem);
+            try {
+                const completions = await provider.provideInlineCompletions(model, position, context, token);
+                return completions;
             }
+            catch (e) {
+                onUnexpectedExternalError(e);
+                return undefined;
+            }
+        })().then(c => deferredPromise.complete(c), e => deferredPromise.error(e));
+        return deferredPromise.p;
+    }
+    const providerResults = await Promise.all(providers.map(async (provider) => ({ provider, completions: await processProvider(provider) })));
+    const itemsByHash = new Map();
+    const lists = [];
+    for (const result of providerResults) {
+        const completions = result.completions;
+        if (!completions) {
+            continue;
+        }
+        const list = new InlineCompletionList(completions, result.provider);
+        lists.push(list);
+        for (const item of completions.items) {
+            const inlineCompletionItem = InlineCompletionItem.from(item, list, defaultReplaceRange, model, languageConfigurationService);
+            itemsByHash.set(inlineCompletionItem.hash(), inlineCompletionItem);
         }
-        return new InlineCompletionProviderResult(Array.from(itemsByHash.values()), new Set(itemsByHash.keys()), lists);
-    });
+    }
+    return new InlineCompletionProviderResult(Array.from(itemsByHash.values()), new Set(itemsByHash.keys()), lists);
 }
 export class InlineCompletionProviderResult {
     constructor(
@@ -229,6 +219,9 @@
     hash() {
         return JSON.stringify({ insertText: this.insertText, range: this.range.toString() });
     }
+    toSingleTextEdit() {
+        return new SingleTextEdit(this.range, this.insertText);
+    }
 }
 function getDefaultRange(position, model) {
     const word = model.getWordAtPosition(position);
@@ -243,7 +236,7 @@
     const lineStart = model.getLineContent(position.lineNumber).substring(0, position.column - 1);
     const newLine = lineStart + text;
     const newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);
-    const slicedTokens = newTokens === null || newTokens === void 0 ? void 0 : newTokens.sliceAndInflate(position.column - 1, newLine.length, 0);
+    const slicedTokens = newTokens?.sliceAndInflate(position.column - 1, newLine.length, 0);
     if (!slicedTokens) {
         return text;
     }
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/singleTextEdit.js b/vs/editor/contrib/inlineCompletions/browser/singleTextEdit.js
--- a/vs/editor/contrib/inlineCompletions/browser/singleTextEdit.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/singleTextEdit.js	2023-12-06 14:23:14.379854783 +0000
@@ -114,8 +114,8 @@
 }
 let lastRequest = undefined;
 function cachingDiff(originalValue, newValue) {
-    if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {
-        return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;
+    if (lastRequest?.originalValue === originalValue && lastRequest?.newValue === newValue) {
+        return lastRequest?.changes;
     }
     else {
         let changes = smartDiff(originalValue, newValue, true);
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/suggestWidgetInlineCompletionProvider.js b/vs/editor/contrib/inlineCompletions/browser/suggestWidgetInlineCompletionProvider.js
--- a/vs/editor/contrib/inlineCompletions/browser/suggestWidgetInlineCompletionProvider.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/suggestWidgetInlineCompletionProvider.js	2023-12-06 14:23:14.379854783 +0000
@@ -47,14 +47,13 @@
             this._register(suggestController.registerSelector({
                 priority: 100,
                 select: (model, pos, suggestItems) => {
-                    var _a;
                     transaction(tx => this.checkModelVersion(tx));
                     const textModel = this.editor.getModel();
                     if (!textModel) {
                         // Should not happen
                         return -1;
                     }
-                    const itemToPreselect = (_a = this.suggestControllerPreselector()) === null || _a === void 0 ? void 0 : _a.removeCommonPrefix(textModel);
+                    const itemToPreselect = this.suggestControllerPreselector()?.removeCommonPrefix(textModel);
                     if (!itemToPreselect) {
                         return -1;
                     }
@@ -132,11 +131,11 @@
     }
     stopForceRenderingAbove() {
         const suggestController = SuggestController.get(this.editor);
-        suggestController === null || suggestController === void 0 ? void 0 : suggestController.stopForceRenderingAbove();
+        suggestController?.stopForceRenderingAbove();
     }
     forceRenderingAbove() {
         const suggestController = SuggestController.get(this.editor);
-        suggestController === null || suggestController === void 0 ? void 0 : suggestController.forceRenderingAbove();
+        suggestController?.forceRenderingAbove();
     }
 }
 export class SuggestItemInfo {
diff -urN -x '*.map' a/vs/editor/contrib/inlineProgress/browser/inlineProgress.js b/vs/editor/contrib/inlineProgress/browser/inlineProgress.js
--- a/vs/editor/contrib/inlineProgress/browser/inlineProgress.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/inlineProgress/browser/inlineProgress.js	2023-12-06 14:23:14.379854783 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import * as dom from '../../../../base/browser/dom.js';
 import { disposableTimeout } from '../../../../base/common/async.js';
 import { Codicon } from '../../../../base/common/codicons.js';
@@ -106,31 +97,29 @@
         this._operationIdPool = 0;
         this._currentDecorations = _editor.createDecorationsCollection();
     }
-    showWhile(position, title, promise) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const operationId = this._operationIdPool++;
-            this._currentOperation = operationId;
-            this.clear();
-            this._showPromise.value = disposableTimeout(() => {
-                const range = Range.fromPositions(position);
-                const decorationIds = this._currentDecorations.set([{
-                        range: range,
-                        options: inlineProgressDecoration,
-                    }]);
-                if (decorationIds.length > 0) {
-                    this._currentWidget.value = this._instantiationService.createInstance(InlineProgressWidget, this.id, this._editor, range, title, promise);
-                }
-            }, this._showDelay);
-            try {
-                return yield promise;
+    async showWhile(position, title, promise) {
+        const operationId = this._operationIdPool++;
+        this._currentOperation = operationId;
+        this.clear();
+        this._showPromise.value = disposableTimeout(() => {
+            const range = Range.fromPositions(position);
+            const decorationIds = this._currentDecorations.set([{
+                    range: range,
+                    options: inlineProgressDecoration,
+                }]);
+            if (decorationIds.length > 0) {
+                this._currentWidget.value = this._instantiationService.createInstance(InlineProgressWidget, this.id, this._editor, range, title, promise);
             }
-            finally {
-                if (this._currentOperation === operationId) {
-                    this.clear();
-                    this._currentOperation = undefined;
-                }
+        }, this._showDelay);
+        try {
+            return await promise;
+        }
+        finally {
+            if (this._currentOperation === operationId) {
+                this.clear();
+                this._currentOperation = undefined;
             }
-        });
+        }
     }
     clear() {
         this._showPromise.clear();
diff -urN -x '*.map' a/vs/editor/contrib/lineSelection/browser/lineSelection.js b/vs/editor/contrib/lineSelection/browser/lineSelection.js
--- a/vs/editor/contrib/lineSelection/browser/lineSelection.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/lineSelection/browser/lineSelection.js	2023-12-06 14:23:14.379854783 +0000
@@ -10,7 +10,7 @@
     constructor() {
         super({
             id: 'expandLineSelection',
-            label: nls.localize('expandLineSelection', "Expand Line Selection"),
+            label: nls.localizeWithPath('vs/editor/contrib/lineSelection/browser/lineSelection', 'expandLineSelection', "Expand Line Selection"),
             alias: 'Expand Line Selection',
             precondition: undefined,
             kbOpts: {
diff -urN -x '*.map' a/vs/editor/contrib/linesOperations/browser/linesOperations.js b/vs/editor/contrib/linesOperations/browser/linesOperations.js
--- a/vs/editor/contrib/linesOperations/browser/linesOperations.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/linesOperations/browser/linesOperations.js	2023-12-06 14:23:14.379854783 +0000
@@ -61,7 +61,7 @@
     constructor() {
         super(false, {
             id: 'editor.action.copyLinesUpAction',
-            label: nls.localize('lines.copyUp', "Copy Line Up"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.copyUp', "Copy Line Up"),
             alias: 'Copy Line Up',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -73,7 +73,7 @@
             menuOpts: {
                 menuId: MenuId.MenubarSelectionMenu,
                 group: '2_line',
-                title: nls.localize({ key: 'miCopyLinesUp', comment: ['&& denotes a mnemonic'] }, "&&Copy Line Up"),
+                title: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', { key: 'miCopyLinesUp', comment: ['&& denotes a mnemonic'] }, "&&Copy Line Up"),
                 order: 1
             }
         });
@@ -83,7 +83,7 @@
     constructor() {
         super(true, {
             id: 'editor.action.copyLinesDownAction',
-            label: nls.localize('lines.copyDown', "Copy Line Down"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.copyDown', "Copy Line Down"),
             alias: 'Copy Line Down',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -95,7 +95,7 @@
             menuOpts: {
                 menuId: MenuId.MenubarSelectionMenu,
                 group: '2_line',
-                title: nls.localize({ key: 'miCopyLinesDown', comment: ['&& denotes a mnemonic'] }, "Co&&py Line Down"),
+                title: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', { key: 'miCopyLinesDown', comment: ['&& denotes a mnemonic'] }, "Co&&py Line Down"),
                 order: 2
             }
         });
@@ -105,13 +105,13 @@
     constructor() {
         super({
             id: 'editor.action.duplicateSelection',
-            label: nls.localize('duplicateSelection', "Duplicate Selection"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'duplicateSelection', "Duplicate Selection"),
             alias: 'Duplicate Selection',
             precondition: EditorContextKeys.writable,
             menuOpts: {
                 menuId: MenuId.MenubarSelectionMenu,
                 group: '2_line',
-                title: nls.localize({ key: 'miDuplicateSelection', comment: ['&& denotes a mnemonic'] }, "&&Duplicate Selection"),
+                title: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', { key: 'miDuplicateSelection', comment: ['&& denotes a mnemonic'] }, "&&Duplicate Selection"),
                 order: 5
             }
         });
@@ -160,7 +160,7 @@
     constructor() {
         super(false, {
             id: 'editor.action.moveLinesUpAction',
-            label: nls.localize('lines.moveUp', "Move Line Up"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.moveUp', "Move Line Up"),
             alias: 'Move Line Up',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -172,7 +172,7 @@
             menuOpts: {
                 menuId: MenuId.MenubarSelectionMenu,
                 group: '2_line',
-                title: nls.localize({ key: 'miMoveLinesUp', comment: ['&& denotes a mnemonic'] }, "Mo&&ve Line Up"),
+                title: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', { key: 'miMoveLinesUp', comment: ['&& denotes a mnemonic'] }, "Mo&&ve Line Up"),
                 order: 3
             }
         });
@@ -182,7 +182,7 @@
     constructor() {
         super(true, {
             id: 'editor.action.moveLinesDownAction',
-            label: nls.localize('lines.moveDown', "Move Line Down"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.moveDown', "Move Line Down"),
             alias: 'Move Line Down',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -194,7 +194,7 @@
             menuOpts: {
                 menuId: MenuId.MenubarSelectionMenu,
                 group: '2_line',
-                title: nls.localize({ key: 'miMoveLinesDown', comment: ['&& denotes a mnemonic'] }, "Move &&Line Down"),
+                title: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', { key: 'miMoveLinesDown', comment: ['&& denotes a mnemonic'] }, "Move &&Line Down"),
                 order: 4
             }
         });
@@ -225,7 +225,7 @@
     constructor() {
         super(false, {
             id: 'editor.action.sortLinesAscending',
-            label: nls.localize('lines.sortAscending', "Sort Lines Ascending"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.sortAscending', "Sort Lines Ascending"),
             alias: 'Sort Lines Ascending',
             precondition: EditorContextKeys.writable
         });
@@ -235,7 +235,7 @@
     constructor() {
         super(true, {
             id: 'editor.action.sortLinesDescending',
-            label: nls.localize('lines.sortDescending', "Sort Lines Descending"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.sortDescending', "Sort Lines Descending"),
             alias: 'Sort Lines Descending',
             precondition: EditorContextKeys.writable
         });
@@ -245,7 +245,7 @@
     constructor() {
         super({
             id: 'editor.action.removeDuplicateLines',
-            label: nls.localize('lines.deleteDuplicates', "Delete Duplicate Lines"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.deleteDuplicates', "Delete Duplicate Lines"),
             alias: 'Delete Duplicate Lines',
             precondition: EditorContextKeys.writable
         });
@@ -288,7 +288,7 @@
     constructor() {
         super({
             id: TrimTrailingWhitespaceAction.ID,
-            label: nls.localize('lines.trimTrailingWhitespace', "Trim Trailing Whitespace"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.trimTrailingWhitespace', "Trim Trailing Whitespace"),
             alias: 'Trim Trailing Whitespace',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -321,7 +321,7 @@
     constructor() {
         super({
             id: 'editor.action.deleteLines',
-            label: nls.localize('lines.delete', "Delete Line"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.delete', "Delete Line"),
             alias: 'Delete Line',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -410,7 +410,7 @@
     constructor() {
         super({
             id: 'editor.action.indentLines',
-            label: nls.localize('lines.indent', "Indent Line"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.indent', "Indent Line"),
             alias: 'Indent Line',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -434,7 +434,7 @@
     constructor() {
         super({
             id: 'editor.action.outdentLines',
-            label: nls.localize('lines.outdent', "Outdent Line"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.outdent', "Outdent Line"),
             alias: 'Outdent Line',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -452,7 +452,7 @@
     constructor() {
         super({
             id: 'editor.action.insertLineBefore',
-            label: nls.localize('lines.insertBefore', "Insert Line Above"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.insertBefore', "Insert Line Above"),
             alias: 'Insert Line Above',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -475,7 +475,7 @@
     constructor() {
         super({
             id: 'editor.action.insertLineAfter',
-            label: nls.localize('lines.insertAfter', "Insert Line Below"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.insertAfter', "Insert Line Below"),
             alias: 'Insert Line Below',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -527,7 +527,7 @@
     constructor() {
         super({
             id: 'deleteAllLeft',
-            label: nls.localize('lines.deleteAllLeft', "Delete All Left"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.deleteAllLeft', "Delete All Left"),
             alias: 'Delete All Left',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -597,7 +597,7 @@
     constructor() {
         super({
             id: 'deleteAllRight',
-            label: nls.localize('lines.deleteAllRight', "Delete All Right"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.deleteAllRight', "Delete All Right"),
             alias: 'Delete All Right',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -655,7 +655,7 @@
     constructor() {
         super({
             id: 'editor.action.joinLines',
-            label: nls.localize('lines.joinLines', "Join Lines"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'lines.joinLines', "Join Lines"),
             alias: 'Join Lines',
             precondition: EditorContextKeys.writable,
             kbOpts: {
@@ -797,7 +797,7 @@
     constructor() {
         super({
             id: 'editor.action.transpose',
-            label: nls.localize('editor.transpose', "Transpose Characters around the Cursor"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'editor.transpose', "Transpose Characters around the Cursor"),
             alias: 'Transpose Characters around the Cursor',
             precondition: EditorContextKeys.writable
         });
@@ -877,7 +877,7 @@
     constructor() {
         super({
             id: 'editor.action.transformToUppercase',
-            label: nls.localize('editor.transformToUppercase', "Transform to Uppercase"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'editor.transformToUppercase', "Transform to Uppercase"),
             alias: 'Transform to Uppercase',
             precondition: EditorContextKeys.writable
         });
@@ -890,7 +890,7 @@
     constructor() {
         super({
             id: 'editor.action.transformToLowercase',
-            label: nls.localize('editor.transformToLowercase', "Transform to Lowercase"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'editor.transformToLowercase', "Transform to Lowercase"),
             alias: 'Transform to Lowercase',
             precondition: EditorContextKeys.writable
         });
@@ -926,7 +926,7 @@
     constructor() {
         super({
             id: 'editor.action.transformToTitlecase',
-            label: nls.localize('editor.transformToTitlecase', "Transform to Title Case"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'editor.transformToTitlecase', "Transform to Title Case"),
             alias: 'Transform to Title Case',
             precondition: EditorContextKeys.writable
         });
@@ -947,7 +947,7 @@
     constructor() {
         super({
             id: 'editor.action.transformToSnakecase',
-            label: nls.localize('editor.transformToSnakecase', "Transform to Snake Case"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'editor.transformToSnakecase', "Transform to Snake Case"),
             alias: 'Transform to Snake Case',
             precondition: EditorContextKeys.writable
         });
@@ -971,7 +971,7 @@
     constructor() {
         super({
             id: 'editor.action.transformToCamelcase',
-            label: nls.localize('editor.transformToCamelcase', "Transform to Camel Case"),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'editor.transformToCamelcase', "Transform to Camel Case"),
             alias: 'Transform to Camel Case',
             precondition: EditorContextKeys.writable
         });
@@ -1001,7 +1001,7 @@
     constructor() {
         super({
             id: 'editor.action.transformToKebabcase',
-            label: nls.localize('editor.transformToKebabcase', 'Transform to Kebab Case'),
+            label: nls.localizeWithPath('vs/editor/contrib/linesOperations/browser/linesOperations', 'editor.transformToKebabcase', 'Transform to Kebab Case'),
             alias: 'Transform to Kebab Case',
             precondition: EditorContextKeys.writable
         });
diff -urN -x '*.map' a/vs/editor/contrib/linkedEditing/browser/linkedEditing.js b/vs/editor/contrib/linkedEditing/browser/linkedEditing.js
--- a/vs/editor/contrib/linkedEditing/browser/linkedEditing.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/linkedEditing/browser/linkedEditing.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var LinkedEditingContribution_1;
 import * as arrays from '../../../../base/common/arrays.js';
 import { createCancelablePromise, Delayer, first } from '../../../../base/common/async.js';
@@ -97,8 +88,7 @@
         }));
         const rangeUpdateScheduler = new Delayer(this._debounceInformation.get(model));
         const triggerRangeUpdate = () => {
-            var _a;
-            this._rangeUpdateTriggerPromise = rangeUpdateScheduler.trigger(() => this.updateRanges(), (_a = this._debounceDuration) !== null && _a !== void 0 ? _a : this._debounceInformation.get(model));
+            this._rangeUpdateTriggerPromise = rangeUpdateScheduler.trigger(() => this.updateRanges(), this._debounceDuration ?? this._debounceInformation.get(model));
         };
         const rangeSyncScheduler = new Delayer(0);
         const triggerRangeSync = (token) => {
@@ -206,87 +196,95 @@
             this._currentRequestPosition = null;
         }
     }
-    updateRanges(force = false) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!this._editor.hasModel()) {
-                this.clearRanges();
-                return;
-            }
-            const position = this._editor.getPosition();
-            if (!this._enabled && !force || this._editor.getSelections().length > 1) {
-                // disabled or multicursor
-                this.clearRanges();
-                return;
-            }
-            const model = this._editor.getModel();
-            const modelVersionId = model.getVersionId();
-            if (this._currentRequestPosition && this._currentRequestModelVersion === modelVersionId) {
-                if (position.equals(this._currentRequestPosition)) {
-                    return; // same position
-                }
-                if (this._currentDecorations.length > 0) {
-                    const range = this._currentDecorations.getRange(0);
-                    if (range && range.containsPosition(position)) {
-                        return; // just moving inside the existing primary range
-                    }
+    get currentUpdateTriggerPromise() {
+        return this._rangeUpdateTriggerPromise || Promise.resolve();
+    }
+    get currentSyncTriggerPromise() {
+        return this._rangeSyncTriggerPromise || Promise.resolve();
+    }
+    async updateRanges(force = false) {
+        if (!this._editor.hasModel()) {
+            this.clearRanges();
+            return;
+        }
+        const position = this._editor.getPosition();
+        if (!this._enabled && !force || this._editor.getSelections().length > 1) {
+            // disabled or multicursor
+            this.clearRanges();
+            return;
+        }
+        const model = this._editor.getModel();
+        const modelVersionId = model.getVersionId();
+        if (this._currentRequestPosition && this._currentRequestModelVersion === modelVersionId) {
+            if (position.equals(this._currentRequestPosition)) {
+                return; // same position
+            }
+            if (this._currentDecorations.length > 0) {
+                const range = this._currentDecorations.getRange(0);
+                if (range && range.containsPosition(position)) {
+                    return; // just moving inside the existing primary range
                 }
             }
-            // Clear existing decorations while we compute new ones
-            this.clearRanges();
-            this._currentRequestPosition = position;
-            this._currentRequestModelVersion = modelVersionId;
-            const request = createCancelablePromise((token) => __awaiter(this, void 0, void 0, function* () {
-                try {
-                    const sw = new StopWatch(false);
-                    const response = yield getLinkedEditingRanges(this._providers, model, position, token);
-                    this._debounceInformation.update(model, sw.elapsed());
-                    if (request !== this._currentRequest) {
-                        return;
-                    }
-                    this._currentRequest = null;
-                    if (modelVersionId !== model.getVersionId()) {
-                        return;
-                    }
-                    let ranges = [];
-                    if (response === null || response === void 0 ? void 0 : response.ranges) {
-                        ranges = response.ranges;
-                    }
-                    this._currentWordPattern = (response === null || response === void 0 ? void 0 : response.wordPattern) || this._languageWordPattern;
-                    let foundReferenceRange = false;
-                    for (let i = 0, len = ranges.length; i < len; i++) {
-                        if (Range.containsPosition(ranges[i], position)) {
-                            foundReferenceRange = true;
-                            if (i !== 0) {
-                                const referenceRange = ranges[i];
-                                ranges.splice(i, 1);
-                                ranges.unshift(referenceRange);
-                            }
-                            break;
+        }
+        // Clear existing decorations while we compute new ones
+        this.clearRanges();
+        this._currentRequestPosition = position;
+        this._currentRequestModelVersion = modelVersionId;
+        const request = createCancelablePromise(async (token) => {
+            try {
+                const sw = new StopWatch(false);
+                const response = await getLinkedEditingRanges(this._providers, model, position, token);
+                this._debounceInformation.update(model, sw.elapsed());
+                if (request !== this._currentRequest) {
+                    return;
+                }
+                this._currentRequest = null;
+                if (modelVersionId !== model.getVersionId()) {
+                    return;
+                }
+                let ranges = [];
+                if (response?.ranges) {
+                    ranges = response.ranges;
+                }
+                this._currentWordPattern = response?.wordPattern || this._languageWordPattern;
+                let foundReferenceRange = false;
+                for (let i = 0, len = ranges.length; i < len; i++) {
+                    if (Range.containsPosition(ranges[i], position)) {
+                        foundReferenceRange = true;
+                        if (i !== 0) {
+                            const referenceRange = ranges[i];
+                            ranges.splice(i, 1);
+                            ranges.unshift(referenceRange);
                         }
+                        break;
                     }
-                    if (!foundReferenceRange) {
-                        // Cannot do linked editing if the ranges are not where the cursor is...
-                        this.clearRanges();
-                        return;
-                    }
-                    const decorations = ranges.map(range => ({ range: range, options: LinkedEditingContribution_1.DECORATION }));
-                    this._visibleContextKey.set(true);
-                    this._currentDecorations.set(decorations);
-                    this._syncRangesToken++; // cancel any pending syncRanges call
-                }
-                catch (err) {
-                    if (!isCancellationError(err)) {
-                        onUnexpectedError(err);
-                    }
-                    if (this._currentRequest === request || !this._currentRequest) {
-                        // stop if we are still the latest request
-                        this.clearRanges();
-                    }
                 }
-            }));
-            this._currentRequest = request;
-            return request;
+                if (!foundReferenceRange) {
+                    // Cannot do linked editing if the ranges are not where the cursor is...
+                    this.clearRanges();
+                    return;
+                }
+                const decorations = ranges.map(range => ({ range: range, options: LinkedEditingContribution_1.DECORATION }));
+                this._visibleContextKey.set(true);
+                this._currentDecorations.set(decorations);
+                this._syncRangesToken++; // cancel any pending syncRanges call
+            }
+            catch (err) {
+                if (!isCancellationError(err)) {
+                    onUnexpectedError(err);
+                }
+                if (this._currentRequest === request || !this._currentRequest) {
+                    // stop if we are still the latest request
+                    this.clearRanges();
+                }
+            }
         });
+        this._currentRequest = request;
+        return request;
+    }
+    // for testing
+    setDebounceDuration(timeInMS) {
+        this._debounceDuration = timeInMS;
     }
 };
 LinkedEditingContribution.ID = 'editor.contrib.linkedEditing';
@@ -306,7 +304,7 @@
     constructor() {
         super({
             id: 'editor.action.linkedEditing',
-            label: nls.localize('linkedEditing.label', "Start Linked Editing"),
+            label: nls.localizeWithPath('vs/editor/contrib/linkedEditing/browser/linkedEditing', 'linkedEditing.label', "Start Linked Editing"),
             alias: 'Start Linked Editing',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
             kbOpts: {
@@ -358,17 +356,17 @@
     // in order of score ask the linked editing range provider
     // until someone response with a good result
     // (good = not null)
-    return first(orderedByScore.map(provider => () => __awaiter(this, void 0, void 0, function* () {
+    return first(orderedByScore.map(provider => async () => {
         try {
-            return yield provider.provideLinkedEditingRanges(model, position, token);
+            return await provider.provideLinkedEditingRanges(model, position, token);
         }
         catch (e) {
             onUnexpectedExternalError(e);
             return undefined;
         }
-    })), result => !!result && arrays.isNonEmptyArray(result === null || result === void 0 ? void 0 : result.ranges));
+    }), result => !!result && arrays.isNonEmptyArray(result?.ranges));
 }
-export const editorLinkedEditingBackground = registerColor('editor.linkedEditingBackground', { dark: Color.fromHex('#f00').transparent(0.3), light: Color.fromHex('#f00').transparent(0.3), hcDark: Color.fromHex('#f00').transparent(0.3), hcLight: Color.white }, nls.localize('editorLinkedEditingBackground', 'Background color when the editor auto renames on type.'));
+export const editorLinkedEditingBackground = registerColor('editor.linkedEditingBackground', { dark: Color.fromHex('#f00').transparent(0.3), light: Color.fromHex('#f00').transparent(0.3), hcDark: Color.fromHex('#f00').transparent(0.3), hcLight: Color.white }, nls.localizeWithPath('vs/editor/contrib/linkedEditing/browser/linkedEditing', 'editorLinkedEditingBackground', 'Background color when the editor auto renames on type.'));
 registerModelAndPositionCommand('_executeLinkedEditingProvider', (_accessor, model, position) => {
     const { linkedEditingRangeProvider } = _accessor.get(ILanguageFeaturesService);
     return getLinkedEditingRanges(linkedEditingRangeProvider, model, position, CancellationToken.None);
diff -urN -x '*.map' a/vs/editor/contrib/links/browser/getLinks.js b/vs/editor/contrib/links/browser/getLinks.js
--- a/vs/editor/contrib/links/browser/getLinks.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/links/browser/getLinks.js	2023-12-06 14:23:14.383854791 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { coalesce } from '../../../../base/common/arrays.js';
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { onUnexpectedExternalError } from '../../../../base/common/errors.js';
@@ -42,23 +33,21 @@
     get tooltip() {
         return this._link.tooltip;
     }
-    resolve(token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (this._link.url) {
-                return this._link.url;
-            }
-            if (typeof this._provider.resolveLink === 'function') {
-                return Promise.resolve(this._provider.resolveLink(this._link, token)).then(value => {
-                    this._link = value || this._link;
-                    if (this._link.url) {
-                        // recurse
-                        return this.resolve(token);
-                    }
-                    return Promise.reject(new Error('missing'));
-                });
-            }
-            return Promise.reject(new Error('missing'));
-        });
+    async resolve(token) {
+        if (this._link.url) {
+            return this._link.url;
+        }
+        if (typeof this._provider.resolveLink === 'function') {
+            return Promise.resolve(this._provider.resolveLink(this._link, token)).then(value => {
+                this._link = value || this._link;
+                if (this._link.url) {
+                    // recurse
+                    return this.resolve(token);
+                }
+                return Promise.reject(new Error('missing'));
+            });
+        }
+        return Promise.reject(new Error('missing'));
     }
 }
 export class LinksList {
@@ -135,7 +124,7 @@
         return new LinksList([]);
     });
 }
-CommandsRegistry.registerCommand('_executeLinkProvider', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {
+CommandsRegistry.registerCommand('_executeLinkProvider', async (accessor, ...args) => {
     let [uri, resolveCount] = args;
     assertType(uri instanceof URI);
     if (typeof resolveCount !== 'number') {
@@ -146,15 +135,15 @@
     if (!model) {
         return [];
     }
-    const list = yield getLinks(linkProvider, model, CancellationToken.None);
+    const list = await getLinks(linkProvider, model, CancellationToken.None);
     if (!list) {
         return [];
     }
     // resolve links
     for (let i = 0; i < Math.min(resolveCount, list.links.length); i++) {
-        yield list.links[i].resolve(CancellationToken.None);
+        await list.links[i].resolve(CancellationToken.None);
     }
     const result = list.links.slice(0);
     list.dispose();
     return result;
-}));
+});
diff -urN -x '*.map' a/vs/editor/contrib/links/browser/links.js b/vs/editor/contrib/links/browser/links.js
--- a/vs/editor/contrib/links/browser/links.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/links/browser/links.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var LinkDetector_1;
 import { createCancelablePromise, RunOnceScheduler } from '../../../../base/common/async.js';
 import { CancellationToken } from '../../../../base/common/cancellation.js';
@@ -101,39 +92,37 @@
         }));
         this.computeLinks.schedule(0);
     }
-    computeLinksNow() {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!this.editor.hasModel() || !this.editor.getOption(70 /* EditorOption.links */)) {
-                return;
-            }
-            const model = this.editor.getModel();
-            if (model.isTooLargeForSyncing()) {
-                return;
-            }
-            if (!this.providers.has(model)) {
+    async computeLinksNow() {
+        if (!this.editor.hasModel() || !this.editor.getOption(70 /* EditorOption.links */)) {
+            return;
+        }
+        const model = this.editor.getModel();
+        if (model.isTooLargeForSyncing()) {
+            return;
+        }
+        if (!this.providers.has(model)) {
+            return;
+        }
+        if (this.activeLinksList) {
+            this.activeLinksList.dispose();
+            this.activeLinksList = null;
+        }
+        this.computePromise = createCancelablePromise(token => getLinks(this.providers, model, token));
+        try {
+            const sw = new StopWatch(false);
+            this.activeLinksList = await this.computePromise;
+            this.debounceInformation.update(model, sw.elapsed());
+            if (model.isDisposed()) {
                 return;
             }
-            if (this.activeLinksList) {
-                this.activeLinksList.dispose();
-                this.activeLinksList = null;
-            }
-            this.computePromise = createCancelablePromise(token => getLinks(this.providers, model, token));
-            try {
-                const sw = new StopWatch(false);
-                this.activeLinksList = yield this.computePromise;
-                this.debounceInformation.update(model, sw.elapsed());
-                if (model.isDisposed()) {
-                    return;
-                }
-                this.updateDecorations(this.activeLinksList.links);
-            }
-            catch (err) {
-                onUnexpectedError(err);
-            }
-            finally {
-                this.computePromise = null;
-            }
-        });
+            this.updateDecorations(this.activeLinksList.links);
+        }
+        catch (err) {
+            onUnexpectedError(err);
+        }
+        finally {
+            this.computePromise = null;
+        }
     }
     updateDecorations(links) {
         const useMetaKey = (this.editor.getOption(77 /* EditorOption.multiCursorModifier */) === 'altKey');
@@ -229,10 +218,10 @@
             const messageOrError = err instanceof Error ? err.message : err;
             // different error cases
             if (messageOrError === 'invalid') {
-                this.notificationService.warn(nls.localize('invalid.url', 'Failed to open this link because it is not well-formed: {0}', link.url.toString()));
+                this.notificationService.warn(nls.localizeWithPath('vs/editor/contrib/links/browser/links', 'invalid.url', 'Failed to open this link because it is not well-formed: {0}', link.url.toString()));
             }
             else if (messageOrError === 'missing') {
-                this.notificationService.warn(nls.localize('missing.url', 'Failed to open this link because its target is missing.'));
+                this.notificationService.warn(nls.localizeWithPath('vs/editor/contrib/links/browser/links', 'missing.url', 'Failed to open this link because its target is missing.'));
             }
             else {
                 onUnexpectedError(err);
@@ -262,10 +251,9 @@
             && (mouseEvent.hasTriggerModifier || (withKey && withKey.keyCodeIsTriggerKey)));
     }
     stop() {
-        var _a;
         this.computeLinks.cancel();
         if (this.activeLinksList) {
-            (_a = this.activeLinksList) === null || _a === void 0 ? void 0 : _a.dispose();
+            this.activeLinksList?.dispose();
             this.activeLinksList = null;
         }
         if (this.computePromise) {
@@ -308,7 +296,7 @@
         };
     }
     static _getOptions(link, useMetaKey, isActive) {
-        const options = Object.assign({}, (isActive ? decoration.active : decoration.general));
+        const options = { ...(isActive ? decoration.active : decoration.general) };
         options.hoverMessage = getHoverMessage(link, useMetaKey);
         return options;
     }
@@ -328,15 +316,15 @@
     const label = link.tooltip
         ? link.tooltip
         : executeCmd
-            ? nls.localize('links.navigate.executeCmd', 'Execute command')
-            : nls.localize('links.navigate.follow', 'Follow link');
+            ? nls.localizeWithPath('vs/editor/contrib/links/browser/links', 'links.navigate.executeCmd', 'Execute command')
+            : nls.localizeWithPath('vs/editor/contrib/links/browser/links', 'links.navigate.follow', 'Follow link');
     const kb = useMetaKey
         ? platform.isMacintosh
-            ? nls.localize('links.navigate.kb.meta.mac', "cmd + click")
-            : nls.localize('links.navigate.kb.meta', "ctrl + click")
+            ? nls.localizeWithPath('vs/editor/contrib/links/browser/links', 'links.navigate.kb.meta.mac', "cmd + click")
+            : nls.localizeWithPath('vs/editor/contrib/links/browser/links', 'links.navigate.kb.meta', "ctrl + click")
         : platform.isMacintosh
-            ? nls.localize('links.navigate.kb.alt.mac', "option + click")
-            : nls.localize('links.navigate.kb.alt', "alt + click");
+            ? nls.localizeWithPath('vs/editor/contrib/links/browser/links', 'links.navigate.kb.alt.mac', "option + click")
+            : nls.localizeWithPath('vs/editor/contrib/links/browser/links', 'links.navigate.kb.alt', "alt + click");
     if (link.url) {
         let nativeLabel = '';
         if (/^command:/i.test(link.url.toString())) {
@@ -344,7 +332,7 @@
             const match = link.url.toString().match(/^command:([^?#]+)/);
             if (match) {
                 const commandId = match[1];
-                nativeLabel = nls.localize('tooltip.explanation', "Execute command {0}", commandId);
+                nativeLabel = nls.localizeWithPath('vs/editor/contrib/links/browser/links', 'tooltip.explanation', "Execute command {0}", commandId);
             }
         }
         const hoverMessage = new MarkdownString('', true)
@@ -360,7 +348,7 @@
     constructor() {
         super({
             id: 'editor.action.openLink',
-            label: nls.localize('label', "Open Link"),
+            label: nls.localizeWithPath('vs/editor/contrib/links/browser/links', 'label', "Open Link"),
             alias: 'Open Link',
             precondition: undefined
         });
diff -urN -x '*.map' a/vs/editor/contrib/longLinesHelper/browser/longLinesHelper.js b/vs/editor/contrib/longLinesHelper/browser/longLinesHelper.js
--- a/vs/editor/contrib/longLinesHelper/browser/longLinesHelper.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/longLinesHelper/browser/longLinesHelper.js	2023-12-06 14:23:14.383854791 +0000
@@ -5,6 +5,9 @@
 import { Disposable } from '../../../../base/common/lifecycle.js';
 import { registerEditorContribution } from '../../../browser/editorExtensions.js';
 class LongLinesHelper extends Disposable {
+    static get(editor) {
+        return editor.getContribution(LongLinesHelper.ID);
+    }
     constructor(_editor) {
         super();
         this._editor = _editor;
diff -urN -x '*.map' a/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.js b/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.js
--- a/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var MarkdownRenderer_1;
 import { renderMarkdown } from '../../../../base/browser/markdownRenderer.js';
 import { createTrustedTypesPolicy } from '../../../../base/browser/trustedTypes.js';
@@ -53,7 +44,7 @@
             return { element, dispose: () => { } };
         }
         const disposables = new DisposableStore();
-        const rendered = disposables.add(renderMarkdown(markdown, Object.assign(Object.assign({}, this._getRenderOptions(markdown, disposables)), options), markedOptions));
+        const rendered = disposables.add(renderMarkdown(markdown, { ...this._getRenderOptions(markdown, disposables), ...options }, markedOptions));
         rendered.element.classList.add('rendered-markdown');
         return {
             element: rendered.element,
@@ -62,8 +53,7 @@
     }
     _getRenderOptions(markdown, disposables) {
         return {
-            codeBlockRenderer: (languageAlias, value) => __awaiter(this, void 0, void 0, function* () {
-                var _a, _b, _c;
+            codeBlockRenderer: async (languageAlias, value) => {
                 // In markdown,
                 // it is possible that we stumble upon language aliases (e.g.js instead of javascript)
                 // it is possible no alias is given in which case we fall back to the current editor lang
@@ -72,14 +62,14 @@
                     languageId = this._languageService.getLanguageIdByLanguageName(languageAlias);
                 }
                 else if (this._options.editor) {
-                    languageId = (_a = this._options.editor.getModel()) === null || _a === void 0 ? void 0 : _a.getLanguageId();
+                    languageId = this._options.editor.getModel()?.getLanguageId();
                 }
                 if (!languageId) {
                     languageId = PLAINTEXT_LANGUAGE_ID;
                 }
-                const html = yield tokenizeToString(this._languageService, value, languageId);
+                const html = await tokenizeToString(this._languageService, value, languageId);
                 const element = document.createElement('span');
-                element.innerHTML = ((_c = (_b = MarkdownRenderer_1._ttpTokenizer) === null || _b === void 0 ? void 0 : _b.createHTML(html)) !== null && _c !== void 0 ? _c : html);
+                element.innerHTML = (MarkdownRenderer_1._ttpTokenizer?.createHTML(html) ?? html);
                 // use "good" font
                 if (this._options.editor) {
                     const fontInfo = this._options.editor.getOption(50 /* EditorOption.fontInfo */);
@@ -92,7 +82,7 @@
                     element.style.fontSize = this._options.codeBlockFontSize;
                 }
                 return element;
-            }),
+            },
             asyncRenderCallback: () => this._onDidRenderAsync.fire(),
             actionHandler: {
                 callback: (link) => openLinkFromMarkdown(this._openerService, link, markdown.isTrusted),
@@ -111,20 +101,18 @@
     __param(2, IOpenerService)
 ], MarkdownRenderer);
 export { MarkdownRenderer };
-export function openLinkFromMarkdown(openerService, link, isTrusted) {
-    return __awaiter(this, void 0, void 0, function* () {
-        try {
-            return yield openerService.open(link, {
-                fromUserGesture: true,
-                allowContributedOpeners: true,
-                allowCommands: toAllowCommandsOption(isTrusted),
-            });
-        }
-        catch (e) {
-            onUnexpectedError(e);
-            return false;
-        }
-    });
+export async function openLinkFromMarkdown(openerService, link, isTrusted) {
+    try {
+        return await openerService.open(link, {
+            fromUserGesture: true,
+            allowContributedOpeners: true,
+            allowCommands: toAllowCommandsOption(isTrusted),
+        });
+    }
+    catch (e) {
+        onUnexpectedError(e);
+        return false;
+    }
 }
 function toAllowCommandsOption(isTrusted) {
     if (isTrusted === true) {
diff -urN -x '*.map' a/vs/editor/contrib/message/browser/messageController.js b/vs/editor/contrib/message/browser/messageController.js
--- a/vs/editor/contrib/message/browser/messageController.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/message/browser/messageController.js	2023-12-06 14:23:14.383854791 +0000
@@ -38,12 +38,14 @@
         this._visible = MessageController_1.MESSAGE_VISIBLE.bindTo(contextKeyService);
     }
     dispose() {
-        var _a;
-        (_a = this._message) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._message?.dispose();
         this._messageListeners.dispose();
         this._messageWidget.dispose();
         this._visible.reset();
     }
+    isVisible() {
+        return this._visible.get();
+    }
     showMessage(message, position) {
         alert(isMarkdownString(message) ? message.value : message);
         this._visible.set(true);
@@ -97,7 +99,7 @@
     }
 };
 MessageController.ID = 'editor.contrib.messageController';
-MessageController.MESSAGE_VISIBLE = new RawContextKey('messageVisible', false, nls.localize('messageVisible', 'Whether the editor is currently showing an inline message'));
+MessageController.MESSAGE_VISIBLE = new RawContextKey('messageVisible', false, nls.localizeWithPath('vs/editor/contrib/message/browser/messageController', 'messageVisible', 'Whether the editor is currently showing an inline message'));
 MessageController = MessageController_1 = __decorate([
     __param(1, IContextKeyService),
     __param(2, IOpenerService)
diff -urN -x '*.map' a/vs/editor/contrib/multicursor/browser/multicursor.js b/vs/editor/contrib/multicursor/browser/multicursor.js
--- a/vs/editor/contrib/multicursor/browser/multicursor.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/multicursor/browser/multicursor.js	2023-12-06 14:23:14.383854791 +0000
@@ -32,7 +32,7 @@
     const cursorDiff = cursorState.filter(cs => !previousCursorState.find(pcs => pcs.equals(cs)));
     if (cursorDiff.length >= 1) {
         const cursorPositions = cursorDiff.map(cs => `line ${cs.viewState.position.lineNumber} column ${cs.viewState.position.column}`).join(', ');
-        const msg = cursorDiff.length === 1 ? nls.localize('cursorAdded', "Cursor added: {0}", cursorPositions) : nls.localize('cursorsAdded', "Cursors added: {0}", cursorPositions);
+        const msg = cursorDiff.length === 1 ? nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'cursorAdded', "Cursor added: {0}", cursorPositions) : nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'cursorsAdded', "Cursors added: {0}", cursorPositions);
         status(msg);
     }
 }
@@ -40,7 +40,7 @@
     constructor() {
         super({
             id: 'editor.action.insertCursorAbove',
-            label: nls.localize('mutlicursor.insertAbove', "Add Cursor Above"),
+            label: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'mutlicursor.insertAbove', "Add Cursor Above"),
             alias: 'Add Cursor Above',
             precondition: undefined,
             kbOpts: {
@@ -55,7 +55,7 @@
             menuOpts: {
                 menuId: MenuId.MenubarSelectionMenu,
                 group: '3_multi',
-                title: nls.localize({ key: 'miInsertCursorAbove', comment: ['&& denotes a mnemonic'] }, "&&Add Cursor Above"),
+                title: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', { key: 'miInsertCursorAbove', comment: ['&& denotes a mnemonic'] }, "&&Add Cursor Above"),
                 order: 2
             }
         });
@@ -83,7 +83,7 @@
     constructor() {
         super({
             id: 'editor.action.insertCursorBelow',
-            label: nls.localize('mutlicursor.insertBelow', "Add Cursor Below"),
+            label: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'mutlicursor.insertBelow', "Add Cursor Below"),
             alias: 'Add Cursor Below',
             precondition: undefined,
             kbOpts: {
@@ -98,7 +98,7 @@
             menuOpts: {
                 menuId: MenuId.MenubarSelectionMenu,
                 group: '3_multi',
-                title: nls.localize({ key: 'miInsertCursorBelow', comment: ['&& denotes a mnemonic'] }, "A&&dd Cursor Below"),
+                title: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', { key: 'miInsertCursorBelow', comment: ['&& denotes a mnemonic'] }, "A&&dd Cursor Below"),
                 order: 3
             }
         });
@@ -126,7 +126,7 @@
     constructor() {
         super({
             id: 'editor.action.insertCursorAtEndOfEachLineSelected',
-            label: nls.localize('mutlicursor.insertAtEndOfEachLineSelected', "Add Cursors to Line Ends"),
+            label: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'mutlicursor.insertAtEndOfEachLineSelected', "Add Cursors to Line Ends"),
             alias: 'Add Cursors to Line Ends',
             precondition: undefined,
             kbOpts: {
@@ -137,7 +137,7 @@
             menuOpts: {
                 menuId: MenuId.MenubarSelectionMenu,
                 group: '3_multi',
-                title: nls.localize({ key: 'miInsertCursorAtEndOfEachLineSelected', comment: ['&& denotes a mnemonic'] }, "Add C&&ursors to Line Ends"),
+                title: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', { key: 'miInsertCursorAtEndOfEachLineSelected', comment: ['&& denotes a mnemonic'] }, "Add C&&ursors to Line Ends"),
                 order: 4
             }
         });
@@ -174,7 +174,7 @@
     constructor() {
         super({
             id: 'editor.action.addCursorsToBottom',
-            label: nls.localize('mutlicursor.addCursorsToBottom', "Add Cursors To Bottom"),
+            label: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'mutlicursor.addCursorsToBottom', "Add Cursors To Bottom"),
             alias: 'Add Cursors To Bottom',
             precondition: undefined
         });
@@ -201,7 +201,7 @@
     constructor() {
         super({
             id: 'editor.action.addCursorsToTop',
-            label: nls.localize('mutlicursor.addCursorsToTop', "Add Cursors To Top"),
+            label: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'mutlicursor.addCursorsToTop', "Add Cursors To Top"),
             alias: 'Add Cursors To Top',
             precondition: undefined
         });
@@ -551,6 +551,11 @@
             this._setSelections(matches.map(m => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)));
         }
     }
+    selectAllUsingSelections(selections) {
+        if (selections.length > 0) {
+            this._setSelections(selections);
+        }
+    }
 }
 MultiCursorSelectionController.ID = 'editor.contrib.multiCursorController';
 export class MultiCursorSelectionControllerAction extends EditorAction {
@@ -579,7 +584,7 @@
     constructor() {
         super({
             id: 'editor.action.addSelectionToNextFindMatch',
-            label: nls.localize('addSelectionToNextFindMatch', "Add Selection To Next Find Match"),
+            label: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'addSelectionToNextFindMatch', "Add Selection To Next Find Match"),
             alias: 'Add Selection To Next Find Match',
             precondition: undefined,
             kbOpts: {
@@ -590,7 +595,7 @@
             menuOpts: {
                 menuId: MenuId.MenubarSelectionMenu,
                 group: '3_multi',
-                title: nls.localize({ key: 'miAddSelectionToNextFindMatch', comment: ['&& denotes a mnemonic'] }, "Add &&Next Occurrence"),
+                title: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', { key: 'miAddSelectionToNextFindMatch', comment: ['&& denotes a mnemonic'] }, "Add &&Next Occurrence"),
                 order: 5
             }
         });
@@ -603,13 +608,13 @@
     constructor() {
         super({
             id: 'editor.action.addSelectionToPreviousFindMatch',
-            label: nls.localize('addSelectionToPreviousFindMatch', "Add Selection To Previous Find Match"),
+            label: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'addSelectionToPreviousFindMatch', "Add Selection To Previous Find Match"),
             alias: 'Add Selection To Previous Find Match',
             precondition: undefined,
             menuOpts: {
                 menuId: MenuId.MenubarSelectionMenu,
                 group: '3_multi',
-                title: nls.localize({ key: 'miAddSelectionToPreviousFindMatch', comment: ['&& denotes a mnemonic'] }, "Add P&&revious Occurrence"),
+                title: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', { key: 'miAddSelectionToPreviousFindMatch', comment: ['&& denotes a mnemonic'] }, "Add P&&revious Occurrence"),
                 order: 6
             }
         });
@@ -622,7 +627,7 @@
     constructor() {
         super({
             id: 'editor.action.moveSelectionToNextFindMatch',
-            label: nls.localize('moveSelectionToNextFindMatch', "Move Last Selection To Next Find Match"),
+            label: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'moveSelectionToNextFindMatch', "Move Last Selection To Next Find Match"),
             alias: 'Move Last Selection To Next Find Match',
             precondition: undefined,
             kbOpts: {
@@ -640,7 +645,7 @@
     constructor() {
         super({
             id: 'editor.action.moveSelectionToPreviousFindMatch',
-            label: nls.localize('moveSelectionToPreviousFindMatch', "Move Last Selection To Previous Find Match"),
+            label: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'moveSelectionToPreviousFindMatch', "Move Last Selection To Previous Find Match"),
             alias: 'Move Last Selection To Previous Find Match',
             precondition: undefined
         });
@@ -653,7 +658,7 @@
     constructor() {
         super({
             id: 'editor.action.selectHighlights',
-            label: nls.localize('selectAllOccurrencesOfFindMatch', "Select All Occurrences of Find Match"),
+            label: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'selectAllOccurrencesOfFindMatch', "Select All Occurrences of Find Match"),
             alias: 'Select All Occurrences of Find Match',
             precondition: undefined,
             kbOpts: {
@@ -664,7 +669,7 @@
             menuOpts: {
                 menuId: MenuId.MenubarSelectionMenu,
                 group: '3_multi',
-                title: nls.localize({ key: 'miSelectHighlights', comment: ['&& denotes a mnemonic'] }, "Select All &&Occurrences"),
+                title: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', { key: 'miSelectHighlights', comment: ['&& denotes a mnemonic'] }, "Select All &&Occurrences"),
                 order: 7
             }
         });
@@ -677,7 +682,7 @@
     constructor() {
         super({
             id: 'editor.action.changeAll',
-            label: nls.localize('changeAll.label', "Change All Occurrences"),
+            label: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'changeAll.label', "Change All Occurrences"),
             alias: 'Change All Occurrences',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.editorTextFocus),
             kbOpts: {
@@ -928,9 +933,9 @@
     constructor() {
         super({
             id: 'editor.action.focusNextCursor',
-            label: nls.localize('mutlicursor.focusNextCursor', "Focus Next Cursor"),
+            label: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'mutlicursor.focusNextCursor', "Focus Next Cursor"),
             description: {
-                description: nls.localize('mutlicursor.focusNextCursor.description', "Focuses the next cursor"),
+                description: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'mutlicursor.focusNextCursor.description', "Focuses the next cursor"),
                 args: [],
             },
             alias: 'Focus Next Cursor',
@@ -961,9 +966,9 @@
     constructor() {
         super({
             id: 'editor.action.focusPreviousCursor',
-            label: nls.localize('mutlicursor.focusPreviousCursor', "Focus Previous Cursor"),
+            label: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'mutlicursor.focusPreviousCursor', "Focus Previous Cursor"),
             description: {
-                description: nls.localize('mutlicursor.focusPreviousCursor.description', "Focuses the previous cursor"),
+                description: nls.localizeWithPath('vs/editor/contrib/multicursor/browser/multicursor', 'mutlicursor.focusPreviousCursor.description', "Focuses the previous cursor"),
                 args: [],
             },
             alias: 'Focus Previous Cursor',
diff -urN -x '*.map' a/vs/editor/contrib/parameterHints/browser/parameterHints.js b/vs/editor/contrib/parameterHints/browser/parameterHints.js
--- a/vs/editor/contrib/parameterHints/browser/parameterHints.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/parameterHints/browser/parameterHints.js	2023-12-06 14:23:14.383854791 +0000
@@ -33,13 +33,12 @@
         this.editor = editor;
         this.model = this._register(new ParameterHintsModel(editor, languageFeaturesService.signatureHelpProvider));
         this._register(this.model.onChangedHints(newParameterHints => {
-            var _a;
             if (newParameterHints) {
                 this.widget.value.show();
                 this.widget.value.render(newParameterHints);
             }
             else {
-                (_a = this.widget.rawValue) === null || _a === void 0 ? void 0 : _a.hide();
+                this.widget.rawValue?.hide();
             }
         }));
         this.widget = new Lazy(() => this._register(instantiationService.createInstance(ParameterHintsWidget, this.editor, this.model)));
@@ -48,12 +47,10 @@
         this.model.cancel();
     }
     previous() {
-        var _a;
-        (_a = this.widget.rawValue) === null || _a === void 0 ? void 0 : _a.previous();
+        this.widget.rawValue?.previous();
     }
     next() {
-        var _a;
-        (_a = this.widget.rawValue) === null || _a === void 0 ? void 0 : _a.next();
+        this.widget.rawValue?.next();
     }
     trigger(context) {
         this.model.trigger(context, 0);
@@ -69,7 +66,7 @@
     constructor() {
         super({
             id: 'editor.action.triggerParameterHints',
-            label: nls.localize('parameterHints.trigger.label', "Trigger Parameter Hints"),
+            label: nls.localizeWithPath('vs/editor/contrib/parameterHints/browser/parameterHints', 'parameterHints.trigger.label', "Trigger Parameter Hints"),
             alias: 'Trigger Parameter Hints',
             precondition: EditorContextKeys.hasSignatureHelpProvider,
             kbOpts: {
@@ -81,7 +78,7 @@
     }
     run(accessor, editor) {
         const controller = ParameterHintsController.get(editor);
-        controller === null || controller === void 0 ? void 0 : controller.trigger({
+        controller?.trigger({
             triggerKind: languages.SignatureHelpTriggerKind.Invoke
         });
     }
diff -urN -x '*.map' a/vs/editor/contrib/parameterHints/browser/parameterHintsModel.js b/vs/editor/contrib/parameterHints/browser/parameterHintsModel.js
--- a/vs/editor/contrib/parameterHints/browser/parameterHintsModel.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/parameterHints/browser/parameterHintsModel.js	2023-12-06 14:23:14.383854791 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { createCancelablePromise, Delayer } from '../../../../base/common/async.js';
 import { onUnexpectedError } from '../../../../base/common/errors.js';
 import { Emitter } from '../../../../base/common/event.js';
@@ -123,59 +114,57 @@
         if (this.state.type !== 1 /* ParameterHintState.Type.Active */) {
             return;
         }
-        this.state = new ParameterHintState.Active(Object.assign(Object.assign({}, this.state.hints), { activeSignature }));
+        this.state = new ParameterHintState.Active({ ...this.state.hints, activeSignature });
         this._onChangedHints.fire(this.state.hints);
     }
-    doTrigger(triggerId) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const isRetrigger = this.state.type === 1 /* ParameterHintState.Type.Active */ || this.state.type === 2 /* ParameterHintState.Type.Pending */;
-            const activeSignatureHelp = this.getLastActiveHints();
-            this.cancel(true);
-            if (this._pendingTriggers.length === 0) {
+    async doTrigger(triggerId) {
+        const isRetrigger = this.state.type === 1 /* ParameterHintState.Type.Active */ || this.state.type === 2 /* ParameterHintState.Type.Pending */;
+        const activeSignatureHelp = this.getLastActiveHints();
+        this.cancel(true);
+        if (this._pendingTriggers.length === 0) {
+            return false;
+        }
+        const context = this._pendingTriggers.reduce(mergeTriggerContexts);
+        this._pendingTriggers = [];
+        const triggerContext = {
+            triggerKind: context.triggerKind,
+            triggerCharacter: context.triggerCharacter,
+            isRetrigger: isRetrigger,
+            activeSignatureHelp: activeSignatureHelp
+        };
+        if (!this.editor.hasModel()) {
+            return false;
+        }
+        const model = this.editor.getModel();
+        const position = this.editor.getPosition();
+        this.state = new ParameterHintState.Pending(createCancelablePromise(token => provideSignatureHelp(this.providers, model, position, triggerContext, token)), activeSignatureHelp);
+        try {
+            const result = await this.state.request;
+            // Check that we are still resolving the correct signature help
+            if (triggerId !== this.triggerId) {
+                result?.dispose();
                 return false;
             }
-            const context = this._pendingTriggers.reduce(mergeTriggerContexts);
-            this._pendingTriggers = [];
-            const triggerContext = {
-                triggerKind: context.triggerKind,
-                triggerCharacter: context.triggerCharacter,
-                isRetrigger: isRetrigger,
-                activeSignatureHelp: activeSignatureHelp
-            };
-            if (!this.editor.hasModel()) {
+            if (!result || !result.value.signatures || result.value.signatures.length === 0) {
+                result?.dispose();
+                this._lastSignatureHelpResult.clear();
+                this.cancel();
                 return false;
             }
-            const model = this.editor.getModel();
-            const position = this.editor.getPosition();
-            this.state = new ParameterHintState.Pending(createCancelablePromise(token => provideSignatureHelp(this.providers, model, position, triggerContext, token)), activeSignatureHelp);
-            try {
-                const result = yield this.state.request;
-                // Check that we are still resolving the correct signature help
-                if (triggerId !== this.triggerId) {
-                    result === null || result === void 0 ? void 0 : result.dispose();
-                    return false;
-                }
-                if (!result || !result.value.signatures || result.value.signatures.length === 0) {
-                    result === null || result === void 0 ? void 0 : result.dispose();
-                    this._lastSignatureHelpResult.clear();
-                    this.cancel();
-                    return false;
-                }
-                else {
-                    this.state = new ParameterHintState.Active(result.value);
-                    this._lastSignatureHelpResult.value = result;
-                    this._onChangedHints.fire(this.state.hints);
-                    return true;
-                }
+            else {
+                this.state = new ParameterHintState.Active(result.value);
+                this._lastSignatureHelpResult.value = result;
+                this._onChangedHints.fire(this.state.hints);
+                return true;
             }
-            catch (error) {
-                if (triggerId === this.triggerId) {
-                    this.state = ParameterHintState.Default;
-                }
-                onUnexpectedError(error);
-                return false;
+        }
+        catch (error) {
+            if (triggerId === this.triggerId) {
+                this.state = ParameterHintState.Default;
             }
-        });
+            onUnexpectedError(error);
+            return false;
+        }
     }
     getLastActiveHints() {
         switch (this.state.type) {
diff -urN -x '*.map' a/vs/editor/contrib/parameterHints/browser/parameterHintsWidget.js b/vs/editor/contrib/parameterHints/browser/parameterHintsWidget.js
--- a/vs/editor/contrib/parameterHints/browser/parameterHintsWidget.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/parameterHints/browser/parameterHintsWidget.js	2023-12-06 14:23:14.383854791 +0000
@@ -31,8 +31,8 @@
 import { registerIcon } from '../../../../platform/theme/common/iconRegistry.js';
 import { ThemeIcon } from '../../../../base/common/themables.js';
 const $ = dom.$;
-const parameterHintsNextIcon = registerIcon('parameter-hints-next', Codicon.chevronDown, nls.localize('parameterHintsNextIcon', 'Icon for show next parameter hint.'));
-const parameterHintsPreviousIcon = registerIcon('parameter-hints-previous', Codicon.chevronUp, nls.localize('parameterHintsPreviousIcon', 'Icon for show previous parameter hint.'));
+const parameterHintsNextIcon = registerIcon('parameter-hints-next', Codicon.chevronDown, nls.localizeWithPath('vs/editor/contrib/parameterHints/browser/parameterHintsWidget', 'parameterHintsNextIcon', 'Icon for show next parameter hint.'));
+const parameterHintsPreviousIcon = registerIcon('parameter-hints-previous', Codicon.chevronUp, nls.localizeWithPath('vs/editor/contrib/parameterHints/browser/parameterHintsWidget', 'parameterHintsPreviousIcon', 'Icon for show previous parameter hint.'));
 let ParameterHintsWidget = ParameterHintsWidget_1 = class ParameterHintsWidget extends Disposable {
     constructor(editor, model, contextKeyService, openerService, languageService) {
         super();
@@ -109,13 +109,11 @@
         this.keyVisible.set(true);
         this.visible = true;
         setTimeout(() => {
-            var _a;
-            (_a = this.domNodes) === null || _a === void 0 ? void 0 : _a.element.classList.add('visible');
+            this.domNodes?.element.classList.add('visible');
         }, 100);
         this.editor.layoutContentWidget(this);
     }
     hide() {
-        var _a;
         this.renderDisposeables.clear();
         if (!this.visible) {
             return;
@@ -123,7 +121,7 @@
         this.keyVisible.reset();
         this.visible = false;
         this.announcedLabel = null;
-        (_a = this.domNodes) === null || _a === void 0 ? void 0 : _a.element.classList.remove('visible');
+        this.domNodes?.element.classList.remove('visible');
         this.editor.layoutContentWidget(this);
     }
     getPosition() {
@@ -136,7 +134,6 @@
         return null;
     }
     render(hints) {
-        var _a;
         this.renderDisposeables.clear();
         if (!this.domNodes) {
             return;
@@ -155,7 +152,7 @@
         code.style.fontSize = `${fontInfo.fontSize}px`;
         code.style.fontFamily = fontInfo.fontFamily;
         const hasParameters = signature.parameters.length > 0;
-        const activeParameterIndex = (_a = signature.activeParameter) !== null && _a !== void 0 ? _a : hints.activeParameter;
+        const activeParameterIndex = signature.activeParameter ?? hints.activeParameter;
         if (!hasParameters) {
             const label = dom.append(code, $('span'));
             label.textContent = signature.label;
@@ -164,7 +161,7 @@
             this.renderParameters(code, signature, activeParameterIndex);
         }
         const activeParameter = signature.parameters[activeParameterIndex];
-        if (activeParameter === null || activeParameter === void 0 ? void 0 : activeParameter.documentation) {
+        if (activeParameter?.documentation) {
             const documentation = $('span.documentation');
             if (typeof activeParameter.documentation === 'string') {
                 documentation.textContent = activeParameter.documentation;
@@ -208,7 +205,7 @@
             // Select method gets called on every user type while parameter hints are visible.
             // We do not want to spam the user with same announcements, so we only announce if the current parameter changed.
             if (this.announcedLabel !== labelToAnnounce) {
-                aria.alert(nls.localize('hint', "{0}, hint", labelToAnnounce));
+                aria.alert(nls.localizeWithPath('vs/editor/contrib/parameterHints/browser/parameterHintsWidget', 'hint', "{0}, hint", labelToAnnounce));
                 this.announcedLabel = labelToAnnounce;
             }
         }
@@ -218,8 +215,7 @@
     renderMarkdownDocs(markdown) {
         const renderedContents = this.renderDisposeables.add(this.markdownRenderer.render(markdown, {
             asyncRenderCallback: () => {
-                var _a;
-                (_a = this.domNodes) === null || _a === void 0 ? void 0 : _a.scrollbar.scanDomNode();
+                this.domNodes?.scrollbar.scanDomNode();
             }
         }));
         renderedContents.element.classList.add('markdown-docs');
@@ -308,4 +304,4 @@
     __param(4, ILanguageService)
 ], ParameterHintsWidget);
 export { ParameterHintsWidget };
-registerColor('editorHoverWidget.highlightForeground', { dark: listHighlightForeground, light: listHighlightForeground, hcDark: listHighlightForeground, hcLight: listHighlightForeground }, nls.localize('editorHoverWidgetHighlightForeground', 'Foreground color of the active item in the parameter hint.'));
+registerColor('editorHoverWidget.highlightForeground', { dark: listHighlightForeground, light: listHighlightForeground, hcDark: listHighlightForeground, hcLight: listHighlightForeground }, nls.localizeWithPath('vs/editor/contrib/parameterHints/browser/parameterHintsWidget', 'editorHoverWidgetHighlightForeground', 'Foreground color of the active item in the parameter hint.'));
diff -urN -x '*.map' a/vs/editor/contrib/parameterHints/browser/provideSignatureHelp.js b/vs/editor/contrib/parameterHints/browser/provideSignatureHelp.js
--- a/vs/editor/contrib/parameterHints/browser/provideSignatureHelp.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/parameterHints/browser/provideSignatureHelp.js	2023-12-06 14:23:14.383854791 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { assertType } from '../../../../base/common/types.js';
@@ -25,32 +16,30 @@
     Visible: new RawContextKey('parameterHintsVisible', false),
     MultipleSignatures: new RawContextKey('parameterHintsMultipleSignatures', false),
 };
-export function provideSignatureHelp(registry, model, position, context, token) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const supports = registry.ordered(model);
-        for (const support of supports) {
-            try {
-                const result = yield support.provideSignatureHelp(model, position, token, context);
-                if (result) {
-                    return result;
-                }
-            }
-            catch (err) {
-                onUnexpectedExternalError(err);
+export async function provideSignatureHelp(registry, model, position, context, token) {
+    const supports = registry.ordered(model);
+    for (const support of supports) {
+        try {
+            const result = await support.provideSignatureHelp(model, position, token, context);
+            if (result) {
+                return result;
             }
         }
-        return undefined;
-    });
+        catch (err) {
+            onUnexpectedExternalError(err);
+        }
+    }
+    return undefined;
 }
-CommandsRegistry.registerCommand('_executeSignatureHelpProvider', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {
+CommandsRegistry.registerCommand('_executeSignatureHelpProvider', async (accessor, ...args) => {
     const [uri, position, triggerCharacter] = args;
     assertType(URI.isUri(uri));
     assertType(Position.isIPosition(position));
     assertType(typeof triggerCharacter === 'string' || !triggerCharacter);
     const languageFeaturesService = accessor.get(ILanguageFeaturesService);
-    const ref = yield accessor.get(ITextModelService).createModelReference(uri);
+    const ref = await accessor.get(ITextModelService).createModelReference(uri);
     try {
-        const result = yield provideSignatureHelp(languageFeaturesService.signatureHelpProvider, ref.object.textEditorModel, Position.lift(position), {
+        const result = await provideSignatureHelp(languageFeaturesService.signatureHelpProvider, ref.object.textEditorModel, Position.lift(position), {
             triggerKind: languages.SignatureHelpTriggerKind.Invoke,
             isRetrigger: false,
             triggerCharacter,
@@ -64,4 +53,4 @@
     finally {
         ref.dispose();
     }
-}));
+});
diff -urN -x '*.map' a/vs/editor/contrib/peekView/browser/peekView.js b/vs/editor/contrib/peekView/browser/peekView.js
--- a/vs/editor/contrib/peekView/browser/peekView.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/peekView/browser/peekView.js	2023-12-06 14:23:14.383854791 +0000
@@ -53,7 +53,7 @@
 }, 1 /* InstantiationType.Delayed */);
 export var PeekContext;
 (function (PeekContext) {
-    PeekContext.inPeekEditor = new RawContextKey('inReferenceSearchEditor', true, nls.localize('inReferenceSearchEditor', "Whether the current code editor is embedded inside peek"));
+    PeekContext.inPeekEditor = new RawContextKey('inReferenceSearchEditor', true, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'inReferenceSearchEditor', "Whether the current code editor is embedded inside peek"));
     PeekContext.notInPeekEditor = PeekContext.inPeekEditor.toNegated();
 })(PeekContext || (PeekContext = {}));
 let PeekContextController = class PeekContextController {
@@ -152,7 +152,7 @@
         this._actionbarWidget = new ActionBar(actionsContainer, actionBarOptions);
         this._disposables.add(this._actionbarWidget);
         if (!noCloseAction) {
-            this._actionbarWidget.push(new Action('peekview.close', nls.localize('label.close', "Close"), ThemeIcon.asClassName(Codicon.close), true, () => {
+            this._actionbarWidget.push(new Action('peekview.close', nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'label.close', "Close"), ThemeIcon.asClassName(Codicon.close), true, () => {
                 this.dispose();
                 return Promise.resolve();
             }), { label: false, icon: true });
@@ -219,18 +219,18 @@
     __param(2, IInstantiationService)
 ], PeekViewWidget);
 export { PeekViewWidget };
-export const peekViewTitleBackground = registerColor('peekViewTitle.background', { dark: '#252526', light: '#F3F3F3', hcDark: Color.black, hcLight: Color.white }, nls.localize('peekViewTitleBackground', 'Background color of the peek view title area.'));
-export const peekViewTitleForeground = registerColor('peekViewTitleLabel.foreground', { dark: Color.white, light: Color.black, hcDark: Color.white, hcLight: editorForeground }, nls.localize('peekViewTitleForeground', 'Color of the peek view title.'));
-export const peekViewTitleInfoForeground = registerColor('peekViewTitleDescription.foreground', { dark: '#ccccccb3', light: '#616161', hcDark: '#FFFFFF99', hcLight: '#292929' }, nls.localize('peekViewTitleInfoForeground', 'Color of the peek view title info.'));
-export const peekViewBorder = registerColor('peekView.border', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('peekViewBorder', 'Color of the peek view borders and arrow.'));
-export const peekViewResultsBackground = registerColor('peekViewResult.background', { dark: '#252526', light: '#F3F3F3', hcDark: Color.black, hcLight: Color.white }, nls.localize('peekViewResultsBackground', 'Background color of the peek view result list.'));
-export const peekViewResultsMatchForeground = registerColor('peekViewResult.lineForeground', { dark: '#bbbbbb', light: '#646465', hcDark: Color.white, hcLight: editorForeground }, nls.localize('peekViewResultsMatchForeground', 'Foreground color for line nodes in the peek view result list.'));
-export const peekViewResultsFileForeground = registerColor('peekViewResult.fileForeground', { dark: Color.white, light: '#1E1E1E', hcDark: Color.white, hcLight: editorForeground }, nls.localize('peekViewResultsFileForeground', 'Foreground color for file nodes in the peek view result list.'));
-export const peekViewResultsSelectionBackground = registerColor('peekViewResult.selectionBackground', { dark: '#3399ff33', light: '#3399ff33', hcDark: null, hcLight: null }, nls.localize('peekViewResultsSelectionBackground', 'Background color of the selected entry in the peek view result list.'));
-export const peekViewResultsSelectionForeground = registerColor('peekViewResult.selectionForeground', { dark: Color.white, light: '#6C6C6C', hcDark: Color.white, hcLight: editorForeground }, nls.localize('peekViewResultsSelectionForeground', 'Foreground color of the selected entry in the peek view result list.'));
-export const peekViewEditorBackground = registerColor('peekViewEditor.background', { dark: '#001F33', light: '#F2F8FC', hcDark: Color.black, hcLight: Color.white }, nls.localize('peekViewEditorBackground', 'Background color of the peek view editor.'));
-export const peekViewEditorGutterBackground = registerColor('peekViewEditorGutter.background', { dark: peekViewEditorBackground, light: peekViewEditorBackground, hcDark: peekViewEditorBackground, hcLight: peekViewEditorBackground }, nls.localize('peekViewEditorGutterBackground', 'Background color of the gutter in the peek view editor.'));
-export const peekViewEditorStickyScrollBackground = registerColor('peekViewEditorStickyScroll.background', { dark: peekViewEditorBackground, light: peekViewEditorBackground, hcDark: peekViewEditorBackground, hcLight: peekViewEditorBackground }, nls.localize('peekViewEditorStickScrollBackground', 'Background color of sticky scroll in the peek view editor.'));
-export const peekViewResultsMatchHighlight = registerColor('peekViewResult.matchHighlightBackground', { dark: '#ea5c004d', light: '#ea5c004d', hcDark: null, hcLight: null }, nls.localize('peekViewResultsMatchHighlight', 'Match highlight color in the peek view result list.'));
-export const peekViewEditorMatchHighlight = registerColor('peekViewEditor.matchHighlightBackground', { dark: '#ff8f0099', light: '#f5d802de', hcDark: null, hcLight: null }, nls.localize('peekViewEditorMatchHighlight', 'Match highlight color in the peek view editor.'));
-export const peekViewEditorMatchHighlightBorder = registerColor('peekViewEditor.matchHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('peekViewEditorMatchHighlightBorder', 'Match highlight border in the peek view editor.'));
+export const peekViewTitleBackground = registerColor('peekViewTitle.background', { dark: '#252526', light: '#F3F3F3', hcDark: Color.black, hcLight: Color.white }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewTitleBackground', 'Background color of the peek view title area.'));
+export const peekViewTitleForeground = registerColor('peekViewTitleLabel.foreground', { dark: Color.white, light: Color.black, hcDark: Color.white, hcLight: editorForeground }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewTitleForeground', 'Color of the peek view title.'));
+export const peekViewTitleInfoForeground = registerColor('peekViewTitleDescription.foreground', { dark: '#ccccccb3', light: '#616161', hcDark: '#FFFFFF99', hcLight: '#292929' }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewTitleInfoForeground', 'Color of the peek view title info.'));
+export const peekViewBorder = registerColor('peekView.border', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewBorder', 'Color of the peek view borders and arrow.'));
+export const peekViewResultsBackground = registerColor('peekViewResult.background', { dark: '#252526', light: '#F3F3F3', hcDark: Color.black, hcLight: Color.white }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewResultsBackground', 'Background color of the peek view result list.'));
+export const peekViewResultsMatchForeground = registerColor('peekViewResult.lineForeground', { dark: '#bbbbbb', light: '#646465', hcDark: Color.white, hcLight: editorForeground }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewResultsMatchForeground', 'Foreground color for line nodes in the peek view result list.'));
+export const peekViewResultsFileForeground = registerColor('peekViewResult.fileForeground', { dark: Color.white, light: '#1E1E1E', hcDark: Color.white, hcLight: editorForeground }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewResultsFileForeground', 'Foreground color for file nodes in the peek view result list.'));
+export const peekViewResultsSelectionBackground = registerColor('peekViewResult.selectionBackground', { dark: '#3399ff33', light: '#3399ff33', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewResultsSelectionBackground', 'Background color of the selected entry in the peek view result list.'));
+export const peekViewResultsSelectionForeground = registerColor('peekViewResult.selectionForeground', { dark: Color.white, light: '#6C6C6C', hcDark: Color.white, hcLight: editorForeground }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewResultsSelectionForeground', 'Foreground color of the selected entry in the peek view result list.'));
+export const peekViewEditorBackground = registerColor('peekViewEditor.background', { dark: '#001F33', light: '#F2F8FC', hcDark: Color.black, hcLight: Color.white }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewEditorBackground', 'Background color of the peek view editor.'));
+export const peekViewEditorGutterBackground = registerColor('peekViewEditorGutter.background', { dark: peekViewEditorBackground, light: peekViewEditorBackground, hcDark: peekViewEditorBackground, hcLight: peekViewEditorBackground }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewEditorGutterBackground', 'Background color of the gutter in the peek view editor.'));
+export const peekViewEditorStickyScrollBackground = registerColor('peekViewEditorStickyScroll.background', { dark: peekViewEditorBackground, light: peekViewEditorBackground, hcDark: peekViewEditorBackground, hcLight: peekViewEditorBackground }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewEditorStickScrollBackground', 'Background color of sticky scroll in the peek view editor.'));
+export const peekViewResultsMatchHighlight = registerColor('peekViewResult.matchHighlightBackground', { dark: '#ea5c004d', light: '#ea5c004d', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewResultsMatchHighlight', 'Match highlight color in the peek view result list.'));
+export const peekViewEditorMatchHighlight = registerColor('peekViewEditor.matchHighlightBackground', { dark: '#ff8f0099', light: '#f5d802de', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewEditorMatchHighlight', 'Match highlight color in the peek view editor.'));
+export const peekViewEditorMatchHighlightBorder = registerColor('peekViewEditor.matchHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localizeWithPath('vs/editor/contrib/peekView/browser/peekView', 'peekViewEditorMatchHighlightBorder', 'Match highlight border in the peek view editor.'));
diff -urN -x '*.map' a/vs/editor/contrib/quickAccess/browser/commandsQuickAccess.js b/vs/editor/contrib/quickAccess/browser/commandsQuickAccess.js
--- a/vs/editor/contrib/quickAccess/browser/commandsQuickAccess.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/quickAccess/browser/commandsQuickAccess.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,26 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-import { stripIcons } from '../../../../base/common/iconLabels.js';
-import { AbstractCommandsQuickAccessProvider } from '../../../../platform/quickinput/browser/commandsQuickAccess.js';
-export class AbstractEditorCommandsQuickAccessProvider extends AbstractCommandsQuickAccessProvider {
-    constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {
-        super(options, instantiationService, keybindingService, commandService, telemetryService, dialogService);
-    }
-    getCodeEditorCommandPicks() {
-        const activeTextEditorControl = this.activeTextEditorControl;
-        if (!activeTextEditorControl) {
-            return [];
-        }
-        const editorCommandPicks = [];
-        for (const editorAction of activeTextEditorControl.getSupportedActions()) {
-            editorCommandPicks.push({
-                commandId: editorAction.id,
-                commandAlias: editorAction.alias,
-                label: stripIcons(editorAction.label) || editorAction.id,
-            });
-        }
-        return editorCommandPicks;
-    }
-}
diff -urN -x '*.map' a/vs/editor/contrib/quickAccess/browser/editorNavigationQuickAccess.js b/vs/editor/contrib/quickAccess/browser/editorNavigationQuickAccess.js
--- a/vs/editor/contrib/quickAccess/browser/editorNavigationQuickAccess.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/quickAccess/browser/editorNavigationQuickAccess.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,153 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-import { createSingleCallFunction } from '../../../../base/common/functional.js';
-import { DisposableStore, MutableDisposable, toDisposable } from '../../../../base/common/lifecycle.js';
-import { getCodeEditor, isDiffEditor } from '../../../browser/editorBrowser.js';
-import { OverviewRulerLane } from '../../../common/model.js';
-import { overviewRulerRangeHighlight } from '../../../common/core/editorColorRegistry.js';
-import { themeColorFromId } from '../../../../platform/theme/common/themeService.js';
-import { status } from '../../../../base/browser/ui/aria/aria.js';
-/**
- * A reusable quick access provider for the editor with support
- * for adding decorations for navigating in the currently active file
- * (for example "Go to line", "Go to symbol").
- */
-export class AbstractEditorNavigationQuickAccessProvider {
-    constructor(options) {
-        this.options = options;
-        //#endregion
-        //#region Decorations Utils
-        this.rangeHighlightDecorationId = undefined;
-    }
-    //#region Provider methods
-    provide(picker, token) {
-        var _a;
-        const disposables = new DisposableStore();
-        // Apply options if any
-        picker.canAcceptInBackground = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.canAcceptInBackground);
-        // Disable filtering & sorting, we control the results
-        picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
-        // Provide based on current active editor
-        const pickerDisposable = disposables.add(new MutableDisposable());
-        pickerDisposable.value = this.doProvide(picker, token);
-        // Re-create whenever the active editor changes
-        disposables.add(this.onDidActiveTextEditorControlChange(() => {
-            // Clear old
-            pickerDisposable.value = undefined;
-            // Add new
-            pickerDisposable.value = this.doProvide(picker, token);
-        }));
-        return disposables;
-    }
-    doProvide(picker, token) {
-        var _a;
-        const disposables = new DisposableStore();
-        // With text control
-        const editor = this.activeTextEditorControl;
-        if (editor && this.canProvideWithTextEditor(editor)) {
-            const context = { editor };
-            // Restore any view state if this picker was closed
-            // without actually going to a line
-            const codeEditor = getCodeEditor(editor);
-            if (codeEditor) {
-                // Remember view state and update it when the cursor position
-                // changes even later because it could be that the user has
-                // configured quick access to remain open when focus is lost and
-                // we always want to restore the current location.
-                let lastKnownEditorViewState = (_a = editor.saveViewState()) !== null && _a !== void 0 ? _a : undefined;
-                disposables.add(codeEditor.onDidChangeCursorPosition(() => {
-                    var _a;
-                    lastKnownEditorViewState = (_a = editor.saveViewState()) !== null && _a !== void 0 ? _a : undefined;
-                }));
-                context.restoreViewState = () => {
-                    if (lastKnownEditorViewState && editor === this.activeTextEditorControl) {
-                        editor.restoreViewState(lastKnownEditorViewState);
-                    }
-                };
-                disposables.add(createSingleCallFunction(token.onCancellationRequested)(() => { var _a; return (_a = context.restoreViewState) === null || _a === void 0 ? void 0 : _a.call(context); }));
-            }
-            // Clean up decorations on dispose
-            disposables.add(toDisposable(() => this.clearDecorations(editor)));
-            // Ask subclass for entries
-            disposables.add(this.provideWithTextEditor(context, picker, token));
-        }
-        // Without text control
-        else {
-            disposables.add(this.provideWithoutTextEditor(picker, token));
-        }
-        return disposables;
-    }
-    /**
-     * Subclasses to implement if they can operate on the text editor.
-     */
-    canProvideWithTextEditor(editor) {
-        return true;
-    }
-    gotoLocation({ editor }, options) {
-        editor.setSelection(options.range);
-        editor.revealRangeInCenter(options.range, 0 /* ScrollType.Smooth */);
-        if (!options.preserveFocus) {
-            editor.focus();
-        }
-        const model = editor.getModel();
-        if (model && 'getLineContent' in model) {
-            status(`${model.getLineContent(options.range.startLineNumber)}`);
-        }
-    }
-    getModel(editor) {
-        var _a;
-        return isDiffEditor(editor) ?
-            (_a = editor.getModel()) === null || _a === void 0 ? void 0 : _a.modified :
-            editor.getModel();
-    }
-    addDecorations(editor, range) {
-        editor.changeDecorations(changeAccessor => {
-            // Reset old decorations if any
-            const deleteDecorations = [];
-            if (this.rangeHighlightDecorationId) {
-                deleteDecorations.push(this.rangeHighlightDecorationId.overviewRulerDecorationId);
-                deleteDecorations.push(this.rangeHighlightDecorationId.rangeHighlightId);
-                this.rangeHighlightDecorationId = undefined;
-            }
-            // Add new decorations for the range
-            const newDecorations = [
-                // highlight the entire line on the range
-                {
-                    range,
-                    options: {
-                        description: 'quick-access-range-highlight',
-                        className: 'rangeHighlight',
-                        isWholeLine: true
-                    }
-                },
-                // also add overview ruler highlight
-                {
-                    range,
-                    options: {
-                        description: 'quick-access-range-highlight-overview',
-                        overviewRuler: {
-                            color: themeColorFromId(overviewRulerRangeHighlight),
-                            position: OverviewRulerLane.Full
-                        }
-                    }
-                }
-            ];
-            const [rangeHighlightId, overviewRulerDecorationId] = changeAccessor.deltaDecorations(deleteDecorations, newDecorations);
-            this.rangeHighlightDecorationId = { rangeHighlightId, overviewRulerDecorationId };
-        });
-    }
-    clearDecorations(editor) {
-        const rangeHighlightDecorationId = this.rangeHighlightDecorationId;
-        if (rangeHighlightDecorationId) {
-            editor.changeDecorations(changeAccessor => {
-                changeAccessor.deltaDecorations([
-                    rangeHighlightDecorationId.overviewRulerDecorationId,
-                    rangeHighlightDecorationId.rangeHighlightId
-                ], []);
-            });
-            this.rangeHighlightDecorationId = undefined;
-        }
-    }
-}
diff -urN -x '*.map' a/vs/editor/contrib/quickAccess/browser/gotoLineQuickAccess.js b/vs/editor/contrib/quickAccess/browser/gotoLineQuickAccess.js
--- a/vs/editor/contrib/quickAccess/browser/gotoLineQuickAccess.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/quickAccess/browser/gotoLineQuickAccess.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,127 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-import { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';
-import { getCodeEditor } from '../../../browser/editorBrowser.js';
-import { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';
-import { localize } from '../../../../nls.js';
-export class AbstractGotoLineQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {
-    constructor() {
-        super({ canAcceptInBackground: true });
-    }
-    provideWithoutTextEditor(picker) {
-        const label = localize('cannotRunGotoLine', "Open a text editor first to go to a line.");
-        picker.items = [{ label }];
-        picker.ariaLabel = label;
-        return Disposable.None;
-    }
-    provideWithTextEditor(context, picker, token) {
-        const editor = context.editor;
-        const disposables = new DisposableStore();
-        // Goto line once picked
-        disposables.add(picker.onDidAccept(event => {
-            const [item] = picker.selectedItems;
-            if (item) {
-                if (!this.isValidLineNumber(editor, item.lineNumber)) {
-                    return;
-                }
-                this.gotoLocation(context, { range: this.toRange(item.lineNumber, item.column), keyMods: picker.keyMods, preserveFocus: event.inBackground });
-                if (!event.inBackground) {
-                    picker.hide();
-                }
-            }
-        }));
-        // React to picker changes
-        const updatePickerAndEditor = () => {
-            const position = this.parsePosition(editor, picker.value.trim().substr(AbstractGotoLineQuickAccessProvider.PREFIX.length));
-            const label = this.getPickLabel(editor, position.lineNumber, position.column);
-            // Picker
-            picker.items = [{
-                    lineNumber: position.lineNumber,
-                    column: position.column,
-                    label
-                }];
-            // ARIA Label
-            picker.ariaLabel = label;
-            // Clear decorations for invalid range
-            if (!this.isValidLineNumber(editor, position.lineNumber)) {
-                this.clearDecorations(editor);
-                return;
-            }
-            // Reveal
-            const range = this.toRange(position.lineNumber, position.column);
-            editor.revealRangeInCenter(range, 0 /* ScrollType.Smooth */);
-            // Decorate
-            this.addDecorations(editor, range);
-        };
-        updatePickerAndEditor();
-        disposables.add(picker.onDidChangeValue(() => updatePickerAndEditor()));
-        // Adjust line number visibility as needed
-        const codeEditor = getCodeEditor(editor);
-        if (codeEditor) {
-            const options = codeEditor.getOptions();
-            const lineNumbers = options.get(67 /* EditorOption.lineNumbers */);
-            if (lineNumbers.renderType === 2 /* RenderLineNumbersType.Relative */) {
-                codeEditor.updateOptions({ lineNumbers: 'on' });
-                disposables.add(toDisposable(() => codeEditor.updateOptions({ lineNumbers: 'relative' })));
-            }
-        }
-        return disposables;
-    }
-    toRange(lineNumber = 1, column = 1) {
-        return {
-            startLineNumber: lineNumber,
-            startColumn: column,
-            endLineNumber: lineNumber,
-            endColumn: column
-        };
-    }
-    parsePosition(editor, value) {
-        // Support line-col formats of `line,col`, `line:col`, `line#col`
-        const numbers = value.split(/,|:|#/).map(part => parseInt(part, 10)).filter(part => !isNaN(part));
-        const endLine = this.lineCount(editor) + 1;
-        return {
-            lineNumber: numbers[0] > 0 ? numbers[0] : endLine + numbers[0],
-            column: numbers[1]
-        };
-    }
-    getPickLabel(editor, lineNumber, column) {
-        // Location valid: indicate this as picker label
-        if (this.isValidLineNumber(editor, lineNumber)) {
-            if (this.isValidColumn(editor, lineNumber, column)) {
-                return localize('gotoLineColumnLabel', "Go to line {0} and character {1}.", lineNumber, column);
-            }
-            return localize('gotoLineLabel', "Go to line {0}.", lineNumber);
-        }
-        // Location invalid: show generic label
-        const position = editor.getPosition() || { lineNumber: 1, column: 1 };
-        const lineCount = this.lineCount(editor);
-        if (lineCount > 1) {
-            return localize('gotoLineLabelEmptyWithLimit', "Current Line: {0}, Character: {1}. Type a line number between 1 and {2} to navigate to.", position.lineNumber, position.column, lineCount);
-        }
-        return localize('gotoLineLabelEmpty', "Current Line: {0}, Character: {1}. Type a line number to navigate to.", position.lineNumber, position.column);
-    }
-    isValidLineNumber(editor, lineNumber) {
-        if (!lineNumber || typeof lineNumber !== 'number') {
-            return false;
-        }
-        return lineNumber > 0 && lineNumber <= this.lineCount(editor);
-    }
-    isValidColumn(editor, lineNumber, column) {
-        if (!column || typeof column !== 'number') {
-            return false;
-        }
-        const model = this.getModel(editor);
-        if (!model) {
-            return false;
-        }
-        const positionCandidate = { lineNumber, column };
-        return model.validatePosition(positionCandidate).equals(positionCandidate);
-    }
-    lineCount(editor) {
-        var _a, _b;
-        return (_b = (_a = this.getModel(editor)) === null || _a === void 0 ? void 0 : _a.getLineCount()) !== null && _b !== void 0 ? _b : 0;
-    }
-}
-AbstractGotoLineQuickAccessProvider.PREFIX = ':';
diff -urN -x '*.map' a/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js b/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js
--- a/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,406 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
-    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
-    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
-    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
-    return c > 3 && r && Object.defineProperty(target, key, r), r;
-};
-var __param = (this && this.__param) || function (paramIndex, decorator) {
-    return function (target, key) { decorator(target, key, paramIndex); }
-};
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var AbstractGotoSymbolQuickAccessProvider_1;
-import { DeferredPromise } from '../../../../base/common/async.js';
-import { CancellationTokenSource } from '../../../../base/common/cancellation.js';
-import { Codicon } from '../../../../base/common/codicons.js';
-import { ThemeIcon } from '../../../../base/common/themables.js';
-import { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';
-import { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';
-import { format, trim } from '../../../../base/common/strings.js';
-import { Range } from '../../../common/core/range.js';
-import { SymbolKinds, getAriaLabelForSymbol } from '../../../common/languages.js';
-import { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';
-import { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';
-import { localize } from '../../../../nls.js';
-import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
-import { findLast } from '../../../../base/common/arraysFind.js';
-let AbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {
-    constructor(_languageFeaturesService, _outlineModelService, options = Object.create(null)) {
-        super(options);
-        this._languageFeaturesService = _languageFeaturesService;
-        this._outlineModelService = _outlineModelService;
-        this.options = options;
-        this.options.canAcceptInBackground = true;
-    }
-    provideWithoutTextEditor(picker) {
-        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', "To go to a symbol, first open a text editor with symbol information."));
-        return Disposable.None;
-    }
-    provideWithTextEditor(context, picker, token) {
-        const editor = context.editor;
-        const model = this.getModel(editor);
-        if (!model) {
-            return Disposable.None;
-        }
-        // Provide symbols from model if available in registry
-        if (this._languageFeaturesService.documentSymbolProvider.has(model)) {
-            return this.doProvideWithEditorSymbols(context, model, picker, token);
-        }
-        // Otherwise show an entry for a model without registry
-        // But give a chance to resolve the symbols at a later
-        // point if possible
-        return this.doProvideWithoutEditorSymbols(context, model, picker, token);
-    }
-    doProvideWithoutEditorSymbols(context, model, picker, token) {
-        const disposables = new DisposableStore();
-        // Generic pick for not having any symbol information
-        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', "The active text editor does not provide symbol information."));
-        // Wait for changes to the registry and see if eventually
-        // we do get symbols. This can happen if the picker is opened
-        // very early after the model has loaded but before the
-        // language registry is ready.
-        // https://github.com/microsoft/vscode/issues/70607
-        (() => __awaiter(this, void 0, void 0, function* () {
-            const result = yield this.waitForLanguageSymbolRegistry(model, disposables);
-            if (!result || token.isCancellationRequested) {
-                return;
-            }
-            disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));
-        }))();
-        return disposables;
-    }
-    provideLabelPick(picker, label) {
-        picker.items = [{ label, index: 0, kind: 14 /* SymbolKind.String */ }];
-        picker.ariaLabel = label;
-    }
-    waitForLanguageSymbolRegistry(model, disposables) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (this._languageFeaturesService.documentSymbolProvider.has(model)) {
-                return true;
-            }
-            const symbolProviderRegistryPromise = new DeferredPromise();
-            // Resolve promise when registry knows model
-            const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {
-                if (this._languageFeaturesService.documentSymbolProvider.has(model)) {
-                    symbolProviderListener.dispose();
-                    symbolProviderRegistryPromise.complete(true);
-                }
-            }));
-            // Resolve promise when we get disposed too
-            disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));
-            return symbolProviderRegistryPromise.p;
-        });
-    }
-    doProvideWithEditorSymbols(context, model, picker, token) {
-        var _a;
-        const editor = context.editor;
-        const disposables = new DisposableStore();
-        // Goto symbol once picked
-        disposables.add(picker.onDidAccept(event => {
-            const [item] = picker.selectedItems;
-            if (item && item.range) {
-                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });
-                if (!event.inBackground) {
-                    picker.hide();
-                }
-            }
-        }));
-        // Goto symbol side by side if enabled
-        disposables.add(picker.onDidTriggerItemButton(({ item }) => {
-            if (item && item.range) {
-                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });
-                picker.hide();
-            }
-        }));
-        // Resolve symbols from document once and reuse this
-        // request for all filtering and typing then on
-        const symbolsPromise = this.getDocumentSymbols(model, token);
-        // Set initial picks and update on type
-        let picksCts = undefined;
-        const updatePickerItems = (positionToEnclose) => __awaiter(this, void 0, void 0, function* () {
-            // Cancel any previous ask for picks and busy
-            picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);
-            picker.busy = false;
-            // Create new cancellation source for this run
-            picksCts = new CancellationTokenSource(token);
-            // Collect symbol picks
-            picker.busy = true;
-            try {
-                const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider_1.PREFIX.length).trim());
-                const items = yield this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token);
-                if (token.isCancellationRequested) {
-                    return;
-                }
-                if (items.length > 0) {
-                    picker.items = items;
-                    if (positionToEnclose && query.original.length === 0) {
-                        const candidate = findLast(items, item => Boolean(item.type !== 'separator' && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));
-                        if (candidate) {
-                            picker.activeItems = [candidate];
-                        }
-                    }
-                }
-                else {
-                    if (query.original.length > 0) {
-                        this.provideLabelPick(picker, localize('noMatchingSymbolResults', "No matching editor symbols"));
-                    }
-                    else {
-                        this.provideLabelPick(picker, localize('noSymbolResults', "No editor symbols"));
-                    }
-                }
-            }
-            finally {
-                if (!token.isCancellationRequested) {
-                    picker.busy = false;
-                }
-            }
-        });
-        disposables.add(picker.onDidChangeValue(() => updatePickerItems(undefined)));
-        updatePickerItems((_a = editor.getSelection()) === null || _a === void 0 ? void 0 : _a.getPosition());
-        // Reveal and decorate when active item changes
-        disposables.add(picker.onDidChangeActive(() => {
-            const [item] = picker.activeItems;
-            if (item && item.range) {
-                // Reveal
-                editor.revealRangeInCenter(item.range.selection, 0 /* ScrollType.Smooth */);
-                // Decorate
-                this.addDecorations(editor, item.range.decoration);
-            }
-        }));
-        return disposables;
-    }
-    doGetSymbolPicks(symbolsPromise, query, options, token) {
-        var _a, _b;
-        return __awaiter(this, void 0, void 0, function* () {
-            const symbols = yield symbolsPromise;
-            if (token.isCancellationRequested) {
-                return [];
-            }
-            const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX) === 0;
-            const filterPos = filterBySymbolKind ? 1 : 0;
-            // Split between symbol and container query
-            let symbolQuery;
-            let containerQuery;
-            if (query.values && query.values.length > 1) {
-                symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part
-                containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts
-            }
-            else {
-                symbolQuery = query;
-            }
-            // Convert to symbol picks and apply filtering
-            let buttons;
-            const openSideBySideDirection = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.openSideBySideDirection) === null || _b === void 0 ? void 0 : _b.call(_a);
-            if (openSideBySideDirection) {
-                buttons = [{
-                        iconClass: openSideBySideDirection === 'right' ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),
-                        tooltip: openSideBySideDirection === 'right' ? localize('openToSide', "Open to the Side") : localize('openToBottom', "Open to the Bottom")
-                    }];
-            }
-            const filteredSymbolPicks = [];
-            for (let index = 0; index < symbols.length; index++) {
-                const symbol = symbols[index];
-                const symbolLabel = trim(symbol.name);
-                const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;
-                const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;
-                let containerLabel = symbol.containerName;
-                if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {
-                    if (containerLabel) {
-                        containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;
-                    }
-                    else {
-                        containerLabel = options.extraContainerLabel;
-                    }
-                }
-                let symbolScore = undefined;
-                let symbolMatches = undefined;
-                let containerScore = undefined;
-                let containerMatches = undefined;
-                if (query.original.length > filterPos) {
-                    // First: try to score on the entire query, it is possible that
-                    // the symbol matches perfectly (e.g. searching for "change log"
-                    // can be a match on a markdown symbol "change log"). In that
-                    // case we want to skip the container query altogether.
-                    let skipContainerQuery = false;
-                    if (symbolQuery !== query) {
-                        [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), { values: undefined /* disable multi-query support */ }), filterPos, symbolLabelIconOffset);
-                        if (typeof symbolScore === 'number') {
-                            skipContainerQuery = true; // since we consumed the query, skip any container matching
-                        }
-                    }
-                    // Otherwise: score on the symbol query and match on the container later
-                    if (typeof symbolScore !== 'number') {
-                        [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);
-                        if (typeof symbolScore !== 'number') {
-                            continue;
-                        }
-                    }
-                    // Score by container if specified
-                    if (!skipContainerQuery && containerQuery) {
-                        if (containerLabel && containerQuery.original.length > 0) {
-                            [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);
-                        }
-                        if (typeof containerScore !== 'number') {
-                            continue;
-                        }
-                        if (typeof symbolScore === 'number') {
-                            symbolScore += containerScore; // boost symbolScore by containerScore
-                        }
-                    }
-                }
-                const deprecated = symbol.tags && symbol.tags.indexOf(1 /* SymbolTag.Deprecated */) >= 0;
-                filteredSymbolPicks.push({
-                    index,
-                    kind: symbol.kind,
-                    score: symbolScore,
-                    label: symbolLabelWithIcon,
-                    ariaLabel: getAriaLabelForSymbol(symbol.name, symbol.kind),
-                    description: containerLabel,
-                    highlights: deprecated ? undefined : {
-                        label: symbolMatches,
-                        description: containerMatches
-                    },
-                    range: {
-                        selection: Range.collapseToStart(symbol.selectionRange),
-                        decoration: symbol.range
-                    },
-                    strikethrough: deprecated,
-                    buttons
-                });
-            }
-            // Sort by score
-            const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ?
-                this.compareByKindAndScore(symbolA, symbolB) :
-                this.compareByScore(symbolA, symbolB));
-            // Add separator for types
-            // - @  only total number of symbols
-            // - @: grouped by symbol kind
-            let symbolPicks = [];
-            if (filterBySymbolKind) {
-                let lastSymbolKind = undefined;
-                let lastSeparator = undefined;
-                let lastSymbolKindCounter = 0;
-                function updateLastSeparatorLabel() {
-                    if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {
-                        lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);
-                    }
-                }
-                for (const symbolPick of sortedFilteredSymbolPicks) {
-                    // Found new kind
-                    if (lastSymbolKind !== symbolPick.kind) {
-                        // Update last separator with number of symbols we found for kind
-                        updateLastSeparatorLabel();
-                        lastSymbolKind = symbolPick.kind;
-                        lastSymbolKindCounter = 1;
-                        // Add new separator for new kind
-                        lastSeparator = { type: 'separator' };
-                        symbolPicks.push(lastSeparator);
-                    }
-                    // Existing kind, keep counting
-                    else {
-                        lastSymbolKindCounter++;
-                    }
-                    // Add to final result
-                    symbolPicks.push(symbolPick);
-                }
-                // Update last separator with number of symbols we found for kind
-                updateLastSeparatorLabel();
-            }
-            else if (sortedFilteredSymbolPicks.length > 0) {
-                symbolPicks = [
-                    { label: localize('symbols', "symbols ({0})", filteredSymbolPicks.length), type: 'separator' },
-                    ...sortedFilteredSymbolPicks
-                ];
-            }
-            return symbolPicks;
-        });
-    }
-    compareByScore(symbolA, symbolB) {
-        if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {
-            return 1;
-        }
-        else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {
-            return -1;
-        }
-        if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {
-            if (symbolA.score > symbolB.score) {
-                return -1;
-            }
-            else if (symbolA.score < symbolB.score) {
-                return 1;
-            }
-        }
-        if (symbolA.index < symbolB.index) {
-            return -1;
-        }
-        else if (symbolA.index > symbolB.index) {
-            return 1;
-        }
-        return 0;
-    }
-    compareByKindAndScore(symbolA, symbolB) {
-        const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;
-        const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;
-        // Sort by type first if scoped search
-        const result = kindA.localeCompare(kindB);
-        if (result === 0) {
-            return this.compareByScore(symbolA, symbolB);
-        }
-        return result;
-    }
-    getDocumentSymbols(document, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const model = yield this._outlineModelService.getOrCreate(document, token);
-            return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();
-        });
-    }
-};
-AbstractGotoSymbolQuickAccessProvider.PREFIX = '@';
-AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':';
-AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider_1.PREFIX}${AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX}`;
-AbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = __decorate([
-    __param(0, ILanguageFeaturesService),
-    __param(1, IOutlineModelService)
-], AbstractGotoSymbolQuickAccessProvider);
-export { AbstractGotoSymbolQuickAccessProvider };
-// #region NLS Helpers
-const FALLBACK_NLS_SYMBOL_KIND = localize('property', "properties ({0})");
-const NLS_SYMBOL_KIND_CACHE = {
-    [5 /* SymbolKind.Method */]: localize('method', "methods ({0})"),
-    [11 /* SymbolKind.Function */]: localize('function', "functions ({0})"),
-    [8 /* SymbolKind.Constructor */]: localize('_constructor', "constructors ({0})"),
-    [12 /* SymbolKind.Variable */]: localize('variable', "variables ({0})"),
-    [4 /* SymbolKind.Class */]: localize('class', "classes ({0})"),
-    [22 /* SymbolKind.Struct */]: localize('struct', "structs ({0})"),
-    [23 /* SymbolKind.Event */]: localize('event', "events ({0})"),
-    [24 /* SymbolKind.Operator */]: localize('operator', "operators ({0})"),
-    [10 /* SymbolKind.Interface */]: localize('interface', "interfaces ({0})"),
-    [2 /* SymbolKind.Namespace */]: localize('namespace', "namespaces ({0})"),
-    [3 /* SymbolKind.Package */]: localize('package', "packages ({0})"),
-    [25 /* SymbolKind.TypeParameter */]: localize('typeParameter', "type parameters ({0})"),
-    [1 /* SymbolKind.Module */]: localize('modules', "modules ({0})"),
-    [6 /* SymbolKind.Property */]: localize('property', "properties ({0})"),
-    [9 /* SymbolKind.Enum */]: localize('enum', "enumerations ({0})"),
-    [21 /* SymbolKind.EnumMember */]: localize('enumMember', "enumeration members ({0})"),
-    [14 /* SymbolKind.String */]: localize('string', "strings ({0})"),
-    [0 /* SymbolKind.File */]: localize('file', "files ({0})"),
-    [17 /* SymbolKind.Array */]: localize('array', "arrays ({0})"),
-    [15 /* SymbolKind.Number */]: localize('number', "numbers ({0})"),
-    [16 /* SymbolKind.Boolean */]: localize('boolean', "booleans ({0})"),
-    [18 /* SymbolKind.Object */]: localize('object', "objects ({0})"),
-    [19 /* SymbolKind.Key */]: localize('key', "keys ({0})"),
-    [7 /* SymbolKind.Field */]: localize('field', "fields ({0})"),
-    [13 /* SymbolKind.Constant */]: localize('constant', "constants ({0})")
-};
-//#endregion
diff -urN -x '*.map' a/vs/editor/contrib/readOnlyMessage/browser/contribution.js b/vs/editor/contrib/readOnlyMessage/browser/contribution.js
--- a/vs/editor/contrib/readOnlyMessage/browser/contribution.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/readOnlyMessage/browser/contribution.js	2023-12-06 14:23:14.383854791 +0000
@@ -19,10 +19,10 @@
             let message = this.editor.getOptions().get(91 /* EditorOption.readOnlyMessage */);
             if (!message) {
                 if (this.editor.isSimpleWidget) {
-                    message = new MarkdownString(nls.localize('editor.simple.readonly', "Cannot edit in read-only input"));
+                    message = new MarkdownString(nls.localizeWithPath('vs/editor/contrib/readOnlyMessage/browser/contribution', 'editor.simple.readonly', "Cannot edit in read-only input"));
                 }
                 else {
-                    message = new MarkdownString(nls.localize('editor.readonly', "Cannot edit in read-only editor"));
+                    message = new MarkdownString(nls.localizeWithPath('vs/editor/contrib/readOnlyMessage/browser/contribution', 'editor.readonly', "Cannot edit in read-only editor"));
                 }
             }
             messageController.showMessage(message, this.editor.getPosition());
diff -urN -x '*.map' a/vs/editor/contrib/rename/browser/rename.js b/vs/editor/contrib/rename/browser/rename.js
--- a/vs/editor/contrib/rename/browser/rename.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/rename/browser/rename.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var RenameController_1;
 import { alert } from '../../../../base/browser/ui/aria/aria.js';
 import { raceCancellation } from '../../../../base/common/async.js';
@@ -57,73 +48,65 @@
     hasProvider() {
         return this._providers.length > 0;
     }
-    resolveRenameLocation(token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const rejects = [];
-            for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
-                const provider = this._providers[this._providerRenameIdx];
-                if (!provider.resolveRenameLocation) {
-                    break;
-                }
-                const res = yield provider.resolveRenameLocation(this.model, this.position, token);
-                if (!res) {
-                    continue;
-                }
-                if (res.rejectReason) {
-                    rejects.push(res.rejectReason);
-                    continue;
-                }
-                return res;
-            }
-            const word = this.model.getWordAtPosition(this.position);
-            if (!word) {
-                return {
-                    range: Range.fromPositions(this.position),
-                    text: '',
-                    rejectReason: rejects.length > 0 ? rejects.join('\n') : undefined
-                };
+    async resolveRenameLocation(token) {
+        const rejects = [];
+        for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
+            const provider = this._providers[this._providerRenameIdx];
+            if (!provider.resolveRenameLocation) {
+                break;
+            }
+            const res = await provider.resolveRenameLocation(this.model, this.position, token);
+            if (!res) {
+                continue;
+            }
+            if (res.rejectReason) {
+                rejects.push(res.rejectReason);
+                continue;
             }
+            return res;
+        }
+        const word = this.model.getWordAtPosition(this.position);
+        if (!word) {
             return {
-                range: new Range(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),
-                text: word.word,
+                range: Range.fromPositions(this.position),
+                text: '',
                 rejectReason: rejects.length > 0 ? rejects.join('\n') : undefined
             };
-        });
-    }
-    provideRenameEdits(newName, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            return this._provideRenameEdits(newName, this._providerRenameIdx, [], token);
-        });
-    }
-    _provideRenameEdits(newName, i, rejects, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const provider = this._providers[i];
-            if (!provider) {
-                return {
-                    edits: [],
-                    rejectReason: rejects.join('\n')
-                };
-            }
-            const result = yield provider.provideRenameEdits(this.model, this.position, newName, token);
-            if (!result) {
-                return this._provideRenameEdits(newName, i + 1, rejects.concat(nls.localize('no result', "No result.")), token);
-            }
-            else if (result.rejectReason) {
-                return this._provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason), token);
-            }
-            return result;
-        });
+        }
+        return {
+            range: new Range(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),
+            text: word.word,
+            rejectReason: rejects.length > 0 ? rejects.join('\n') : undefined
+        };
+    }
+    async provideRenameEdits(newName, token) {
+        return this._provideRenameEdits(newName, this._providerRenameIdx, [], token);
+    }
+    async _provideRenameEdits(newName, i, rejects, token) {
+        const provider = this._providers[i];
+        if (!provider) {
+            return {
+                edits: [],
+                rejectReason: rejects.join('\n')
+            };
+        }
+        const result = await provider.provideRenameEdits(this.model, this.position, newName, token);
+        if (!result) {
+            return this._provideRenameEdits(newName, i + 1, rejects.concat(nls.localizeWithPath('vs/editor/contrib/rename/browser/rename', 'no result', "No result.")), token);
+        }
+        else if (result.rejectReason) {
+            return this._provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason), token);
+        }
+        return result;
     }
 }
-export function rename(registry, model, position, newName) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const skeleton = new RenameSkeleton(model, position, registry);
-        const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
-        if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
-            return { edits: [], rejectReason: loc.rejectReason };
-        }
-        return skeleton.provideRenameEdits(newName, CancellationToken.None);
-    });
+export async function rename(registry, model, position, newName) {
+    const skeleton = new RenameSkeleton(model, position, registry);
+    const loc = await skeleton.resolveRenameLocation(CancellationToken.None);
+    if (loc?.rejectReason) {
+        return { edits: [], rejectReason: loc.rejectReason };
+    }
+    return skeleton.provideRenameEdits(newName, CancellationToken.None);
 }
 // ---  register actions and commands
 let RenameController = RenameController_1 = class RenameController {
@@ -147,100 +130,97 @@
         this._disposableStore.dispose();
         this._cts.dispose(true);
     }
-    run() {
-        var _a, _b;
-        return __awaiter(this, void 0, void 0, function* () {
-            // set up cancellation token to prevent reentrant rename, this
-            // is the parent to the resolve- and rename-tokens
-            this._cts.dispose(true);
-            this._cts = new CancellationTokenSource();
-            if (!this.editor.hasModel()) {
-                return undefined;
-            }
-            const position = this.editor.getPosition();
-            const skeleton = new RenameSkeleton(this.editor.getModel(), position, this._languageFeaturesService.renameProvider);
-            if (!skeleton.hasProvider()) {
-                return undefined;
-            }
-            // part 1 - resolve rename location
-            const cts1 = new EditorStateCancellationTokenSource(this.editor, 4 /* CodeEditorStateFlag.Position */ | 1 /* CodeEditorStateFlag.Value */, undefined, this._cts.token);
-            let loc;
-            try {
-                const resolveLocationOperation = skeleton.resolveRenameLocation(cts1.token);
-                this._progressService.showWhile(resolveLocationOperation, 250);
-                loc = yield resolveLocationOperation;
-            }
-            catch (e) {
-                (_a = MessageController.get(this.editor)) === null || _a === void 0 ? void 0 : _a.showMessage(e || nls.localize('resolveRenameLocationFailed', "An unknown error occurred while resolving rename location"), position);
-                return undefined;
-            }
-            finally {
-                cts1.dispose();
-            }
-            if (!loc) {
-                return undefined;
-            }
-            if (loc.rejectReason) {
-                (_b = MessageController.get(this.editor)) === null || _b === void 0 ? void 0 : _b.showMessage(loc.rejectReason, position);
-                return undefined;
-            }
-            if (cts1.token.isCancellationRequested) {
-                return undefined;
-            }
-            // part 2 - do rename at location
-            const cts2 = new EditorStateCancellationTokenSource(this.editor, 4 /* CodeEditorStateFlag.Position */ | 1 /* CodeEditorStateFlag.Value */, loc.range, this._cts.token);
-            const selection = this.editor.getSelection();
-            let selectionStart = 0;
-            let selectionEnd = loc.text.length;
-            if (!Range.isEmpty(selection) && !Range.spansMultipleLines(selection) && Range.containsRange(loc.range, selection)) {
-                selectionStart = Math.max(0, selection.startColumn - loc.range.startColumn);
-                selectionEnd = Math.min(loc.range.endColumn, selection.endColumn) - loc.range.startColumn;
-            }
-            const supportPreview = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, 'editor.rename.enablePreview');
-            const inputFieldResult = yield this._renameInputField.getInput(loc.range, loc.text, selectionStart, selectionEnd, supportPreview, cts2.token);
-            // no result, only hint to focus the editor or not
-            if (typeof inputFieldResult === 'boolean') {
-                if (inputFieldResult) {
-                    this.editor.focus();
-                }
-                cts2.dispose();
-                return undefined;
+    async run() {
+        // set up cancellation token to prevent reentrant rename, this
+        // is the parent to the resolve- and rename-tokens
+        this._cts.dispose(true);
+        this._cts = new CancellationTokenSource();
+        if (!this.editor.hasModel()) {
+            return undefined;
+        }
+        const position = this.editor.getPosition();
+        const skeleton = new RenameSkeleton(this.editor.getModel(), position, this._languageFeaturesService.renameProvider);
+        if (!skeleton.hasProvider()) {
+            return undefined;
+        }
+        // part 1 - resolve rename location
+        const cts1 = new EditorStateCancellationTokenSource(this.editor, 4 /* CodeEditorStateFlag.Position */ | 1 /* CodeEditorStateFlag.Value */, undefined, this._cts.token);
+        let loc;
+        try {
+            const resolveLocationOperation = skeleton.resolveRenameLocation(cts1.token);
+            this._progressService.showWhile(resolveLocationOperation, 250);
+            loc = await resolveLocationOperation;
+        }
+        catch (e) {
+            MessageController.get(this.editor)?.showMessage(e || nls.localizeWithPath('vs/editor/contrib/rename/browser/rename', 'resolveRenameLocationFailed', "An unknown error occurred while resolving rename location"), position);
+            return undefined;
+        }
+        finally {
+            cts1.dispose();
+        }
+        if (!loc) {
+            return undefined;
+        }
+        if (loc.rejectReason) {
+            MessageController.get(this.editor)?.showMessage(loc.rejectReason, position);
+            return undefined;
+        }
+        if (cts1.token.isCancellationRequested) {
+            return undefined;
+        }
+        // part 2 - do rename at location
+        const cts2 = new EditorStateCancellationTokenSource(this.editor, 4 /* CodeEditorStateFlag.Position */ | 1 /* CodeEditorStateFlag.Value */, loc.range, this._cts.token);
+        const selection = this.editor.getSelection();
+        let selectionStart = 0;
+        let selectionEnd = loc.text.length;
+        if (!Range.isEmpty(selection) && !Range.spansMultipleLines(selection) && Range.containsRange(loc.range, selection)) {
+            selectionStart = Math.max(0, selection.startColumn - loc.range.startColumn);
+            selectionEnd = Math.min(loc.range.endColumn, selection.endColumn) - loc.range.startColumn;
+        }
+        const supportPreview = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, 'editor.rename.enablePreview');
+        const inputFieldResult = await this._renameInputField.getInput(loc.range, loc.text, selectionStart, selectionEnd, supportPreview, cts2.token);
+        // no result, only hint to focus the editor or not
+        if (typeof inputFieldResult === 'boolean') {
+            if (inputFieldResult) {
+                this.editor.focus();
             }
-            this.editor.focus();
-            const renameOperation = raceCancellation(skeleton.provideRenameEdits(inputFieldResult.newName, cts2.token), cts2.token).then((renameResult) => __awaiter(this, void 0, void 0, function* () {
-                if (!renameResult || !this.editor.hasModel()) {
-                    return;
-                }
-                if (renameResult.rejectReason) {
-                    this._notificationService.info(renameResult.rejectReason);
-                    return;
+            cts2.dispose();
+            return undefined;
+        }
+        this.editor.focus();
+        const renameOperation = raceCancellation(skeleton.provideRenameEdits(inputFieldResult.newName, cts2.token), cts2.token).then(async (renameResult) => {
+            if (!renameResult || !this.editor.hasModel()) {
+                return;
+            }
+            if (renameResult.rejectReason) {
+                this._notificationService.info(renameResult.rejectReason);
+                return;
+            }
+            // collapse selection to active end
+            this.editor.setSelection(Range.fromPositions(this.editor.getSelection().getPosition()));
+            this._bulkEditService.apply(renameResult, {
+                editor: this.editor,
+                showPreview: inputFieldResult.wantsPreview,
+                label: nls.localizeWithPath('vs/editor/contrib/rename/browser/rename', 'label', "Renaming '{0}' to '{1}'", loc?.text, inputFieldResult.newName),
+                code: 'undoredo.rename',
+                quotableLabel: nls.localizeWithPath('vs/editor/contrib/rename/browser/rename', 'quotableLabel', "Renaming {0} to {1}", loc?.text, inputFieldResult.newName),
+                respectAutoSaveConfig: true
+            }).then(result => {
+                if (result.ariaSummary) {
+                    alert(nls.localizeWithPath('vs/editor/contrib/rename/browser/rename', 'aria', "Successfully renamed '{0}' to '{1}'. Summary: {2}", loc.text, inputFieldResult.newName, result.ariaSummary));
                 }
-                // collapse selection to active end
-                this.editor.setSelection(Range.fromPositions(this.editor.getSelection().getPosition()));
-                this._bulkEditService.apply(renameResult, {
-                    editor: this.editor,
-                    showPreview: inputFieldResult.wantsPreview,
-                    label: nls.localize('label', "Renaming '{0}' to '{1}'", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),
-                    code: 'undoredo.rename',
-                    quotableLabel: nls.localize('quotableLabel', "Renaming {0} to {1}", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),
-                    respectAutoSaveConfig: true
-                }).then(result => {
-                    if (result.ariaSummary) {
-                        alert(nls.localize('aria', "Successfully renamed '{0}' to '{1}'. Summary: {2}", loc.text, inputFieldResult.newName, result.ariaSummary));
-                    }
-                }).catch(err => {
-                    this._notificationService.error(nls.localize('rename.failedApply', "Rename failed to apply edits"));
-                    this._logService.error(err);
-                });
-            }), err => {
-                this._notificationService.error(nls.localize('rename.failed', "Rename failed to compute edits"));
+            }).catch(err => {
+                this._notificationService.error(nls.localizeWithPath('vs/editor/contrib/rename/browser/rename', 'rename.failedApply', "Rename failed to apply edits"));
                 this._logService.error(err);
-            }).finally(() => {
-                cts2.dispose();
             });
-            this._progressService.showWhile(renameOperation, 250);
-            return renameOperation;
+        }, err => {
+            this._notificationService.error(nls.localizeWithPath('vs/editor/contrib/rename/browser/rename', 'rename.failed', "Rename failed to compute edits"));
+            this._logService.error(err);
+        }).finally(() => {
+            cts2.dispose();
         });
+        this._progressService.showWhile(renameOperation, 250);
+        return renameOperation;
     }
     acceptRenameInput(wantsPreview) {
         this._renameInputField.acceptInput(wantsPreview);
@@ -264,7 +244,7 @@
     constructor() {
         super({
             id: 'editor.action.rename',
-            label: nls.localize('rename.label', "Rename Symbol"),
+            label: nls.localizeWithPath('vs/editor/contrib/rename/browser/rename', 'rename.label', "Rename Symbol"),
             alias: 'Rename Symbol',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
             kbOpts: {
@@ -344,16 +324,14 @@
     const { renameProvider } = accessor.get(ILanguageFeaturesService);
     return rename(renameProvider, model, position, newName);
 });
-registerModelAndPositionCommand('_executePrepareRename', function (accessor, model, position) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const { renameProvider } = accessor.get(ILanguageFeaturesService);
-        const skeleton = new RenameSkeleton(model, position, renameProvider);
-        const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
-        if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
-            throw new Error(loc.rejectReason);
-        }
-        return loc;
-    });
+registerModelAndPositionCommand('_executePrepareRename', async function (accessor, model, position) {
+    const { renameProvider } = accessor.get(ILanguageFeaturesService);
+    const skeleton = new RenameSkeleton(model, position, renameProvider);
+    const loc = await skeleton.resolveRenameLocation(CancellationToken.None);
+    if (loc?.rejectReason) {
+        throw new Error(loc.rejectReason);
+    }
+    return loc;
 });
 //todo@jrieken use editor options world
 Registry.as(Extensions.Configuration).registerConfiguration({
@@ -361,7 +339,7 @@
     properties: {
         'editor.rename.enablePreview': {
             scope: 5 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */,
-            description: nls.localize('enablePreview', "Enable/disable the ability to preview changes before renaming"),
+            description: nls.localizeWithPath('vs/editor/contrib/rename/browser/rename', 'enablePreview', "Enable/disable the ability to preview changes before renaming"),
             default: true,
             type: 'boolean'
         }
diff -urN -x '*.map' a/vs/editor/contrib/rename/browser/renameInputField.js b/vs/editor/contrib/rename/browser/renameInputField.js
--- a/vs/editor/contrib/rename/browser/renameInputField.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/rename/browser/renameInputField.js	2023-12-06 14:23:14.383854791 +0000
@@ -14,12 +14,12 @@
 import { DisposableStore } from '../../../../base/common/lifecycle.js';
 import './renameInputField.css';
 import { Position } from '../../../common/core/position.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';
 import { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';
 import { editorWidgetBackground, inputBackground, inputBorder, inputForeground, widgetBorder, widgetShadow } from '../../../../platform/theme/common/colorRegistry.js';
 import { IThemeService } from '../../../../platform/theme/common/themeService.js';
-export const CONTEXT_RENAME_INPUT_VISIBLE = new RawContextKey('renameInputVisible', false, localize('renameInputVisible', "Whether the rename input widget is visible"));
+export const CONTEXT_RENAME_INPUT_VISIBLE = new RawContextKey('renameInputVisible', false, localizeWithPath('vs/editor/contrib/rename/browser/renameInputField', 'renameInputVisible', "Whether the rename input widget is visible"));
 let RenameInputField = class RenameInputField {
     constructor(_editor, _acceptKeybindings, _themeService, _keybindingService, contextKeyService) {
         this._editor = _editor;
@@ -51,7 +51,7 @@
             this._input = document.createElement('input');
             this._input.className = 'rename-input';
             this._input.type = 'text';
-            this._input.setAttribute('aria-label', localize('renameAriaLabel', "Rename input. Type new name and press Enter to commit."));
+            this._input.setAttribute('aria-label', localizeWithPath('vs/editor/contrib/rename/browser/renameInputField', 'renameAriaLabel', "Rename input. Type new name and press Enter to commit."));
             this._domNode.appendChild(this._input);
             this._label = document.createElement('div');
             this._label.className = 'rename-label';
@@ -62,22 +62,21 @@
         return this._domNode;
     }
     _updateStyles(theme) {
-        var _a, _b, _c, _d;
         if (!this._input || !this._domNode) {
             return;
         }
         const widgetShadowColor = theme.getColor(widgetShadow);
         const widgetBorderColor = theme.getColor(widgetBorder);
-        this._domNode.style.backgroundColor = String((_a = theme.getColor(editorWidgetBackground)) !== null && _a !== void 0 ? _a : '');
+        this._domNode.style.backgroundColor = String(theme.getColor(editorWidgetBackground) ?? '');
         this._domNode.style.boxShadow = widgetShadowColor ? ` 0 0 8px 2px ${widgetShadowColor}` : '';
         this._domNode.style.border = widgetBorderColor ? `1px solid ${widgetBorderColor}` : '';
-        this._domNode.style.color = String((_b = theme.getColor(inputForeground)) !== null && _b !== void 0 ? _b : '');
-        this._input.style.backgroundColor = String((_c = theme.getColor(inputBackground)) !== null && _c !== void 0 ? _c : '');
+        this._domNode.style.color = String(theme.getColor(inputForeground) ?? '');
+        this._input.style.backgroundColor = String(theme.getColor(inputBackground) ?? '');
         // this._input.style.color = String(theme.getColor(inputForeground) ?? '');
         const border = theme.getColor(inputBorder);
         this._input.style.borderWidth = border ? '1px' : '0px';
         this._input.style.borderStyle = border ? 'solid' : 'none';
-        this._input.style.borderColor = (_d = border === null || border === void 0 ? void 0 : border.toString()) !== null && _d !== void 0 ? _d : 'none';
+        this._input.style.borderColor = border?.toString() ?? 'none';
     }
     _updateFont() {
         if (!this._input || !this._label) {
@@ -99,9 +98,8 @@
         };
     }
     beforeRender() {
-        var _a, _b;
         const [accept, preview] = this._acceptKeybindings;
-        this._label.innerText = localize({ key: 'label', comment: ['placeholders are keybindings, e.g "F2 to Rename, Shift+F2 to Preview"'] }, "{0} to Rename, {1} to Preview", (_a = this._keybindingService.lookupKeybinding(accept)) === null || _a === void 0 ? void 0 : _a.getLabel(), (_b = this._keybindingService.lookupKeybinding(preview)) === null || _b === void 0 ? void 0 : _b.getLabel());
+        this._label.innerText = localizeWithPath('vs/editor/contrib/rename/browser/renameInputField', { key: 'label', comment: ['placeholders are keybindings, e.g "F2 to Rename, Shift+F2 to Preview"'] }, "{0} to Rename, {1} to Preview", this._keybindingService.lookupKeybinding(accept)?.getLabel(), this._keybindingService.lookupKeybinding(preview)?.getLabel());
         return null;
     }
     afterRender(position) {
@@ -111,12 +109,10 @@
         }
     }
     acceptInput(wantsPreview) {
-        var _a;
-        (_a = this._currentAcceptInput) === null || _a === void 0 ? void 0 : _a.call(this, wantsPreview);
+        this._currentAcceptInput?.(wantsPreview);
     }
     cancelInput(focusEditor) {
-        var _a;
-        (_a = this._currentCancelInput) === null || _a === void 0 ? void 0 : _a.call(this, focusEditor);
+        this._currentCancelInput?.(focusEditor);
     }
     getInput(where, value, selectionStart, selectionEnd, supportPreview, token) {
         this._domNode.classList.toggle('preview', supportPreview);
@@ -147,7 +143,7 @@
                 });
             };
             disposeOnDone.add(token.onCancellationRequested(() => this.cancelInput(true)));
-            disposeOnDone.add(this._editor.onDidBlurEditorWidget(() => { var _a; return this.cancelInput(!((_a = this._domNode) === null || _a === void 0 ? void 0 : _a.ownerDocument.hasFocus())); }));
+            disposeOnDone.add(this._editor.onDidBlurEditorWidget(() => this.cancelInput(!this._domNode?.ownerDocument.hasFocus())));
             this._show();
         }).finally(() => {
             disposeOnDone.dispose();
diff -urN -x '*.map' a/vs/editor/contrib/semanticTokens/browser/documentSemanticTokens.js b/vs/editor/contrib/semanticTokens/browser/documentSemanticTokens.js
--- a/vs/editor/contrib/semanticTokens/browser/documentSemanticTokens.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/semanticTokens/browser/documentSemanticTokens.js	2023-12-06 14:23:14.383854791 +0000
@@ -53,6 +53,7 @@
                 }
             }
         };
+        modelService.getModels().forEach(model => register(model));
         this._register(modelService.onModelAdded((model) => {
             if (isSemanticColoringEnabled(model, themeService, configurationService)) {
                 register(model);
diff -urN -x '*.map' a/vs/editor/contrib/semanticTokens/browser/viewportSemanticTokens.js b/vs/editor/contrib/semanticTokens/browser/viewportSemanticTokens.js
--- a/vs/editor/contrib/semanticTokens/browser/viewportSemanticTokens.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/semanticTokens/browser/viewportSemanticTokens.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,6 +11,7 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
+var ViewportSemanticTokensContribution_1;
 import { createCancelablePromise, RunOnceScheduler } from '../../../../base/common/async.js';
 import { Disposable } from '../../../../base/common/lifecycle.js';
 import { registerEditorContribution } from '../../../browser/editorExtensions.js';
@@ -23,7 +24,10 @@
 import { StopWatch } from '../../../../base/common/stopwatch.js';
 import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
 import { ISemanticTokensStylingService } from '../../../common/services/semanticTokensStyling.js';
-let ViewportSemanticTokensContribution = class ViewportSemanticTokensContribution extends Disposable {
+let ViewportSemanticTokensContribution = ViewportSemanticTokensContribution_1 = class ViewportSemanticTokensContribution extends Disposable {
+    static get(editor) {
+        return editor.getContribution(ViewportSemanticTokensContribution_1.ID);
+    }
     constructor(editor, _semanticTokensStylingService, _themeService, _configurationService, languageFeatureDebounceService, languageFeaturesService) {
         super();
         this._semanticTokensStylingService = _semanticTokensStylingService;
@@ -120,7 +124,7 @@
     }
 };
 ViewportSemanticTokensContribution.ID = 'editor.contrib.viewportSemanticTokens';
-ViewportSemanticTokensContribution = __decorate([
+ViewportSemanticTokensContribution = ViewportSemanticTokensContribution_1 = __decorate([
     __param(1, ISemanticTokensStylingService),
     __param(2, IThemeService),
     __param(3, IConfigurationService),
diff -urN -x '*.map' a/vs/editor/contrib/semanticTokens/common/getSemanticTokens.js b/vs/editor/contrib/semanticTokens/common/getSemanticTokens.js
--- a/vs/editor/contrib/semanticTokens/common/getSemanticTokens.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/semanticTokens/common/getSemanticTokens.js	2023-12-06 14:23:14.383854791 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { URI } from '../../../../base/common/uri.js';
@@ -40,41 +31,39 @@
     const groups = registry.orderedGroups(model);
     return (groups.length > 0 ? groups[0] : []);
 }
-export function getDocumentSemanticTokens(registry, model, lastProvider, lastResultId, token) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const providers = getDocumentSemanticTokensProviders(registry, model);
-        // Get tokens from all providers at the same time.
-        const results = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {
-            let result;
-            let error = null;
-            try {
-                result = yield provider.provideDocumentSemanticTokens(model, (provider === lastProvider ? lastResultId : null), token);
-            }
-            catch (err) {
-                error = err;
-                result = null;
-            }
-            if (!result || (!isSemanticTokens(result) && !isSemanticTokensEdits(result))) {
-                result = null;
-            }
-            return new DocumentSemanticTokensResult(provider, result, error);
-        })));
-        // Try to return the first result with actual tokens or
-        // the first result which threw an error (!!)
-        for (const result of results) {
-            if (result.error) {
-                throw result.error;
-            }
-            if (result.tokens) {
-                return result;
-            }
-        }
-        // Return the first result, even if it doesn't have tokens
-        if (results.length > 0) {
-            return results[0];
+export async function getDocumentSemanticTokens(registry, model, lastProvider, lastResultId, token) {
+    const providers = getDocumentSemanticTokensProviders(registry, model);
+    // Get tokens from all providers at the same time.
+    const results = await Promise.all(providers.map(async (provider) => {
+        let result;
+        let error = null;
+        try {
+            result = await provider.provideDocumentSemanticTokens(model, (provider === lastProvider ? lastResultId : null), token);
         }
-        return null;
-    });
+        catch (err) {
+            error = err;
+            result = null;
+        }
+        if (!result || (!isSemanticTokens(result) && !isSemanticTokensEdits(result))) {
+            result = null;
+        }
+        return new DocumentSemanticTokensResult(provider, result, error);
+    }));
+    // Try to return the first result with actual tokens or
+    // the first result which threw an error (!!)
+    for (const result of results) {
+        if (result.error) {
+            throw result.error;
+        }
+        if (result.tokens) {
+            return result;
+        }
+    }
+    // Return the first result, even if it doesn't have tokens
+    if (results.length > 0) {
+        return results[0];
+    }
+    return null;
 }
 function _getDocumentSemanticTokensProviderHighestGroup(registry, model) {
     const result = registry.orderedGroups(model);
@@ -93,38 +82,36 @@
     const groups = providers.orderedGroups(model);
     return (groups.length > 0 ? groups[0] : []);
 }
-export function getDocumentRangeSemanticTokens(registry, model, range, token) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const providers = getDocumentRangeSemanticTokensProviders(registry, model);
-        // Get tokens from all providers at the same time.
-        const results = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {
-            let result;
-            try {
-                result = yield provider.provideDocumentRangeSemanticTokens(model, range, token);
-            }
-            catch (err) {
-                onUnexpectedExternalError(err);
-                result = null;
-            }
-            if (!result || !isSemanticTokens(result)) {
-                result = null;
-            }
-            return new DocumentRangeSemanticTokensResult(provider, result);
-        })));
-        // Try to return the first result with actual tokens
-        for (const result of results) {
-            if (result.tokens) {
-                return result;
-            }
-        }
-        // Return the first result, even if it doesn't have tokens
-        if (results.length > 0) {
-            return results[0];
+export async function getDocumentRangeSemanticTokens(registry, model, range, token) {
+    const providers = getDocumentRangeSemanticTokensProviders(registry, model);
+    // Get tokens from all providers at the same time.
+    const results = await Promise.all(providers.map(async (provider) => {
+        let result;
+        try {
+            result = await provider.provideDocumentRangeSemanticTokens(model, range, token);
         }
-        return null;
-    });
+        catch (err) {
+            onUnexpectedExternalError(err);
+            result = null;
+        }
+        if (!result || !isSemanticTokens(result)) {
+            result = null;
+        }
+        return new DocumentRangeSemanticTokensResult(provider, result);
+    }));
+    // Try to return the first result with actual tokens
+    for (const result of results) {
+        if (result.tokens) {
+            return result;
+        }
+    }
+    // Return the first result, even if it doesn't have tokens
+    if (results.length > 0) {
+        return results[0];
+    }
+    return null;
 }
-CommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {
+CommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', async (accessor, ...args) => {
     const [uri] = args;
     assertType(uri instanceof URI);
     const model = accessor.get(IModelService).getModel(uri);
@@ -138,8 +125,8 @@
         return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);
     }
     return providers[0].getLegend();
-}));
-CommandsRegistry.registerCommand('_provideDocumentSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {
+});
+CommandsRegistry.registerCommand('_provideDocumentSemanticTokens', async (accessor, ...args) => {
     const [uri] = args;
     assertType(uri instanceof URI);
     const model = accessor.get(IModelService).getModel(uri);
@@ -151,7 +138,7 @@
         // there is no provider => fall back to a document range semantic tokens provider
         return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());
     }
-    const r = yield getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);
+    const r = await getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);
     if (!r) {
         return undefined;
     }
@@ -168,8 +155,8 @@
         provider.releaseDocumentSemanticTokens(tokens.resultId);
     }
     return buff;
-}));
-CommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {
+});
+CommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', async (accessor, ...args) => {
     const [uri, range] = args;
     assertType(uri instanceof URI);
     const model = accessor.get(IModelService).getModel(uri);
@@ -193,13 +180,13 @@
         console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);
         return providers[0].getLegend();
     }
-    const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);
+    const result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);
     if (!result) {
         return undefined;
     }
     return result.provider.getLegend();
-}));
-CommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {
+});
+CommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', async (accessor, ...args) => {
     const [uri, range] = args;
     assertType(uri instanceof URI);
     assertType(Range.isIRange(range));
@@ -208,7 +195,7 @@
         return undefined;
     }
     const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);
-    const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);
+    const result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);
     if (!result || !result.tokens) {
         // there is no provider or it didn't return tokens
         return undefined;
@@ -218,4 +205,4 @@
         type: 'full',
         data: result.tokens.data
     });
-}));
+});
diff -urN -x '*.map' a/vs/editor/contrib/semanticTokens/common/semanticTokensConfig.js b/vs/editor/contrib/semanticTokens/common/semanticTokensConfig.js
--- a/vs/editor/contrib/semanticTokens/common/semanticTokensConfig.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/semanticTokens/common/semanticTokensConfig.js	2023-12-06 14:23:14.383854791 +0000
@@ -4,8 +4,7 @@
  *--------------------------------------------------------------------------------------------*/
 export const SEMANTIC_HIGHLIGHTING_SETTING_ID = 'editor.semanticHighlighting';
 export function isSemanticColoringEnabled(model, themeService, configurationService) {
-    var _a;
-    const setting = (_a = configurationService.getValue(SEMANTIC_HIGHLIGHTING_SETTING_ID, { overrideIdentifier: model.getLanguageId(), resource: model.uri })) === null || _a === void 0 ? void 0 : _a.enabled;
+    const setting = configurationService.getValue(SEMANTIC_HIGHLIGHTING_SETTING_ID, { overrideIdentifier: model.getLanguageId(), resource: model.uri })?.enabled;
     if (typeof setting === 'boolean') {
         return setting;
     }
diff -urN -x '*.map' a/vs/editor/contrib/smartSelect/browser/bracketSelections.js b/vs/editor/contrib/smartSelect/browser/bracketSelections.js
--- a/vs/editor/contrib/smartSelect/browser/bracketSelections.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/smartSelect/browser/bracketSelections.js	2023-12-06 14:23:14.383854791 +0000
@@ -2,31 +2,20 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { LinkedList } from '../../../../base/common/linkedList.js';
 import { Position } from '../../../common/core/position.js';
 import { Range } from '../../../common/core/range.js';
 export class BracketSelectionRangeProvider {
-    provideSelectionRanges(model, positions) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const result = [];
-            for (const position of positions) {
-                const bucket = [];
-                result.push(bucket);
-                const ranges = new Map();
-                yield new Promise(resolve => BracketSelectionRangeProvider._bracketsRightYield(resolve, 0, model, position, ranges));
-                yield new Promise(resolve => BracketSelectionRangeProvider._bracketsLeftYield(resolve, 0, model, position, ranges, bucket));
-            }
-            return result;
-        });
+    async provideSelectionRanges(model, positions) {
+        const result = [];
+        for (const position of positions) {
+            const bucket = [];
+            result.push(bucket);
+            const ranges = new Map();
+            await new Promise(resolve => BracketSelectionRangeProvider._bracketsRightYield(resolve, 0, model, position, ranges));
+            await new Promise(resolve => BracketSelectionRangeProvider._bracketsLeftYield(resolve, 0, model, position, ranges, bucket));
+        }
+        return result;
     }
     static _bracketsRightYield(resolve, round, model, pos, ranges) {
         const counts = new Map();
diff -urN -x '*.map' a/vs/editor/contrib/smartSelect/browser/smartSelect.js b/vs/editor/contrib/smartSelect/browser/smartSelect.js
--- a/vs/editor/contrib/smartSelect/browser/smartSelect.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/smartSelect/browser/smartSelect.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var SmartSelectController_1;
 import * as arrays from '../../../../base/common/arrays.js';
 import { CancellationToken } from '../../../../base/common/cancellation.js';
@@ -66,61 +57,56 @@
         this._ignoreSelection = false;
     }
     dispose() {
-        var _a;
-        (_a = this._selectionListener) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._selectionListener?.dispose();
     }
-    run(forward) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!this._editor.hasModel()) {
-                return;
-            }
-            const selections = this._editor.getSelections();
-            const model = this._editor.getModel();
-            if (!this._state) {
-                yield provideSelectionRanges(this._languageFeaturesService.selectionRangeProvider, model, selections.map(s => s.getPosition()), this._editor.getOption(112 /* EditorOption.smartSelect */), CancellationToken.None).then(ranges => {
-                    var _a;
-                    if (!arrays.isNonEmptyArray(ranges) || ranges.length !== selections.length) {
-                        // invalid result
-                        return;
-                    }
-                    if (!this._editor.hasModel() || !arrays.equals(this._editor.getSelections(), selections, (a, b) => a.equalsSelection(b))) {
-                        // invalid editor state
-                        return;
-                    }
-                    for (let i = 0; i < ranges.length; i++) {
-                        ranges[i] = ranges[i].filter(range => {
-                            // filter ranges inside the selection
-                            return range.containsPosition(selections[i].getStartPosition()) && range.containsPosition(selections[i].getEndPosition());
-                        });
-                        // prepend current selection
-                        ranges[i].unshift(selections[i]);
-                    }
-                    this._state = ranges.map(ranges => new SelectionRanges(0, ranges));
-                    // listen to caret move and forget about state
-                    (_a = this._selectionListener) === null || _a === void 0 ? void 0 : _a.dispose();
-                    this._selectionListener = this._editor.onDidChangeCursorPosition(() => {
-                        var _a;
-                        if (!this._ignoreSelection) {
-                            (_a = this._selectionListener) === null || _a === void 0 ? void 0 : _a.dispose();
-                            this._state = undefined;
-                        }
+    async run(forward) {
+        if (!this._editor.hasModel()) {
+            return;
+        }
+        const selections = this._editor.getSelections();
+        const model = this._editor.getModel();
+        if (!this._state) {
+            await provideSelectionRanges(this._languageFeaturesService.selectionRangeProvider, model, selections.map(s => s.getPosition()), this._editor.getOption(112 /* EditorOption.smartSelect */), CancellationToken.None).then(ranges => {
+                if (!arrays.isNonEmptyArray(ranges) || ranges.length !== selections.length) {
+                    // invalid result
+                    return;
+                }
+                if (!this._editor.hasModel() || !arrays.equals(this._editor.getSelections(), selections, (a, b) => a.equalsSelection(b))) {
+                    // invalid editor state
+                    return;
+                }
+                for (let i = 0; i < ranges.length; i++) {
+                    ranges[i] = ranges[i].filter(range => {
+                        // filter ranges inside the selection
+                        return range.containsPosition(selections[i].getStartPosition()) && range.containsPosition(selections[i].getEndPosition());
                     });
+                    // prepend current selection
+                    ranges[i].unshift(selections[i]);
+                }
+                this._state = ranges.map(ranges => new SelectionRanges(0, ranges));
+                // listen to caret move and forget about state
+                this._selectionListener?.dispose();
+                this._selectionListener = this._editor.onDidChangeCursorPosition(() => {
+                    if (!this._ignoreSelection) {
+                        this._selectionListener?.dispose();
+                        this._state = undefined;
+                    }
                 });
-            }
-            if (!this._state) {
-                // no state
-                return;
-            }
-            this._state = this._state.map(state => state.mov(forward));
-            const newSelections = this._state.map(state => Selection.fromPositions(state.ranges[state.index].getStartPosition(), state.ranges[state.index].getEndPosition()));
-            this._ignoreSelection = true;
-            try {
-                this._editor.setSelections(newSelections);
-            }
-            finally {
-                this._ignoreSelection = false;
-            }
-        });
+            });
+        }
+        if (!this._state) {
+            // no state
+            return;
+        }
+        this._state = this._state.map(state => state.mov(forward));
+        const newSelections = this._state.map(state => Selection.fromPositions(state.ranges[state.index].getStartPosition(), state.ranges[state.index].getEndPosition()));
+        this._ignoreSelection = true;
+        try {
+            this._editor.setSelections(newSelections);
+        }
+        finally {
+            this._ignoreSelection = false;
+        }
     }
 };
 SmartSelectController.ID = 'editor.contrib.smartSelectController';
@@ -133,20 +119,18 @@
         super(opts);
         this._forward = forward;
     }
-    run(_accessor, editor) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const controller = SmartSelectController.get(editor);
-            if (controller) {
-                yield controller.run(this._forward);
-            }
-        });
+    async run(_accessor, editor) {
+        const controller = SmartSelectController.get(editor);
+        if (controller) {
+            await controller.run(this._forward);
+        }
     }
 }
 class GrowSelectionAction extends AbstractSmartSelect {
     constructor() {
         super(true, {
             id: 'editor.action.smartSelect.expand',
-            label: nls.localize('smartSelect.expand', "Expand Selection"),
+            label: nls.localizeWithPath('vs/editor/contrib/smartSelect/browser/smartSelect', 'smartSelect.expand', "Expand Selection"),
             alias: 'Expand Selection',
             precondition: undefined,
             kbOpts: {
@@ -161,7 +145,7 @@
             menuOpts: {
                 menuId: MenuId.MenubarSelectionMenu,
                 group: '1_basic',
-                title: nls.localize({ key: 'miSmartSelectGrow', comment: ['&& denotes a mnemonic'] }, "&&Expand Selection"),
+                title: nls.localizeWithPath('vs/editor/contrib/smartSelect/browser/smartSelect', { key: 'miSmartSelectGrow', comment: ['&& denotes a mnemonic'] }, "&&Expand Selection"),
                 order: 2
             }
         });
@@ -173,7 +157,7 @@
     constructor() {
         super(false, {
             id: 'editor.action.smartSelect.shrink',
-            label: nls.localize('smartSelect.shrink', "Shrink Selection"),
+            label: nls.localizeWithPath('vs/editor/contrib/smartSelect/browser/smartSelect', 'smartSelect.shrink', "Shrink Selection"),
             alias: 'Shrink Selection',
             precondition: undefined,
             kbOpts: {
@@ -188,7 +172,7 @@
             menuOpts: {
                 menuId: MenuId.MenubarSelectionMenu,
                 group: '1_basic',
-                title: nls.localize({ key: 'miSmartSelectShrink', comment: ['&& denotes a mnemonic'] }, "&&Shrink Selection"),
+                title: nls.localizeWithPath('vs/editor/contrib/smartSelect/browser/smartSelect', { key: 'miSmartSelectShrink', comment: ['&& denotes a mnemonic'] }, "&&Shrink Selection"),
                 order: 3
             }
         });
@@ -197,103 +181,99 @@
 registerEditorContribution(SmartSelectController.ID, SmartSelectController, 4 /* EditorContributionInstantiation.Lazy */);
 registerEditorAction(GrowSelectionAction);
 registerEditorAction(ShrinkSelectionAction);
-export function provideSelectionRanges(registry, model, positions, options, token) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const providers = registry.all(model)
-            .concat(new WordSelectionRangeProvider(options.selectSubwords)); // ALWAYS have word based selection range
-        if (providers.length === 1) {
-            // add word selection and bracket selection when no provider exists
-            providers.unshift(new BracketSelectionRangeProvider());
-        }
-        const work = [];
-        const allRawRanges = [];
-        for (const provider of providers) {
-            work.push(Promise.resolve(provider.provideSelectionRanges(model, positions, token)).then(allProviderRanges => {
-                if (arrays.isNonEmptyArray(allProviderRanges) && allProviderRanges.length === positions.length) {
-                    for (let i = 0; i < positions.length; i++) {
-                        if (!allRawRanges[i]) {
-                            allRawRanges[i] = [];
-                        }
-                        for (const oneProviderRanges of allProviderRanges[i]) {
-                            if (Range.isIRange(oneProviderRanges.range) && Range.containsPosition(oneProviderRanges.range, positions[i])) {
-                                allRawRanges[i].push(Range.lift(oneProviderRanges.range));
-                            }
+export async function provideSelectionRanges(registry, model, positions, options, token) {
+    const providers = registry.all(model)
+        .concat(new WordSelectionRangeProvider(options.selectSubwords)); // ALWAYS have word based selection range
+    if (providers.length === 1) {
+        // add word selection and bracket selection when no provider exists
+        providers.unshift(new BracketSelectionRangeProvider());
+    }
+    const work = [];
+    const allRawRanges = [];
+    for (const provider of providers) {
+        work.push(Promise.resolve(provider.provideSelectionRanges(model, positions, token)).then(allProviderRanges => {
+            if (arrays.isNonEmptyArray(allProviderRanges) && allProviderRanges.length === positions.length) {
+                for (let i = 0; i < positions.length; i++) {
+                    if (!allRawRanges[i]) {
+                        allRawRanges[i] = [];
+                    }
+                    for (const oneProviderRanges of allProviderRanges[i]) {
+                        if (Range.isIRange(oneProviderRanges.range) && Range.containsPosition(oneProviderRanges.range, positions[i])) {
+                            allRawRanges[i].push(Range.lift(oneProviderRanges.range));
                         }
                     }
                 }
-            }, onUnexpectedExternalError));
+            }
+        }, onUnexpectedExternalError));
+    }
+    await Promise.all(work);
+    return allRawRanges.map(oneRawRanges => {
+        if (oneRawRanges.length === 0) {
+            return [];
         }
-        yield Promise.all(work);
-        return allRawRanges.map(oneRawRanges => {
-            if (oneRawRanges.length === 0) {
-                return [];
+        // sort all by start/end position
+        oneRawRanges.sort((a, b) => {
+            if (Position.isBefore(a.getStartPosition(), b.getStartPosition())) {
+                return 1;
+            }
+            else if (Position.isBefore(b.getStartPosition(), a.getStartPosition())) {
+                return -1;
             }
-            // sort all by start/end position
-            oneRawRanges.sort((a, b) => {
-                if (Position.isBefore(a.getStartPosition(), b.getStartPosition())) {
-                    return 1;
-                }
-                else if (Position.isBefore(b.getStartPosition(), a.getStartPosition())) {
-                    return -1;
-                }
-                else if (Position.isBefore(a.getEndPosition(), b.getEndPosition())) {
-                    return -1;
-                }
-                else if (Position.isBefore(b.getEndPosition(), a.getEndPosition())) {
-                    return 1;
-                }
-                else {
-                    return 0;
-                }
-            });
-            // remove ranges that don't contain the former range or that are equal to the
-            // former range
-            const oneRanges = [];
-            let last;
-            for (const range of oneRawRanges) {
-                if (!last || (Range.containsRange(range, last) && !Range.equalsRange(range, last))) {
-                    oneRanges.push(range);
-                    last = range;
-                }
+            else if (Position.isBefore(a.getEndPosition(), b.getEndPosition())) {
+                return -1;
             }
-            if (!options.selectLeadingAndTrailingWhitespace) {
-                return oneRanges;
+            else if (Position.isBefore(b.getEndPosition(), a.getEndPosition())) {
+                return 1;
             }
-            // add ranges that expand trivia at line starts and ends whenever a range
-            // wraps onto the a new line
-            const oneRangesWithTrivia = [oneRanges[0]];
-            for (let i = 1; i < oneRanges.length; i++) {
-                const prev = oneRanges[i - 1];
-                const cur = oneRanges[i];
-                if (cur.startLineNumber !== prev.startLineNumber || cur.endLineNumber !== prev.endLineNumber) {
-                    // add line/block range without leading/failing whitespace
-                    const rangeNoWhitespace = new Range(prev.startLineNumber, model.getLineFirstNonWhitespaceColumn(prev.startLineNumber), prev.endLineNumber, model.getLineLastNonWhitespaceColumn(prev.endLineNumber));
-                    if (rangeNoWhitespace.containsRange(prev) && !rangeNoWhitespace.equalsRange(prev) && cur.containsRange(rangeNoWhitespace) && !cur.equalsRange(rangeNoWhitespace)) {
-                        oneRangesWithTrivia.push(rangeNoWhitespace);
-                    }
-                    // add line/block range
-                    const rangeFull = new Range(prev.startLineNumber, 1, prev.endLineNumber, model.getLineMaxColumn(prev.endLineNumber));
-                    if (rangeFull.containsRange(prev) && !rangeFull.equalsRange(rangeNoWhitespace) && cur.containsRange(rangeFull) && !cur.equalsRange(rangeFull)) {
-                        oneRangesWithTrivia.push(rangeFull);
-                    }
-                }
-                oneRangesWithTrivia.push(cur);
+            else {
+                return 0;
             }
-            return oneRangesWithTrivia;
         });
-    });
-}
-CommandsRegistry.registerCommand('_executeSelectionRangeProvider', function (accessor, ...args) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const [resource, positions] = args;
-        assertType(URI.isUri(resource));
-        const registry = accessor.get(ILanguageFeaturesService).selectionRangeProvider;
-        const reference = yield accessor.get(ITextModelService).createModelReference(resource);
-        try {
-            return provideSelectionRanges(registry, reference.object.textEditorModel, positions, { selectLeadingAndTrailingWhitespace: true, selectSubwords: true }, CancellationToken.None);
+        // remove ranges that don't contain the former range or that are equal to the
+        // former range
+        const oneRanges = [];
+        let last;
+        for (const range of oneRawRanges) {
+            if (!last || (Range.containsRange(range, last) && !Range.equalsRange(range, last))) {
+                oneRanges.push(range);
+                last = range;
+            }
         }
-        finally {
-            reference.dispose();
+        if (!options.selectLeadingAndTrailingWhitespace) {
+            return oneRanges;
         }
+        // add ranges that expand trivia at line starts and ends whenever a range
+        // wraps onto the a new line
+        const oneRangesWithTrivia = [oneRanges[0]];
+        for (let i = 1; i < oneRanges.length; i++) {
+            const prev = oneRanges[i - 1];
+            const cur = oneRanges[i];
+            if (cur.startLineNumber !== prev.startLineNumber || cur.endLineNumber !== prev.endLineNumber) {
+                // add line/block range without leading/failing whitespace
+                const rangeNoWhitespace = new Range(prev.startLineNumber, model.getLineFirstNonWhitespaceColumn(prev.startLineNumber), prev.endLineNumber, model.getLineLastNonWhitespaceColumn(prev.endLineNumber));
+                if (rangeNoWhitespace.containsRange(prev) && !rangeNoWhitespace.equalsRange(prev) && cur.containsRange(rangeNoWhitespace) && !cur.equalsRange(rangeNoWhitespace)) {
+                    oneRangesWithTrivia.push(rangeNoWhitespace);
+                }
+                // add line/block range
+                const rangeFull = new Range(prev.startLineNumber, 1, prev.endLineNumber, model.getLineMaxColumn(prev.endLineNumber));
+                if (rangeFull.containsRange(prev) && !rangeFull.equalsRange(rangeNoWhitespace) && cur.containsRange(rangeFull) && !cur.equalsRange(rangeFull)) {
+                    oneRangesWithTrivia.push(rangeFull);
+                }
+            }
+            oneRangesWithTrivia.push(cur);
+        }
+        return oneRangesWithTrivia;
     });
+}
+CommandsRegistry.registerCommand('_executeSelectionRangeProvider', async function (accessor, ...args) {
+    const [resource, positions] = args;
+    assertType(URI.isUri(resource));
+    const registry = accessor.get(ILanguageFeaturesService).selectionRangeProvider;
+    const reference = await accessor.get(ITextModelService).createModelReference(resource);
+    try {
+        return provideSelectionRanges(registry, reference.object.textEditorModel, positions, { selectLeadingAndTrailingWhitespace: true, selectSubwords: true }, CancellationToken.None);
+    }
+    finally {
+        reference.dispose();
+    }
 });
diff -urN -x '*.map' a/vs/editor/contrib/snippet/browser/snippetController2.js b/vs/editor/contrib/snippet/browser/snippetController2.js
--- a/vs/editor/contrib/snippet/browser/snippetController2.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/snippet/browser/snippetController2.js	2023-12-06 14:23:14.383854791 +0000
@@ -20,7 +20,7 @@
 import { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';
 import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
 import { showSimpleSuggestions } from '../../suggest/browser/suggest.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { ContextKeyExpr, IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';
 import { ILogService } from '../../../../platform/log/common/log.js';
 import { SnippetSession } from './snippetSession.js';
@@ -49,19 +49,30 @@
         this._hasPrevTabstop = SnippetController2_1.HasPrevTabstop.bindTo(contextKeyService);
     }
     dispose() {
-        var _a;
         this._inSnippet.reset();
         this._hasPrevTabstop.reset();
         this._hasNextTabstop.reset();
-        (_a = this._session) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._session?.dispose();
         this._snippetListener.dispose();
     }
+    apply(edits, opts) {
+        try {
+            this._doInsert(edits, typeof opts === 'undefined' ? _defaultOptions : { ..._defaultOptions, ...opts });
+        }
+        catch (e) {
+            this.cancel();
+            this._logService.error(e);
+            this._logService.error('snippet_error');
+            this._logService.error('insert_edits=', edits);
+            this._logService.error('existing_template=', this._session ? this._session._logInfo() : '<no_session>');
+        }
+    }
     insert(template, opts) {
         // this is here to find out more about the yet-not-understood
         // error that sometimes happens when we fail to inserted a nested
         // snippet
         try {
-            this._doInsert(template, typeof opts === 'undefined' ? _defaultOptions : Object.assign(Object.assign({}, _defaultOptions), opts));
+            this._doInsert(template, typeof opts === 'undefined' ? _defaultOptions : { ..._defaultOptions, ...opts });
         }
         catch (e) {
             this.cancel();
@@ -72,7 +83,6 @@
         }
     }
     _doInsert(template, opts) {
-        var _a;
         if (!this._editor.hasModel()) {
             return;
         }
@@ -99,7 +109,7 @@
             this._editor.getModel().pushStackElement();
         }
         // regster completion item provider when there is any choice element
-        if ((_a = this._session) === null || _a === void 0 ? void 0 : _a.hasChoice) {
+        if (this._session?.hasChoice) {
             const provider = {
                 _debugDisplayName: 'snippetChoiceCompletions',
                 provideCompletionItems: (model, position) => {
@@ -122,7 +132,7 @@
                             sortText: 'a'.repeat(i + 1),
                             range: activeChoice.range,
                             filterText: isAnyOfOptions ? `${word}_${option.value}` : undefined,
-                            command: { id: 'jumpToNextSnippetPlaceholder', title: localize('next', 'Go to next placeholder...') }
+                            command: { id: 'jumpToNextSnippetPlaceholder', title: localizeWithPath('vs/editor/contrib/snippet/browser/snippetController2', 'next', 'Go to next placeholder...') }
                         });
                     }
                     return { suggestions };
@@ -132,7 +142,7 @@
             let registration;
             let isRegistered = false;
             const disable = () => {
-                registration === null || registration === void 0 ? void 0 : registration.dispose();
+                registration?.dispose();
                 isRegistered = false;
             };
             const enable = () => {
@@ -179,14 +189,13 @@
         this._handleChoice();
     }
     _handleChoice() {
-        var _a;
         if (!this._session || !this._editor.hasModel()) {
             this._currentChoice = undefined;
             return;
         }
         const { activeChoice } = this._session;
         if (!activeChoice || !this._choiceCompletions) {
-            (_a = this._choiceCompletions) === null || _a === void 0 ? void 0 : _a.disable();
+            this._choiceCompletions?.disable();
             this._currentChoice = undefined;
             return;
         }
@@ -205,13 +214,12 @@
         }
     }
     cancel(resetSelection = false) {
-        var _a;
         this._inSnippet.reset();
         this._hasPrevTabstop.reset();
         this._hasNextTabstop.reset();
         this._snippetListener.clear();
         this._currentChoice = undefined;
-        (_a = this._session) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._session?.dispose();
         this._session = undefined;
         this._modelVersionId = -1;
         if (resetSelection) {
@@ -222,23 +230,27 @@
         }
     }
     prev() {
-        var _a;
-        (_a = this._session) === null || _a === void 0 ? void 0 : _a.prev();
+        this._session?.prev();
         this._updateState();
     }
     next() {
-        var _a;
-        (_a = this._session) === null || _a === void 0 ? void 0 : _a.next();
+        this._session?.next();
         this._updateState();
     }
     isInSnippet() {
         return Boolean(this._inSnippet.get());
     }
+    getSessionEnclosingRange() {
+        if (this._session) {
+            return this._session.getEnclosingRange();
+        }
+        return undefined;
+    }
 };
 SnippetController2.ID = 'snippetController2';
-SnippetController2.InSnippetMode = new RawContextKey('inSnippetMode', false, localize('inSnippetMode', "Whether the editor in current in snippet mode"));
-SnippetController2.HasNextTabstop = new RawContextKey('hasNextTabstop', false, localize('hasNextTabstop', "Whether there is a next tab stop when in snippet mode"));
-SnippetController2.HasPrevTabstop = new RawContextKey('hasPrevTabstop', false, localize('hasPrevTabstop', "Whether there is a previous tab stop when in snippet mode"));
+SnippetController2.InSnippetMode = new RawContextKey('inSnippetMode', false, localizeWithPath('vs/editor/contrib/snippet/browser/snippetController2', 'inSnippetMode', "Whether the editor in current in snippet mode"));
+SnippetController2.HasNextTabstop = new RawContextKey('hasNextTabstop', false, localizeWithPath('vs/editor/contrib/snippet/browser/snippetController2', 'hasNextTabstop', "Whether there is a next tab stop when in snippet mode"));
+SnippetController2.HasPrevTabstop = new RawContextKey('hasPrevTabstop', false, localizeWithPath('vs/editor/contrib/snippet/browser/snippetController2', 'hasPrevTabstop', "Whether there is a previous tab stop when in snippet mode"));
 SnippetController2 = SnippetController2_1 = __decorate([
     __param(1, ILogService),
     __param(2, ILanguageFeaturesService),
diff -urN -x '*.map' a/vs/editor/contrib/snippet/browser/snippetParser.js b/vs/editor/contrib/snippet/browser/snippetParser.js
--- a/vs/editor/contrib/snippet/browser/snippetParser.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/snippet/browser/snippetParser.js	2023-12-06 14:23:14.383854791 +0000
@@ -140,6 +140,9 @@
     }
 }
 export class Text extends Marker {
+    static escape(value) {
+        return value.replace(/\$|}|\\/g, '\\$&');
+    }
     constructor(value) {
         super();
         this.value = value;
@@ -147,6 +150,9 @@
     toString() {
         return this.value;
     }
+    toTextmateString() {
+        return Text.escape(this.value);
+    }
     len() {
         return this.value.length;
     }
@@ -189,6 +195,24 @@
             ? this._children[0]
             : undefined;
     }
+    toTextmateString() {
+        let transformString = '';
+        if (this.transform) {
+            transformString = this.transform.toTextmateString();
+        }
+        if (this.children.length === 0 && !this.transform) {
+            return `\$${this.index}`;
+        }
+        else if (this.children.length === 0) {
+            return `\${${this.index}${transformString}}`;
+        }
+        else if (this.choice) {
+            return `\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;
+        }
+        else {
+            return `\${${this.index}:${this.children.map(child => child.toTextmateString()).join('')}${transformString}}`;
+        }
+    }
     clone() {
         const ret = new Placeholder(this.index);
         if (this.transform) {
@@ -213,6 +237,11 @@
     toString() {
         return this.options[0].value;
     }
+    toTextmateString() {
+        return this.options
+            .map(option => option.value.replace(/\||,|\\/g, '\\$&'))
+            .join(',');
+    }
     len() {
         return this.options[0].len();
     }
@@ -258,6 +287,9 @@
     toString() {
         return '';
     }
+    toTextmateString() {
+        return `/${this.regexp.source}/${this.children.map(c => c.toTextmateString())}/${(this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : '')}`;
+    }
     clone() {
         const ret = new Transform();
         ret.regexp = new RegExp(this.regexp.source, '' + (this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : ''));
@@ -322,6 +354,24 @@
         })
             .join('');
     }
+    toTextmateString() {
+        let value = '${';
+        value += this.index;
+        if (this.shorthandName) {
+            value += `:/${this.shorthandName}`;
+        }
+        else if (this.ifValue && this.elseValue) {
+            value += `:?${this.ifValue}:${this.elseValue}`;
+        }
+        else if (this.ifValue) {
+            value += `:+${this.ifValue}`;
+        }
+        else if (this.elseValue) {
+            value += `:-${this.elseValue}`;
+        }
+        value += '}';
+        return value;
+    }
     clone() {
         const ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
         return ret;
@@ -343,6 +393,18 @@
         }
         return false;
     }
+    toTextmateString() {
+        let transformString = '';
+        if (this.transform) {
+            transformString = this.transform.toTextmateString();
+        }
+        if (this.children.length === 0) {
+            return `\${${this.name}${transformString}}`;
+        }
+        else {
+            return `\${${this.name}:${this.children.map(child => child.toTextmateString()).join('')}${transformString}}`;
+        }
+    }
     clone() {
         const ret = new Variable(this.name);
         if (this.transform) {
@@ -438,6 +500,9 @@
         this._placeholders = undefined;
         return super.replace(child, others);
     }
+    toTextmateString() {
+        return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), '');
+    }
     clone() {
         const ret = new TextmateSnippet();
         this._children = this.children.map(child => child.clone());
@@ -455,13 +520,20 @@
     static escape(value) {
         return value.replace(/\$|}|\\/g, '\\$&');
     }
+    /**
+     * Takes a snippet and returns the insertable string, e.g return the snippet-string
+     * without any placeholder, tabstop, variables etc...
+     */
+    static asInsertText(value) {
+        return new SnippetParser().parse(value).toString();
+    }
     static guessNeedsClipboard(template) {
         return /\${?CLIPBOARD/.test(template);
     }
     parse(value, insertFinalTabstop, enforceFinalTabstop) {
         const snippet = new TextmateSnippet();
         this.parseFragment(value, snippet);
-        this.ensureFinalTabstop(snippet, enforceFinalTabstop !== null && enforceFinalTabstop !== void 0 ? enforceFinalTabstop : false, insertFinalTabstop !== null && insertFinalTabstop !== void 0 ? insertFinalTabstop : false);
+        this.ensureFinalTabstop(snippet, enforceFinalTabstop ?? false, insertFinalTabstop ?? false);
         return snippet;
     }
     parseFragment(value, snippet) {
diff -urN -x '*.map' a/vs/editor/contrib/snippet/browser/snippetSession.js b/vs/editor/contrib/snippet/browser/snippetSession.js
--- a/vs/editor/contrib/snippet/browser/snippetSession.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/snippet/browser/snippetSession.js	2023-12-06 14:23:14.383854791 +0000
@@ -138,7 +138,7 @@
             }
             return selections;
         });
-        return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);
+        return !couldSkipThisPlaceholder ? newSelections ?? [] : this.move(fwd);
     }
     _hasPlaceholderBeenCollapsed(placeholder) {
         // A placeholder is empty when it wasn't empty when authored but
@@ -216,7 +216,7 @@
             return undefined;
         }
         const placeholder = this._placeholderGroups[this._placeholderGroupsIdx][0];
-        if (!(placeholder === null || placeholder === void 0 ? void 0 : placeholder.choice)) {
+        if (!placeholder?.choice) {
             return undefined;
         }
         const id = this._placeholderDecorations.get(placeholder);
@@ -281,6 +281,20 @@
             this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);
         });
     }
+    getEnclosingRange() {
+        let result;
+        const model = this._editor.getModel();
+        for (const decorationId of this._placeholderDecorations.values()) {
+            const placeholderRange = model.getDecorationRange(decorationId) ?? undefined;
+            if (!result) {
+                result = placeholderRange;
+            }
+            else {
+                result = result.plusRange(placeholderRange);
+            }
+        }
+        return result;
+    }
 }
 OneSnippet._decor = {
     active: ModelDecorationOptions.register({ description: 'snippet-placeholder-1', stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */, className: 'snippet-placeholder' }),
@@ -323,7 +337,7 @@
                 }
                 else {
                     // check if text start is after a linebreak
-                    snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();
+                    snippetTextString = snippetTextString ?? snippet.toString();
                     const prevChar = snippetTextString.charCodeAt(offset - 1);
                     if (prevChar === 10 /* CharCode.LineFeed */ || prevChar === 13 /* CharCode.CarriageReturn */) {
                         lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);
@@ -643,6 +657,19 @@
         // have any left, we don't have a selection anymore
         return allPossibleSelections.size > 0;
     }
+    getEnclosingRange() {
+        let result;
+        for (const snippet of this._snippets) {
+            const snippetRange = snippet.getEnclosingRange();
+            if (!result) {
+                result = snippetRange;
+            }
+            else {
+                result = result.plusRange(snippetRange);
+            }
+        }
+        return result;
+    }
 };
 SnippetSession = SnippetSession_1 = __decorate([
     __param(3, ILanguageConfigurationService)
diff -urN -x '*.map' a/vs/editor/contrib/snippet/browser/snippetVariables.js b/vs/editor/contrib/snippet/browser/snippetVariables.js
--- a/vs/editor/contrib/snippet/browser/snippetVariables.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/snippet/browser/snippetVariables.js	2023-12-06 14:23:14.383854791 +0000
@@ -288,10 +288,10 @@
         return undefined;
     }
 }
-TimeBasedVariableResolver.dayNames = [nls.localize('Sunday', "Sunday"), nls.localize('Monday', "Monday"), nls.localize('Tuesday', "Tuesday"), nls.localize('Wednesday', "Wednesday"), nls.localize('Thursday', "Thursday"), nls.localize('Friday', "Friday"), nls.localize('Saturday', "Saturday")];
-TimeBasedVariableResolver.dayNamesShort = [nls.localize('SundayShort', "Sun"), nls.localize('MondayShort', "Mon"), nls.localize('TuesdayShort', "Tue"), nls.localize('WednesdayShort', "Wed"), nls.localize('ThursdayShort', "Thu"), nls.localize('FridayShort', "Fri"), nls.localize('SaturdayShort', "Sat")];
-TimeBasedVariableResolver.monthNames = [nls.localize('January', "January"), nls.localize('February', "February"), nls.localize('March', "March"), nls.localize('April', "April"), nls.localize('May', "May"), nls.localize('June', "June"), nls.localize('July', "July"), nls.localize('August', "August"), nls.localize('September', "September"), nls.localize('October', "October"), nls.localize('November', "November"), nls.localize('December', "December")];
-TimeBasedVariableResolver.monthNamesShort = [nls.localize('JanuaryShort', "Jan"), nls.localize('FebruaryShort', "Feb"), nls.localize('MarchShort', "Mar"), nls.localize('AprilShort', "Apr"), nls.localize('MayShort', "May"), nls.localize('JuneShort', "Jun"), nls.localize('JulyShort', "Jul"), nls.localize('AugustShort', "Aug"), nls.localize('SeptemberShort', "Sep"), nls.localize('OctoberShort', "Oct"), nls.localize('NovemberShort', "Nov"), nls.localize('DecemberShort', "Dec")];
+TimeBasedVariableResolver.dayNames = [nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'Sunday', "Sunday"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'Monday', "Monday"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'Tuesday', "Tuesday"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'Wednesday', "Wednesday"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'Thursday', "Thursday"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'Friday', "Friday"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'Saturday', "Saturday")];
+TimeBasedVariableResolver.dayNamesShort = [nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'SundayShort', "Sun"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'MondayShort', "Mon"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'TuesdayShort', "Tue"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'WednesdayShort', "Wed"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'ThursdayShort', "Thu"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'FridayShort', "Fri"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'SaturdayShort', "Sat")];
+TimeBasedVariableResolver.monthNames = [nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'January', "January"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'February', "February"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'March', "March"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'April', "April"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'May', "May"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'June', "June"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'July', "July"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'August', "August"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'September', "September"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'October', "October"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'November', "November"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'December', "December")];
+TimeBasedVariableResolver.monthNamesShort = [nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'JanuaryShort', "Jan"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'FebruaryShort', "Feb"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'MarchShort', "Mar"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'AprilShort', "Apr"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'MayShort', "May"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'JuneShort', "Jun"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'JulyShort', "Jul"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'AugustShort', "Aug"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'SeptemberShort', "Sep"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'OctoberShort', "Oct"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'NovemberShort', "Nov"), nls.localizeWithPath('vs/editor/contrib/snippet/browser/snippetVariables', 'DecemberShort', "Dec")];
 export class WorkspaceBasedVariableResolver {
     constructor(_workspaceService) {
         this._workspaceService = _workspaceService;
diff -urN -x '*.map' a/vs/editor/contrib/stickyScroll/browser/stickyScrollActions.js b/vs/editor/contrib/stickyScroll/browser/stickyScrollActions.js
--- a/vs/editor/contrib/stickyScroll/browser/stickyScrollActions.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/stickyScroll/browser/stickyScrollActions.js	2023-12-06 14:23:14.383854791 +0000
@@ -2,17 +2,8 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { EditorAction2 } from '../../../browser/editorExtensions.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { Categories } from '../../../../platform/action/common/actionCommonCategories.js';
 import { Action2, MenuId } from '../../../../platform/actions/common/actions.js';
 import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
@@ -24,15 +15,15 @@
         super({
             id: 'editor.action.toggleStickyScroll',
             title: {
-                value: localize('toggleStickyScroll', "Toggle Sticky Scroll"),
-                mnemonicTitle: localize({ key: 'mitoggleStickyScroll', comment: ['&& denotes a mnemonic'] }, "&&Toggle Sticky Scroll"),
+                value: localizeWithPath('vs/editor/contrib/stickyScroll/browser/stickyScrollActions', 'toggleStickyScroll', "Toggle Sticky Scroll"),
+                mnemonicTitle: localizeWithPath('vs/editor/contrib/stickyScroll/browser/stickyScrollActions', { key: 'mitoggleStickyScroll', comment: ['&& denotes a mnemonic'] }, "&&Toggle Sticky Scroll"),
                 original: 'Toggle Sticky Scroll',
             },
             category: Categories.View,
             toggled: {
                 condition: ContextKeyExpr.equals('config.editor.stickyScroll.enabled', true),
-                title: localize('stickyScroll', "Sticky Scroll"),
-                mnemonicTitle: localize({ key: 'miStickyScroll', comment: ['&& denotes a mnemonic'] }, "&&Sticky Scroll"),
+                title: localizeWithPath('vs/editor/contrib/stickyScroll/browser/stickyScrollActions', 'stickyScroll', "Sticky Scroll"),
+                mnemonicTitle: localizeWithPath('vs/editor/contrib/stickyScroll/browser/stickyScrollActions', { key: 'miStickyScroll', comment: ['&& denotes a mnemonic'] }, "&&Sticky Scroll"),
             },
             menu: [
                 { id: MenuId.CommandPalette },
@@ -41,12 +32,10 @@
             ]
         });
     }
-    run(accessor) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const configurationService = accessor.get(IConfigurationService);
-            const newValue = !configurationService.getValue('editor.stickyScroll.enabled');
-            return configurationService.updateValue('editor.stickyScroll.enabled', newValue);
-        });
+    async run(accessor) {
+        const configurationService = accessor.get(IConfigurationService);
+        const newValue = !configurationService.getValue('editor.stickyScroll.enabled');
+        return configurationService.updateValue('editor.stickyScroll.enabled', newValue);
     }
 }
 const weight = 100 /* KeybindingWeight.EditorContrib */;
@@ -55,8 +44,8 @@
         super({
             id: 'editor.action.focusStickyScroll',
             title: {
-                value: localize('focusStickyScroll', "Focus Sticky Scroll"),
-                mnemonicTitle: localize({ key: 'mifocusStickyScroll', comment: ['&& denotes a mnemonic'] }, "&&Focus Sticky Scroll"),
+                value: localizeWithPath('vs/editor/contrib/stickyScroll/browser/stickyScrollActions', 'focusStickyScroll', "Focus Sticky Scroll"),
+                mnemonicTitle: localizeWithPath('vs/editor/contrib/stickyScroll/browser/stickyScrollActions', { key: 'mifocusStickyScroll', comment: ['&& denotes a mnemonic'] }, "&&Focus Sticky Scroll"),
                 original: 'Focus Sticky Scroll',
             },
             precondition: ContextKeyExpr.and(ContextKeyExpr.has('config.editor.stickyScroll.enabled'), EditorContextKeys.stickyScrollVisible),
@@ -66,8 +55,7 @@
         });
     }
     runEditorCommand(_accessor, editor) {
-        var _a;
-        (_a = StickyScrollController.get(editor)) === null || _a === void 0 ? void 0 : _a.focus();
+        StickyScrollController.get(editor)?.focus();
     }
 }
 export class SelectNextStickyScrollLine extends EditorAction2 {
@@ -75,7 +63,7 @@
         super({
             id: 'editor.action.selectNextStickyScrollLine',
             title: {
-                value: localize('selectNextStickyScrollLine.title', "Select next sticky scroll line"),
+                value: localizeWithPath('vs/editor/contrib/stickyScroll/browser/stickyScrollActions', 'selectNextStickyScrollLine.title', "Select next sticky scroll line"),
                 original: 'Select next sticky scroll line'
             },
             precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
@@ -86,8 +74,7 @@
         });
     }
     runEditorCommand(_accessor, editor) {
-        var _a;
-        (_a = StickyScrollController.get(editor)) === null || _a === void 0 ? void 0 : _a.focusNext();
+        StickyScrollController.get(editor)?.focusNext();
     }
 }
 export class SelectPreviousStickyScrollLine extends EditorAction2 {
@@ -95,7 +82,7 @@
         super({
             id: 'editor.action.selectPreviousStickyScrollLine',
             title: {
-                value: localize('selectPreviousStickyScrollLine.title', "Select previous sticky scroll line"),
+                value: localizeWithPath('vs/editor/contrib/stickyScroll/browser/stickyScrollActions', 'selectPreviousStickyScrollLine.title', "Select previous sticky scroll line"),
                 original: 'Select previous sticky scroll line'
             },
             precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
@@ -106,8 +93,7 @@
         });
     }
     runEditorCommand(_accessor, editor) {
-        var _a;
-        (_a = StickyScrollController.get(editor)) === null || _a === void 0 ? void 0 : _a.focusPrevious();
+        StickyScrollController.get(editor)?.focusPrevious();
     }
 }
 export class GoToStickyScrollLine extends EditorAction2 {
@@ -115,7 +101,7 @@
         super({
             id: 'editor.action.goToFocusedStickyScrollLine',
             title: {
-                value: localize('goToFocusedStickyScrollLine.title', "Go to focused sticky scroll line"),
+                value: localizeWithPath('vs/editor/contrib/stickyScroll/browser/stickyScrollActions', 'goToFocusedStickyScrollLine.title', "Go to focused sticky scroll line"),
                 original: 'Go to focused sticky scroll line'
             },
             precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
@@ -126,8 +112,7 @@
         });
     }
     runEditorCommand(_accessor, editor) {
-        var _a;
-        (_a = StickyScrollController.get(editor)) === null || _a === void 0 ? void 0 : _a.goToFocused();
+        StickyScrollController.get(editor)?.goToFocused();
     }
 }
 export class SelectEditor extends EditorAction2 {
@@ -135,7 +120,7 @@
         super({
             id: 'editor.action.selectEditor',
             title: {
-                value: localize('selectEditor.title', "Select Editor"),
+                value: localizeWithPath('vs/editor/contrib/stickyScroll/browser/stickyScrollActions', 'selectEditor.title', "Select Editor"),
                 original: 'Select Editor'
             },
             precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
@@ -146,7 +131,6 @@
         });
     }
     runEditorCommand(_accessor, editor) {
-        var _a;
-        (_a = StickyScrollController.get(editor)) === null || _a === void 0 ? void 0 : _a.selectEditor();
+        StickyScrollController.get(editor)?.selectEditor();
     }
 }
diff -urN -x '*.map' a/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js b/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js
--- a/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var StickyScrollController_1;
 import { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';
 import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
@@ -77,9 +68,9 @@
                 this._readConfiguration();
             }
         }));
-        this._register(dom.addDisposableListener(stickyScrollDomNode, dom.EventType.CONTEXT_MENU, (event) => __awaiter(this, void 0, void 0, function* () {
+        this._register(dom.addDisposableListener(stickyScrollDomNode, dom.EventType.CONTEXT_MENU, async (event) => {
             this._onContextMenu(event);
-        })));
+        }));
         this._stickyScrollFocusedContextKey = EditorContextKeys.stickyScrollFocused.bindTo(this._contextKeyService);
         this._stickyScrollVisibleContextKey = EditorContextKeys.stickyScrollVisible.bindTo(this._contextKeyService);
         const focusTracker = this._register(dom.trackFocus(stickyScrollDomNode));
@@ -104,13 +95,18 @@
             this._onMouseDown = true;
         }));
     }
+    get stickyScrollCandidateProvider() {
+        return this._stickyLineCandidateProvider;
+    }
+    get stickyScrollWidgetState() {
+        return this._widgetState;
+    }
     static get(editor) {
         return editor.getContribution(StickyScrollController_1.ID);
     }
     _disposeFocusStickyScrollStore() {
-        var _a;
         this._stickyScrollFocusedContextKey.set(false);
-        (_a = this._focusDisposableStore) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._focusDisposableStore?.dispose();
         this._focused = false;
         this._positionRevealed = false;
         this._onMouseDown = false;
@@ -313,7 +309,7 @@
         this._register(gesture.onCancel(() => {
             sessionStore.clear();
         }));
-        this._register(gesture.onExecute((e) => __awaiter(this, void 0, void 0, function* () {
+        this._register(gesture.onExecute(async (e) => {
             if (e.target.type !== 12 /* MouseTargetType.OVERLAY_WIDGET */ || e.target.detail !== this._stickyScrollWidget.getId()) {
                 // not hovering over our widget
                 return;
@@ -330,7 +326,7 @@
                 this._revealPosition({ lineNumber: position.lineNumber, column: 1 });
             }
             this._instaService.invokeFunction(goToDefinitionWithLocation, e, this._editor, { uri: this._editor.getModel().uri, range: this._stickyRangeProjectedOnEditor });
-        })));
+        }));
     }
     _onContextMenu(e) {
         const event = new StandardMouseEvent(e);
@@ -344,7 +340,7 @@
             return;
         }
         const stickyLine = this._stickyScrollWidget.getStickyLineForLine(line);
-        const foldingIcon = stickyLine === null || stickyLine === void 0 ? void 0 : stickyLine.foldingIcon;
+        const foldingIcon = stickyLine?.foldingIcon;
         if (!foldingIcon) {
             return;
         }
@@ -413,52 +409,49 @@
         const theoreticalLines = layoutInfo.height / this._editor.getOption(66 /* EditorOption.lineHeight */);
         this._maxStickyLines = Math.round(theoreticalLines * .25);
     }
-    _renderStickyScroll(rebuildFromLine = Infinity) {
-        var _a, _b;
-        return __awaiter(this, void 0, void 0, function* () {
-            const model = this._editor.getModel();
-            if (!model || model.isTooLargeForTokenization()) {
-                this._foldingModel = null;
-                this._stickyScrollWidget.setState(undefined, null, rebuildFromLine);
-                return;
+    async _renderStickyScroll(rebuildFromLine = Infinity) {
+        const model = this._editor.getModel();
+        if (!model || model.isTooLargeForTokenization()) {
+            this._foldingModel = null;
+            this._stickyScrollWidget.setState(undefined, null, rebuildFromLine);
+            return;
+        }
+        const stickyLineVersion = this._stickyLineCandidateProvider.getVersionId();
+        if (stickyLineVersion === undefined || stickyLineVersion === model.getVersionId()) {
+            this._foldingModel = await FoldingController.get(this._editor)?.getFoldingModel() ?? null;
+            this._widgetState = this.findScrollWidgetState();
+            this._stickyScrollVisibleContextKey.set(!(this._widgetState.startLineNumbers.length === 0));
+            if (!this._focused) {
+                this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, rebuildFromLine);
             }
-            const stickyLineVersion = this._stickyLineCandidateProvider.getVersionId();
-            if (stickyLineVersion === undefined || stickyLineVersion === model.getVersionId()) {
-                this._foldingModel = (_b = yield ((_a = FoldingController.get(this._editor)) === null || _a === void 0 ? void 0 : _a.getFoldingModel())) !== null && _b !== void 0 ? _b : null;
-                this._widgetState = this.findScrollWidgetState();
-                this._stickyScrollVisibleContextKey.set(!(this._widgetState.startLineNumbers.length === 0));
-                if (!this._focused) {
+            else {
+                // Suppose that previously the sticky scroll widget had height 0, then if there are visible lines, set the last line as focused
+                if (this._focusedStickyElementIndex === -1) {
                     this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, rebuildFromLine);
+                    this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1;
+                    if (this._focusedStickyElementIndex !== -1) {
+                        this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
+                    }
                 }
                 else {
-                    // Suppose that previously the sticky scroll widget had height 0, then if there are visible lines, set the last line as focused
-                    if (this._focusedStickyElementIndex === -1) {
-                        this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, rebuildFromLine);
-                        this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1;
-                        if (this._focusedStickyElementIndex !== -1) {
-                            this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
-                        }
+                    const focusedStickyElementLineNumber = this._stickyScrollWidget.lineNumbers[this._focusedStickyElementIndex];
+                    this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, rebuildFromLine);
+                    // Suppose that after setting the state, there are no sticky lines, set the focused index to -1
+                    if (this._stickyScrollWidget.lineNumberCount === 0) {
+                        this._focusedStickyElementIndex = -1;
                     }
                     else {
-                        const focusedStickyElementLineNumber = this._stickyScrollWidget.lineNumbers[this._focusedStickyElementIndex];
-                        this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, rebuildFromLine);
-                        // Suppose that after setting the state, there are no sticky lines, set the focused index to -1
-                        if (this._stickyScrollWidget.lineNumberCount === 0) {
-                            this._focusedStickyElementIndex = -1;
-                        }
-                        else {
-                            const previousFocusedLineNumberExists = this._stickyScrollWidget.lineNumbers.includes(focusedStickyElementLineNumber);
-                            // If the line number is still there, do not change anything
-                            // If the line number is not there, set the new focused line to be the last line
-                            if (!previousFocusedLineNumberExists) {
-                                this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1;
-                            }
-                            this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
+                        const previousFocusedLineNumberExists = this._stickyScrollWidget.lineNumbers.includes(focusedStickyElementLineNumber);
+                        // If the line number is still there, do not change anything
+                        // If the line number is not there, set the new focused line to be the last line
+                        if (!previousFocusedLineNumberExists) {
+                            this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1;
                         }
+                        this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
                     }
                 }
             }
-        });
+        }
     }
     findScrollWidgetState() {
         const lineHeight = this._editor.getOption(66 /* EditorOption.lineHeight */);
diff -urN -x '*.map' a/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.js b/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.js
--- a/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';
 import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
 import { OutlineElement, OutlineGroup, OutlineModel } from '../../documentSymbols/browser/outlineModel.js';
@@ -77,37 +68,35 @@
             this._modelPromise = null;
         }
     }
-    update(textModel, textModelVersionId, token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            this._updateOperation.clear();
-            this._updateOperation.add({
-                dispose: () => {
-                    this._cancelModelPromise();
-                    this._updateScheduler.cancel();
+    async update(textModel, textModelVersionId, token) {
+        this._updateOperation.clear();
+        this._updateOperation.add({
+            dispose: () => {
+                this._cancelModelPromise();
+                this._updateScheduler.cancel();
+            }
+        });
+        this._cancelModelPromise();
+        return await this._updateScheduler.trigger(async () => {
+            for (const modelProvider of this._modelProviders) {
+                const { statusPromise, modelPromise } = modelProvider.computeStickyModel(textModel, textModelVersionId, token);
+                this._modelPromise = modelPromise;
+                const status = await statusPromise;
+                if (this._modelPromise !== modelPromise) {
+                    return null;
                 }
-            });
-            this._cancelModelPromise();
-            return yield this._updateScheduler.trigger(() => __awaiter(this, void 0, void 0, function* () {
-                for (const modelProvider of this._modelProviders) {
-                    const { statusPromise, modelPromise } = modelProvider.computeStickyModel(textModel, textModelVersionId, token);
-                    this._modelPromise = modelPromise;
-                    const status = yield statusPromise;
-                    if (this._modelPromise !== modelPromise) {
+                switch (status) {
+                    case Status.CANCELED:
+                        this._updateOperation.clear();
                         return null;
-                    }
-                    switch (status) {
-                        case Status.CANCELED:
-                            this._updateOperation.clear();
-                            return null;
-                        case Status.VALID:
-                            return modelProvider.stickyModel;
-                    }
+                    case Status.VALID:
+                        return modelProvider.stickyModel;
                 }
-                return null;
-            })).catch((error) => {
-                onUnexpectedError(error);
-                return null;
-            });
+            }
+            return null;
+        }).catch((error) => {
+            onUnexpectedError(error);
+            return null;
         });
     }
 };
@@ -173,12 +162,14 @@
         super();
         this._languageFeaturesService = _languageFeaturesService;
     }
+    get provider() {
+        return this._languageFeaturesService.documentSymbolProvider;
+    }
     createModelFromProvider(textModel, modelVersionId, token) {
         return OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, textModel, token);
     }
     createStickyModel(textModel, modelVersionId, token, model) {
-        var _a;
-        const { stickyOutlineElement, providerID } = this._stickyModelFromOutlineModel(model, (_a = this._stickyModel) === null || _a === void 0 ? void 0 : _a.outlineProviderId);
+        const { stickyOutlineElement, providerID } = this._stickyModelFromOutlineModel(model, this._stickyModel?.outlineProviderId);
         return new StickyModel(textModel.uri, modelVersionId, stickyOutlineElement, providerID);
     }
     isModelValid(model) {
@@ -309,6 +300,9 @@
         super(editor);
         this._languageConfigurationService = _languageConfigurationService;
     }
+    get provider() {
+        return null;
+    }
     createModelFromProvider(textModel, modelVersionId, token) {
         const provider = new IndentRangeProvider(textModel, this._languageConfigurationService, this._foldingLimitReporter);
         return provider.compute(token);
@@ -322,6 +316,9 @@
         super(editor);
         this._languageFeaturesService = _languageFeaturesService;
     }
+    get provider() {
+        return this._languageFeaturesService.foldingRangeProvider;
+    }
     isProviderValid(textModel) {
         const selectedProviders = FoldingController.getFoldingRangeProviders(this._languageFeaturesService, textModel);
         return selectedProviders.length > 0;
diff -urN -x '*.map' a/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js b/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js
--- a/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,18 +11,9 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';
 import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
-import { CancellationTokenSource } from '../../../../base/common/cancellation.js';
+import { CancellationTokenSource, } from '../../../../base/common/cancellation.js';
 import { RunOnceScheduler } from '../../../../base/common/async.js';
 import { binarySearch } from '../../../../base/common/arrays.js';
 import { Emitter } from '../../../../base/common/event.js';
@@ -77,33 +68,27 @@
         this.update();
     }
     getVersionId() {
-        var _a;
-        return (_a = this._model) === null || _a === void 0 ? void 0 : _a.version;
+        return this._model?.version;
     }
-    update() {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            (_a = this._cts) === null || _a === void 0 ? void 0 : _a.dispose(true);
-            this._cts = new CancellationTokenSource();
-            yield this.updateStickyModel(this._cts.token);
-            this._onDidChangeStickyScroll.fire();
-        });
+    async update() {
+        this._cts?.dispose(true);
+        this._cts = new CancellationTokenSource();
+        await this.updateStickyModel(this._cts.token);
+        this._onDidChangeStickyScroll.fire();
     }
-    updateStickyModel(token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!this._editor.hasModel() || !this._stickyModelProvider || this._editor.getModel().isTooLargeForTokenization()) {
-                this._model = null;
-                return;
-            }
-            const textModel = this._editor.getModel();
-            const modelVersionId = textModel.getVersionId();
-            const model = yield this._stickyModelProvider.update(textModel, modelVersionId, token);
-            if (token.isCancellationRequested) {
-                // the computation was canceled, so do not overwrite the model
-                return;
-            }
-            this._model = model;
-        });
+    async updateStickyModel(token) {
+        if (!this._editor.hasModel() || !this._stickyModelProvider || this._editor.getModel().isTooLargeForTokenization()) {
+            this._model = null;
+            return;
+        }
+        const textModel = this._editor.getModel();
+        const modelVersionId = textModel.getVersionId();
+        const model = await this._stickyModelProvider.update(textModel, modelVersionId, token);
+        if (token.isCancellationRequested) {
+            // the computation was canceled, so do not overwrite the model
+            return;
+        }
+        this._model = model;
     }
     updateIndex(index) {
         if (index === -1) {
@@ -148,13 +133,12 @@
         }
     }
     getCandidateStickyLinesIntersecting(range) {
-        var _a, _b;
-        if (!((_a = this._model) === null || _a === void 0 ? void 0 : _a.element)) {
+        if (!this._model?.element) {
             return [];
         }
         let stickyLineCandidates = [];
         this.getCandidateStickyLinesIntersectingFromStickyModel(range, this._model.element, stickyLineCandidates, 0, -1);
-        const hiddenRanges = (_b = this._editor._getViewModel()) === null || _b === void 0 ? void 0 : _b.getHiddenAreas();
+        const hiddenRanges = this._editor._getViewModel()?.getHiddenAreas();
         if (hiddenRanges) {
             for (const hiddenRange of hiddenRanges) {
                 stickyLineCandidates = stickyLineCandidates.filter(stickyLine => !(stickyLine.startLineNumber >= hiddenRange.startLineNumber && stickyLine.endLineNumber <= hiddenRange.endLineNumber + 1));
@@ -163,6 +147,7 @@
         return stickyLineCandidates;
     }
 };
+StickyLineCandidateProvider.ID = 'store.contrib.stickyScrollController';
 StickyLineCandidateProvider = __decorate([
     __param(1, ILanguageFeaturesService),
     __param(2, ILanguageConfigurationService)
diff -urN -x '*.map' a/vs/editor/contrib/stickyScroll/browser/stickyScrollWidget.js b/vs/editor/contrib/stickyScroll/browser/stickyScrollWidget.js
--- a/vs/editor/contrib/stickyScroll/browser/stickyScrollWidget.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/stickyScroll/browser/stickyScrollWidget.js	2023-12-06 14:23:14.383854791 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import * as dom from '../../../../base/browser/dom.js';
 import { createTrustedTypesPolicy } from '../../../../base/browser/trustedTypes.js';
 import { equals } from '../../../../base/common/arrays.js';
@@ -163,38 +154,36 @@
             foldingIcon.setVisible(allVisible ? true : foldingIcon.isCollapsed);
         }
     }
-    _renderRootNode(previousStickyLines, foldingModel, rebuildFromLine = Infinity) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const layoutInfo = this._editor.getLayoutInfo();
-            for (const [index, line] of this._lineNumbers.entries()) {
-                const previousStickyLine = previousStickyLines[index];
-                const stickyLine = (line >= rebuildFromLine || (previousStickyLine === null || previousStickyLine === void 0 ? void 0 : previousStickyLine.lineNumber) !== line)
-                    ? this._renderChildNode(index, line, foldingModel, layoutInfo)
-                    : this._updateTopAndZIndexOfStickyLine(previousStickyLine);
-                if (!stickyLine) {
-                    continue;
-                }
-                this._linesDomNode.appendChild(stickyLine.lineDomNode);
-                this._lineNumbersDomNode.appendChild(stickyLine.lineNumberDomNode);
-                this._stickyLines.push(stickyLine);
-            }
-            if (foldingModel) {
-                this._setFoldingHoverListeners();
-                this._useFoldingOpacityTransition(!this._isOnGlyphMargin);
-            }
-            const widgetHeight = this._lineNumbers.length * this._lineHeight + this._lastLineRelativePosition;
-            if (widgetHeight === 0) {
-                this._clearStickyWidget();
-                return;
+    async _renderRootNode(previousStickyLines, foldingModel, rebuildFromLine = Infinity) {
+        const layoutInfo = this._editor.getLayoutInfo();
+        for (const [index, line] of this._lineNumbers.entries()) {
+            const previousStickyLine = previousStickyLines[index];
+            const stickyLine = (line >= rebuildFromLine || previousStickyLine?.lineNumber !== line)
+                ? this._renderChildNode(index, line, foldingModel, layoutInfo)
+                : this._updateTopAndZIndexOfStickyLine(previousStickyLine);
+            if (!stickyLine) {
+                continue;
             }
-            this._rootDomNode.style.display = 'block';
-            this._lineNumbersDomNode.style.height = `${widgetHeight}px`;
-            this._linesDomNodeScrollable.style.height = `${widgetHeight}px`;
-            this._rootDomNode.style.height = `${widgetHeight}px`;
-            this._rootDomNode.style.marginLeft = '0px';
-            this._updateMinContentWidth();
-            this._editor.layoutOverlayWidget(this);
-        });
+            this._linesDomNode.appendChild(stickyLine.lineDomNode);
+            this._lineNumbersDomNode.appendChild(stickyLine.lineNumberDomNode);
+            this._stickyLines.push(stickyLine);
+        }
+        if (foldingModel) {
+            this._setFoldingHoverListeners();
+            this._useFoldingOpacityTransition(!this._isOnGlyphMargin);
+        }
+        const widgetHeight = this._lineNumbers.length * this._lineHeight + this._lastLineRelativePosition;
+        if (widgetHeight === 0) {
+            this._clearStickyWidget();
+            return;
+        }
+        this._rootDomNode.style.display = 'block';
+        this._lineNumbersDomNode.style.height = `${widgetHeight}px`;
+        this._linesDomNodeScrollable.style.height = `${widgetHeight}px`;
+        this._rootDomNode.style.height = `${widgetHeight}px`;
+        this._rootDomNode.style.marginLeft = '0px';
+        this._updateMinContentWidth();
+        this._editor.layoutOverlayWidget(this);
     }
     _setFoldingHoverListeners() {
         const showFoldingControls = this._editor.getOption(109 /* EditorOption.showFoldingControls */);
@@ -278,7 +267,6 @@
         return this._updateTopAndZIndexOfStickyLine(renderedLine);
     }
     _updateTopAndZIndexOfStickyLine(stickyLine) {
-        var _a;
         const index = stickyLine.index;
         const lineHTMLNode = stickyLine.lineDomNode;
         const lineNumberHTMLNode = stickyLine.lineNumberDomNode;
@@ -287,7 +275,7 @@
         const intermediateLineZIndex = '1';
         lineHTMLNode.style.zIndex = isLastLine ? lastLineZIndex : intermediateLineZIndex;
         lineNumberHTMLNode.style.zIndex = isLastLine ? lastLineZIndex : intermediateLineZIndex;
-        const lastLineTop = `${index * this._lineHeight + this._lastLineRelativePosition + (((_a = stickyLine.foldingIcon) === null || _a === void 0 ? void 0 : _a.isCollapsed) ? 1 : 0)}px`;
+        const lastLineTop = `${index * this._lineHeight + this._lastLineRelativePosition + (stickyLine.foldingIcon?.isCollapsed ? 1 : 0)}px`;
         const intermediateLineTop = `${index * this._lineHeight}px`;
         lineHTMLNode.style.top = isLastLine ? lastLineTop : intermediateLineTop;
         lineNumberHTMLNode.style.top = isLastLine ? lastLineTop : intermediateLineTop;
@@ -355,8 +343,7 @@
         return new Position(renderedStickyLine.lineNumber, column);
     }
     getLineNumberFromChildDomNode(domNode) {
-        var _a, _b;
-        return (_b = (_a = this._getRenderedStickyLineFromChildDomNode(domNode)) === null || _a === void 0 ? void 0 : _a.lineNumber) !== null && _b !== void 0 ? _b : null;
+        return this._getRenderedStickyLineFromChildDomNode(domNode)?.lineNumber ?? null;
     }
     _getRenderedStickyLineFromChildDomNode(domNode) {
         const index = this.getLineIndexFromChildDomNode(domNode);
diff -urN -x '*.map' a/vs/editor/contrib/suggest/browser/suggest.js b/vs/editor/contrib/suggest/browser/suggest.js
--- a/vs/editor/contrib/suggest/browser/suggest.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/suggest/browser/suggest.js	2023-12-06 14:23:14.383854791 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { CancellationError, isCancellationError, onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { FuzzyScore } from '../../../../base/common/filters.js';
@@ -22,7 +13,7 @@
 import { Range } from '../../../common/core/range.js';
 import { ITextModelService } from '../../../common/services/resolverService.js';
 import { SnippetParser } from '../../snippet/browser/snippetParser.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { MenuId } from '../../../../platform/actions/common/actions.js';
 import { CommandsRegistry } from '../../../../platform/commands/common/commands.js';
 import { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';
@@ -30,19 +21,18 @@
 import { historyNavigationVisible } from '../../../../platform/history/browser/contextScopedHistoryWidget.js';
 export const Context = {
     Visible: historyNavigationVisible,
-    HasFocusedSuggestion: new RawContextKey('suggestWidgetHasFocusedSuggestion', false, localize('suggestWidgetHasSelection', "Whether any suggestion is focused")),
-    DetailsVisible: new RawContextKey('suggestWidgetDetailsVisible', false, localize('suggestWidgetDetailsVisible', "Whether suggestion details are visible")),
-    MultipleSuggestions: new RawContextKey('suggestWidgetMultipleSuggestions', false, localize('suggestWidgetMultipleSuggestions', "Whether there are multiple suggestions to pick from")),
-    MakesTextEdit: new RawContextKey('suggestionMakesTextEdit', true, localize('suggestionMakesTextEdit', "Whether inserting the current suggestion yields in a change or has everything already been typed")),
-    AcceptSuggestionsOnEnter: new RawContextKey('acceptSuggestionOnEnter', true, localize('acceptSuggestionOnEnter', "Whether suggestions are inserted when pressing Enter")),
-    HasInsertAndReplaceRange: new RawContextKey('suggestionHasInsertAndReplaceRange', false, localize('suggestionHasInsertAndReplaceRange', "Whether the current suggestion has insert and replace behaviour")),
-    InsertMode: new RawContextKey('suggestionInsertMode', undefined, { type: 'string', description: localize('suggestionInsertMode', "Whether the default behaviour is to insert or replace") }),
-    CanResolve: new RawContextKey('suggestionCanResolve', false, localize('suggestionCanResolve', "Whether the current suggestion supports to resolve further details")),
+    HasFocusedSuggestion: new RawContextKey('suggestWidgetHasFocusedSuggestion', false, localizeWithPath('vs/editor/contrib/suggest/browser/suggest', 'suggestWidgetHasSelection', "Whether any suggestion is focused")),
+    DetailsVisible: new RawContextKey('suggestWidgetDetailsVisible', false, localizeWithPath('vs/editor/contrib/suggest/browser/suggest', 'suggestWidgetDetailsVisible', "Whether suggestion details are visible")),
+    MultipleSuggestions: new RawContextKey('suggestWidgetMultipleSuggestions', false, localizeWithPath('vs/editor/contrib/suggest/browser/suggest', 'suggestWidgetMultipleSuggestions', "Whether there are multiple suggestions to pick from")),
+    MakesTextEdit: new RawContextKey('suggestionMakesTextEdit', true, localizeWithPath('vs/editor/contrib/suggest/browser/suggest', 'suggestionMakesTextEdit', "Whether inserting the current suggestion yields in a change or has everything already been typed")),
+    AcceptSuggestionsOnEnter: new RawContextKey('acceptSuggestionOnEnter', true, localizeWithPath('vs/editor/contrib/suggest/browser/suggest', 'acceptSuggestionOnEnter', "Whether suggestions are inserted when pressing Enter")),
+    HasInsertAndReplaceRange: new RawContextKey('suggestionHasInsertAndReplaceRange', false, localizeWithPath('vs/editor/contrib/suggest/browser/suggest', 'suggestionHasInsertAndReplaceRange', "Whether the current suggestion has insert and replace behaviour")),
+    InsertMode: new RawContextKey('suggestionInsertMode', undefined, { type: 'string', description: localizeWithPath('vs/editor/contrib/suggest/browser/suggest', 'suggestionInsertMode', "Whether the default behaviour is to insert or replace") }),
+    CanResolve: new RawContextKey('suggestionCanResolve', false, localizeWithPath('vs/editor/contrib/suggest/browser/suggest', 'suggestionCanResolve', "Whether the current suggestion supports to resolve further details")),
 };
 export const suggestWidgetStatusbarMenu = new MenuId('suggestWidgetStatusBar');
 export class CompletionItem {
     constructor(position, completion, container, provider) {
-        var _a;
         this.position = position;
         this.completion = completion;
         this.container = container;
@@ -54,7 +44,7 @@
         this.distance = 0;
         this.textLabel = typeof completion.label === 'string'
             ? completion.label
-            : (_a = completion.label) === null || _a === void 0 ? void 0 : _a.label;
+            : completion.label?.label;
         // ensure lower-variants (perf)
         this.labelLow = this.textLabel.toLowerCase();
         // validate label
@@ -94,30 +84,28 @@
     get resolveDuration() {
         return this._resolveDuration !== undefined ? this._resolveDuration : -1;
     }
-    resolve(token) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!this._resolveCache) {
-                const sub = token.onCancellationRequested(() => {
+    async resolve(token) {
+        if (!this._resolveCache) {
+            const sub = token.onCancellationRequested(() => {
+                this._resolveCache = undefined;
+                this._resolveDuration = undefined;
+            });
+            const sw = new StopWatch(true);
+            this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, token)).then(value => {
+                Object.assign(this.completion, value);
+                this._resolveDuration = sw.elapsed();
+            }, err => {
+                if (isCancellationError(err)) {
+                    // the IPC queue will reject the request with the
+                    // cancellation error -> reset cached
                     this._resolveCache = undefined;
                     this._resolveDuration = undefined;
-                });
-                const sw = new StopWatch(true);
-                this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, token)).then(value => {
-                    Object.assign(this.completion, value);
-                    this._resolveDuration = sw.elapsed();
-                }, err => {
-                    if (isCancellationError(err)) {
-                        // the IPC queue will reject the request with the
-                        // cancellation error -> reset cached
-                        this._resolveCache = undefined;
-                        this._resolveDuration = undefined;
-                    }
-                }).finally(() => {
-                    sub.dispose();
-                });
-            }
-            return this._resolveCache;
-        });
+                }
+            }).finally(() => {
+                sub.dispose();
+            });
+        }
+        return this._resolveCache;
     }
 }
 export class CompletionOptions {
@@ -134,6 +122,11 @@
 export function getSnippetSuggestSupport() {
     return _snippetSuggestSupport;
 }
+export function setSnippetSuggestSupport(support) {
+    const old = _snippetSuggestSupport;
+    _snippetSuggestSupport = support;
+    return old;
+}
 export class CompletionItemModel {
     constructor(items, needsClipboard, durations, disposable) {
         this.items = items;
@@ -142,109 +135,106 @@
         this.disposable = disposable;
     }
 }
-export function provideSuggestionItems(registry, model, position, options = CompletionOptions.default, context = { triggerKind: 0 /* languages.CompletionTriggerKind.Invoke */ }, token = CancellationToken.None) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const sw = new StopWatch();
-        position = position.clone();
-        const word = model.getWordAtPosition(position);
-        const defaultReplaceRange = word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn) : Range.fromPositions(position);
-        const defaultRange = { replace: defaultReplaceRange, insert: defaultReplaceRange.setEndPosition(position.lineNumber, position.column) };
-        const result = [];
-        const disposables = new DisposableStore();
-        const durations = [];
-        let needsClipboard = false;
-        const onCompletionList = (provider, container, sw) => {
-            var _a, _b, _c;
-            let didAddResult = false;
-            if (!container) {
-                return didAddResult;
-            }
-            for (const suggestion of container.suggestions) {
-                if (!options.kindFilter.has(suggestion.kind)) {
-                    // skip if not showing deprecated suggestions
-                    if (!options.showDeprecated && ((_a = suggestion === null || suggestion === void 0 ? void 0 : suggestion.tags) === null || _a === void 0 ? void 0 : _a.includes(1 /* languages.CompletionItemTag.Deprecated */))) {
-                        continue;
-                    }
-                    // fill in default range when missing
-                    if (!suggestion.range) {
-                        suggestion.range = defaultRange;
-                    }
-                    // fill in default sortText when missing
-                    if (!suggestion.sortText) {
-                        suggestion.sortText = typeof suggestion.label === 'string' ? suggestion.label : suggestion.label.label;
-                    }
-                    if (!needsClipboard && suggestion.insertTextRules && suggestion.insertTextRules & 4 /* languages.CompletionItemInsertTextRule.InsertAsSnippet */) {
-                        needsClipboard = SnippetParser.guessNeedsClipboard(suggestion.insertText);
-                    }
-                    result.push(new CompletionItem(position, suggestion, container, provider));
-                    didAddResult = true;
-                }
-            }
-            if (isDisposable(container)) {
-                disposables.add(container);
-            }
-            durations.push({
-                providerName: (_b = provider._debugDisplayName) !== null && _b !== void 0 ? _b : 'unknown_provider', elapsedProvider: (_c = container.duration) !== null && _c !== void 0 ? _c : -1, elapsedOverall: sw.elapsed()
-            });
+export async function provideSuggestionItems(registry, model, position, options = CompletionOptions.default, context = { triggerKind: 0 /* languages.CompletionTriggerKind.Invoke */ }, token = CancellationToken.None) {
+    const sw = new StopWatch();
+    position = position.clone();
+    const word = model.getWordAtPosition(position);
+    const defaultReplaceRange = word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn) : Range.fromPositions(position);
+    const defaultRange = { replace: defaultReplaceRange, insert: defaultReplaceRange.setEndPosition(position.lineNumber, position.column) };
+    const result = [];
+    const disposables = new DisposableStore();
+    const durations = [];
+    let needsClipboard = false;
+    const onCompletionList = (provider, container, sw) => {
+        let didAddResult = false;
+        if (!container) {
             return didAddResult;
-        };
-        // ask for snippets in parallel to asking "real" providers. Only do something if configured to
-        // do so - no snippet filter, no special-providers-only request
-        const snippetCompletions = (() => __awaiter(this, void 0, void 0, function* () {
-            if (!_snippetSuggestSupport || options.kindFilter.has(27 /* languages.CompletionItemKind.Snippet */)) {
-                return;
+        }
+        for (const suggestion of container.suggestions) {
+            if (!options.kindFilter.has(suggestion.kind)) {
+                // skip if not showing deprecated suggestions
+                if (!options.showDeprecated && suggestion?.tags?.includes(1 /* languages.CompletionItemTag.Deprecated */)) {
+                    continue;
+                }
+                // fill in default range when missing
+                if (!suggestion.range) {
+                    suggestion.range = defaultRange;
+                }
+                // fill in default sortText when missing
+                if (!suggestion.sortText) {
+                    suggestion.sortText = typeof suggestion.label === 'string' ? suggestion.label : suggestion.label.label;
+                }
+                if (!needsClipboard && suggestion.insertTextRules && suggestion.insertTextRules & 4 /* languages.CompletionItemInsertTextRule.InsertAsSnippet */) {
+                    needsClipboard = SnippetParser.guessNeedsClipboard(suggestion.insertText);
+                }
+                result.push(new CompletionItem(position, suggestion, container, provider));
+                didAddResult = true;
             }
+        }
+        if (isDisposable(container)) {
+            disposables.add(container);
+        }
+        durations.push({
+            providerName: provider._debugDisplayName ?? 'unknown_provider', elapsedProvider: container.duration ?? -1, elapsedOverall: sw.elapsed()
+        });
+        return didAddResult;
+    };
+    // ask for snippets in parallel to asking "real" providers. Only do something if configured to
+    // do so - no snippet filter, no special-providers-only request
+    const snippetCompletions = (async () => {
+        if (!_snippetSuggestSupport || options.kindFilter.has(27 /* languages.CompletionItemKind.Snippet */)) {
+            return;
+        }
+        // we have items from a previous session that we can reuse
+        const reuseItems = options.providerItemsToReuse.get(_snippetSuggestSupport);
+        if (reuseItems) {
+            reuseItems.forEach(item => result.push(item));
+            return;
+        }
+        if (options.providerFilter.size > 0 && !options.providerFilter.has(_snippetSuggestSupport)) {
+            return;
+        }
+        const sw = new StopWatch();
+        const list = await _snippetSuggestSupport.provideCompletionItems(model, position, context, token);
+        onCompletionList(_snippetSuggestSupport, list, sw);
+    })();
+    // add suggestions from contributed providers - providers are ordered in groups of
+    // equal score and once a group produces a result the process stops
+    // get provider groups, always add snippet suggestion provider
+    for (const providerGroup of registry.orderedGroups(model)) {
+        // for each support in the group ask for suggestions
+        let didAddResult = false;
+        await Promise.all(providerGroup.map(async (provider) => {
             // we have items from a previous session that we can reuse
-            const reuseItems = options.providerItemsToReuse.get(_snippetSuggestSupport);
-            if (reuseItems) {
-                reuseItems.forEach(item => result.push(item));
+            if (options.providerItemsToReuse.has(provider)) {
+                const items = options.providerItemsToReuse.get(provider);
+                items.forEach(item => result.push(item));
+                didAddResult = didAddResult || items.length > 0;
                 return;
             }
-            if (options.providerFilter.size > 0 && !options.providerFilter.has(_snippetSuggestSupport)) {
+            // check if this provider is filtered out
+            if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) {
                 return;
             }
-            const sw = new StopWatch();
-            const list = yield _snippetSuggestSupport.provideCompletionItems(model, position, context, token);
-            onCompletionList(_snippetSuggestSupport, list, sw);
-        }))();
-        // add suggestions from contributed providers - providers are ordered in groups of
-        // equal score and once a group produces a result the process stops
-        // get provider groups, always add snippet suggestion provider
-        for (const providerGroup of registry.orderedGroups(model)) {
-            // for each support in the group ask for suggestions
-            let didAddResult = false;
-            yield Promise.all(providerGroup.map((provider) => __awaiter(this, void 0, void 0, function* () {
-                // we have items from a previous session that we can reuse
-                if (options.providerItemsToReuse.has(provider)) {
-                    const items = options.providerItemsToReuse.get(provider);
-                    items.forEach(item => result.push(item));
-                    didAddResult = didAddResult || items.length > 0;
-                    return;
-                }
-                // check if this provider is filtered out
-                if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) {
-                    return;
-                }
-                try {
-                    const sw = new StopWatch();
-                    const list = yield provider.provideCompletionItems(model, position, context, token);
-                    didAddResult = onCompletionList(provider, list, sw) || didAddResult;
-                }
-                catch (err) {
-                    onUnexpectedExternalError(err);
-                }
-            })));
-            if (didAddResult || token.isCancellationRequested) {
-                break;
+            try {
+                const sw = new StopWatch();
+                const list = await provider.provideCompletionItems(model, position, context, token);
+                didAddResult = onCompletionList(provider, list, sw) || didAddResult;
             }
+            catch (err) {
+                onUnexpectedExternalError(err);
+            }
+        }));
+        if (didAddResult || token.isCancellationRequested) {
+            break;
         }
-        yield snippetCompletions;
-        if (token.isCancellationRequested) {
-            disposables.dispose();
-            return Promise.reject(new CancellationError());
-        }
-        return new CompletionItemModel(result.sort(getSuggestionComparator(options.snippetSortOrder)), needsClipboard, { entries: durations, elapsed: sw.elapsed() }, disposables);
-    });
+    }
+    await snippetCompletions;
+    if (token.isCancellationRequested) {
+        disposables.dispose();
+        return Promise.reject(new CancellationError());
+    }
+    return new CompletionItemModel(result.sort(getSuggestionComparator(options.snippetSortOrder)), needsClipboard, { entries: durations, elapsed: sw.elapsed() }, disposables);
 }
 function defaultComparator(a, b) {
     // check with 'sortText'
@@ -295,14 +285,14 @@
 export function getSuggestionComparator(snippetConfig) {
     return _snippetComparators.get(snippetConfig);
 }
-CommandsRegistry.registerCommand('_executeCompletionItemProvider', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {
+CommandsRegistry.registerCommand('_executeCompletionItemProvider', async (accessor, ...args) => {
     const [uri, position, triggerCharacter, maxItemsToResolve] = args;
     assertType(URI.isUri(uri));
     assertType(Position.isIPosition(position));
     assertType(typeof triggerCharacter === 'string' || !triggerCharacter);
     assertType(typeof maxItemsToResolve === 'number' || !maxItemsToResolve);
     const { completionProvider } = accessor.get(ILanguageFeaturesService);
-    const ref = yield accessor.get(ITextModelService).createModelReference(uri);
+    const ref = await accessor.get(ITextModelService).createModelReference(uri);
     try {
         const result = {
             incomplete: false,
@@ -310,16 +300,16 @@
         };
         const resolving = [];
         const actualPosition = ref.object.textEditorModel.validatePosition(position);
-        const completions = yield provideSuggestionItems(completionProvider, ref.object.textEditorModel, actualPosition, undefined, { triggerCharacter: triggerCharacter !== null && triggerCharacter !== void 0 ? triggerCharacter : undefined, triggerKind: triggerCharacter ? 1 /* languages.CompletionTriggerKind.TriggerCharacter */ : 0 /* languages.CompletionTriggerKind.Invoke */ });
+        const completions = await provideSuggestionItems(completionProvider, ref.object.textEditorModel, actualPosition, undefined, { triggerCharacter: triggerCharacter ?? undefined, triggerKind: triggerCharacter ? 1 /* languages.CompletionTriggerKind.TriggerCharacter */ : 0 /* languages.CompletionTriggerKind.Invoke */ });
         for (const item of completions.items) {
-            if (resolving.length < (maxItemsToResolve !== null && maxItemsToResolve !== void 0 ? maxItemsToResolve : 0)) {
+            if (resolving.length < (maxItemsToResolve ?? 0)) {
                 resolving.push(item.resolve(CancellationToken.None));
             }
             result.incomplete = result.incomplete || item.container.incomplete;
             result.suggestions.push(item.completion);
         }
         try {
-            yield Promise.all(resolving);
+            await Promise.all(resolving);
             return result;
         }
         finally {
@@ -329,10 +319,9 @@
     finally {
         ref.dispose();
     }
-}));
+});
 export function showSimpleSuggestions(editor, provider) {
-    var _a;
-    (_a = editor.getContribution('editor.contrib.suggestController')) === null || _a === void 0 ? void 0 : _a.triggerSuggest(new Set().add(provider), undefined, true);
+    editor.getContribution('editor.contrib.suggestController')?.triggerSuggest(new Set().add(provider), undefined, true);
 }
 export class QuickSuggestionsOptions {
     static isAllOff(config) {
diff -urN -x '*.map' a/vs/editor/contrib/suggest/browser/suggestAlternatives.js b/vs/editor/contrib/suggest/browser/suggestAlternatives.js
--- a/vs/editor/contrib/suggest/browser/suggestAlternatives.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/suggest/browser/suggestAlternatives.js	2023-12-06 14:23:14.383854791 +0000
@@ -23,9 +23,8 @@
         this.reset();
     }
     reset() {
-        var _a;
         this._ckOtherSuggestions.reset();
-        (_a = this._listener) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._listener?.dispose();
         this._model = undefined;
         this._acceptNext = undefined;
         this._ignore = false;
diff -urN -x '*.map' a/vs/editor/contrib/suggest/browser/suggestController.js b/vs/editor/contrib/suggest/browser/suggestController.js
--- a/vs/editor/contrib/suggest/browser/suggestController.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/suggest/browser/suggestController.js	2023-12-06 14:23:14.383854791 +0000
@@ -399,14 +399,13 @@
         });
     }
     _reportSuggestionAcceptedTelemetry(item, model, itemResolved, commandExectionDuration, additionalEditsAppliedAsync) {
-        var _a, _b, _c;
         if (Math.floor(Math.random() * 100) === 0) {
             // throttle telemetry event because accepting completions happens a lot
             return;
         }
         this._telemetryService.publicLog2('suggest.acceptedSuggestion', {
-            extensionId: (_b = (_a = item.extensionId) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 'unknown',
-            providerId: (_c = item.provider._debugDisplayName) !== null && _c !== void 0 ? _c : 'unknown',
+            extensionId: item.extensionId?.value ?? 'unknown',
+            providerId: item.provider._debugDisplayName ?? 'unknown',
             kind: item.completion.kind,
             basenameHash: hash(basename(model.uri)).toString(16),
             languageId: model.getLanguageId(),
@@ -434,14 +433,14 @@
     }
     _alertCompletionItem(item) {
         if (isNonEmptyArray(item.completion.additionalTextEdits)) {
-            const msg = nls.localize('aria.alert.snippet', "Accepting '{0}' made {1} additional edits", item.textLabel, item.completion.additionalTextEdits.length);
+            const msg = nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestController', 'aria.alert.snippet', "Accepting '{0}' made {1} additional edits", item.textLabel, item.completion.additionalTextEdits.length);
             alert(msg);
         }
     }
     triggerSuggest(onlyFrom, auto, noFilter) {
         if (this.editor.hasModel()) {
             this.model.trigger({
-                auto: auto !== null && auto !== void 0 ? auto : false,
+                auto: auto ?? false,
                 completionOptions: { providerFilter: onlyFrom, kindFilter: noFilter ? new Set() : undefined }
             });
             this.editor.revealPosition(this.editor.getPosition(), 0 /* ScrollType.Smooth */);
@@ -614,7 +613,7 @@
     constructor() {
         super({
             id: TriggerSuggestAction.id,
-            label: nls.localize('suggest.trigger.label', "Trigger Suggest"),
+            label: nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestController', 'suggest.trigger.label', "Trigger Suggest"),
             alias: 'Trigger Suggest',
             precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCompletionItemProvider, SuggestContext.Visible.toNegated()),
             kbOpts: {
@@ -664,19 +663,19 @@
         }],
     menuOpts: [{
             menuId: suggestWidgetStatusbarMenu,
-            title: nls.localize('accept.insert', "Insert"),
+            title: nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestController', 'accept.insert', "Insert"),
             group: 'left',
             order: 1,
             when: SuggestContext.HasInsertAndReplaceRange.toNegated()
         }, {
             menuId: suggestWidgetStatusbarMenu,
-            title: nls.localize('accept.insert', "Insert"),
+            title: nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestController', 'accept.insert', "Insert"),
             group: 'left',
             order: 1,
             when: ContextKeyExpr.and(SuggestContext.HasInsertAndReplaceRange, SuggestContext.InsertMode.isEqualTo('insert'))
         }, {
             menuId: suggestWidgetStatusbarMenu,
-            title: nls.localize('accept.replace', "Replace"),
+            title: nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestController', 'accept.replace', "Replace"),
             group: 'left',
             order: 1,
             when: ContextKeyExpr.and(SuggestContext.HasInsertAndReplaceRange, SuggestContext.InsertMode.isEqualTo('replace'))
@@ -699,13 +698,13 @@
             group: 'left',
             order: 2,
             when: ContextKeyExpr.and(SuggestContext.HasInsertAndReplaceRange, SuggestContext.InsertMode.isEqualTo('insert')),
-            title: nls.localize('accept.replace', "Replace")
+            title: nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestController', 'accept.replace', "Replace")
         }, {
             menuId: suggestWidgetStatusbarMenu,
             group: 'left',
             order: 2,
             when: ContextKeyExpr.and(SuggestContext.HasInsertAndReplaceRange, SuggestContext.InsertMode.isEqualTo('replace')),
-            title: nls.localize('accept.insert', "Insert")
+            title: nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestController', 'accept.insert', "Insert")
         }]
 }));
 // continue to support the old command
@@ -813,13 +812,13 @@
             group: 'right',
             order: 1,
             when: ContextKeyExpr.and(SuggestContext.DetailsVisible, SuggestContext.CanResolve),
-            title: nls.localize('detail.more', "show less")
+            title: nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestController', 'detail.more', "show less")
         }, {
             menuId: suggestWidgetStatusbarMenu,
             group: 'right',
             order: 1,
             when: ContextKeyExpr.and(SuggestContext.DetailsVisible.toNegated(), SuggestContext.CanResolve),
-            title: nls.localize('detail.less', "show more")
+            title: nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestController', 'detail.less', "show more")
         }]
 }));
 registerEditorCommand(new SuggestCommand({
@@ -847,7 +846,7 @@
     id: 'insertBestCompletion',
     precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals('config.editor.tabCompletion', 'on'), WordContextKey.AtEnd, SuggestContext.Visible.toNegated(), SuggestAlternatives.OtherSuggestions.toNegated(), SnippetController2.InSnippetMode.toNegated()),
     handler: (x, arg) => {
-        x.triggerSuggestAndAcceptBest(isObject(arg) ? Object.assign({ fallback: 'tab' }, arg) : { fallback: 'tab' });
+        x.triggerSuggestAndAcceptBest(isObject(arg) ? { fallback: 'tab', ...arg } : { fallback: 'tab' });
     },
     kbOpts: {
         weight,
@@ -878,13 +877,12 @@
     constructor() {
         super({
             id: 'editor.action.resetSuggestSize',
-            label: nls.localize('suggest.reset.label', "Reset Suggest Widget Size"),
+            label: nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestController', 'suggest.reset.label', "Reset Suggest Widget Size"),
             alias: 'Reset Suggest Widget Size',
             precondition: undefined
         });
     }
     run(_accessor, editor) {
-        var _a;
-        (_a = SuggestController.get(editor)) === null || _a === void 0 ? void 0 : _a.resetWidgetSize();
+        SuggestController.get(editor)?.resetWidgetSize();
     }
 });
diff -urN -x '*.map' a/vs/editor/contrib/suggest/browser/suggestInlineCompletions.js b/vs/editor/contrib/suggest/browser/suggestInlineCompletions.js
--- a/vs/editor/contrib/suggest/browser/suggestInlineCompletions.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/suggest/browser/suggestInlineCompletions.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var EditorContribution_1;
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { FuzzyScore } from '../../../../base/common/filters.js';
@@ -62,7 +53,6 @@
             && this.completionModel.getIncompleteProvider().size === 0; // no incomplete results
     }
     get items() {
-        var _a;
         const result = [];
         // Split items by preselected index. This ensures the memory-selected item shows first and that better/worst
         // ranked items are before/after
@@ -81,7 +71,7 @@
             const insertText = item.completion.insertTextRules && (item.completion.insertTextRules & 4 /* CompletionItemInsertTextRule.InsertAsSnippet */)
                 ? { snippet: item.completion.insertText }
                 : item.completion.insertText;
-            result.push(new SuggestInlineCompletion(range, insertText, (_a = item.filterTextLow) !== null && _a !== void 0 ? _a : item.labelLow, item.completion.additionalTextEdits, item.completion.command, item));
+            result.push(new SuggestInlineCompletion(range, insertText, item.filterTextLow ?? item.labelLow, item.completion.additionalTextEdits, item.completion.command, item));
             // resolve the first N suggestions eagerly
             if (resolveCount-- >= 0) {
                 item.resolve(CancellationToken.None);
@@ -100,67 +90,64 @@
         this._clipboardService = _clipboardService;
         this._suggestMemoryService = _suggestMemoryService;
     }
-    provideInlineCompletions(model, position, context, token) {
-        var _a;
-        return __awaiter(this, void 0, void 0, function* () {
-            if (context.selectedSuggestionInfo) {
-                return;
-            }
-            const config = this._getEditorOption(88 /* EditorOption.quickSuggestions */, model);
-            if (QuickSuggestionsOptions.isAllOff(config)) {
-                // quick suggest is off (for this model/language)
-                return;
-            }
-            model.tokenization.tokenizeIfCheap(position.lineNumber);
-            const lineTokens = model.tokenization.getLineTokens(position.lineNumber);
-            const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(position.column - 1 - 1, 0)));
-            if (QuickSuggestionsOptions.valueFor(config, tokenType) !== 'inline') {
-                // quick suggest is off (for this token)
-                return undefined;
-            }
-            // We consider non-empty leading words and trigger characters. The latter only
-            // when no word is being typed (word characters superseed trigger characters)
-            let wordInfo = model.getWordAtPosition(position);
-            let triggerCharacterInfo;
-            if (!(wordInfo === null || wordInfo === void 0 ? void 0 : wordInfo.word)) {
-                triggerCharacterInfo = this._getTriggerCharacterInfo(model, position);
-            }
-            if (!(wordInfo === null || wordInfo === void 0 ? void 0 : wordInfo.word) && !triggerCharacterInfo) {
-                // not at word, not a trigger character
-                return;
-            }
-            // ensure that we have word information and that we are at the end of a word
-            // otherwise we stop because we don't want to do quick suggestions inside words
-            if (!wordInfo) {
-                wordInfo = model.getWordUntilPosition(position);
-            }
-            if (wordInfo.endColumn !== position.column) {
-                return;
-            }
-            let result;
-            const leadingLineContents = model.getValueInRange(new Range(position.lineNumber, 1, position.lineNumber, position.column));
-            if (!triggerCharacterInfo && ((_a = this._lastResult) === null || _a === void 0 ? void 0 : _a.canBeReused(model, position.lineNumber, wordInfo))) {
-                // reuse a previous result iff possible, only a refilter is needed
-                // TODO@jrieken this can be improved further and only incomplete results can be updated
-                // console.log(`REUSE with ${wordInfo.word}`);
-                const newLineContext = new LineContext(leadingLineContents, position.column - this._lastResult.word.endColumn);
-                this._lastResult.completionModel.lineContext = newLineContext;
-                this._lastResult.acquire();
-                result = this._lastResult;
-            }
-            else {
-                // refesh model is required
-                const completions = yield provideSuggestionItems(this._languageFeatureService.completionProvider, model, position, new CompletionOptions(undefined, undefined, triggerCharacterInfo === null || triggerCharacterInfo === void 0 ? void 0 : triggerCharacterInfo.providers), triggerCharacterInfo && { triggerKind: 1 /* CompletionTriggerKind.TriggerCharacter */, triggerCharacter: triggerCharacterInfo.ch }, token);
-                let clipboardText;
-                if (completions.needsClipboard) {
-                    clipboardText = yield this._clipboardService.readText();
-                }
-                const completionModel = new CompletionModel(completions.items, position.column, new LineContext(leadingLineContents, 0), WordDistance.None, this._getEditorOption(117 /* EditorOption.suggest */, model), this._getEditorOption(111 /* EditorOption.snippetSuggestions */, model), { boostFullMatch: false, firstMatchCanBeWeak: false }, clipboardText);
-                result = new InlineCompletionResults(model, position.lineNumber, wordInfo, completionModel, completions, this._suggestMemoryService);
+    async provideInlineCompletions(model, position, context, token) {
+        if (context.selectedSuggestionInfo) {
+            return;
+        }
+        const config = this._getEditorOption(88 /* EditorOption.quickSuggestions */, model);
+        if (QuickSuggestionsOptions.isAllOff(config)) {
+            // quick suggest is off (for this model/language)
+            return;
+        }
+        model.tokenization.tokenizeIfCheap(position.lineNumber);
+        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);
+        const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(position.column - 1 - 1, 0)));
+        if (QuickSuggestionsOptions.valueFor(config, tokenType) !== 'inline') {
+            // quick suggest is off (for this token)
+            return undefined;
+        }
+        // We consider non-empty leading words and trigger characters. The latter only
+        // when no word is being typed (word characters superseed trigger characters)
+        let wordInfo = model.getWordAtPosition(position);
+        let triggerCharacterInfo;
+        if (!wordInfo?.word) {
+            triggerCharacterInfo = this._getTriggerCharacterInfo(model, position);
+        }
+        if (!wordInfo?.word && !triggerCharacterInfo) {
+            // not at word, not a trigger character
+            return;
+        }
+        // ensure that we have word information and that we are at the end of a word
+        // otherwise we stop because we don't want to do quick suggestions inside words
+        if (!wordInfo) {
+            wordInfo = model.getWordUntilPosition(position);
+        }
+        if (wordInfo.endColumn !== position.column) {
+            return;
+        }
+        let result;
+        const leadingLineContents = model.getValueInRange(new Range(position.lineNumber, 1, position.lineNumber, position.column));
+        if (!triggerCharacterInfo && this._lastResult?.canBeReused(model, position.lineNumber, wordInfo)) {
+            // reuse a previous result iff possible, only a refilter is needed
+            // TODO@jrieken this can be improved further and only incomplete results can be updated
+            // console.log(`REUSE with ${wordInfo.word}`);
+            const newLineContext = new LineContext(leadingLineContents, position.column - this._lastResult.word.endColumn);
+            this._lastResult.completionModel.lineContext = newLineContext;
+            this._lastResult.acquire();
+            result = this._lastResult;
+        }
+        else {
+            // refesh model is required
+            const completions = await provideSuggestionItems(this._languageFeatureService.completionProvider, model, position, new CompletionOptions(undefined, undefined, triggerCharacterInfo?.providers), triggerCharacterInfo && { triggerKind: 1 /* CompletionTriggerKind.TriggerCharacter */, triggerCharacter: triggerCharacterInfo.ch }, token);
+            let clipboardText;
+            if (completions.needsClipboard) {
+                clipboardText = await this._clipboardService.readText();
             }
-            this._lastResult = result;
-            return result;
-        });
+            const completionModel = new CompletionModel(completions.items, position.column, new LineContext(leadingLineContents, 0), WordDistance.None, this._getEditorOption(117 /* EditorOption.suggest */, model), this._getEditorOption(111 /* EditorOption.snippetSuggestions */, model), { boostFullMatch: false, firstMatchCanBeWeak: false }, clipboardText);
+            result = new InlineCompletionResults(model, position.lineNumber, wordInfo, completionModel, completions, this._suggestMemoryService);
+        }
+        this._lastResult = result;
+        return result;
     }
     handleItemDidShow(_completions, item) {
         item.completion.resolve(CancellationToken.None);
@@ -169,11 +156,10 @@
         result.release();
     }
     _getTriggerCharacterInfo(model, position) {
-        var _a;
         const ch = model.getValueInRange(Range.fromPositions({ lineNumber: position.lineNumber, column: position.column - 1 }, position));
         const providers = new Set();
         for (const provider of this._languageFeatureService.completionProvider.all(model)) {
-            if ((_a = provider.triggerCharacters) === null || _a === void 0 ? void 0 : _a.includes(ch)) {
+            if (provider.triggerCharacters?.includes(ch)) {
                 providers.add(provider);
             }
         }
@@ -194,18 +180,16 @@
         // HACK - way to contribute something only once
         if (++EditorContribution_1._counter === 1) {
             const provider = instaService.createInstance(SuggestInlineCompletions, (id, model) => {
-                var _a;
                 // HACK - reuse the editor options world outside from a "normal" contribution
-                const editor = (_a = editorService.listCodeEditors().find(editor => editor.getModel() === model)) !== null && _a !== void 0 ? _a : _editor;
+                const editor = editorService.listCodeEditors().find(editor => editor.getModel() === model) ?? _editor;
                 return editor.getOption(id);
             });
             EditorContribution_1._disposable = languageFeatureService.inlineCompletionsProvider.register('*', provider);
         }
     }
     dispose() {
-        var _a;
         if (--EditorContribution_1._counter === 0) {
-            (_a = EditorContribution_1._disposable) === null || _a === void 0 ? void 0 : _a.dispose();
+            EditorContribution_1._disposable?.dispose();
             EditorContribution_1._disposable = undefined;
         }
     }
diff -urN -x '*.map' a/vs/editor/contrib/suggest/browser/suggestMemory.js b/vs/editor/contrib/suggest/browser/suggestMemory.js
--- a/vs/editor/contrib/suggest/browser/suggestMemory.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/suggest/browser/suggestMemory.js	2023-12-06 14:23:14.383854791 +0000
@@ -205,12 +205,11 @@
         return this._withStrategy(model, pos).select(model, pos, items);
     }
     _withStrategy(model, pos) {
-        var _a;
         const mode = this._configService.getValue('editor.suggestSelection', {
             overrideIdentifier: model.getLanguageIdAtPosition(pos.lineNumber, pos.column),
             resource: model.uri
         });
-        if (((_a = this._strategy) === null || _a === void 0 ? void 0 : _a.name) !== mode) {
+        if (this._strategy?.name !== mode) {
             this._saveState();
             const ctor = SuggestMemoryService_1._strategyCtors.get(mode) || NoMemory;
             this._strategy = new ctor();
diff -urN -x '*.map' a/vs/editor/contrib/suggest/browser/suggestModel.js b/vs/editor/contrib/suggest/browser/suggestModel.js
--- a/vs/editor/contrib/suggest/browser/suggestModel.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/suggest/browser/suggestModel.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var SuggestModel_1;
 import { TimeoutTimer } from '../../../../base/common/async.js';
 import { CancellationTokenSource } from '../../../../base/common/cancellation.js';
@@ -185,7 +176,6 @@
             }
         }
         const checkTriggerCharacter = (text) => {
-            var _a;
             if (!canShowSuggestOnTriggerCharacters(this._editor, this._contextKeyService, this._configurationService)) {
                 return;
             }
@@ -225,7 +215,7 @@
                     triggerKind: 1 /* CompletionTriggerKind.TriggerCharacter */,
                     triggerCharacter: lastChar,
                     retrigger: Boolean(this._completionModel),
-                    clipboardText: (_a = this._completionModel) === null || _a === void 0 ? void 0 : _a.clipboardText,
+                    clipboardText: this._completionModel?.clipboardText,
                     completionOptions: { providerFilter: supports, providerItemsToReuse }
                 });
             }
@@ -246,10 +236,9 @@
         }
     }
     cancel(retrigger = false) {
-        var _a;
         if (this._triggerState !== undefined) {
             this._triggerQuickSuggest.cancel();
-            (_a = this._requestToken) === null || _a === void 0 ? void 0 : _a.cancel();
+            this._requestToken?.cancel();
             this._requestToken = undefined;
             this._triggerState = undefined;
             this._completionModel = undefined;
@@ -306,12 +295,11 @@
         }
     }
     _doTriggerQuickSuggest() {
-        var _a;
         if (QuickSuggestionsOptions.isAllOff(this._editor.getOption(88 /* EditorOption.quickSuggestions */))) {
             // not enabled
             return;
         }
-        if (this._editor.getOption(117 /* EditorOption.suggest */).snippetsPreventQuickSuggestions && ((_a = SnippetController2.get(this._editor)) === null || _a === void 0 ? void 0 : _a.isInSnippet())) {
+        if (this._editor.getOption(117 /* EditorOption.suggest */).snippetsPreventQuickSuggestions && SnippetController2.get(this._editor)?.isInSnippet()) {
             // no quick suggestion when in snippet mode
             return;
         }
@@ -358,11 +346,10 @@
         assertType(this._triggerState !== undefined);
         const model = this._editor.getModel();
         const position = this._editor.getPosition();
-        const ctx = new LineContext(model, position, Object.assign(Object.assign({}, this._triggerState), { refilter: true }));
+        const ctx = new LineContext(model, position, { ...this._triggerState, refilter: true });
         this._onNewContext(ctx);
     }
     trigger(options) {
-        var _a, _b, _c, _d, _e, _f;
         if (!this._editor.hasModel()) {
             return;
         }
@@ -371,11 +358,11 @@
         // Cancel previous requests, change state & update UI
         this.cancel(options.retrigger);
         this._triggerState = options;
-        this._onDidTrigger.fire({ auto: options.auto, shy: (_a = options.shy) !== null && _a !== void 0 ? _a : false, position: this._editor.getPosition() });
+        this._onDidTrigger.fire({ auto: options.auto, shy: options.shy ?? false, position: this._editor.getPosition() });
         // Capture context when request was sent
         this._context = ctx;
         // Build context for request
-        let suggestCtx = { triggerKind: (_b = options.triggerKind) !== null && _b !== void 0 ? _b : 0 /* CompletionTriggerKind.Invoke */ };
+        let suggestCtx = { triggerKind: options.triggerKind ?? 0 /* CompletionTriggerKind.Invoke */ };
         if (options.triggerCharacter) {
             suggestCtx = {
                 triggerKind: 1 /* CompletionTriggerKind.TriggerCharacter */,
@@ -399,18 +386,17 @@
                 break;
         }
         const { itemKind: itemKindFilter, showDeprecated } = SuggestModel_1._createSuggestFilter(this._editor);
-        const completionOptions = new CompletionOptions(snippetSortOrder, (_d = (_c = options.completionOptions) === null || _c === void 0 ? void 0 : _c.kindFilter) !== null && _d !== void 0 ? _d : itemKindFilter, (_e = options.completionOptions) === null || _e === void 0 ? void 0 : _e.providerFilter, (_f = options.completionOptions) === null || _f === void 0 ? void 0 : _f.providerItemsToReuse, showDeprecated);
+        const completionOptions = new CompletionOptions(snippetSortOrder, options.completionOptions?.kindFilter ?? itemKindFilter, options.completionOptions?.providerFilter, options.completionOptions?.providerItemsToReuse, showDeprecated);
         const wordDistance = WordDistance.create(this._editorWorkerService, this._editor);
         const completions = provideSuggestionItems(this._languageFeaturesService.completionProvider, model, this._editor.getPosition(), completionOptions, suggestCtx, this._requestToken.token);
-        Promise.all([completions, wordDistance]).then(([completions, wordDistance]) => __awaiter(this, void 0, void 0, function* () {
-            var _g;
-            (_g = this._requestToken) === null || _g === void 0 ? void 0 : _g.dispose();
+        Promise.all([completions, wordDistance]).then(async ([completions, wordDistance]) => {
+            this._requestToken?.dispose();
             if (!this._editor.hasModel()) {
                 return;
             }
-            let clipboardText = options === null || options === void 0 ? void 0 : options.clipboardText;
+            let clipboardText = options?.clipboardText;
             if (!clipboardText && completions.needsClipboard) {
-                clipboardText = yield this._clipboardService.readText();
+                clipboardText = await this._clipboardService.readText();
             }
             if (this._triggerState === undefined) {
                 return;
@@ -422,7 +408,10 @@
             // 	items = items.concat(existing.items).sort(cmpFn);
             // }
             const ctx = new LineContext(model, this._editor.getPosition(), options);
-            const fuzzySearchOptions = Object.assign(Object.assign({}, FuzzyScoreOptions.default), { firstMatchCanBeWeak: !this._editor.getOption(117 /* EditorOption.suggest */).matchOnWordStartOnly });
+            const fuzzySearchOptions = {
+                ...FuzzyScoreOptions.default,
+                firstMatchCanBeWeak: !this._editor.getOption(117 /* EditorOption.suggest */).matchOnWordStartOnly
+            };
             this._completionModel = new CompletionModel(completions.items, this._context.column, {
                 leadingLineContent: ctx.leadingLineContent,
                 characterCountDelta: ctx.column - this._context.column
@@ -440,7 +429,7 @@
                     }
                 }
             }
-        })).catch(onUnexpectedError);
+        }).catch(onUnexpectedError);
     }
     _reportDurationsTelemetry(durations) {
         if (this._telemetryGate++ % 230 !== 0) {
diff -urN -x '*.map' a/vs/editor/contrib/suggest/browser/suggestWidget.js b/vs/editor/contrib/suggest/browser/suggestWidget.js
--- a/vs/editor/contrib/suggest/browser/suggestWidget.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/suggest/browser/suggestWidget.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 var SuggestWidget_1;
 import * as dom from '../../../../base/browser/dom.js';
 import '../../../../base/browser/ui/codicons/codiconStyles.js'; // The codicon symbol styles are defined here and must be loaded
@@ -50,30 +41,29 @@
 /**
  * Suggest widget colors
  */
-registerColor('editorSuggestWidget.background', { dark: editorWidgetBackground, light: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localize('editorSuggestWidgetBackground', 'Background color of the suggest widget.'));
-registerColor('editorSuggestWidget.border', { dark: editorWidgetBorder, light: editorWidgetBorder, hcDark: editorWidgetBorder, hcLight: editorWidgetBorder }, nls.localize('editorSuggestWidgetBorder', 'Border color of the suggest widget.'));
-const editorSuggestWidgetForeground = registerColor('editorSuggestWidget.foreground', { dark: editorForeground, light: editorForeground, hcDark: editorForeground, hcLight: editorForeground }, nls.localize('editorSuggestWidgetForeground', 'Foreground color of the suggest widget.'));
-registerColor('editorSuggestWidget.selectedForeground', { dark: quickInputListFocusForeground, light: quickInputListFocusForeground, hcDark: quickInputListFocusForeground, hcLight: quickInputListFocusForeground }, nls.localize('editorSuggestWidgetSelectedForeground', 'Foreground color of the selected entry in the suggest widget.'));
-registerColor('editorSuggestWidget.selectedIconForeground', { dark: quickInputListFocusIconForeground, light: quickInputListFocusIconForeground, hcDark: quickInputListFocusIconForeground, hcLight: quickInputListFocusIconForeground }, nls.localize('editorSuggestWidgetSelectedIconForeground', 'Icon foreground color of the selected entry in the suggest widget.'));
-export const editorSuggestWidgetSelectedBackground = registerColor('editorSuggestWidget.selectedBackground', { dark: quickInputListFocusBackground, light: quickInputListFocusBackground, hcDark: quickInputListFocusBackground, hcLight: quickInputListFocusBackground }, nls.localize('editorSuggestWidgetSelectedBackground', 'Background color of the selected entry in the suggest widget.'));
-registerColor('editorSuggestWidget.highlightForeground', { dark: listHighlightForeground, light: listHighlightForeground, hcDark: listHighlightForeground, hcLight: listHighlightForeground }, nls.localize('editorSuggestWidgetHighlightForeground', 'Color of the match highlights in the suggest widget.'));
-registerColor('editorSuggestWidget.focusHighlightForeground', { dark: listFocusHighlightForeground, light: listFocusHighlightForeground, hcDark: listFocusHighlightForeground, hcLight: listFocusHighlightForeground }, nls.localize('editorSuggestWidgetFocusHighlightForeground', 'Color of the match highlights in the suggest widget when an item is focused.'));
-registerColor('editorSuggestWidgetStatus.foreground', { dark: transparent(editorSuggestWidgetForeground, .5), light: transparent(editorSuggestWidgetForeground, .5), hcDark: transparent(editorSuggestWidgetForeground, .5), hcLight: transparent(editorSuggestWidgetForeground, .5) }, nls.localize('editorSuggestWidgetStatusForeground', 'Foreground color of the suggest widget status.'));
+registerColor('editorSuggestWidget.background', { dark: editorWidgetBackground, light: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'editorSuggestWidgetBackground', 'Background color of the suggest widget.'));
+registerColor('editorSuggestWidget.border', { dark: editorWidgetBorder, light: editorWidgetBorder, hcDark: editorWidgetBorder, hcLight: editorWidgetBorder }, nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'editorSuggestWidgetBorder', 'Border color of the suggest widget.'));
+const editorSuggestWidgetForeground = registerColor('editorSuggestWidget.foreground', { dark: editorForeground, light: editorForeground, hcDark: editorForeground, hcLight: editorForeground }, nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'editorSuggestWidgetForeground', 'Foreground color of the suggest widget.'));
+registerColor('editorSuggestWidget.selectedForeground', { dark: quickInputListFocusForeground, light: quickInputListFocusForeground, hcDark: quickInputListFocusForeground, hcLight: quickInputListFocusForeground }, nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'editorSuggestWidgetSelectedForeground', 'Foreground color of the selected entry in the suggest widget.'));
+registerColor('editorSuggestWidget.selectedIconForeground', { dark: quickInputListFocusIconForeground, light: quickInputListFocusIconForeground, hcDark: quickInputListFocusIconForeground, hcLight: quickInputListFocusIconForeground }, nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'editorSuggestWidgetSelectedIconForeground', 'Icon foreground color of the selected entry in the suggest widget.'));
+export const editorSuggestWidgetSelectedBackground = registerColor('editorSuggestWidget.selectedBackground', { dark: quickInputListFocusBackground, light: quickInputListFocusBackground, hcDark: quickInputListFocusBackground, hcLight: quickInputListFocusBackground }, nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'editorSuggestWidgetSelectedBackground', 'Background color of the selected entry in the suggest widget.'));
+registerColor('editorSuggestWidget.highlightForeground', { dark: listHighlightForeground, light: listHighlightForeground, hcDark: listHighlightForeground, hcLight: listHighlightForeground }, nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'editorSuggestWidgetHighlightForeground', 'Color of the match highlights in the suggest widget.'));
+registerColor('editorSuggestWidget.focusHighlightForeground', { dark: listFocusHighlightForeground, light: listFocusHighlightForeground, hcDark: listFocusHighlightForeground, hcLight: listFocusHighlightForeground }, nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'editorSuggestWidgetFocusHighlightForeground', 'Color of the match highlights in the suggest widget when an item is focused.'));
+registerColor('editorSuggestWidgetStatus.foreground', { dark: transparent(editorSuggestWidgetForeground, .5), light: transparent(editorSuggestWidgetForeground, .5), hcDark: transparent(editorSuggestWidgetForeground, .5), hcLight: transparent(editorSuggestWidgetForeground, .5) }, nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'editorSuggestWidgetStatusForeground', 'Foreground color of the suggest widget status.'));
 class PersistedWidgetSize {
     constructor(_service, editor) {
         this._service = _service;
         this._key = `suggestWidget.size/${editor.getEditorType()}/${editor instanceof EmbeddedCodeEditorWidget}`;
     }
     restore() {
-        var _a;
-        const raw = (_a = this._service.get(this._key, 0 /* StorageScope.PROFILE */)) !== null && _a !== void 0 ? _a : '';
+        const raw = this._service.get(this._key, 0 /* StorageScope.PROFILE */) ?? '';
         try {
             const obj = JSON.parse(raw);
             if (dom.Dimension.is(obj)) {
                 return dom.Dimension.lift(obj);
             }
         }
-        catch (_b) {
+        catch {
             // ignore
         }
         return undefined;
@@ -126,7 +116,6 @@
             state = new ResizeState(this._persistedSize.restore(), this.element.size);
         }));
         this._disposables.add(this.element.onDidResize(e => {
-            var _a, _b, _c, _d;
             this._resize(e.dimension.width, e.dimension.height);
             if (state) {
                 state.persistHeight = state.persistHeight || !!e.north || !!e.south;
@@ -142,10 +131,10 @@
                 const threshold = Math.round(itemHeight / 2);
                 let { width, height } = this.element.size;
                 if (!state.persistHeight || Math.abs(state.currentSize.height - height) <= threshold) {
-                    height = (_b = (_a = state.persistedSize) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : defaultSize.height;
+                    height = state.persistedSize?.height ?? defaultSize.height;
                 }
                 if (!state.persistWidth || Math.abs(state.currentSize.width - width) <= threshold) {
-                    width = (_d = (_c = state.persistedSize) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : defaultSize.width;
+                    width = state.persistedSize?.width ?? defaultSize.width;
                 }
                 this._persistedSize.store(new dom.Dimension(width, height));
             }
@@ -173,20 +162,20 @@
             multipleSelectionSupport: false,
             accessibilityProvider: {
                 getRole: () => 'option',
-                getWidgetAriaLabel: () => nls.localize('suggest', "Suggest"),
+                getWidgetAriaLabel: () => nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'suggest', "Suggest"),
                 getWidgetRole: () => 'listbox',
                 getAriaLabel: (item) => {
                     let label = item.textLabel;
                     if (typeof item.completion.label !== 'string') {
                         const { detail, description } = item.completion.label;
                         if (detail && description) {
-                            label = nls.localize('label.full', '{0} {1}, {2}', label, detail, description);
+                            label = nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'label.full', '{0} {1}, {2}', label, detail, description);
                         }
                         else if (detail) {
-                            label = nls.localize('label.detail', '{0} {1}', label, detail);
+                            label = nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'label.detail', '{0} {1}', label, detail);
                         }
                         else if (description) {
-                            label = nls.localize('label.desc', '{0}, {1}', label, description);
+                            label = nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'label.desc', '{0}, {1}', label, description);
                         }
                     }
                     if (!item.isResolved || !this._isDetailsVisible()) {
@@ -194,7 +183,7 @@
                     }
                     const { documentation, detail } = item.completion;
                     const docs = strings.format('{0}{1}', detail || '', documentation ? (typeof documentation === 'string' ? documentation : documentation.value) : '');
-                    return nls.localize('ariaCurrenttSuggestionReadDetails', "{0}, docs: {1}", label, docs);
+                    return nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'ariaCurrenttSuggestionReadDetails', "{0}, docs: {1}", label, docs);
                 },
             }
         });
@@ -228,13 +217,12 @@
         this._disposables.add(this.editor.onMouseDown((e) => this._onEditorMouseDown(e)));
     }
     dispose() {
-        var _a;
         this._details.widget.dispose();
         this._details.dispose();
         this._list.dispose();
         this._status.dispose();
         this._disposables.dispose();
-        (_a = this._loadingTimeout) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._loadingTimeout?.dispose();
         this._pendingLayout.dispose();
         this._pendingShowDetails.dispose();
         this._showTimeout.dispose();
@@ -283,7 +271,6 @@
         this._details.widget.borderWidth = isHighContrast(theme.type) ? 2 : 1;
     }
     _onListFocus(e) {
-        var _a;
         if (this._ignoreFocusEvents) {
             return;
         }
@@ -304,11 +291,11 @@
         const item = e.elements[0];
         const index = e.indexes[0];
         if (item !== this._focusedItem) {
-            (_a = this._currentSuggestionDetails) === null || _a === void 0 ? void 0 : _a.cancel();
+            this._currentSuggestionDetails?.cancel();
             this._currentSuggestionDetails = undefined;
             this._focusedItem = item;
             this._list.reveal(index);
-            this._currentSuggestionDetails = createCancelablePromise((token) => __awaiter(this, void 0, void 0, function* () {
+            this._currentSuggestionDetails = createCancelablePromise(async (token) => {
                 const loading = disposableTimeout(() => {
                     if (this._isDetailsVisible()) {
                         this.showDetails(true);
@@ -316,13 +303,13 @@
                 }, 250);
                 const sub = token.onCancellationRequested(() => loading.dispose());
                 try {
-                    return yield item.resolve(token);
+                    return await item.resolve(token);
                 }
                 finally {
                     loading.dispose();
                     sub.dispose();
                 }
-            }));
+            });
             this._currentSuggestionDetails.then(() => {
                 if (index >= this._list.length || item !== this._list.element(index)) {
                     return;
@@ -426,10 +413,9 @@
         }
     }
     showSuggestions(completionModel, selectionIndex, isFrozen, isAuto, noFocus) {
-        var _a, _b;
         this._contentWidget.setPosition(this.editor.getPosition());
-        (_a = this._loadingTimeout) === null || _a === void 0 ? void 0 : _a.dispose();
-        (_b = this._currentSuggestionDetails) === null || _b === void 0 ? void 0 : _b.cancel();
+        this._loadingTimeout?.dispose();
+        this._currentSuggestionDetails?.cancel();
         this._currentSuggestionDetails = undefined;
         if (this._completionModel !== completionModel) {
             this._completionModel = completionModel;
@@ -623,10 +609,9 @@
         this._persistedSize.reset();
     }
     hideWidget() {
-        var _a;
         this._pendingLayout.clear();
         this._pendingShowDetails.clear();
-        (_a = this._loadingTimeout) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._loadingTimeout?.dispose();
         this._setState(0 /* State.Hidden */);
         this._onDidHide.fire(this);
         this.element.clearSashHoverState();
@@ -658,7 +643,6 @@
         this._positionDetails();
     }
     _layout(size) {
-        var _a, _b, _c;
         if (!this.editor.hasModel()) {
             return;
         }
@@ -701,7 +685,7 @@
             const availableSpaceAbove = editorBox.top + cursorBox.top - info.verticalPadding;
             const maxHeightAbove = Math.min(availableSpaceAbove, fullHeight);
             let maxHeight = Math.min(Math.max(maxHeightAbove, maxHeightBelow) + info.borderHeight, fullHeight);
-            if (height === ((_a = this._cappedHeight) === null || _a === void 0 ? void 0 : _a.capped)) {
+            if (height === this._cappedHeight?.capped) {
                 // Restore the old (wanted) height when the current
                 // height is capped to fit
                 height = this._cappedHeight.wanted;
@@ -730,7 +714,7 @@
             // the wanted height for later. This is required when going
             // left to widen suggestions.
             this._cappedHeight = height === fullHeight
-                ? { wanted: (_c = (_b = this._cappedHeight) === null || _b === void 0 ? void 0 : _b.wanted) !== null && _c !== void 0 ? _c : size.height, capped: height }
+                ? { wanted: this._cappedHeight?.wanted ?? size.height, capped: height }
                 : undefined;
         }
         this._resize(width, height);
@@ -747,9 +731,8 @@
         this._positionDetails();
     }
     _positionDetails() {
-        var _a;
         if (this._isDetailsVisible()) {
-            this._details.placeAtAnchor(this.element.domNode, ((_a = this._contentWidget.getPosition()) === null || _a === void 0 ? void 0 : _a.preference[0]) === 2 /* ContentWidgetPositionPreference.BELOW */);
+            this._details.placeAtAnchor(this.element.domNode, this._contentWidget.getPosition()?.preference[0] === 2 /* ContentWidgetPositionPreference.BELOW */);
         }
     }
     getLayoutInfo() {
@@ -785,8 +768,8 @@
         this._forceRenderingAbove = false;
     }
 };
-SuggestWidget.LOADING_MESSAGE = nls.localize('suggestWidget.loading', "Loading...");
-SuggestWidget.NO_SUGGESTIONS_MESSAGE = nls.localize('suggestWidget.noSuggestions', "No suggestions.");
+SuggestWidget.LOADING_MESSAGE = nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'suggestWidget.loading', "Loading...");
+SuggestWidget.NO_SUGGESTIONS_MESSAGE = nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidget', 'suggestWidget.noSuggestions', "No suggestions.");
 SuggestWidget = SuggestWidget_1 = __decorate([
     __param(1, IStorageService),
     __param(2, IContextKeyService),
diff -urN -x '*.map' a/vs/editor/contrib/suggest/browser/suggestWidgetDetails.js b/vs/editor/contrib/suggest/browser/suggestWidgetDetails.js
--- a/vs/editor/contrib/suggest/browser/suggestWidgetDetails.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/suggest/browser/suggestWidgetDetails.js	2023-12-06 14:23:14.383854791 +0000
@@ -47,7 +47,7 @@
         this._disposables.add(this._scrollbar);
         this._header = dom.append(this._body, dom.$('.header'));
         this._close = dom.append(this._header, dom.$('span' + ThemeIcon.asCSSSelector(Codicon.close)));
-        this._close.title = nls.localize('details.close', "Close");
+        this._close.title = nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidgetDetails', 'details.close', "Close");
         this._type = dom.append(this._header, dom.$('p.type'));
         this._docs = dom.append(this._body, dom.$('p.docs'));
         this._configureFont();
@@ -91,24 +91,23 @@
         };
     }
     renderLoading() {
-        this._type.textContent = nls.localize('loading', "Loading...");
+        this._type.textContent = nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidgetDetails', 'loading', "Loading...");
         this._docs.textContent = '';
         this.domNode.classList.remove('no-docs', 'no-type');
         this.layout(this.size.width, this.getLayoutInfo().lineHeight * 2);
         this._onDidChangeContents.fire(this);
     }
     renderItem(item, explainMode) {
-        var _a, _b;
         this._renderDisposeable.clear();
         let { detail, documentation } = item.completion;
         if (explainMode) {
             let md = '';
             md += `score: ${item.score[0]}\n`;
-            md += `prefix: ${(_a = item.word) !== null && _a !== void 0 ? _a : '(no prefix)'}\n`;
+            md += `prefix: ${item.word ?? '(no prefix)'}\n`;
             md += `word: ${item.completion.filterText ? item.completion.filterText + ' (filterText)' : item.textLabel}\n`;
             md += `distance: ${item.distance} (localityBonus-setting)\n`;
             md += `index: ${item.idx}, based on ${item.completion.sortText && `sortText: "${item.completion.sortText}"` || 'label'}\n`;
-            md += `commit_chars: ${(_b = item.completion.commitCharacters) === null || _b === void 0 ? void 0 : _b.join('')}\n`;
+            md += `commit_chars: ${item.completion.commitCharacters?.join('')}\n`;
             documentation = new MarkdownString().appendCodeblock('empty', md);
             detail = `Provider: ${item.provider._debugDisplayName}`;
         }
@@ -255,9 +254,8 @@
             }
         }));
         this._disposables.add(this.widget.onDidChangeContents(() => {
-            var _a;
             if (this._anchorBox) {
-                this._placeAtAnchor(this._anchorBox, (_a = this._userSize) !== null && _a !== void 0 ? _a : this.widget.size, this._preferAlignAtTop);
+                this._placeAtAnchor(this._anchorBox, this._userSize ?? this.widget.size, this._preferAlignAtTop);
             }
         }));
     }
@@ -296,14 +294,12 @@
         }
     }
     placeAtAnchor(anchor, preferAlignAtTop) {
-        var _a;
         const anchorBox = anchor.getBoundingClientRect();
         this._anchorBox = anchorBox;
         this._preferAlignAtTop = preferAlignAtTop;
-        this._placeAtAnchor(this._anchorBox, (_a = this._userSize) !== null && _a !== void 0 ? _a : this.widget.size, preferAlignAtTop);
+        this._placeAtAnchor(this._anchorBox, this._userSize ?? this.widget.size, preferAlignAtTop);
     }
     _placeAtAnchor(anchorBox, size, preferAlignAtTop) {
-        var _a;
         const bodyBox = dom.getClientArea(this.getDomNode().ownerDocument.body);
         const info = this.widget.getLayoutInfo();
         const defaultMinSize = new dom.Dimension(220, 2 * info.lineHeight);
@@ -333,7 +329,7 @@
         })();
         // take first placement that fits or the first with "least bad" fit
         const placements = [eastPlacement, westPlacement, southPacement];
-        const placement = (_a = placements.find(p => p.fit >= 0)) !== null && _a !== void 0 ? _a : placements.sort((a, b) => b.fit - a.fit)[0];
+        const placement = placements.find(p => p.fit >= 0) ?? placements.sort((a, b) => b.fit - a.fit)[0];
         // top/bottom placement
         const bottom = anchorBox.top + anchorBox.height - info.borderHeight;
         let alignAtTop;
diff -urN -x '*.map' a/vs/editor/contrib/suggest/browser/suggestWidgetRenderer.js b/vs/editor/contrib/suggest/browser/suggestWidgetRenderer.js
--- a/vs/editor/contrib/suggest/browser/suggestWidgetRenderer.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/suggest/browser/suggestWidgetRenderer.js	2023-12-06 14:23:14.383854791 +0000
@@ -32,7 +32,7 @@
 export function getAriaId(index) {
     return `suggest-aria-id:${index}`;
 }
-const suggestMoreInfoIcon = registerIcon('suggest-more-info', Codicon.chevronRight, nls.localize('suggestMoreInfoIcon', 'Icon for more information in the suggest widget.'));
+const suggestMoreInfoIcon = registerIcon('suggest-more-info', Codicon.chevronRight, nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidgetRenderer', 'suggestMoreInfoIcon', 'Icon for more information in the suggest widget.'));
 const _completionItemColor = new (_a = class ColorExtractor {
         extract(item, out) {
             if (item.textLabel.match(_a._regexStrict)) {
@@ -86,7 +86,7 @@
         const qualifierLabel = append(left, $('span.qualifier-label'));
         const detailsLabel = append(right, $('span.details-label'));
         const readMore = append(right, $('span.readMore' + ThemeIcon.asCSSSelector(suggestMoreInfoIcon)));
-        readMore.title = nls.localize('readMore', "Read More");
+        readMore.title = nls.localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidgetRenderer', 'readMore', "Read More");
         const configureFont = () => {
             const options = this._editor.getOptions();
             const fontInfo = options.get(50 /* EditorOption.fontInfo */);
diff -urN -x '*.map' a/vs/editor/contrib/suggest/browser/suggestWidgetStatus.js b/vs/editor/contrib/suggest/browser/suggestWidgetStatus.js
--- a/vs/editor/contrib/suggest/browser/suggestWidgetStatus.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/suggest/browser/suggestWidgetStatus.js	2023-12-06 14:23:14.383854791 +0000
@@ -14,7 +14,7 @@
 import * as dom from '../../../../base/browser/dom.js';
 import { ActionBar } from '../../../../base/browser/ui/actionbar/actionbar.js';
 import { DisposableStore } from '../../../../base/common/lifecycle.js';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { MenuEntryActionViewItem } from '../../../../platform/actions/browser/menuEntryActionViewItem.js';
 import { IMenuService, MenuItemAction } from '../../../../platform/actions/common/actions.js';
 import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';
@@ -26,12 +26,11 @@
             return super.updateLabel();
         }
         if (this.label) {
-            this.label.textContent = localize({ key: 'content', comment: ['A label', 'A keybinding'] }, '{0} ({1})', this._action.label, StatusBarViewItem.symbolPrintEnter(kb));
+            this.label.textContent = localizeWithPath('vs/editor/contrib/suggest/browser/suggestWidgetStatus', { key: 'content', comment: ['A label', 'A keybinding'] }, '{0} ({1})', this._action.label, StatusBarViewItem.symbolPrintEnter(kb));
         }
     }
     static symbolPrintEnter(kb) {
-        var _a;
-        return (_a = kb.getLabel()) === null || _a === void 0 ? void 0 : _a.replace(/\benter\b/gi, '\u23CE');
+        return kb.getLabel()?.replace(/\benter\b/gi, '\u23CE');
     }
 }
 let SuggestWidgetStatus = class SuggestWidgetStatus {
diff -urN -x '*.map' a/vs/editor/contrib/suggest/browser/wordContextKey.js b/vs/editor/contrib/suggest/browser/wordContextKey.js
--- a/vs/editor/contrib/suggest/browser/wordContextKey.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/suggest/browser/wordContextKey.js	2023-12-06 14:23:14.383854791 +0000
@@ -22,9 +22,8 @@
         this._update();
     }
     dispose() {
-        var _a;
         this._configListener.dispose();
-        (_a = this._selectionListener) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._selectionListener?.dispose();
         this._ckAtEnd.reset();
     }
     _update() {
diff -urN -x '*.map' a/vs/editor/contrib/suggest/browser/wordDistance.js b/vs/editor/contrib/suggest/browser/wordDistance.js
--- a/vs/editor/contrib/suggest/browser/wordDistance.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/suggest/browser/wordDistance.js	2023-12-06 14:23:14.383854791 +0000
@@ -2,69 +2,58 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { binarySearch, isFalsyOrEmpty } from '../../../../base/common/arrays.js';
 import { Range } from '../../../common/core/range.js';
 import { BracketSelectionRangeProvider } from '../../smartSelect/browser/bracketSelections.js';
 export class WordDistance {
-    static create(service, editor) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (!editor.getOption(117 /* EditorOption.suggest */).localityBonus) {
-                return WordDistance.None;
-            }
-            if (!editor.hasModel()) {
-                return WordDistance.None;
-            }
-            const model = editor.getModel();
-            const position = editor.getPosition();
-            if (!service.canComputeWordRanges(model.uri)) {
-                return WordDistance.None;
-            }
-            const [ranges] = yield new BracketSelectionRangeProvider().provideSelectionRanges(model, [position]);
-            if (ranges.length === 0) {
-                return WordDistance.None;
-            }
-            const wordRanges = yield service.computeWordRanges(model.uri, ranges[0].range);
-            if (!wordRanges) {
-                return WordDistance.None;
-            }
-            // remove current word
-            const wordUntilPos = model.getWordUntilPosition(position);
-            delete wordRanges[wordUntilPos.word];
-            return new class extends WordDistance {
-                distance(anchor, item) {
-                    if (!position.equals(editor.getPosition())) {
-                        return 0;
-                    }
-                    if (item.kind === 17 /* CompletionItemKind.Keyword */) {
-                        return 2 << 20;
-                    }
-                    const word = typeof item.label === 'string' ? item.label : item.label.label;
-                    const wordLines = wordRanges[word];
-                    if (isFalsyOrEmpty(wordLines)) {
-                        return 2 << 20;
-                    }
-                    const idx = binarySearch(wordLines, Range.fromPositions(anchor), Range.compareRangesUsingStarts);
-                    const bestWordRange = idx >= 0 ? wordLines[idx] : wordLines[Math.max(0, ~idx - 1)];
-                    let blockDistance = ranges.length;
-                    for (const range of ranges) {
-                        if (!Range.containsRange(range.range, bestWordRange)) {
-                            break;
-                        }
-                        blockDistance -= 1;
+    static async create(service, editor) {
+        if (!editor.getOption(117 /* EditorOption.suggest */).localityBonus) {
+            return WordDistance.None;
+        }
+        if (!editor.hasModel()) {
+            return WordDistance.None;
+        }
+        const model = editor.getModel();
+        const position = editor.getPosition();
+        if (!service.canComputeWordRanges(model.uri)) {
+            return WordDistance.None;
+        }
+        const [ranges] = await new BracketSelectionRangeProvider().provideSelectionRanges(model, [position]);
+        if (ranges.length === 0) {
+            return WordDistance.None;
+        }
+        const wordRanges = await service.computeWordRanges(model.uri, ranges[0].range);
+        if (!wordRanges) {
+            return WordDistance.None;
+        }
+        // remove current word
+        const wordUntilPos = model.getWordUntilPosition(position);
+        delete wordRanges[wordUntilPos.word];
+        return new class extends WordDistance {
+            distance(anchor, item) {
+                if (!position.equals(editor.getPosition())) {
+                    return 0;
+                }
+                if (item.kind === 17 /* CompletionItemKind.Keyword */) {
+                    return 2 << 20;
+                }
+                const word = typeof item.label === 'string' ? item.label : item.label.label;
+                const wordLines = wordRanges[word];
+                if (isFalsyOrEmpty(wordLines)) {
+                    return 2 << 20;
+                }
+                const idx = binarySearch(wordLines, Range.fromPositions(anchor), Range.compareRangesUsingStarts);
+                const bestWordRange = idx >= 0 ? wordLines[idx] : wordLines[Math.max(0, ~idx - 1)];
+                let blockDistance = ranges.length;
+                for (const range of ranges) {
+                    if (!Range.containsRange(range.range, bestWordRange)) {
+                        break;
                     }
-                    return blockDistance;
+                    blockDistance -= 1;
                 }
-            };
-        });
+                return blockDistance;
+            }
+        };
     }
 }
 WordDistance.None = new class extends WordDistance {
diff -urN -x '*.map' a/vs/editor/contrib/symbolIcons/browser/symbolIcons.js b/vs/editor/contrib/symbolIcons/browser/symbolIcons.js
--- a/vs/editor/contrib/symbolIcons/browser/symbolIcons.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/symbolIcons/browser/symbolIcons.js	2023-12-06 14:23:14.383854791 +0000
@@ -3,203 +3,203 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import './symbolIcons.css';
-import { localize } from '../../../../nls.js';
+import { localizeWithPath } from '../../../../nls.js';
 import { foreground, registerColor } from '../../../../platform/theme/common/colorRegistry.js';
 export const SYMBOL_ICON_ARRAY_FOREGROUND = registerColor('symbolIcon.arrayForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground,
-}, localize('symbolIcon.arrayForeground', 'The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.arrayForeground', 'The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_BOOLEAN_FOREGROUND = registerColor('symbolIcon.booleanForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground,
-}, localize('symbolIcon.booleanForeground', 'The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.booleanForeground', 'The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_CLASS_FOREGROUND = registerColor('symbolIcon.classForeground', {
     dark: '#EE9D28',
     light: '#D67E00',
     hcDark: '#EE9D28',
     hcLight: '#D67E00'
-}, localize('symbolIcon.classForeground', 'The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.classForeground', 'The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_COLOR_FOREGROUND = registerColor('symbolIcon.colorForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.colorForeground', 'The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.colorForeground', 'The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_CONSTANT_FOREGROUND = registerColor('symbolIcon.constantForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.constantForeground', 'The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.constantForeground', 'The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_CONSTRUCTOR_FOREGROUND = registerColor('symbolIcon.constructorForeground', {
     dark: '#B180D7',
     light: '#652D90',
     hcDark: '#B180D7',
     hcLight: '#652D90'
-}, localize('symbolIcon.constructorForeground', 'The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.constructorForeground', 'The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_ENUMERATOR_FOREGROUND = registerColor('symbolIcon.enumeratorForeground', {
     dark: '#EE9D28',
     light: '#D67E00',
     hcDark: '#EE9D28',
     hcLight: '#D67E00'
-}, localize('symbolIcon.enumeratorForeground', 'The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.enumeratorForeground', 'The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND = registerColor('symbolIcon.enumeratorMemberForeground', {
     dark: '#75BEFF',
     light: '#007ACC',
     hcDark: '#75BEFF',
     hcLight: '#007ACC'
-}, localize('symbolIcon.enumeratorMemberForeground', 'The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.enumeratorMemberForeground', 'The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_EVENT_FOREGROUND = registerColor('symbolIcon.eventForeground', {
     dark: '#EE9D28',
     light: '#D67E00',
     hcDark: '#EE9D28',
     hcLight: '#D67E00'
-}, localize('symbolIcon.eventForeground', 'The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.eventForeground', 'The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_FIELD_FOREGROUND = registerColor('symbolIcon.fieldForeground', {
     dark: '#75BEFF',
     light: '#007ACC',
     hcDark: '#75BEFF',
     hcLight: '#007ACC'
-}, localize('symbolIcon.fieldForeground', 'The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.fieldForeground', 'The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_FILE_FOREGROUND = registerColor('symbolIcon.fileForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.fileForeground', 'The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.fileForeground', 'The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_FOLDER_FOREGROUND = registerColor('symbolIcon.folderForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.folderForeground', 'The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.folderForeground', 'The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_FUNCTION_FOREGROUND = registerColor('symbolIcon.functionForeground', {
     dark: '#B180D7',
     light: '#652D90',
     hcDark: '#B180D7',
     hcLight: '#652D90'
-}, localize('symbolIcon.functionForeground', 'The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.functionForeground', 'The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_INTERFACE_FOREGROUND = registerColor('symbolIcon.interfaceForeground', {
     dark: '#75BEFF',
     light: '#007ACC',
     hcDark: '#75BEFF',
     hcLight: '#007ACC'
-}, localize('symbolIcon.interfaceForeground', 'The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.interfaceForeground', 'The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_KEY_FOREGROUND = registerColor('symbolIcon.keyForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.keyForeground', 'The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.keyForeground', 'The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_KEYWORD_FOREGROUND = registerColor('symbolIcon.keywordForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.keywordForeground', 'The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.keywordForeground', 'The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_METHOD_FOREGROUND = registerColor('symbolIcon.methodForeground', {
     dark: '#B180D7',
     light: '#652D90',
     hcDark: '#B180D7',
     hcLight: '#652D90'
-}, localize('symbolIcon.methodForeground', 'The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.methodForeground', 'The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_MODULE_FOREGROUND = registerColor('symbolIcon.moduleForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.moduleForeground', 'The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.moduleForeground', 'The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_NAMESPACE_FOREGROUND = registerColor('symbolIcon.namespaceForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.namespaceForeground', 'The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.namespaceForeground', 'The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_NULL_FOREGROUND = registerColor('symbolIcon.nullForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.nullForeground', 'The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.nullForeground', 'The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_NUMBER_FOREGROUND = registerColor('symbolIcon.numberForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.numberForeground', 'The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.numberForeground', 'The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_OBJECT_FOREGROUND = registerColor('symbolIcon.objectForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.objectForeground', 'The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.objectForeground', 'The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_OPERATOR_FOREGROUND = registerColor('symbolIcon.operatorForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.operatorForeground', 'The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.operatorForeground', 'The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_PACKAGE_FOREGROUND = registerColor('symbolIcon.packageForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.packageForeground', 'The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.packageForeground', 'The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_PROPERTY_FOREGROUND = registerColor('symbolIcon.propertyForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.propertyForeground', 'The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.propertyForeground', 'The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_REFERENCE_FOREGROUND = registerColor('symbolIcon.referenceForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.referenceForeground', 'The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.referenceForeground', 'The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_SNIPPET_FOREGROUND = registerColor('symbolIcon.snippetForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.snippetForeground', 'The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.snippetForeground', 'The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_STRING_FOREGROUND = registerColor('symbolIcon.stringForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.stringForeground', 'The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.stringForeground', 'The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_STRUCT_FOREGROUND = registerColor('symbolIcon.structForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground,
-}, localize('symbolIcon.structForeground', 'The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.structForeground', 'The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_TEXT_FOREGROUND = registerColor('symbolIcon.textForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.textForeground', 'The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.textForeground', 'The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_TYPEPARAMETER_FOREGROUND = registerColor('symbolIcon.typeParameterForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.typeParameterForeground', 'The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.typeParameterForeground', 'The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_UNIT_FOREGROUND = registerColor('symbolIcon.unitForeground', {
     dark: foreground,
     light: foreground,
     hcDark: foreground,
     hcLight: foreground
-}, localize('symbolIcon.unitForeground', 'The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.unitForeground', 'The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
 export const SYMBOL_ICON_VARIABLE_FOREGROUND = registerColor('symbolIcon.variableForeground', {
     dark: '#75BEFF',
     light: '#007ACC',
     hcDark: '#75BEFF',
     hcLight: '#007ACC',
-}, localize('symbolIcon.variableForeground', 'The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
+}, localizeWithPath('vs/editor/contrib/symbolIcons/browser/symbolIcons', 'symbolIcon.variableForeground', 'The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));
diff -urN -x '*.map' a/vs/editor/contrib/toggleTabFocusMode/browser/toggleTabFocusMode.js b/vs/editor/contrib/toggleTabFocusMode/browser/toggleTabFocusMode.js
--- a/vs/editor/contrib/toggleTabFocusMode/browser/toggleTabFocusMode.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/toggleTabFocusMode/browser/toggleTabFocusMode.js	2023-12-06 14:23:14.383854791 +0000
@@ -10,7 +10,7 @@
     constructor() {
         super({
             id: ToggleTabFocusModeAction.ID,
-            title: { value: nls.localize({ key: 'toggle.tabMovesFocus', comment: ['Turn on/off use of tab key for moving focus around VS Code'] }, 'Toggle Tab Key Moves Focus'), original: 'Toggle Tab Key Moves Focus' },
+            title: { value: nls.localizeWithPath('vs/editor/contrib/toggleTabFocusMode/browser/toggleTabFocusMode', { key: 'toggle.tabMovesFocus', comment: ['Turn on/off use of tab key for moving focus around VS Code'] }, 'Toggle Tab Key Moves Focus'), original: 'Toggle Tab Key Moves Focus' },
             precondition: undefined,
             keybinding: {
                 primary: 2048 /* KeyMod.CtrlCmd */ | 43 /* KeyCode.KeyM */,
@@ -25,10 +25,10 @@
         const newValue = !oldValue;
         TabFocus.setTabFocusMode(newValue);
         if (newValue) {
-            alert(nls.localize('toggle.tabMovesFocus.on', "Pressing Tab will now move focus to the next focusable element"));
+            alert(nls.localizeWithPath('vs/editor/contrib/toggleTabFocusMode/browser/toggleTabFocusMode', 'toggle.tabMovesFocus.on', "Pressing Tab will now move focus to the next focusable element"));
         }
         else {
-            alert(nls.localize('toggle.tabMovesFocus.off', "Pressing Tab will now insert the tab character"));
+            alert(nls.localizeWithPath('vs/editor/contrib/toggleTabFocusMode/browser/toggleTabFocusMode', 'toggle.tabMovesFocus.off', "Pressing Tab will now insert the tab character"));
         }
     }
 }
diff -urN -x '*.map' a/vs/editor/contrib/tokenization/browser/tokenization.js b/vs/editor/contrib/tokenization/browser/tokenization.js
--- a/vs/editor/contrib/tokenization/browser/tokenization.js	2023-12-06 14:22:33.811782429 +0000
+++ b/vs/editor/contrib/tokenization/browser/tokenization.js	2023-12-06 14:23:14.383854791 +0000
@@ -9,7 +9,7 @@
     constructor() {
         super({
             id: 'editor.action.forceRetokenize',
-            label: nls.localize('forceRetokenize', "Developer: Force Retokenize"),
+            label: nls.localizeWithPath('vs/editor/contrib/tokenization/browser/tokenization', 'forceRetokenize', "Developer: Force Retokenize"),
             alias: 'Developer: Force Retokenize',
             precondition: undefined
         });
diff -urN -x '*.map' a/vs/editor/contrib/unicodeHighlighter/browser/bannerController.js b/vs/editor/contrib/unicodeHighlighter/browser/bannerController.js
--- a/vs/editor/contrib/unicodeHighlighter/browser/bannerController.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/unicodeHighlighter/browser/bannerController.js	2023-12-06 14:23:14.383854791 +0000
@@ -34,11 +34,13 @@
         this.banner.clear();
     }
     show(item) {
-        this.banner.show(Object.assign(Object.assign({}, item), { onClose: () => {
-                var _a;
+        this.banner.show({
+            ...item,
+            onClose: () => {
                 this.hide();
-                (_a = item.onClose) === null || _a === void 0 ? void 0 : _a.call(item);
-            } }));
+                item.onClose?.();
+            }
+        });
         this._editor.setBanner(this.banner.element, BANNER_ELEMENT_HEIGHT);
     }
 };
@@ -97,7 +99,7 @@
         this.messageActionsContainer = append(this.element, $('div.message-actions-container'));
         if (item.actions) {
             for (const action of item.actions) {
-                this._register(this.instantiationService.createInstance(Link, this.messageActionsContainer, Object.assign(Object.assign({}, action), { tabIndex: -1 }), {}));
+                this._register(this.instantiationService.createInstance(Link, this.messageActionsContainer, { ...action, tabIndex: -1 }, {}));
             }
         }
         // Action
diff -urN -x '*.map' a/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js b/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js
--- a/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js	2023-12-06 14:22:33.799782407 +0000
+++ b/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { RunOnceScheduler } from '../../../../base/common/async.js';
 import { Codicon } from '../../../../base/common/codicons.js';
 import { MarkdownString } from '../../../../base/common/htmlContent.js';
@@ -44,7 +35,7 @@
 import { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';
 import { registerIcon } from '../../../../platform/theme/common/iconRegistry.js';
 import { IWorkspaceTrustManagementService } from '../../../../platform/workspace/common/workspaceTrust.js';
-export const warningIcon = registerIcon('extensions-warning-message', Codicon.warning, nls.localize('warningIcon', 'Icon shown with a warning message in the extensions editor.'));
+export const warningIcon = registerIcon('extensions-warning-message', Codicon.warning, nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'warningIcon', 'Icon shown with a warning message in the extensions editor.'));
 let UnicodeHighlighter = class UnicodeHighlighter extends Disposable {
     constructor(_editor, _editorWorkerService, _workspaceTrustService, instantiationService) {
         super();
@@ -63,19 +54,19 @@
                 let data;
                 if (state.nonBasicAsciiCharacterCount >= max) {
                     data = {
-                        message: nls.localize('unicodeHighlighting.thisDocumentHasManyNonBasicAsciiUnicodeCharacters', 'This document contains many non-basic ASCII unicode characters'),
+                        message: nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlighting.thisDocumentHasManyNonBasicAsciiUnicodeCharacters', 'This document contains many non-basic ASCII unicode characters'),
                         command: new DisableHighlightingOfNonBasicAsciiCharactersAction(),
                     };
                 }
                 else if (state.ambiguousCharacterCount >= max) {
                     data = {
-                        message: nls.localize('unicodeHighlighting.thisDocumentHasManyAmbiguousUnicodeCharacters', 'This document contains many ambiguous unicode characters'),
+                        message: nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlighting.thisDocumentHasManyAmbiguousUnicodeCharacters', 'This document contains many ambiguous unicode characters'),
                         command: new DisableHighlightingOfAmbiguousCharactersAction(),
                     };
                 }
                 else if (state.invisibleCharacterCount >= max) {
                     data = {
-                        message: nls.localize('unicodeHighlighting.thisDocumentHasManyInvisibleUnicodeCharacters', 'This document contains many invisible unicode characters'),
+                        message: nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlighting.thisDocumentHasManyInvisibleUnicodeCharacters', 'This document contains many invisible unicode characters'),
                         command: new DisableHighlightingOfInvisibleCharactersAction(),
                     };
                 }
@@ -345,6 +336,18 @@
         };
     }
 }
+export class UnicodeHighlighterHover {
+    constructor(owner, range, decoration) {
+        this.owner = owner;
+        this.range = range;
+        this.decoration = decoration;
+    }
+    isValidForHoverAnchor(anchor) {
+        return (anchor.type === 1 /* HoverAnchorType.Range */
+            && this.range.startColumn <= anchor.range.startColumn
+            && this.range.endColumn >= anchor.range.endColumn);
+    }
+}
 let UnicodeHighlighterHoverParticipant = class UnicodeHighlighterHoverParticipant {
     constructor(_editor, _languageService, _openerService) {
         this._editor = _editor;
@@ -377,18 +380,18 @@
             switch (highlightInfo.reason.kind) {
                 case 0 /* UnicodeHighlighterReasonKind.Ambiguous */: {
                     if (isBasicASCII(highlightInfo.reason.confusableWith)) {
-                        reason = nls.localize('unicodeHighlight.characterIsAmbiguousASCII', 'The character {0} could be confused with the ASCII character {1}, which is more common in source code.', codePointStr, formatCodePointMarkdown(highlightInfo.reason.confusableWith.codePointAt(0)));
+                        reason = nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlight.characterIsAmbiguousASCII', 'The character {0} could be confused with the ASCII character {1}, which is more common in source code.', codePointStr, formatCodePointMarkdown(highlightInfo.reason.confusableWith.codePointAt(0)));
                     }
                     else {
-                        reason = nls.localize('unicodeHighlight.characterIsAmbiguous', 'The character {0} could be confused with the character {1}, which is more common in source code.', codePointStr, formatCodePointMarkdown(highlightInfo.reason.confusableWith.codePointAt(0)));
+                        reason = nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlight.characterIsAmbiguous', 'The character {0} could be confused with the character {1}, which is more common in source code.', codePointStr, formatCodePointMarkdown(highlightInfo.reason.confusableWith.codePointAt(0)));
                     }
                     break;
                 }
                 case 1 /* UnicodeHighlighterReasonKind.Invisible */:
-                    reason = nls.localize('unicodeHighlight.characterIsInvisible', 'The character {0} is invisible.', codePointStr);
+                    reason = nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlight.characterIsInvisible', 'The character {0} is invisible.', codePointStr);
                     break;
                 case 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */:
-                    reason = nls.localize('unicodeHighlight.characterIsNonBasicAscii', 'The character {0} is not a basic ASCII character.', codePointStr);
+                    reason = nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlight.characterIsNonBasicAscii', 'The character {0} is not a basic ASCII character.', codePointStr);
                     break;
             }
             if (existedReason.has(reason)) {
@@ -401,7 +404,7 @@
                 inComment: highlightInfo.inComment,
                 inString: highlightInfo.inString,
             };
-            const adjustSettings = nls.localize('unicodeHighlight.adjustSettings', 'Adjust settings');
+            const adjustSettings = nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlight.adjustSettings', 'Adjust settings');
             const uri = `command:${ShowExcludeOptions.ID}?${encodeURIComponent(JSON.stringify(adjustSettingsArgs))}`;
             const markdown = new MarkdownString('', true)
                 .appendMarkdown(reason)
@@ -471,72 +474,62 @@
     constructor() {
         super({
             id: DisableHighlightingOfAmbiguousCharactersAction.ID,
-            label: nls.localize('action.unicodeHighlight.disableHighlightingInComments', 'Disable highlighting of characters in comments'),
+            label: nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'action.unicodeHighlight.disableHighlightingInComments', 'Disable highlighting of characters in comments'),
             alias: 'Disable highlighting of characters in comments',
             precondition: undefined
         });
-        this.shortLabel = nls.localize('unicodeHighlight.disableHighlightingInComments.shortLabel', 'Disable Highlight In Comments');
+        this.shortLabel = nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlight.disableHighlightingInComments.shortLabel', 'Disable Highlight In Comments');
     }
-    run(accessor, editor, args) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
-            if (configurationService) {
-                this.runAction(configurationService);
-            }
-        });
+    async run(accessor, editor, args) {
+        const configurationService = accessor?.get(IConfigurationService);
+        if (configurationService) {
+            this.runAction(configurationService);
+        }
     }
-    runAction(configurationService) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield configurationService.updateValue(unicodeHighlightConfigKeys.includeComments, false, 2 /* ConfigurationTarget.USER */);
-        });
+    async runAction(configurationService) {
+        await configurationService.updateValue(unicodeHighlightConfigKeys.includeComments, false, 2 /* ConfigurationTarget.USER */);
     }
 }
+DisableHighlightingInCommentsAction.ID = 'editor.action.unicodeHighlight.disableHighlightingInComments';
 export class DisableHighlightingInStringsAction extends EditorAction {
     constructor() {
         super({
             id: DisableHighlightingOfAmbiguousCharactersAction.ID,
-            label: nls.localize('action.unicodeHighlight.disableHighlightingInStrings', 'Disable highlighting of characters in strings'),
+            label: nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'action.unicodeHighlight.disableHighlightingInStrings', 'Disable highlighting of characters in strings'),
             alias: 'Disable highlighting of characters in strings',
             precondition: undefined
         });
-        this.shortLabel = nls.localize('unicodeHighlight.disableHighlightingInStrings.shortLabel', 'Disable Highlight In Strings');
+        this.shortLabel = nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlight.disableHighlightingInStrings.shortLabel', 'Disable Highlight In Strings');
     }
-    run(accessor, editor, args) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
-            if (configurationService) {
-                this.runAction(configurationService);
-            }
-        });
+    async run(accessor, editor, args) {
+        const configurationService = accessor?.get(IConfigurationService);
+        if (configurationService) {
+            this.runAction(configurationService);
+        }
     }
-    runAction(configurationService) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield configurationService.updateValue(unicodeHighlightConfigKeys.includeStrings, false, 2 /* ConfigurationTarget.USER */);
-        });
+    async runAction(configurationService) {
+        await configurationService.updateValue(unicodeHighlightConfigKeys.includeStrings, false, 2 /* ConfigurationTarget.USER */);
     }
 }
+DisableHighlightingInStringsAction.ID = 'editor.action.unicodeHighlight.disableHighlightingInStrings';
 export class DisableHighlightingOfAmbiguousCharactersAction extends EditorAction {
     constructor() {
         super({
             id: DisableHighlightingOfAmbiguousCharactersAction.ID,
-            label: nls.localize('action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters', 'Disable highlighting of ambiguous characters'),
+            label: nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters', 'Disable highlighting of ambiguous characters'),
             alias: 'Disable highlighting of ambiguous characters',
             precondition: undefined
         });
-        this.shortLabel = nls.localize('unicodeHighlight.disableHighlightingOfAmbiguousCharacters.shortLabel', 'Disable Ambiguous Highlight');
+        this.shortLabel = nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlight.disableHighlightingOfAmbiguousCharacters.shortLabel', 'Disable Ambiguous Highlight');
     }
-    run(accessor, editor, args) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
-            if (configurationService) {
-                this.runAction(configurationService);
-            }
-        });
+    async run(accessor, editor, args) {
+        const configurationService = accessor?.get(IConfigurationService);
+        if (configurationService) {
+            this.runAction(configurationService);
+        }
     }
-    runAction(configurationService) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield configurationService.updateValue(unicodeHighlightConfigKeys.ambiguousCharacters, false, 2 /* ConfigurationTarget.USER */);
-        });
+    async runAction(configurationService) {
+        await configurationService.updateValue(unicodeHighlightConfigKeys.ambiguousCharacters, false, 2 /* ConfigurationTarget.USER */);
     }
 }
 DisableHighlightingOfAmbiguousCharactersAction.ID = 'editor.action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters';
@@ -544,24 +537,20 @@
     constructor() {
         super({
             id: DisableHighlightingOfInvisibleCharactersAction.ID,
-            label: nls.localize('action.unicodeHighlight.disableHighlightingOfInvisibleCharacters', 'Disable highlighting of invisible characters'),
+            label: nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'action.unicodeHighlight.disableHighlightingOfInvisibleCharacters', 'Disable highlighting of invisible characters'),
             alias: 'Disable highlighting of invisible characters',
             precondition: undefined
         });
-        this.shortLabel = nls.localize('unicodeHighlight.disableHighlightingOfInvisibleCharacters.shortLabel', 'Disable Invisible Highlight');
+        this.shortLabel = nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlight.disableHighlightingOfInvisibleCharacters.shortLabel', 'Disable Invisible Highlight');
     }
-    run(accessor, editor, args) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
-            if (configurationService) {
-                this.runAction(configurationService);
-            }
-        });
+    async run(accessor, editor, args) {
+        const configurationService = accessor?.get(IConfigurationService);
+        if (configurationService) {
+            this.runAction(configurationService);
+        }
     }
-    runAction(configurationService) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield configurationService.updateValue(unicodeHighlightConfigKeys.invisibleCharacters, false, 2 /* ConfigurationTarget.USER */);
-        });
+    async runAction(configurationService) {
+        await configurationService.updateValue(unicodeHighlightConfigKeys.invisibleCharacters, false, 2 /* ConfigurationTarget.USER */);
     }
 }
 DisableHighlightingOfInvisibleCharactersAction.ID = 'editor.action.unicodeHighlight.disableHighlightingOfInvisibleCharacters';
@@ -569,24 +558,20 @@
     constructor() {
         super({
             id: DisableHighlightingOfNonBasicAsciiCharactersAction.ID,
-            label: nls.localize('action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters', 'Disable highlighting of non basic ASCII characters'),
+            label: nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters', 'Disable highlighting of non basic ASCII characters'),
             alias: 'Disable highlighting of non basic ASCII characters',
             precondition: undefined
         });
-        this.shortLabel = nls.localize('unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters.shortLabel', 'Disable Non ASCII Highlight');
+        this.shortLabel = nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters.shortLabel', 'Disable Non ASCII Highlight');
     }
-    run(accessor, editor, args) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
-            if (configurationService) {
-                this.runAction(configurationService);
-            }
-        });
+    async run(accessor, editor, args) {
+        const configurationService = accessor?.get(IConfigurationService);
+        if (configurationService) {
+            this.runAction(configurationService);
+        }
     }
-    runAction(configurationService) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield configurationService.updateValue(unicodeHighlightConfigKeys.nonBasicASCII, false, 2 /* ConfigurationTarget.USER */);
-        });
+    async runAction(configurationService) {
+        await configurationService.updateValue(unicodeHighlightConfigKeys.nonBasicASCII, false, 2 /* ConfigurationTarget.USER */);
     }
 }
 DisableHighlightingOfNonBasicAsciiCharactersAction.ID = 'editor.action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters';
@@ -594,102 +579,95 @@
     constructor() {
         super({
             id: ShowExcludeOptions.ID,
-            label: nls.localize('action.unicodeHighlight.showExcludeOptions', "Show Exclude Options"),
+            label: nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'action.unicodeHighlight.showExcludeOptions', "Show Exclude Options"),
             alias: 'Show Exclude Options',
             precondition: undefined
         });
     }
-    run(accessor, editor, args) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const { codePoint, reason, inString, inComment } = args;
-            const char = String.fromCodePoint(codePoint);
-            const quickPickService = accessor.get(IQuickInputService);
-            const configurationService = accessor.get(IConfigurationService);
-            function getExcludeCharFromBeingHighlightedLabel(codePoint) {
-                if (InvisibleCharacters.isInvisibleCharacter(codePoint)) {
-                    return nls.localize('unicodeHighlight.excludeInvisibleCharFromBeingHighlighted', 'Exclude {0} (invisible character) from being highlighted', codePointToHex(codePoint));
-                }
-                return nls.localize('unicodeHighlight.excludeCharFromBeingHighlighted', 'Exclude {0} from being highlighted', `${codePointToHex(codePoint)} "${char}"`);
-            }
-            const options = [];
-            if (reason.kind === 0 /* UnicodeHighlighterReasonKind.Ambiguous */) {
-                for (const locale of reason.notAmbiguousInLocales) {
-                    options.push({
-                        label: nls.localize("unicodeHighlight.allowCommonCharactersInLanguage", "Allow unicode characters that are more common in the language \"{0}\".", locale),
-                        run: () => __awaiter(this, void 0, void 0, function* () {
-                            excludeLocaleFromBeingHighlighted(configurationService, [locale]);
-                        }),
-                    });
-                }
-            }
-            options.push({
-                label: getExcludeCharFromBeingHighlightedLabel(codePoint),
-                run: () => excludeCharFromBeingHighlighted(configurationService, [codePoint])
-            });
-            if (inComment) {
-                const action = new DisableHighlightingInCommentsAction();
-                options.push({ label: action.label, run: () => __awaiter(this, void 0, void 0, function* () { return action.runAction(configurationService); }) });
-            }
-            else if (inString) {
-                const action = new DisableHighlightingInStringsAction();
-                options.push({ label: action.label, run: () => __awaiter(this, void 0, void 0, function* () { return action.runAction(configurationService); }) });
-            }
-            if (reason.kind === 0 /* UnicodeHighlighterReasonKind.Ambiguous */) {
-                const action = new DisableHighlightingOfAmbiguousCharactersAction();
-                options.push({ label: action.label, run: () => __awaiter(this, void 0, void 0, function* () { return action.runAction(configurationService); }) });
-            }
-            else if (reason.kind === 1 /* UnicodeHighlighterReasonKind.Invisible */) {
-                const action = new DisableHighlightingOfInvisibleCharactersAction();
-                options.push({ label: action.label, run: () => __awaiter(this, void 0, void 0, function* () { return action.runAction(configurationService); }) });
-            }
-            else if (reason.kind === 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */) {
-                const action = new DisableHighlightingOfNonBasicAsciiCharactersAction();
-                options.push({ label: action.label, run: () => __awaiter(this, void 0, void 0, function* () { return action.runAction(configurationService); }) });
-            }
-            else {
-                expectNever(reason);
-            }
-            const result = yield quickPickService.pick(options, { title: nls.localize('unicodeHighlight.configureUnicodeHighlightOptions', 'Configure Unicode Highlight Options') });
-            if (result) {
-                yield result.run();
+    async run(accessor, editor, args) {
+        const { codePoint, reason, inString, inComment } = args;
+        const char = String.fromCodePoint(codePoint);
+        const quickPickService = accessor.get(IQuickInputService);
+        const configurationService = accessor.get(IConfigurationService);
+        function getExcludeCharFromBeingHighlightedLabel(codePoint) {
+            if (InvisibleCharacters.isInvisibleCharacter(codePoint)) {
+                return nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlight.excludeInvisibleCharFromBeingHighlighted', 'Exclude {0} (invisible character) from being highlighted', codePointToHex(codePoint));
+            }
+            return nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlight.excludeCharFromBeingHighlighted', 'Exclude {0} from being highlighted', `${codePointToHex(codePoint)} "${char}"`);
+        }
+        const options = [];
+        if (reason.kind === 0 /* UnicodeHighlighterReasonKind.Ambiguous */) {
+            for (const locale of reason.notAmbiguousInLocales) {
+                options.push({
+                    label: nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', "unicodeHighlight.allowCommonCharactersInLanguage", "Allow unicode characters that are more common in the language \"{0}\".", locale),
+                    run: async () => {
+                        excludeLocaleFromBeingHighlighted(configurationService, [locale]);
+                    },
+                });
             }
-        });
-    }
-}
-ShowExcludeOptions.ID = 'editor.action.unicodeHighlight.showExcludeOptions';
-function excludeCharFromBeingHighlighted(configurationService, charCodes) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const existingValue = configurationService.getValue(unicodeHighlightConfigKeys.allowedCharacters);
-        let value;
-        if ((typeof existingValue === 'object') && existingValue) {
-            value = existingValue;
-        }
-        else {
-            value = {};
-        }
-        for (const charCode of charCodes) {
-            value[String.fromCodePoint(charCode)] = true;
         }
-        yield configurationService.updateValue(unicodeHighlightConfigKeys.allowedCharacters, value, 2 /* ConfigurationTarget.USER */);
-    });
-}
-function excludeLocaleFromBeingHighlighted(configurationService, locales) {
-    var _a;
-    return __awaiter(this, void 0, void 0, function* () {
-        const existingValue = (_a = configurationService.inspect(unicodeHighlightConfigKeys.allowedLocales).user) === null || _a === void 0 ? void 0 : _a.value;
-        let value;
-        if ((typeof existingValue === 'object') && existingValue) {
-            // Copy value, as the existing value is read only
-            value = Object.assign({}, existingValue);
+        options.push({
+            label: getExcludeCharFromBeingHighlightedLabel(codePoint),
+            run: () => excludeCharFromBeingHighlighted(configurationService, [codePoint])
+        });
+        if (inComment) {
+            const action = new DisableHighlightingInCommentsAction();
+            options.push({ label: action.label, run: async () => action.runAction(configurationService) });
+        }
+        else if (inString) {
+            const action = new DisableHighlightingInStringsAction();
+            options.push({ label: action.label, run: async () => action.runAction(configurationService) });
+        }
+        if (reason.kind === 0 /* UnicodeHighlighterReasonKind.Ambiguous */) {
+            const action = new DisableHighlightingOfAmbiguousCharactersAction();
+            options.push({ label: action.label, run: async () => action.runAction(configurationService) });
+        }
+        else if (reason.kind === 1 /* UnicodeHighlighterReasonKind.Invisible */) {
+            const action = new DisableHighlightingOfInvisibleCharactersAction();
+            options.push({ label: action.label, run: async () => action.runAction(configurationService) });
+        }
+        else if (reason.kind === 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */) {
+            const action = new DisableHighlightingOfNonBasicAsciiCharactersAction();
+            options.push({ label: action.label, run: async () => action.runAction(configurationService) });
         }
         else {
-            value = {};
+            expectNever(reason);
         }
-        for (const locale of locales) {
-            value[locale] = true;
+        const result = await quickPickService.pick(options, { title: nls.localizeWithPath('vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter', 'unicodeHighlight.configureUnicodeHighlightOptions', 'Configure Unicode Highlight Options') });
+        if (result) {
+            await result.run();
         }
-        yield configurationService.updateValue(unicodeHighlightConfigKeys.allowedLocales, value, 2 /* ConfigurationTarget.USER */);
-    });
+    }
+}
+ShowExcludeOptions.ID = 'editor.action.unicodeHighlight.showExcludeOptions';
+async function excludeCharFromBeingHighlighted(configurationService, charCodes) {
+    const existingValue = configurationService.getValue(unicodeHighlightConfigKeys.allowedCharacters);
+    let value;
+    if ((typeof existingValue === 'object') && existingValue) {
+        value = existingValue;
+    }
+    else {
+        value = {};
+    }
+    for (const charCode of charCodes) {
+        value[String.fromCodePoint(charCode)] = true;
+    }
+    await configurationService.updateValue(unicodeHighlightConfigKeys.allowedCharacters, value, 2 /* ConfigurationTarget.USER */);
+}
+async function excludeLocaleFromBeingHighlighted(configurationService, locales) {
+    const existingValue = configurationService.inspect(unicodeHighlightConfigKeys.allowedLocales).user?.value;
+    let value;
+    if ((typeof existingValue === 'object') && existingValue) {
+        // Copy value, as the existing value is read only
+        value = Object.assign({}, existingValue);
+    }
+    else {
+        value = {};
+    }
+    for (const locale of locales) {
+        value[locale] = true;
+    }
+    await configurationService.updateValue(unicodeHighlightConfigKeys.allowedLocales, value, 2 /* ConfigurationTarget.USER */);
 }
 function expectNever(value) {
     throw new Error(`Unexpected value: ${value}`);
diff -urN -x '*.map' a/vs/editor/contrib/unusualLineTerminators/browser/unusualLineTerminators.js b/vs/editor/contrib/unusualLineTerminators/browser/unusualLineTerminators.js
--- a/vs/editor/contrib/unusualLineTerminators/browser/unusualLineTerminators.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/contrib/unusualLineTerminators/browser/unusualLineTerminators.js	2023-12-06 14:23:14.383854791 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { Disposable } from '../../../../base/common/lifecycle.js';
 import { basename } from '../../../../base/common/resources.js';
 import { registerEditorContribution } from '../../../browser/editorExtensions.js';
@@ -59,58 +50,56 @@
         }));
         this._checkForUnusualLineTerminators();
     }
-    _checkForUnusualLineTerminators() {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (this._config === 'off') {
-                return;
-            }
-            if (!this._editor.hasModel()) {
-                return;
-            }
-            const model = this._editor.getModel();
-            if (!model.mightContainUnusualLineTerminators()) {
-                return;
-            }
-            const ignoreState = readIgnoreState(this._codeEditorService, model);
-            if (ignoreState === true) {
-                // this model should be ignored
-                return;
-            }
-            if (this._editor.getOption(90 /* EditorOption.readOnly */)) {
-                // read only editor => sorry!
-                return;
-            }
-            if (this._config === 'auto') {
-                // just do it!
-                model.removeUnusualLineTerminators(this._editor.getSelections());
-                return;
-            }
-            if (this._isPresentingDialog) {
-                // we're currently showing the dialog, which is async.
-                // avoid spamming the user
-                return;
-            }
-            let result;
-            try {
-                this._isPresentingDialog = true;
-                result = yield this._dialogService.confirm({
-                    title: nls.localize('unusualLineTerminators.title', "Unusual Line Terminators"),
-                    message: nls.localize('unusualLineTerminators.message', "Detected unusual line terminators"),
-                    detail: nls.localize('unusualLineTerminators.detail', "The file '{0}' contains one or more unusual line terminator characters, like Line Separator (LS) or Paragraph Separator (PS).\n\nIt is recommended to remove them from the file. This can be configured via `editor.unusualLineTerminators`.", basename(model.uri)),
-                    primaryButton: nls.localize({ key: 'unusualLineTerminators.fix', comment: ['&& denotes a mnemonic'] }, "&&Remove Unusual Line Terminators"),
-                    cancelButton: nls.localize('unusualLineTerminators.ignore', "Ignore")
-                });
-            }
-            finally {
-                this._isPresentingDialog = false;
-            }
-            if (!result.confirmed) {
-                // this model should be ignored
-                writeIgnoreState(this._codeEditorService, model, true);
-                return;
-            }
+    async _checkForUnusualLineTerminators() {
+        if (this._config === 'off') {
+            return;
+        }
+        if (!this._editor.hasModel()) {
+            return;
+        }
+        const model = this._editor.getModel();
+        if (!model.mightContainUnusualLineTerminators()) {
+            return;
+        }
+        const ignoreState = readIgnoreState(this._codeEditorService, model);
+        if (ignoreState === true) {
+            // this model should be ignored
+            return;
+        }
+        if (this._editor.getOption(90 /* EditorOption.readOnly */)) {
+            // read only editor => sorry!
+            return;
+        }
+        if (this._config === 'auto') {
+            // just do it!
             model.removeUnusualLineTerminators(this._editor.getSelections());
-        });
+            return;
+        }
+        if (this._isPresentingDialog) {
+            // we're currently showing the dialog, which is async.
+            // avoid spamming the user
+            return;
+        }
+        let result;
+        try {
+            this._isPresentingDialog = true;
+            result = await this._dialogService.confirm({
+                title: nls.localizeWithPath('vs/editor/contrib/unusualLineTerminators/browser/unusualLineTerminators', 'unusualLineTerminators.title', "Unusual Line Terminators"),
+                message: nls.localizeWithPath('vs/editor/contrib/unusualLineTerminators/browser/unusualLineTerminators', 'unusualLineTerminators.message', "Detected unusual line terminators"),
+                detail: nls.localizeWithPath('vs/editor/contrib/unusualLineTerminators/browser/unusualLineTerminators', 'unusualLineTerminators.detail', "The file '{0}' contains one or more unusual line terminator characters, like Line Separator (LS) or Paragraph Separator (PS).\n\nIt is recommended to remove them from the file. This can be configured via `editor.unusualLineTerminators`.", basename(model.uri)),
+                primaryButton: nls.localizeWithPath('vs/editor/contrib/unusualLineTerminators/browser/unusualLineTerminators', { key: 'unusualLineTerminators.fix', comment: ['&& denotes a mnemonic'] }, "&&Remove Unusual Line Terminators"),
+                cancelButton: nls.localizeWithPath('vs/editor/contrib/unusualLineTerminators/browser/unusualLineTerminators', 'unusualLineTerminators.ignore', "Ignore")
+            });
+        }
+        finally {
+            this._isPresentingDialog = false;
+        }
+        if (!result.confirmed) {
+            // this model should be ignored
+            writeIgnoreState(this._codeEditorService, model, true);
+            return;
+        }
+        model.removeUnusualLineTerminators(this._editor.getSelections());
     }
 };
 UnusualLineTerminatorsDetector.ID = 'editor.contrib.unusualLineTerminatorsDetector';
diff -urN -x '*.map' a/vs/editor/contrib/wordHighlighter/browser/highlightDecorations.js b/vs/editor/contrib/wordHighlighter/browser/highlightDecorations.js
--- a/vs/editor/contrib/wordHighlighter/browser/highlightDecorations.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/wordHighlighter/browser/highlightDecorations.js	2023-12-06 14:23:14.383854791 +0000
@@ -9,15 +9,15 @@
 import * as nls from '../../../../nls.js';
 import { activeContrastBorder, editorSelectionHighlight, minimapSelectionOccurrenceHighlight, overviewRulerSelectionHighlightForeground, registerColor } from '../../../../platform/theme/common/colorRegistry.js';
 import { registerThemingParticipant, themeColorFromId } from '../../../../platform/theme/common/themeService.js';
-const wordHighlightBackground = registerColor('editor.wordHighlightBackground', { dark: '#575757B8', light: '#57575740', hcDark: null, hcLight: null }, nls.localize('wordHighlight', 'Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations.'), true);
-registerColor('editor.wordHighlightStrongBackground', { dark: '#004972B8', light: '#0e639c40', hcDark: null, hcLight: null }, nls.localize('wordHighlightStrong', 'Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations.'), true);
-registerColor('editor.wordHighlightTextBackground', { light: wordHighlightBackground, dark: wordHighlightBackground, hcDark: wordHighlightBackground, hcLight: wordHighlightBackground }, nls.localize('wordHighlightText', 'Background color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations.'), true);
-const wordHighlightBorder = registerColor('editor.wordHighlightBorder', { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('wordHighlightBorder', 'Border color of a symbol during read-access, like reading a variable.'));
-registerColor('editor.wordHighlightStrongBorder', { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('wordHighlightStrongBorder', 'Border color of a symbol during write-access, like writing to a variable.'));
-registerColor('editor.wordHighlightTextBorder', { light: wordHighlightBorder, dark: wordHighlightBorder, hcDark: wordHighlightBorder, hcLight: wordHighlightBorder }, nls.localize('wordHighlightTextBorder', "Border color of a textual occurrence for a symbol."));
-const overviewRulerWordHighlightForeground = registerColor('editorOverviewRuler.wordHighlightForeground', { dark: '#A0A0A0CC', light: '#A0A0A0CC', hcDark: '#A0A0A0CC', hcLight: '#A0A0A0CC' }, nls.localize('overviewRulerWordHighlightForeground', 'Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations.'), true);
-const overviewRulerWordHighlightStrongForeground = registerColor('editorOverviewRuler.wordHighlightStrongForeground', { dark: '#C0A0C0CC', light: '#C0A0C0CC', hcDark: '#C0A0C0CC', hcLight: '#C0A0C0CC' }, nls.localize('overviewRulerWordHighlightStrongForeground', 'Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations.'), true);
-const overviewRulerWordHighlightTextForeground = registerColor('editorOverviewRuler.wordHighlightTextForeground', { dark: overviewRulerSelectionHighlightForeground, light: overviewRulerSelectionHighlightForeground, hcDark: overviewRulerSelectionHighlightForeground, hcLight: overviewRulerSelectionHighlightForeground }, nls.localize('overviewRulerWordHighlightTextForeground', 'Overview ruler marker color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations.'), true);
+const wordHighlightBackground = registerColor('editor.wordHighlightBackground', { dark: '#575757B8', light: '#57575740', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/contrib/wordHighlighter/browser/highlightDecorations', 'wordHighlight', 'Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations.'), true);
+registerColor('editor.wordHighlightStrongBackground', { dark: '#004972B8', light: '#0e639c40', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/editor/contrib/wordHighlighter/browser/highlightDecorations', 'wordHighlightStrong', 'Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations.'), true);
+registerColor('editor.wordHighlightTextBackground', { light: wordHighlightBackground, dark: wordHighlightBackground, hcDark: wordHighlightBackground, hcLight: wordHighlightBackground }, nls.localizeWithPath('vs/editor/contrib/wordHighlighter/browser/highlightDecorations', 'wordHighlightText', 'Background color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations.'), true);
+const wordHighlightBorder = registerColor('editor.wordHighlightBorder', { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localizeWithPath('vs/editor/contrib/wordHighlighter/browser/highlightDecorations', 'wordHighlightBorder', 'Border color of a symbol during read-access, like reading a variable.'));
+registerColor('editor.wordHighlightStrongBorder', { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localizeWithPath('vs/editor/contrib/wordHighlighter/browser/highlightDecorations', 'wordHighlightStrongBorder', 'Border color of a symbol during write-access, like writing to a variable.'));
+registerColor('editor.wordHighlightTextBorder', { light: wordHighlightBorder, dark: wordHighlightBorder, hcDark: wordHighlightBorder, hcLight: wordHighlightBorder }, nls.localizeWithPath('vs/editor/contrib/wordHighlighter/browser/highlightDecorations', 'wordHighlightTextBorder', "Border color of a textual occurrence for a symbol."));
+const overviewRulerWordHighlightForeground = registerColor('editorOverviewRuler.wordHighlightForeground', { dark: '#A0A0A0CC', light: '#A0A0A0CC', hcDark: '#A0A0A0CC', hcLight: '#A0A0A0CC' }, nls.localizeWithPath('vs/editor/contrib/wordHighlighter/browser/highlightDecorations', 'overviewRulerWordHighlightForeground', 'Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations.'), true);
+const overviewRulerWordHighlightStrongForeground = registerColor('editorOverviewRuler.wordHighlightStrongForeground', { dark: '#C0A0C0CC', light: '#C0A0C0CC', hcDark: '#C0A0C0CC', hcLight: '#C0A0C0CC' }, nls.localizeWithPath('vs/editor/contrib/wordHighlighter/browser/highlightDecorations', 'overviewRulerWordHighlightStrongForeground', 'Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations.'), true);
+const overviewRulerWordHighlightTextForeground = registerColor('editorOverviewRuler.wordHighlightTextForeground', { dark: overviewRulerSelectionHighlightForeground, light: overviewRulerSelectionHighlightForeground, hcDark: overviewRulerSelectionHighlightForeground, hcLight: overviewRulerSelectionHighlightForeground }, nls.localizeWithPath('vs/editor/contrib/wordHighlighter/browser/highlightDecorations', 'overviewRulerWordHighlightTextForeground', 'Overview ruler marker color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations.'), true);
 const _WRITE_OPTIONS = ModelDecorationOptions.register({
     description: 'word-highlight-strong',
     stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,
diff -urN -x '*.map' a/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js b/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js
--- a/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js	2023-12-06 14:22:33.803782415 +0000
+++ b/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js	2023-12-06 14:23:14.387854798 +0000
@@ -17,7 +17,7 @@
 import { createCancelablePromise, first, timeout } from '../../../../base/common/async.js';
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { onUnexpectedError, onUnexpectedExternalError } from '../../../../base/common/errors.js';
-import { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';
+import { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';
 import { EditorAction, registerEditorAction, registerEditorContribution, registerModelAndPositionCommand } from '../../../browser/editorExtensions.js';
 import { Range } from '../../../common/core/range.js';
 import { EditorContextKeys } from '../../../common/editorContextKeys.js';
@@ -184,6 +184,12 @@
         }
         this._run();
     }
+    stop() {
+        if (!this.occurrencesHighlight) {
+            return;
+        }
+        this._stopAll();
+    }
     _getSortedHighlights() {
         return (this.decorations.getRanges()
             .sort(Range.compareRangesUsingStarts));
@@ -357,7 +363,7 @@
         this._hasWordHighlights.set(this.hasDecorations());
         // update decorators of friends
         for (const other of this.linkedHighlighters()) {
-            if ((other === null || other === void 0 ? void 0 : other.editor.getModel()) === this.editor.getModel()) {
+            if (other?.editor.getModel() === this.editor.getModel()) {
                 other._stopAll();
                 other.decorations.set(decorations);
                 other._hasWordHighlights.set(other.hasDecorations());
@@ -398,18 +404,31 @@
         return false;
     }
     moveNext() {
-        var _a;
-        (_a = this.wordHighlighter) === null || _a === void 0 ? void 0 : _a.moveNext();
+        this.wordHighlighter?.moveNext();
     }
     moveBack() {
-        var _a;
-        (_a = this.wordHighlighter) === null || _a === void 0 ? void 0 : _a.moveBack();
+        this.wordHighlighter?.moveBack();
     }
     restoreViewState(state) {
         if (this.wordHighlighter && state) {
             this.wordHighlighter.restore();
         }
     }
+    stopHighlighting() {
+        this.wordHighlighter?.stop();
+    }
+    linkWordHighlighters(editor) {
+        const other = WordHighlighterContribution_1.get(editor);
+        if (!other) {
+            return Disposable.None;
+        }
+        this.linkedContributions.add(other);
+        other.linkedContributions.add(this);
+        return toDisposable(() => {
+            this.linkedContributions.delete(other);
+            other.linkedContributions.delete(this);
+        });
+    }
     dispose() {
         if (this.wordHighlighter) {
             this.wordHighlighter.dispose();
@@ -446,7 +465,7 @@
     constructor() {
         super(true, {
             id: 'editor.action.wordHighlight.next',
-            label: nls.localize('wordHighlight.next.label', "Go to Next Symbol Highlight"),
+            label: nls.localizeWithPath('vs/editor/contrib/wordHighlighter/browser/wordHighlighter', 'wordHighlight.next.label', "Go to Next Symbol Highlight"),
             alias: 'Go to Next Symbol Highlight',
             precondition: ctxHasWordHighlights,
             kbOpts: {
@@ -461,7 +480,7 @@
     constructor() {
         super(false, {
             id: 'editor.action.wordHighlight.prev',
-            label: nls.localize('wordHighlight.previous.label', "Go to Previous Symbol Highlight"),
+            label: nls.localizeWithPath('vs/editor/contrib/wordHighlighter/browser/wordHighlighter', 'wordHighlight.previous.label', "Go to Previous Symbol Highlight"),
             alias: 'Go to Previous Symbol Highlight',
             precondition: ctxHasWordHighlights,
             kbOpts: {
@@ -476,7 +495,7 @@
     constructor() {
         super({
             id: 'editor.action.wordHighlight.trigger',
-            label: nls.localize('wordHighlight.trigger.label', "Trigger Symbol Highlight"),
+            label: nls.localizeWithPath('vs/editor/contrib/wordHighlighter/browser/wordHighlighter', 'wordHighlight.trigger.label', "Trigger Symbol Highlight"),
             alias: 'Trigger Symbol Highlight',
             precondition: ctxHasWordHighlights.toNegated(),
             kbOpts: {
diff -urN -x '*.map' a/vs/editor/contrib/wordOperations/browser/wordOperations.js b/vs/editor/contrib/wordOperations/browser/wordOperations.js
--- a/vs/editor/contrib/wordOperations/browser/wordOperations.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/contrib/wordOperations/browser/wordOperations.js	2023-12-06 14:23:14.387854798 +0000
@@ -85,14 +85,13 @@
 }
 export class CursorWordLeft extends WordLeftCommand {
     constructor() {
-        var _a;
         super({
             inSelectionMode: false,
             wordNavigationType: 1 /* WordNavigationType.WordStartFast */,
             id: 'cursorWordLeft',
             precondition: undefined,
             kbOpts: {
-                kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a === void 0 ? void 0 : _a.negate()),
+                kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)?.negate()),
                 primary: 2048 /* KeyMod.CtrlCmd */ | 15 /* KeyCode.LeftArrow */,
                 mac: { primary: 512 /* KeyMod.Alt */ | 15 /* KeyCode.LeftArrow */ },
                 weight: 100 /* KeybindingWeight.EditorContrib */
@@ -122,14 +121,13 @@
 }
 export class CursorWordLeftSelect extends WordLeftCommand {
     constructor() {
-        var _a;
         super({
             inSelectionMode: true,
             wordNavigationType: 1 /* WordNavigationType.WordStartFast */,
             id: 'cursorWordLeftSelect',
             precondition: undefined,
             kbOpts: {
-                kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a === void 0 ? void 0 : _a.negate()),
+                kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)?.negate()),
                 primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 15 /* KeyCode.LeftArrow */,
                 mac: { primary: 512 /* KeyMod.Alt */ | 1024 /* KeyMod.Shift */ | 15 /* KeyCode.LeftArrow */ },
                 weight: 100 /* KeybindingWeight.EditorContrib */
@@ -176,14 +174,13 @@
 }
 export class CursorWordEndRight extends WordRightCommand {
     constructor() {
-        var _a;
         super({
             inSelectionMode: false,
             wordNavigationType: 2 /* WordNavigationType.WordEnd */,
             id: 'cursorWordEndRight',
             precondition: undefined,
             kbOpts: {
-                kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a === void 0 ? void 0 : _a.negate()),
+                kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)?.negate()),
                 primary: 2048 /* KeyMod.CtrlCmd */ | 17 /* KeyCode.RightArrow */,
                 mac: { primary: 512 /* KeyMod.Alt */ | 17 /* KeyCode.RightArrow */ },
                 weight: 100 /* KeybindingWeight.EditorContrib */
@@ -213,14 +210,13 @@
 }
 export class CursorWordEndRightSelect extends WordRightCommand {
     constructor() {
-        var _a;
         super({
             inSelectionMode: true,
             wordNavigationType: 2 /* WordNavigationType.WordEnd */,
             id: 'cursorWordEndRightSelect',
             precondition: undefined,
             kbOpts: {
-                kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a === void 0 ? void 0 : _a.negate()),
+                kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)?.negate()),
                 primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 17 /* KeyCode.RightArrow */,
                 mac: { primary: 512 /* KeyMod.Alt */ | 1024 /* KeyMod.Shift */ | 17 /* KeyCode.RightArrow */ },
                 weight: 100 /* KeybindingWeight.EditorContrib */
@@ -398,7 +394,7 @@
         super({
             id: 'deleteInsideWord',
             precondition: EditorContextKeys.writable,
-            label: nls.localize('deleteInsideWord', "Delete Word"),
+            label: nls.localizeWithPath('vs/editor/contrib/wordOperations/browser/wordOperations', 'deleteInsideWord', "Delete Word"),
             alias: 'Delete Word'
         });
     }
diff -urN -x '*.map' a/vs/editor/contrib/zoneWidget/browser/zoneWidget.js b/vs/editor/contrib/zoneWidget/browser/zoneWidget.js
--- a/vs/editor/contrib/zoneWidget/browser/zoneWidget.js	2023-12-06 14:22:33.807782422 +0000
+++ b/vs/editor/contrib/zoneWidget/browser/zoneWidget.js	2023-12-06 14:23:14.387854798 +0000
@@ -193,7 +193,6 @@
         this.domNode.style.top = top + 'px';
     }
     _onViewZoneHeight(height) {
-        var _a;
         this.domNode.style.height = `${height}px`;
         if (this.container) {
             const containerHeight = height - this._decoratingElementsHeight();
@@ -201,7 +200,7 @@
             const layoutInfo = this.editor.getLayoutInfo();
             this._doLayout(containerHeight, this._getWidth(layoutInfo));
         }
-        (_a = this._resizeSash) === null || _a === void 0 ? void 0 : _a.layout();
+        this._resizeSash?.layout();
     }
     get position() {
         const range = this._positionMarkerId.getRange(0);
@@ -210,6 +209,9 @@
         }
         return range.getStartPosition();
     }
+    hasFocus() {
+        return this.domNode.contains(dom.getActiveElement());
+    }
     show(rangeOrPos, heightInLines) {
         const range = Range.isIRange(rangeOrPos) ? Range.lift(rangeOrPos) : Range.fromPositions(rangeOrPos);
         this._isShowing = true;
@@ -218,7 +220,6 @@
         this._positionMarkerId.set([{ range, options: ModelDecorationOptions.EMPTY }]);
     }
     hide() {
-        var _a;
         if (this._viewZone) {
             this.editor.changeViewZones(accessor => {
                 if (this._viewZone) {
@@ -231,7 +232,7 @@
             this.editor.removeOverlayWidget(this._overlayWidget);
             this._overlayWidget = null;
         }
-        (_a = this._arrow) === null || _a === void 0 ? void 0 : _a.hide();
+        this._arrow?.hide();
         this._positionMarkerId.clear();
     }
     _decoratingElementsHeight() {
diff -urN -x '*.map' a/vs/editor/edcore.main.js b/vs/editor/edcore.main.js
--- a/vs/editor/edcore.main.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/edcore.main.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,14 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-import './editor.all.js';
-import './standalone/browser/iPadShowKeyboard/iPadShowKeyboard.js';
-import './standalone/browser/inspectTokens/inspectTokens.js';
-import './standalone/browser/quickAccess/standaloneHelpQuickAccess.js';
-import './standalone/browser/quickAccess/standaloneGotoLineQuickAccess.js';
-import './standalone/browser/quickAccess/standaloneGotoSymbolQuickAccess.js';
-import './standalone/browser/quickAccess/standaloneCommandsQuickAccess.js';
-import './standalone/browser/referenceSearch/standaloneReferenceSearch.js';
-import './standalone/browser/toggleHighContrast/toggleHighContrast.js';
-export * from './editor.api.js';
diff -urN -x '*.map' a/vs/editor/editor.api.js b/vs/editor/editor.api.js
--- a/vs/editor/editor.api.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/editor.api.js	2023-12-06 14:23:14.355854741 +0000
@@ -33,7 +33,7 @@
 export const editor = api.editor;
 export const languages = api.languages;
 const monacoEnvironment = globalThis.MonacoEnvironment;
-if ((monacoEnvironment === null || monacoEnvironment === void 0 ? void 0 : monacoEnvironment.globalAPI) || (typeof define === 'function' && define.amd)) {
+if (monacoEnvironment?.globalAPI || (typeof define === 'function' && define.amd)) {
     globalThis.monaco = api;
 }
 if (typeof globalThis.require !== 'undefined' && typeof globalThis.require.config === 'function') {
diff -urN -x '*.map' a/vs/editor/editor.main.js b/vs/editor/editor.main.js
--- a/vs/editor/editor.main.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/editor.main.js	2023-12-06 14:23:14.355854741 +0000
@@ -1,7 +1,7 @@
-import '../basic-languages/monaco.contribution';
-import '../language/css/monaco.contribution';
-import '../language/html/monaco.contribution';
-import '../language/json/monaco.contribution';
-import '../language/typescript/monaco.contribution';
-
-export * from './edcore.main';
\ No newline at end of file
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import './editor.all.js';
+import './standalone/browser/iPadShowKeyboard/iPadShowKeyboard.js';
+export * from './editor.api.js';
diff -urN -x '*.map' a/vs/editor/standalone/browser/colorizer.js b/vs/editor/standalone/browser/colorizer.js
--- a/vs/editor/standalone/browser/colorizer.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/colorizer.js	2023-12-06 14:23:14.387854798 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { createTrustedTypesPolicy } from '../../../base/browser/trustedTypes.js';
 import * as strings from '../../../base/common/strings.js';
 import { TokenizationRegistry } from '../../common/languages.js';
@@ -33,32 +24,29 @@
         const text = domNode.firstChild ? domNode.firstChild.nodeValue : '';
         domNode.className += ' ' + theme;
         const render = (str) => {
-            var _a;
-            const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(str)) !== null && _a !== void 0 ? _a : str;
+            const trustedhtml = ttPolicy?.createHTML(str) ?? str;
             domNode.innerHTML = trustedhtml;
         };
         return this.colorize(languageService, text || '', languageId, options).then(render, (err) => console.error(err));
     }
-    static colorize(languageService, text, languageId, options) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const languageIdCodec = languageService.languageIdCodec;
-            let tabSize = 4;
-            if (options && typeof options.tabSize === 'number') {
-                tabSize = options.tabSize;
-            }
-            if (strings.startsWithUTF8BOM(text)) {
-                text = text.substr(1);
-            }
-            const lines = strings.splitLines(text);
-            if (!languageService.isRegisteredLanguageId(languageId)) {
-                return _fakeColorize(lines, tabSize, languageIdCodec);
-            }
-            const tokenizationSupport = yield TokenizationRegistry.getOrCreate(languageId);
-            if (tokenizationSupport) {
-                return _colorize(lines, tabSize, tokenizationSupport, languageIdCodec);
-            }
+    static async colorize(languageService, text, languageId, options) {
+        const languageIdCodec = languageService.languageIdCodec;
+        let tabSize = 4;
+        if (options && typeof options.tabSize === 'number') {
+            tabSize = options.tabSize;
+        }
+        if (strings.startsWithUTF8BOM(text)) {
+            text = text.substr(1);
+        }
+        const lines = strings.splitLines(text);
+        if (!languageService.isRegisteredLanguageId(languageId)) {
             return _fakeColorize(lines, tabSize, languageIdCodec);
-        });
+        }
+        const tokenizationSupport = await TokenizationRegistry.getOrCreate(languageId);
+        if (tokenizationSupport) {
+            return _colorize(lines, tabSize, tokenizationSupport, languageIdCodec);
+        }
+        return _fakeColorize(lines, tabSize, languageIdCodec);
     }
     static colorizeLine(line, mightContainNonBasicASCII, mightContainRTL, tokens, tabSize = 4) {
         const isBasicASCII = ViewLineRenderingData.isBasicASCII(line, mightContainNonBasicASCII);
diff -urN -x '*.map' a/vs/editor/standalone/browser/inspectTokens/inspectTokens.js b/vs/editor/standalone/browser/inspectTokens/inspectTokens.js
--- a/vs/editor/standalone/browser/inspectTokens/inspectTokens.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/inspectTokens/inspectTokens.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,238 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
-    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
-    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
-    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
-    return c > 3 && r && Object.defineProperty(target, key, r), r;
-};
-var __param = (this && this.__param) || function (paramIndex, decorator) {
-    return function (target, key) { decorator(target, key, paramIndex); }
-};
-var InspectTokensController_1;
-import './inspectTokens.css';
-import { $, append, reset } from '../../../../base/browser/dom.js';
-import { Color } from '../../../../base/common/color.js';
-import { Disposable } from '../../../../base/common/lifecycle.js';
-import { EditorAction, registerEditorAction, registerEditorContribution } from '../../../browser/editorExtensions.js';
-import { TokenizationRegistry } from '../../../common/languages.js';
-import { TokenMetadata } from '../../../common/encodedTokenAttributes.js';
-import { NullState, nullTokenize, nullTokenizeEncoded } from '../../../common/languages/nullTokenize.js';
-import { ILanguageService } from '../../../common/languages/language.js';
-import { IStandaloneThemeService } from '../../common/standaloneTheme.js';
-import { InspectTokensNLS } from '../../../common/standaloneStrings.js';
-let InspectTokensController = InspectTokensController_1 = class InspectTokensController extends Disposable {
-    static get(editor) {
-        return editor.getContribution(InspectTokensController_1.ID);
-    }
-    constructor(editor, standaloneColorService, languageService) {
-        super();
-        this._editor = editor;
-        this._languageService = languageService;
-        this._widget = null;
-        this._register(this._editor.onDidChangeModel((e) => this.stop()));
-        this._register(this._editor.onDidChangeModelLanguage((e) => this.stop()));
-        this._register(TokenizationRegistry.onDidChange((e) => this.stop()));
-        this._register(this._editor.onKeyUp((e) => e.keyCode === 9 /* KeyCode.Escape */ && this.stop()));
-    }
-    dispose() {
-        this.stop();
-        super.dispose();
-    }
-    launch() {
-        if (this._widget) {
-            return;
-        }
-        if (!this._editor.hasModel()) {
-            return;
-        }
-        this._widget = new InspectTokensWidget(this._editor, this._languageService);
-    }
-    stop() {
-        if (this._widget) {
-            this._widget.dispose();
-            this._widget = null;
-        }
-    }
-};
-InspectTokensController.ID = 'editor.contrib.inspectTokens';
-InspectTokensController = InspectTokensController_1 = __decorate([
-    __param(1, IStandaloneThemeService),
-    __param(2, ILanguageService)
-], InspectTokensController);
-class InspectTokens extends EditorAction {
-    constructor() {
-        super({
-            id: 'editor.action.inspectTokens',
-            label: InspectTokensNLS.inspectTokensAction,
-            alias: 'Developer: Inspect Tokens',
-            precondition: undefined
-        });
-    }
-    run(accessor, editor) {
-        const controller = InspectTokensController.get(editor);
-        controller === null || controller === void 0 ? void 0 : controller.launch();
-    }
-}
-function renderTokenText(tokenText) {
-    let result = '';
-    for (let charIndex = 0, len = tokenText.length; charIndex < len; charIndex++) {
-        const charCode = tokenText.charCodeAt(charIndex);
-        switch (charCode) {
-            case 9 /* CharCode.Tab */:
-                result += '\u2192'; // &rarr;
-                break;
-            case 32 /* CharCode.Space */:
-                result += '\u00B7'; // &middot;
-                break;
-            default:
-                result += String.fromCharCode(charCode);
-        }
-    }
-    return result;
-}
-function getSafeTokenizationSupport(languageIdCodec, languageId) {
-    const tokenizationSupport = TokenizationRegistry.get(languageId);
-    if (tokenizationSupport) {
-        return tokenizationSupport;
-    }
-    const encodedLanguageId = languageIdCodec.encodeLanguageId(languageId);
-    return {
-        getInitialState: () => NullState,
-        tokenize: (line, hasEOL, state) => nullTokenize(languageId, state),
-        tokenizeEncoded: (line, hasEOL, state) => nullTokenizeEncoded(encodedLanguageId, state)
-    };
-}
-class InspectTokensWidget extends Disposable {
-    constructor(editor, languageService) {
-        super();
-        // Editor.IContentWidget.allowEditorOverflow
-        this.allowEditorOverflow = true;
-        this._editor = editor;
-        this._languageService = languageService;
-        this._model = this._editor.getModel();
-        this._domNode = document.createElement('div');
-        this._domNode.className = 'tokens-inspect-widget';
-        this._tokenizationSupport = getSafeTokenizationSupport(this._languageService.languageIdCodec, this._model.getLanguageId());
-        this._compute(this._editor.getPosition());
-        this._register(this._editor.onDidChangeCursorPosition((e) => this._compute(this._editor.getPosition())));
-        this._editor.addContentWidget(this);
-    }
-    dispose() {
-        this._editor.removeContentWidget(this);
-        super.dispose();
-    }
-    getId() {
-        return InspectTokensWidget._ID;
-    }
-    _compute(position) {
-        const data = this._getTokensAtLine(position.lineNumber);
-        let token1Index = 0;
-        for (let i = data.tokens1.length - 1; i >= 0; i--) {
-            const t = data.tokens1[i];
-            if (position.column - 1 >= t.offset) {
-                token1Index = i;
-                break;
-            }
-        }
-        let token2Index = 0;
-        for (let i = (data.tokens2.length >>> 1); i >= 0; i--) {
-            if (position.column - 1 >= data.tokens2[(i << 1)]) {
-                token2Index = i;
-                break;
-            }
-        }
-        const lineContent = this._model.getLineContent(position.lineNumber);
-        let tokenText = '';
-        if (token1Index < data.tokens1.length) {
-            const tokenStartIndex = data.tokens1[token1Index].offset;
-            const tokenEndIndex = token1Index + 1 < data.tokens1.length ? data.tokens1[token1Index + 1].offset : lineContent.length;
-            tokenText = lineContent.substring(tokenStartIndex, tokenEndIndex);
-        }
-        reset(this._domNode, $('h2.tm-token', undefined, renderTokenText(tokenText), $('span.tm-token-length', undefined, `${tokenText.length} ${tokenText.length === 1 ? 'char' : 'chars'}`)));
-        append(this._domNode, $('hr.tokens-inspect-separator', { 'style': 'clear:both' }));
-        const metadata = (token2Index << 1) + 1 < data.tokens2.length ? this._decodeMetadata(data.tokens2[(token2Index << 1) + 1]) : null;
-        append(this._domNode, $('table.tm-metadata-table', undefined, $('tbody', undefined, $('tr', undefined, $('td.tm-metadata-key', undefined, 'language'), $('td.tm-metadata-value', undefined, `${metadata ? metadata.languageId : '-?-'}`)), $('tr', undefined, $('td.tm-metadata-key', undefined, 'token type'), $('td.tm-metadata-value', undefined, `${metadata ? this._tokenTypeToString(metadata.tokenType) : '-?-'}`)), $('tr', undefined, $('td.tm-metadata-key', undefined, 'font style'), $('td.tm-metadata-value', undefined, `${metadata ? this._fontStyleToString(metadata.fontStyle) : '-?-'}`)), $('tr', undefined, $('td.tm-metadata-key', undefined, 'foreground'), $('td.tm-metadata-value', undefined, `${metadata ? Color.Format.CSS.formatHex(metadata.foreground) : '-?-'}`)), $('tr', undefined, $('td.tm-metadata-key', undefined, 'background'), $('td.tm-metadata-value', undefined, `${metadata ? Color.Format.CSS.formatHex(metadata.background) : '-?-'}`)))));
-        append(this._domNode, $('hr.tokens-inspect-separator'));
-        if (token1Index < data.tokens1.length) {
-            append(this._domNode, $('span.tm-token-type', undefined, data.tokens1[token1Index].type));
-        }
-        this._editor.layoutContentWidget(this);
-    }
-    _decodeMetadata(metadata) {
-        const colorMap = TokenizationRegistry.getColorMap();
-        const languageId = TokenMetadata.getLanguageId(metadata);
-        const tokenType = TokenMetadata.getTokenType(metadata);
-        const fontStyle = TokenMetadata.getFontStyle(metadata);
-        const foreground = TokenMetadata.getForeground(metadata);
-        const background = TokenMetadata.getBackground(metadata);
-        return {
-            languageId: this._languageService.languageIdCodec.decodeLanguageId(languageId),
-            tokenType: tokenType,
-            fontStyle: fontStyle,
-            foreground: colorMap[foreground],
-            background: colorMap[background]
-        };
-    }
-    _tokenTypeToString(tokenType) {
-        switch (tokenType) {
-            case 0 /* StandardTokenType.Other */: return 'Other';
-            case 1 /* StandardTokenType.Comment */: return 'Comment';
-            case 2 /* StandardTokenType.String */: return 'String';
-            case 3 /* StandardTokenType.RegEx */: return 'RegEx';
-            default: return '??';
-        }
-    }
-    _fontStyleToString(fontStyle) {
-        let r = '';
-        if (fontStyle & 1 /* FontStyle.Italic */) {
-            r += 'italic ';
-        }
-        if (fontStyle & 2 /* FontStyle.Bold */) {
-            r += 'bold ';
-        }
-        if (fontStyle & 4 /* FontStyle.Underline */) {
-            r += 'underline ';
-        }
-        if (fontStyle & 8 /* FontStyle.Strikethrough */) {
-            r += 'strikethrough ';
-        }
-        if (r.length === 0) {
-            r = '---';
-        }
-        return r;
-    }
-    _getTokensAtLine(lineNumber) {
-        const stateBeforeLine = this._getStateBeforeLine(lineNumber);
-        const tokenizationResult1 = this._tokenizationSupport.tokenize(this._model.getLineContent(lineNumber), true, stateBeforeLine);
-        const tokenizationResult2 = this._tokenizationSupport.tokenizeEncoded(this._model.getLineContent(lineNumber), true, stateBeforeLine);
-        return {
-            startState: stateBeforeLine,
-            tokens1: tokenizationResult1.tokens,
-            tokens2: tokenizationResult2.tokens,
-            endState: tokenizationResult1.endState
-        };
-    }
-    _getStateBeforeLine(lineNumber) {
-        let state = this._tokenizationSupport.getInitialState();
-        for (let i = 1; i < lineNumber; i++) {
-            const tokenizationResult = this._tokenizationSupport.tokenize(this._model.getLineContent(i), true, state);
-            state = tokenizationResult.endState;
-        }
-        return state;
-    }
-    getDomNode() {
-        return this._domNode;
-    }
-    getPosition() {
-        return {
-            position: this._editor.getPosition(),
-            preference: [2 /* ContentWidgetPositionPreference.BELOW */, 1 /* ContentWidgetPositionPreference.ABOVE */]
-        };
-    }
-}
-InspectTokensWidget._ID = 'editor.contrib.inspectTokensWidget';
-registerEditorContribution(InspectTokensController.ID, InspectTokensController, 4 /* EditorContributionInstantiation.Lazy */);
-registerEditorAction(InspectTokens);
diff -urN -x '*.map' a/vs/editor/standalone/browser/quickAccess/standaloneCommandsQuickAccess.js b/vs/editor/standalone/browser/quickAccess/standaloneCommandsQuickAccess.js
--- a/vs/editor/standalone/browser/quickAccess/standaloneCommandsQuickAccess.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/quickAccess/standaloneCommandsQuickAccess.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,93 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
-    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
-    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
-    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
-    return c > 3 && r && Object.defineProperty(target, key, r), r;
-};
-var __param = (this && this.__param) || function (paramIndex, decorator) {
-    return function (target, key) { decorator(target, key, paramIndex); }
-};
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-import { Registry } from '../../../../platform/registry/common/platform.js';
-import { Extensions } from '../../../../platform/quickinput/common/quickAccess.js';
-import { QuickCommandNLS } from '../../../common/standaloneStrings.js';
-import { ICodeEditorService } from '../../../browser/services/codeEditorService.js';
-import { AbstractEditorCommandsQuickAccessProvider } from '../../../contrib/quickAccess/browser/commandsQuickAccess.js';
-import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
-import { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';
-import { ICommandService } from '../../../../platform/commands/common/commands.js';
-import { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';
-import { IDialogService } from '../../../../platform/dialogs/common/dialogs.js';
-import { EditorAction, registerEditorAction } from '../../../browser/editorExtensions.js';
-import { EditorContextKeys } from '../../../common/editorContextKeys.js';
-import { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';
-let StandaloneCommandsQuickAccessProvider = class StandaloneCommandsQuickAccessProvider extends AbstractEditorCommandsQuickAccessProvider {
-    get activeTextEditorControl() { var _a; return (_a = this.codeEditorService.getFocusedCodeEditor()) !== null && _a !== void 0 ? _a : undefined; }
-    constructor(instantiationService, codeEditorService, keybindingService, commandService, telemetryService, dialogService) {
-        super({ showAlias: false }, instantiationService, keybindingService, commandService, telemetryService, dialogService);
-        this.codeEditorService = codeEditorService;
-    }
-    getCommandPicks() {
-        return __awaiter(this, void 0, void 0, function* () {
-            return this.getCodeEditorCommandPicks();
-        });
-    }
-    hasAdditionalCommandPicks() {
-        return false;
-    }
-    getAdditionalCommandPicks() {
-        return __awaiter(this, void 0, void 0, function* () {
-            return [];
-        });
-    }
-};
-StandaloneCommandsQuickAccessProvider = __decorate([
-    __param(0, IInstantiationService),
-    __param(1, ICodeEditorService),
-    __param(2, IKeybindingService),
-    __param(3, ICommandService),
-    __param(4, ITelemetryService),
-    __param(5, IDialogService)
-], StandaloneCommandsQuickAccessProvider);
-export { StandaloneCommandsQuickAccessProvider };
-export class GotoLineAction extends EditorAction {
-    constructor() {
-        super({
-            id: GotoLineAction.ID,
-            label: QuickCommandNLS.quickCommandActionLabel,
-            alias: 'Command Palette',
-            precondition: undefined,
-            kbOpts: {
-                kbExpr: EditorContextKeys.focus,
-                primary: 59 /* KeyCode.F1 */,
-                weight: 100 /* KeybindingWeight.EditorContrib */
-            },
-            contextMenuOpts: {
-                group: 'z_commands',
-                order: 1
-            }
-        });
-    }
-    run(accessor) {
-        accessor.get(IQuickInputService).quickAccess.show(StandaloneCommandsQuickAccessProvider.PREFIX);
-    }
-}
-GotoLineAction.ID = 'editor.action.quickCommand';
-registerEditorAction(GotoLineAction);
-Registry.as(Extensions.Quickaccess).registerQuickAccessProvider({
-    ctor: StandaloneCommandsQuickAccessProvider,
-    prefix: StandaloneCommandsQuickAccessProvider.PREFIX,
-    helpEntries: [{ description: QuickCommandNLS.quickCommandHelp, commandId: GotoLineAction.ID }]
-});
diff -urN -x '*.map' a/vs/editor/standalone/browser/quickAccess/standaloneGotoLineQuickAccess.js b/vs/editor/standalone/browser/quickAccess/standaloneGotoLineQuickAccess.js
--- a/vs/editor/standalone/browser/quickAccess/standaloneGotoLineQuickAccess.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/quickAccess/standaloneGotoLineQuickAccess.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,63 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
-    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
-    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
-    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
-    return c > 3 && r && Object.defineProperty(target, key, r), r;
-};
-var __param = (this && this.__param) || function (paramIndex, decorator) {
-    return function (target, key) { decorator(target, key, paramIndex); }
-};
-import { AbstractGotoLineQuickAccessProvider } from '../../../contrib/quickAccess/browser/gotoLineQuickAccess.js';
-import { Registry } from '../../../../platform/registry/common/platform.js';
-import { Extensions } from '../../../../platform/quickinput/common/quickAccess.js';
-import { ICodeEditorService } from '../../../browser/services/codeEditorService.js';
-import { GoToLineNLS } from '../../../common/standaloneStrings.js';
-import { Event } from '../../../../base/common/event.js';
-import { EditorAction, registerEditorAction } from '../../../browser/editorExtensions.js';
-import { EditorContextKeys } from '../../../common/editorContextKeys.js';
-import { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';
-let StandaloneGotoLineQuickAccessProvider = class StandaloneGotoLineQuickAccessProvider extends AbstractGotoLineQuickAccessProvider {
-    constructor(editorService) {
-        super();
-        this.editorService = editorService;
-        this.onDidActiveTextEditorControlChange = Event.None;
-    }
-    get activeTextEditorControl() {
-        var _a;
-        return (_a = this.editorService.getFocusedCodeEditor()) !== null && _a !== void 0 ? _a : undefined;
-    }
-};
-StandaloneGotoLineQuickAccessProvider = __decorate([
-    __param(0, ICodeEditorService)
-], StandaloneGotoLineQuickAccessProvider);
-export { StandaloneGotoLineQuickAccessProvider };
-export class GotoLineAction extends EditorAction {
-    constructor() {
-        super({
-            id: GotoLineAction.ID,
-            label: GoToLineNLS.gotoLineActionLabel,
-            alias: 'Go to Line/Column...',
-            precondition: undefined,
-            kbOpts: {
-                kbExpr: EditorContextKeys.focus,
-                primary: 2048 /* KeyMod.CtrlCmd */ | 37 /* KeyCode.KeyG */,
-                mac: { primary: 256 /* KeyMod.WinCtrl */ | 37 /* KeyCode.KeyG */ },
-                weight: 100 /* KeybindingWeight.EditorContrib */
-            }
-        });
-    }
-    run(accessor) {
-        accessor.get(IQuickInputService).quickAccess.show(StandaloneGotoLineQuickAccessProvider.PREFIX);
-    }
-}
-GotoLineAction.ID = 'editor.action.gotoLine';
-registerEditorAction(GotoLineAction);
-Registry.as(Extensions.Quickaccess).registerQuickAccessProvider({
-    ctor: StandaloneGotoLineQuickAccessProvider,
-    prefix: StandaloneGotoLineQuickAccessProvider.PREFIX,
-    helpEntries: [{ description: GoToLineNLS.gotoLineActionLabel, commandId: GotoLineAction.ID }]
-});
diff -urN -x '*.map' a/vs/editor/standalone/browser/quickAccess/standaloneGotoSymbolQuickAccess.js b/vs/editor/standalone/browser/quickAccess/standaloneGotoSymbolQuickAccess.js
--- a/vs/editor/standalone/browser/quickAccess/standaloneGotoSymbolQuickAccess.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/quickAccess/standaloneGotoSymbolQuickAccess.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,75 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
-    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
-    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
-    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
-    return c > 3 && r && Object.defineProperty(target, key, r), r;
-};
-var __param = (this && this.__param) || function (paramIndex, decorator) {
-    return function (target, key) { decorator(target, key, paramIndex); }
-};
-import '../../../../base/browser/ui/codicons/codiconStyles.js'; // The codicon symbol styles are defined here and must be loaded
-import '../../../contrib/symbolIcons/browser/symbolIcons.js'; // The codicon symbol colors are defined here and must be loaded to get colors
-import { AbstractGotoSymbolQuickAccessProvider } from '../../../contrib/quickAccess/browser/gotoSymbolQuickAccess.js';
-import { Registry } from '../../../../platform/registry/common/platform.js';
-import { Extensions } from '../../../../platform/quickinput/common/quickAccess.js';
-import { ICodeEditorService } from '../../../browser/services/codeEditorService.js';
-import { QuickOutlineNLS } from '../../../common/standaloneStrings.js';
-import { Event } from '../../../../base/common/event.js';
-import { EditorAction, registerEditorAction } from '../../../browser/editorExtensions.js';
-import { EditorContextKeys } from '../../../common/editorContextKeys.js';
-import { IQuickInputService, ItemActivation } from '../../../../platform/quickinput/common/quickInput.js';
-import { IOutlineModelService } from '../../../contrib/documentSymbols/browser/outlineModel.js';
-import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
-let StandaloneGotoSymbolQuickAccessProvider = class StandaloneGotoSymbolQuickAccessProvider extends AbstractGotoSymbolQuickAccessProvider {
-    constructor(editorService, languageFeaturesService, outlineModelService) {
-        super(languageFeaturesService, outlineModelService);
-        this.editorService = editorService;
-        this.onDidActiveTextEditorControlChange = Event.None;
-    }
-    get activeTextEditorControl() {
-        var _a;
-        return (_a = this.editorService.getFocusedCodeEditor()) !== null && _a !== void 0 ? _a : undefined;
-    }
-};
-StandaloneGotoSymbolQuickAccessProvider = __decorate([
-    __param(0, ICodeEditorService),
-    __param(1, ILanguageFeaturesService),
-    __param(2, IOutlineModelService)
-], StandaloneGotoSymbolQuickAccessProvider);
-export { StandaloneGotoSymbolQuickAccessProvider };
-export class GotoSymbolAction extends EditorAction {
-    constructor() {
-        super({
-            id: GotoSymbolAction.ID,
-            label: QuickOutlineNLS.quickOutlineActionLabel,
-            alias: 'Go to Symbol...',
-            precondition: EditorContextKeys.hasDocumentSymbolProvider,
-            kbOpts: {
-                kbExpr: EditorContextKeys.focus,
-                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 45 /* KeyCode.KeyO */,
-                weight: 100 /* KeybindingWeight.EditorContrib */
-            },
-            contextMenuOpts: {
-                group: 'navigation',
-                order: 3
-            }
-        });
-    }
-    run(accessor) {
-        accessor.get(IQuickInputService).quickAccess.show(AbstractGotoSymbolQuickAccessProvider.PREFIX, { itemActivation: ItemActivation.NONE });
-    }
-}
-GotoSymbolAction.ID = 'editor.action.quickOutline';
-registerEditorAction(GotoSymbolAction);
-Registry.as(Extensions.Quickaccess).registerQuickAccessProvider({
-    ctor: StandaloneGotoSymbolQuickAccessProvider,
-    prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX,
-    helpEntries: [
-        { description: QuickOutlineNLS.quickOutlineActionLabel, prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX, commandId: GotoSymbolAction.ID },
-        { description: QuickOutlineNLS.quickOutlineByCategoryActionLabel, prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY }
-    ]
-});
diff -urN -x '*.map' a/vs/editor/standalone/browser/quickAccess/standaloneHelpQuickAccess.js b/vs/editor/standalone/browser/quickAccess/standaloneHelpQuickAccess.js
--- a/vs/editor/standalone/browser/quickAccess/standaloneHelpQuickAccess.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/quickAccess/standaloneHelpQuickAccess.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,13 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-import { Registry } from '../../../../platform/registry/common/platform.js';
-import { Extensions } from '../../../../platform/quickinput/common/quickAccess.js';
-import { QuickHelpNLS } from '../../../common/standaloneStrings.js';
-import { HelpQuickAccessProvider } from '../../../../platform/quickinput/browser/helpQuickAccess.js';
-Registry.as(Extensions.Quickaccess).registerQuickAccessProvider({
-    ctor: HelpQuickAccessProvider,
-    prefix: '',
-    helpEntries: [{ description: QuickHelpNLS.helpQuickAccessActionLabel }]
-});
diff -urN -x '*.map' a/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js b/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js
--- a/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js	2023-12-06 14:23:14.387854798 +0000
@@ -73,6 +73,9 @@
         return quickInputService;
     }
     get quickAccess() { return this.activeService.quickAccess; }
+    get backButton() { return this.activeService.backButton; }
+    get onShow() { return this.activeService.onShow; }
+    get onHide() { return this.activeService.onHide; }
     constructor(instantiationService, codeEditorService) {
         this.instantiationService = instantiationService;
         this.codeEditorService = codeEditorService;
@@ -81,12 +84,36 @@
     pick(picks, options = {}, token = CancellationToken.None) {
         return this.activeService /* TS fail */.pick(picks, options, token);
     }
+    input(options, token) {
+        return this.activeService.input(options, token);
+    }
     createQuickPick() {
         return this.activeService.createQuickPick();
     }
     createInputBox() {
         return this.activeService.createInputBox();
     }
+    createQuickWidget() {
+        return this.activeService.createQuickWidget();
+    }
+    focus() {
+        return this.activeService.focus();
+    }
+    toggle() {
+        return this.activeService.toggle();
+    }
+    navigate(next, quickNavigate) {
+        return this.activeService.navigate(next, quickNavigate);
+    }
+    accept() {
+        return this.activeService.accept();
+    }
+    back() {
+        return this.activeService.back();
+    }
+    cancel() {
+        return this.activeService.cancel();
+    }
 };
 StandaloneQuickInputService = __decorate([
     __param(0, IInstantiationService),
diff -urN -x '*.map' a/vs/editor/standalone/browser/referenceSearch/standaloneReferenceSearch.js b/vs/editor/standalone/browser/referenceSearch/standaloneReferenceSearch.js
--- a/vs/editor/standalone/browser/referenceSearch/standaloneReferenceSearch.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/referenceSearch/standaloneReferenceSearch.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,36 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
-    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
-    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
-    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
-    return c > 3 && r && Object.defineProperty(target, key, r), r;
-};
-var __param = (this && this.__param) || function (paramIndex, decorator) {
-    return function (target, key) { decorator(target, key, paramIndex); }
-};
-import { registerEditorContribution } from '../../../browser/editorExtensions.js';
-import { ICodeEditorService } from '../../../browser/services/codeEditorService.js';
-import { ReferencesController } from '../../../contrib/gotoSymbol/browser/peek/referencesController.js';
-import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
-import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';
-import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
-import { INotificationService } from '../../../../platform/notification/common/notification.js';
-import { IStorageService } from '../../../../platform/storage/common/storage.js';
-let StandaloneReferencesController = class StandaloneReferencesController extends ReferencesController {
-    constructor(editor, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService) {
-        super(true, editor, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService);
-    }
-};
-StandaloneReferencesController = __decorate([
-    __param(1, IContextKeyService),
-    __param(2, ICodeEditorService),
-    __param(3, INotificationService),
-    __param(4, IInstantiationService),
-    __param(5, IStorageService),
-    __param(6, IConfigurationService)
-], StandaloneReferencesController);
-export { StandaloneReferencesController };
-registerEditorContribution(ReferencesController.ID, StandaloneReferencesController, 4 /* EditorContributionInstantiation.Lazy */);
diff -urN -x '*.map' a/vs/editor/standalone/browser/standaloneCodeEditor.js b/vs/editor/standalone/browser/standaloneCodeEditor.js
--- a/vs/editor/standalone/browser/standaloneCodeEditor.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/standaloneCodeEditor.js	2023-12-06 14:23:14.387854798 +0000
@@ -60,7 +60,7 @@
  */
 let StandaloneCodeEditor = class StandaloneCodeEditor extends CodeEditorWidget {
     constructor(domElement, _options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {
-        const options = Object.assign({}, _options);
+        const options = { ..._options };
         options.ariaLabel = options.ariaLabel || StandaloneCodeEditorNLS.editorViewAccessibleLabel;
         options.ariaLabel = options.ariaLabel + ';' + (StandaloneCodeEditorNLS.accessibilityHelpMessage);
         super(domElement, options, {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);
@@ -168,7 +168,7 @@
 export { StandaloneCodeEditor };
 let StandaloneEditor = class StandaloneEditor extends StandaloneCodeEditor {
     constructor(domElement, _options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, configurationService, accessibilityService, modelService, languageService, languageConfigurationService, languageFeaturesService) {
-        const options = Object.assign({}, _options);
+        const options = { ..._options };
         updateConfigurationService(configurationService, options, false);
         const themeDomRegistration = themeService.registerEditorContainer(domElement);
         if (typeof options.theme === 'string') {
@@ -241,7 +241,7 @@
 export { StandaloneEditor };
 let StandaloneDiffEditor2 = class StandaloneDiffEditor2 extends DiffEditorWidget {
     constructor(domElement, _options, instantiationService, contextKeyService, codeEditorService, themeService, notificationService, configurationService, contextMenuService, editorProgressService, clipboardService, audioCueService) {
-        const options = Object.assign({}, _options);
+        const options = { ..._options };
         updateConfigurationService(configurationService, options, true);
         const themeDomRegistration = themeService.registerEditorContainer(domElement);
         if (typeof options.theme === 'string') {
diff -urN -x '*.map' a/vs/editor/standalone/browser/standaloneCodeEditorService.js b/vs/editor/standalone/browser/standaloneCodeEditorService.js
--- a/vs/editor/standalone/browser/standaloneCodeEditorService.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/standaloneCodeEditorService.js	2023-12-06 14:23:14.387854798 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { windowOpenNoOpener } from '../../../base/browser/dom.js';
 import { Schemas } from '../../../base/common/network.js';
 import { AbstractCodeEditorService } from '../../browser/services/abstractCodeEditorService.js';
@@ -34,12 +25,12 @@
         this._register(this.onCodeEditorRemove(() => this._checkContextKey()));
         this._editorIsOpen = contextKeyService.createKey('editorIsOpen', false);
         this._activeCodeEditor = null;
-        this._register(this.registerCodeEditorOpenHandler((input, source, sideBySide) => __awaiter(this, void 0, void 0, function* () {
+        this._register(this.registerCodeEditorOpenHandler(async (input, source, sideBySide) => {
             if (!source) {
                 return null;
             }
             return this.doOpenEditor(source, input);
-        })));
+        }));
     }
     _checkContextKey() {
         let hasCodeEditor = false;
diff -urN -x '*.map' a/vs/editor/standalone/browser/standaloneEditor.js b/vs/editor/standalone/browser/standaloneEditor.js
--- a/vs/editor/standalone/browser/standaloneEditor.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/standaloneEditor.js	2023-12-06 14:23:14.387854798 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';
 import { splitLines } from '../../../base/common/strings.js';
 import { URI } from '../../../base/common/uri.js';
@@ -366,13 +357,11 @@
 export function registerLinkOpener(opener) {
     const openerService = StandaloneServices.get(IOpenerService);
     return openerService.registerOpener({
-        open(resource) {
-            return __awaiter(this, void 0, void 0, function* () {
-                if (typeof resource === 'string') {
-                    resource = URI.parse(resource);
-                }
-                return opener.open(resource);
-            });
+        async open(resource) {
+            if (typeof resource === 'string') {
+                resource = URI.parse(resource);
+            }
+            return opener.open(resource);
         }
     });
 }
@@ -386,12 +375,11 @@
  */
 export function registerEditorOpener(opener) {
     const codeEditorService = StandaloneServices.get(ICodeEditorService);
-    return codeEditorService.registerCodeEditorOpenHandler((input, source, sideBySide) => __awaiter(this, void 0, void 0, function* () {
-        var _a;
+    return codeEditorService.registerCodeEditorOpenHandler(async (input, source, sideBySide) => {
         if (!source) {
             return null;
         }
-        const selection = (_a = input.options) === null || _a === void 0 ? void 0 : _a.selection;
+        const selection = input.options?.selection;
         let selectionOrPosition;
         if (selection && typeof selection.endLineNumber === 'number' && typeof selection.endColumn === 'number') {
             selectionOrPosition = selection;
@@ -399,11 +387,11 @@
         else if (selection) {
             selectionOrPosition = { lineNumber: selection.startLineNumber, column: selection.startColumn };
         }
-        if (yield opener.openCodeEditor(source, input.resource, selectionOrPosition)) {
+        if (await opener.openCodeEditor(source, input.resource, selectionOrPosition)) {
             return source; // return source editor to indicate that this handler has successfully handled the opening
         }
         return null; // fallback to other registered handlers
-    }));
+    });
 }
 /**
  * @internal
diff -urN -x '*.map' a/vs/editor/standalone/browser/standaloneLanguages.js b/vs/editor/standalone/browser/standaloneLanguages.js
--- a/vs/editor/standalone/browser/standaloneLanguages.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/standaloneLanguages.js	2023-12-06 14:23:14.387854798 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { Color } from '../../../base/common/color.js';
 import { Range } from '../../common/core/range.js';
 import * as languages from '../../common/languages.js';
@@ -260,8 +251,8 @@
  * with a tokens provider set using `registerDocumentSemanticTokensProvider` or `registerDocumentRangeSemanticTokensProvider`.
  */
 export function registerTokensProviderFactory(languageId, factory) {
-    const adaptedFactory = new languages.LazyTokenizationSupport(() => __awaiter(this, void 0, void 0, function* () {
-        const result = yield Promise.resolve(factory.create());
+    const adaptedFactory = new languages.LazyTokenizationSupport(async () => {
+        const result = await Promise.resolve(factory.create());
         if (!result) {
             return null;
         }
@@ -269,7 +260,7 @@
             return createTokenizationSupportAdapter(languageId, result);
         }
         return new MonarchTokenizer(StandaloneServices.get(ILanguageService), StandaloneServices.get(IStandaloneThemeService), languageId, compile(languageId, result), StandaloneServices.get(IConfigurationService));
-    }));
+    });
     return languages.TokenizationRegistry.registerFactory(languageId, adaptedFactory);
 }
 /**
@@ -402,8 +393,8 @@
 export function registerCodeActionProvider(languageSelector, provider, metadata) {
     const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
     return languageFeaturesService.codeActionProvider.register(languageSelector, {
-        providedCodeActionKinds: metadata === null || metadata === void 0 ? void 0 : metadata.providedCodeActionKinds,
-        documentation: metadata === null || metadata === void 0 ? void 0 : metadata.documentation,
+        providedCodeActionKinds: metadata?.providedCodeActionKinds,
+        documentation: metadata?.documentation,
         provideCodeActions: (model, range, context, token) => {
             const markerService = StandaloneServices.get(IMarkerService);
             const markers = markerService.read({ resource: model.uri }).filter(m => {
diff -urN -x '*.map' a/vs/editor/standalone/browser/standaloneLayoutService.js b/vs/editor/standalone/browser/standaloneLayoutService.js
--- a/vs/editor/standalone/browser/standaloneLayoutService.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/standaloneLayoutService.js	2023-12-06 14:23:14.387854798 +0000
@@ -35,8 +35,7 @@
         throw new Error(`ILayoutService.container is not available in the standalone editor!`);
     }
     focus() {
-        var _a;
-        (_a = this._codeEditorService.getFocusedCodeEditor()) === null || _a === void 0 ? void 0 : _a.focus();
+        this._codeEditorService.getFocusedCodeEditor()?.focus();
     }
     constructor(_codeEditorService) {
         this._codeEditorService = _codeEditorService;
diff -urN -x '*.map' a/vs/editor/standalone/browser/standaloneServices.js b/vs/editor/standalone/browser/standaloneServices.js
--- a/vs/editor/standalone/browser/standaloneServices.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/standaloneServices.js	2023-12-06 14:23:14.387854798 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import '../../common/languages/languageConfigurationRegistry.js';
 import './standaloneCodeEditorService.js';
 import './standaloneLayoutService.js';
@@ -30,7 +21,7 @@
 import * as strings from '../../../base/common/strings.js';
 import * as dom from '../../../base/browser/dom.js';
 import { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';
-import { Emitter } from '../../../base/common/event.js';
+import { Emitter, Event } from '../../../base/common/event.js';
 import { KeyCodeChord, decodeKeybinding } from '../../../base/common/keybindings.js';
 import { ImmortalReference, toDisposable, DisposableStore, Disposable, combinedDisposable } from '../../../base/common/lifecycle.js';
 import { OS, isLinux, isMacintosh } from '../../../base/common/platform.js';
@@ -101,8 +92,6 @@
 import { DefaultConfiguration } from '../../../platform/configuration/common/configurations.js';
 import { IAudioCueService } from '../../../platform/audioCues/browser/audioCueService.js';
 import { LogService } from '../../../platform/log/common/logService.js';
-import { getEditorFeatures } from '../../common/editorFeatures.js';
-import { onUnexpectedError } from '../../../base/common/errors.js';
 import { IEnvironmentService } from '../../../platform/environment/common/environment.js';
 class SimpleModel {
     constructor(model) {
@@ -110,13 +99,34 @@
         this.model = model;
         this._onWillDispose = new Emitter();
     }
+    get onWillDispose() {
+        return this._onWillDispose.event;
+    }
+    resolve() {
+        return Promise.resolve();
+    }
     get textEditorModel() {
         return this.model;
     }
+    createSnapshot() {
+        return this.model.createSnapshot();
+    }
+    isReadonly() {
+        return false;
+    }
     dispose() {
         this.disposed = true;
         this._onWillDispose.fire();
     }
+    isDisposed() {
+        return this.disposed;
+    }
+    isResolved() {
+        return true;
+    }
+    getLanguageId() {
+        return this.model.getLanguageId();
+    }
 }
 let StandaloneTextModelService = class StandaloneTextModelService {
     constructor(modelService) {
@@ -129,6 +139,14 @@
         }
         return Promise.resolve(new ImmortalReference(new SimpleModel(model)));
     }
+    registerTextModelContentProvider(scheme, provider) {
+        return {
+            dispose: function () { }
+        };
+    }
+    canHandleResource(resource) {
+        return false;
+    }
 };
 StandaloneTextModelService = __decorate([
     __param(0, IModelService)
@@ -137,10 +155,8 @@
     show() {
         return StandaloneEditorProgressService.NULL_PROGRESS_RUNNER;
     }
-    showWhile(promise, delay) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield promise;
-        });
+    async showWhile(promise, delay) {
+        await promise;
     }
 }
 StandaloneEditorProgressService.NULL_PROGRESS_RUNNER = {
@@ -157,19 +173,46 @@
 }
 class StandaloneEnvironmentService {
     constructor() {
+        this.stateResource = URI.from({ scheme: 'monaco', authority: 'stateResource' });
+        this.userRoamingDataHome = URI.from({ scheme: 'monaco', authority: 'userRoamingDataHome' });
+        this.keyboardLayoutResource = URI.from({ scheme: 'monaco', authority: 'keyboardLayoutResource' });
+        this.argvResource = URI.from({ scheme: 'monaco', authority: 'argvResource' });
+        this.untitledWorkspacesHome = URI.from({ scheme: 'monaco', authority: 'untitledWorkspacesHome' });
+        this.workspaceStorageHome = URI.from({ scheme: 'monaco', authority: 'workspaceStorageHome' });
+        this.localHistoryHome = URI.from({ scheme: 'monaco', authority: 'localHistoryHome' });
+        this.cacheHome = URI.from({ scheme: 'monaco', authority: 'cacheHome' });
+        this.userDataSyncHome = URI.from({ scheme: 'monaco', authority: 'userDataSyncHome' });
+        this.sync = undefined;
+        this.continueOn = undefined;
+        this.editSessionId = undefined;
+        this.debugExtensionHost = { port: null, break: false };
         this.isExtensionDevelopment = false;
+        this.disableExtensions = false;
+        this.enableExtensions = undefined;
+        this.extensionDevelopmentLocationURI = undefined;
+        this.extensionDevelopmentKind = undefined;
+        this.extensionTestsLocationURI = undefined;
+        this.logsHome = URI.from({ scheme: 'monaco', authority: 'logsHome' });
+        this.logLevel = undefined;
+        this.extensionLogLevel = undefined;
+        this.verbose = false;
         this.isBuilt = false;
+        this.disableTelemetry = false;
+        this.serviceMachineIdResource = URI.from({ scheme: 'monaco', authority: 'serviceMachineIdResource' });
+        this.policyFile = undefined;
     }
 }
 class StandaloneDialogService {
-    confirm(confirmation) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const confirmed = this.doConfirm(confirmation.message, confirmation.detail);
-            return {
-                confirmed,
-                checkboxChecked: false // unsupported
-            };
-        });
+    constructor() {
+        this.onWillShowDialog = Event.None;
+        this.onDidShowDialog = Event.None;
+    }
+    async confirm(confirmation) {
+        const confirmed = this.doConfirm(confirmation.message, confirmation.detail);
+        return {
+            confirmed,
+            checkboxChecked: false // unsupported
+        };
     }
     doConfirm(message, detail) {
         let messageText = message;
@@ -178,28 +221,41 @@
         }
         return window.confirm(messageText);
     }
-    prompt(prompt) {
-        var _a, _b;
-        return __awaiter(this, void 0, void 0, function* () {
-            let result = undefined;
-            const confirmed = this.doConfirm(prompt.message, prompt.detail);
-            if (confirmed) {
-                const promptButtons = [...((_a = prompt.buttons) !== null && _a !== void 0 ? _a : [])];
-                if (prompt.cancelButton && typeof prompt.cancelButton !== 'string' && typeof prompt.cancelButton !== 'boolean') {
-                    promptButtons.push(prompt.cancelButton);
-                }
-                result = yield ((_b = promptButtons[0]) === null || _b === void 0 ? void 0 : _b.run({ checkboxChecked: false }));
+    async prompt(prompt) {
+        let result = undefined;
+        const confirmed = this.doConfirm(prompt.message, prompt.detail);
+        if (confirmed) {
+            const promptButtons = [...(prompt.buttons ?? [])];
+            if (prompt.cancelButton && typeof prompt.cancelButton !== 'string' && typeof prompt.cancelButton !== 'boolean') {
+                promptButtons.push(prompt.cancelButton);
             }
-            return { result };
-        });
+            result = await promptButtons[0]?.run({ checkboxChecked: false });
+        }
+        return { result };
     }
-    error(message, detail) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield this.prompt({ type: Severity.Error, message, detail });
-        });
+    async info(message, detail) {
+        await this.prompt({ type: Severity.Info, message, detail });
+    }
+    async warn(message, detail) {
+        await this.prompt({ type: Severity.Warning, message, detail });
+    }
+    async error(message, detail) {
+        await this.prompt({ type: Severity.Error, message, detail });
+    }
+    input() {
+        return Promise.resolve({ confirmed: false }); // unsupported
+    }
+    about() {
+        return Promise.resolve(undefined);
     }
 }
 export class StandaloneNotificationService {
+    constructor() {
+        this.onDidAddNotification = Event.None;
+        this.onDidRemoveNotification = Event.None;
+        this.onDidChangeDoNotDisturbMode = Event.None;
+        this.doNotDisturbMode = false;
+    }
     info(message) {
         return this.notify({ severity: Severity.Info, message });
     }
@@ -235,6 +291,7 @@
     constructor(instantiationService) {
         this._onWillExecuteCommand = new Emitter();
         this._onDidExecuteCommand = new Emitter();
+        this.onWillExecuteCommand = this._onWillExecuteCommand.event;
         this.onDidExecuteCommand = this._onDidExecuteCommand.event;
         this._instantiationService = instantiationService;
     }
@@ -328,11 +385,10 @@
     }
     addDynamicKeybindings(rules) {
         const entries = rules.map((rule) => {
-            var _a;
             const keybinding = decodeKeybinding(rule.keybinding, OS);
             return {
                 keybinding,
-                command: (_a = rule.command) !== null && _a !== void 0 ? _a : null,
+                command: rule.command ?? null,
                 commandArgs: rule.commandArgs,
                 when: rule.when,
                 weight1: 1000,
@@ -358,10 +414,13 @@
         this._cachedResolver = null;
         this._onDidUpdateKeybindings.fire();
     }
+    getUserKeybindingItems() {
+        return this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);
+    }
     _getResolver() {
         if (!this._cachedResolver) {
             const defaults = this._toNormalizedKeybindingItems(KeybindingsRegistry.getDefaultKeybindings(), true);
-            const overrides = this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);
+            const overrides = this.getUserKeybindingItems();
             this._cachedResolver = new KeybindingResolver(defaults, overrides, (str) => this._log(str));
         }
         return this._cachedResolver;
@@ -380,7 +439,7 @@
                 result[resultLen++] = new ResolvedKeybindingItem(undefined, item.command, item.commandArgs, when, isDefault, null, false);
             }
             else {
-                const resolvedKeybindings = USLayoutResolvedKeybinding.resolveKeybinding(keybinding, OS);
+                const resolvedKeybindings = this.resolveKeybinding(keybinding);
                 for (const resolvedKeybinding of resolvedKeybindings) {
                     result[resultLen++] = new ResolvedKeybindingItem(resolvedKeybinding, item.command, item.commandArgs, when, isDefault, null, false);
                 }
@@ -388,10 +447,25 @@
         }
         return result;
     }
+    resolveKeybinding(keybinding) {
+        return USLayoutResolvedKeybinding.resolveKeybinding(keybinding, OS);
+    }
     resolveKeyboardEvent(keyboardEvent) {
         const chord = new KeyCodeChord(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, keyboardEvent.keyCode);
         return new USLayoutResolvedKeybinding([chord], OS);
     }
+    resolveUserBinding(userBinding) {
+        return [];
+    }
+    _dumpDebugInfo() {
+        return '';
+    }
+    _dumpDebugInfoJSON() {
+        return '';
+    }
+    registerSchemaContribution(contribution) {
+        // noop
+    }
 };
 StandaloneKeybindingService = __decorate([
     __param(0, IContextKeyService),
@@ -453,6 +527,27 @@
     inspect(key, options = {}) {
         return this._configuration.inspect(key, options, undefined);
     }
+    keys() {
+        return this._configuration.keys(undefined);
+    }
+    reloadConfiguration() {
+        return Promise.resolve(undefined);
+    }
+    getConfigurationData() {
+        const emptyModel = {
+            contents: {},
+            keys: [],
+            overrides: []
+        };
+        return {
+            defaults: emptyModel,
+            policy: emptyModel,
+            application: emptyModel,
+            user: emptyModel,
+            workspace: emptyModel,
+            folders: []
+        };
+    }
 }
 let StandaloneResourceConfigurationService = class StandaloneResourceConfigurationService {
     constructor(configurationService, modelService, languageService) {
@@ -460,6 +555,7 @@
         this.modelService = modelService;
         this.languageService = languageService;
         this._onDidChangeConfiguration = new Emitter();
+        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
         this.configurationService.onDidChangeConfiguration((e) => {
             this._onDidChangeConfiguration.fire({ affectedKeys: e.affectedKeys, affectsConfiguration: (resource, configuration) => e.affectsConfiguration(configuration) });
         });
@@ -479,6 +575,10 @@
             overrideIdentifier: language
         });
     }
+    inspect(resource, position, section) {
+        const language = resource ? this.getLanguage(resource, position) : undefined;
+        return this.configurationService.inspect(section, { resource, overrideIdentifier: language });
+    }
     getLanguage(resource, position) {
         const model = this.modelService.getModel(resource);
         if (model) {
@@ -486,6 +586,9 @@
         }
         return this.languageService.guessLanguageIdByFilepathOrFirstLine(resource);
     }
+    updateValue(resource, key, value, configurationTarget) {
+        return this.configurationService.updateValue(key, value, { resource }, configurationTarget);
+    }
 };
 StandaloneResourceConfigurationService = __decorate([
     __param(0, IConfigurationService),
@@ -508,19 +611,57 @@
     __param(0, IConfigurationService)
 ], StandaloneResourcePropertiesService);
 class StandaloneTelemetryService {
+    constructor() {
+        this.telemetryLevel = 0 /* TelemetryLevel.NONE */;
+        this.sessionId = 'someValue.sessionId';
+        this.machineId = 'someValue.machineId';
+        this.firstSessionDate = 'someValue.firstSessionDate';
+        this.sendErrorTelemetry = false;
+    }
+    setEnabled() { }
+    setExperimentProperty() { }
+    publicLog() { }
     publicLog2() { }
+    publicLogError() { }
+    publicLogError2() { }
 }
 class StandaloneWorkspaceContextService {
     constructor() {
+        this._onDidChangeWorkspaceName = new Emitter();
+        this.onDidChangeWorkspaceName = this._onDidChangeWorkspaceName.event;
+        this._onWillChangeWorkspaceFolders = new Emitter();
+        this.onWillChangeWorkspaceFolders = this._onWillChangeWorkspaceFolders.event;
+        this._onDidChangeWorkspaceFolders = new Emitter();
+        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
+        this._onDidChangeWorkbenchState = new Emitter();
+        this.onDidChangeWorkbenchState = this._onDidChangeWorkbenchState.event;
         const resource = URI.from({ scheme: StandaloneWorkspaceContextService.SCHEME, authority: 'model', path: '/' });
         this.workspace = { id: STANDALONE_EDITOR_WORKSPACE_ID, folders: [new WorkspaceFolder({ uri: resource, name: '', index: 0 })] };
     }
+    getCompleteWorkspace() {
+        return Promise.resolve(this.getWorkspace());
+    }
     getWorkspace() {
         return this.workspace;
     }
+    getWorkbenchState() {
+        if (this.workspace) {
+            if (this.workspace.configuration) {
+                return 3 /* WorkbenchState.WORKSPACE */;
+            }
+            return 2 /* WorkbenchState.FOLDER */;
+        }
+        return 1 /* WorkbenchState.EMPTY */;
+    }
     getWorkspaceFolder(resource) {
         return resource && resource.scheme === StandaloneWorkspaceContextService.SCHEME ? this.workspace.folders[0] : null;
     }
+    isInsideWorkspace(resource) {
+        return resource && resource.scheme === StandaloneWorkspaceContextService.SCHEME;
+    }
+    isCurrentWorkspace(workspaceIdOrFolder) {
+        return true;
+    }
 }
 StandaloneWorkspaceContextService.SCHEME = 'inmemory';
 export function updateConfigurationService(configurationService, source, isDiffEditor) {
@@ -551,48 +692,52 @@
     hasPreviewHandler() {
         return false;
     }
-    apply(editsIn, _options) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const edits = Array.isArray(editsIn) ? editsIn : ResourceEdit.convert(editsIn);
-            const textEdits = new Map();
-            for (const edit of edits) {
-                if (!(edit instanceof ResourceTextEdit)) {
-                    throw new Error('bad edit - only text edits are supported');
-                }
-                const model = this._modelService.getModel(edit.resource);
-                if (!model) {
-                    throw new Error('bad edit - model not found');
-                }
-                if (typeof edit.versionId === 'number' && model.getVersionId() !== edit.versionId) {
-                    throw new Error('bad state - model changed in the meantime');
-                }
-                let array = textEdits.get(model);
-                if (!array) {
-                    array = [];
-                    textEdits.set(model, array);
-                }
-                array.push(EditOperation.replaceMove(Range.lift(edit.textEdit.range), edit.textEdit.text));
-            }
-            let totalEdits = 0;
-            let totalFiles = 0;
-            for (const [model, edits] of textEdits) {
-                model.pushStackElement();
-                model.pushEditOperations([], edits, () => []);
-                model.pushStackElement();
-                totalFiles += 1;
-                totalEdits += edits.length;
-            }
-            return {
-                ariaSummary: strings.format(StandaloneServicesNLS.bulkEditServiceSummary, totalEdits, totalFiles),
-                isApplied: totalEdits > 0
-            };
-        });
+    setPreviewHandler() {
+        return Disposable.None;
+    }
+    async apply(editsIn, _options) {
+        const edits = Array.isArray(editsIn) ? editsIn : ResourceEdit.convert(editsIn);
+        const textEdits = new Map();
+        for (const edit of edits) {
+            if (!(edit instanceof ResourceTextEdit)) {
+                throw new Error('bad edit - only text edits are supported');
+            }
+            const model = this._modelService.getModel(edit.resource);
+            if (!model) {
+                throw new Error('bad edit - model not found');
+            }
+            if (typeof edit.versionId === 'number' && model.getVersionId() !== edit.versionId) {
+                throw new Error('bad state - model changed in the meantime');
+            }
+            let array = textEdits.get(model);
+            if (!array) {
+                array = [];
+                textEdits.set(model, array);
+            }
+            array.push(EditOperation.replaceMove(Range.lift(edit.textEdit.range), edit.textEdit.text));
+        }
+        let totalEdits = 0;
+        let totalFiles = 0;
+        for (const [model, edits] of textEdits) {
+            model.pushStackElement();
+            model.pushEditOperations([], edits, () => []);
+            model.pushStackElement();
+            totalFiles += 1;
+            totalEdits += edits.length;
+        }
+        return {
+            ariaSummary: strings.format(StandaloneServicesNLS.bulkEditServiceSummary, totalEdits, totalFiles),
+            isApplied: totalEdits > 0
+        };
     }
 };
 StandaloneBulkEditService = __decorate([
     __param(0, IModelService)
 ], StandaloneBulkEditService);
 class StandaloneUriLabelService {
+    constructor() {
+        this.onDidChangeFormatters = Event.None;
+    }
     getUriLabel(resource, options) {
         if (resource.scheme === 'file') {
             return resource.fsPath;
@@ -602,6 +747,24 @@
     getUriBasenameLabel(resource) {
         return basename(resource);
     }
+    getWorkspaceLabel(workspace, options) {
+        return '';
+    }
+    getSeparator(scheme, authority) {
+        return '/';
+    }
+    registerFormatter(formatter) {
+        throw new Error('Not implemented');
+    }
+    registerCachedFormatter(formatter) {
+        return this.registerFormatter(formatter);
+    }
+    getHostLabel() {
+        return '';
+    }
+    getHostTooltip() {
+        return undefined;
+    }
 }
 let StandaloneContextViewService = class StandaloneContextViewService extends ContextViewService {
     constructor(layoutService, _codeEditorService) {
@@ -626,10 +789,44 @@
     constructor() {
         this._neverEmitter = new Emitter();
         this.onDidChangeTrust = this._neverEmitter.event;
+        this.onDidChangeTrustedFolders = this._neverEmitter.event;
+        this.workspaceResolved = Promise.resolve();
+        this.workspaceTrustInitialized = Promise.resolve();
+        this.acceptsOutOfWorkspaceFiles = true;
     }
     isWorkspaceTrusted() {
         return true;
     }
+    isWorkspaceTrustForced() {
+        return false;
+    }
+    canSetParentFolderTrust() {
+        return false;
+    }
+    async setParentFolderTrust(trusted) {
+        // noop
+    }
+    canSetWorkspaceTrust() {
+        return false;
+    }
+    async setWorkspaceTrust(trusted) {
+        // noop
+    }
+    getUriTrustInfo(uri) {
+        throw new Error('Method not supported.');
+    }
+    async setUrisTrust(uri, trusted) {
+        // noop
+    }
+    getTrustedUris() {
+        return [];
+    }
+    async setTrustedUris(uris) {
+        // noop
+    }
+    addWorkspaceTrustTransitionParticipant(participant) {
+        throw new Error('Method not supported.');
+    }
 }
 class StandaloneLanguageService extends LanguageService {
     constructor() {
@@ -656,9 +853,20 @@
     __param(5, IContextKeyService)
 ], StandaloneContextMenuService);
 class StandaloneAudioService {
-    playAudioCue(cue, options) {
-        return __awaiter(this, void 0, void 0, function* () {
-        });
+    async playAudioCue(cue, options) {
+    }
+    async playAudioCues(cues) {
+    }
+    isEnabled(cue) {
+        return false;
+    }
+    onEnabledChanged(cue) {
+        return Event.None;
+    }
+    async playSound(cue, allowManyInParallel) {
+    }
+    playAudioCueLoop(cue) {
+        return toDisposable(() => { });
     }
 }
 registerSingleton(IConfigurationService, StandaloneConfigurationService, 0 /* InstantiationType.Eager */);
@@ -747,16 +955,6 @@
                 }
             }
         }
-        // Instantiate all editor features
-        const editorFeatures = getEditorFeatures();
-        for (const feature of editorFeatures) {
-            try {
-                instantiationService.createInstance(feature);
-            }
-            catch (err) {
-                onUnexpectedError(err);
-            }
-        }
         onDidInitialize.fire();
         return instantiationService;
     }
diff -urN -x '*.map' a/vs/editor/standalone/browser/standaloneThemeService.js b/vs/editor/standalone/browser/standaloneThemeService.js
--- a/vs/editor/standalone/browser/standaloneThemeService.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/standaloneThemeService.js	2023-12-06 14:23:14.387854798 +0000
@@ -44,6 +44,9 @@
         this.defaultColors = Object.create(null);
         this._tokenTheme = null;
     }
+    get label() {
+        return this.themeName;
+    }
     get base() {
         return this.themeData.base;
     }
@@ -147,6 +150,9 @@
             strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */)
         };
     }
+    get tokenColorMap() {
+        return [];
+    }
 }
 function isBuiltinTheme(themeName) {
     return (themeName === VS_LIGHT_THEME_NAME
@@ -175,6 +181,8 @@
         super();
         this._onColorThemeChange = this._register(new Emitter());
         this.onDidColorThemeChange = this._onColorThemeChange.event;
+        this._onFileIconThemeChange = this._register(new Emitter());
+        this.onDidFileIconThemeChange = this._onFileIconThemeChange.event;
         this._onProductIconThemeChange = this._register(new Emitter());
         this.onDidProductIconThemeChange = this._onProductIconThemeChange.event;
         this._environment = Object.create(null);
diff -urN -x '*.map' a/vs/editor/standalone/browser/toggleHighContrast/toggleHighContrast.js b/vs/editor/standalone/browser/toggleHighContrast/toggleHighContrast.js
--- a/vs/editor/standalone/browser/toggleHighContrast/toggleHighContrast.js	2023-12-06 14:22:33.815782437 +0000
+++ b/vs/editor/standalone/browser/toggleHighContrast/toggleHighContrast.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,34 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-import { EditorAction, registerEditorAction } from '../../../browser/editorExtensions.js';
-import { IStandaloneThemeService } from '../../common/standaloneTheme.js';
-import { ToggleHighContrastNLS } from '../../../common/standaloneStrings.js';
-import { isDark, isHighContrast } from '../../../../platform/theme/common/theme.js';
-import { HC_BLACK_THEME_NAME, HC_LIGHT_THEME_NAME, VS_DARK_THEME_NAME, VS_LIGHT_THEME_NAME } from '../standaloneThemeService.js';
-class ToggleHighContrast extends EditorAction {
-    constructor() {
-        super({
-            id: 'editor.action.toggleHighContrast',
-            label: ToggleHighContrastNLS.toggleHighContrast,
-            alias: 'Toggle High Contrast Theme',
-            precondition: undefined
-        });
-        this._originalThemeName = null;
-    }
-    run(accessor, editor) {
-        const standaloneThemeService = accessor.get(IStandaloneThemeService);
-        const currentTheme = standaloneThemeService.getColorTheme();
-        if (isHighContrast(currentTheme.type)) {
-            // We must toggle back to the integrator's theme
-            standaloneThemeService.setTheme(this._originalThemeName || (isDark(currentTheme.type) ? VS_DARK_THEME_NAME : VS_LIGHT_THEME_NAME));
-            this._originalThemeName = null;
-        }
-        else {
-            standaloneThemeService.setTheme(isDark(currentTheme.type) ? HC_BLACK_THEME_NAME : HC_LIGHT_THEME_NAME);
-            this._originalThemeName = currentTheme.themeName;
-        }
-    }
-}
-registerEditorAction(ToggleHighContrast);
diff -urN -x '*.map' a/vs/nls.js b/vs/nls.js
--- a/vs/nls.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/nls.js	2023-12-06 14:23:14.343854719 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 let isPseudo = (typeof document !== 'undefined' && document.location && document.location.hash.indexOf('pseudo=true') >= 0);
 const DEFAULT_TAG = 'i-default';
 function _format(message, args) {
@@ -55,16 +46,14 @@
     }
     return path + '/';
 }
-function getMessagesFromTranslationsService(translationServiceUrl, language, name) {
-    return __awaiter(this, void 0, void 0, function* () {
-        const url = endWithSlash(translationServiceUrl) + endWithSlash(language) + 'vscode/' + endWithSlash(name);
-        const res = yield fetch(url);
-        if (res.ok) {
-            const messages = yield res.json();
-            return messages;
-        }
-        throw new Error(`${res.status} - ${res.statusText}`);
-    });
+async function getMessagesFromTranslationsService(translationServiceUrl, language, name) {
+    const url = endWithSlash(translationServiceUrl) + endWithSlash(language) + 'vscode/' + endWithSlash(name);
+    const res = await fetch(url);
+    if (res.ok) {
+        const messages = await res.json();
+        return messages;
+    }
+    throw new Error(`${res.status} - ${res.statusText}`);
 }
 function createScopedLocalize(scope) {
     return function (idx, defaultValue) {
@@ -78,13 +67,27 @@
 export function localize(data, message, ...args) {
     return _format(message, args);
 }
+let locale = undefined;
+let translations = {};
+export function setLocale(_locale, _translations) {
+    locale = _locale;
+    translations = _translations;
+}
+/**
+ * @skipMangle
+ */
+export function localizeWithPath(path, data, defaultMessage, ...args) {
+    const key = typeof data === 'object' ? data.key : data;
+    const message = (translations[path] ?? {})[key] ?? defaultMessage;
+    return _format(message, args);
+}
 /**
  * @skipMangle
  */
 export function getConfiguredDefaultLocale(_) {
     // This returns undefined because this implementation isn't used and is overwritten by the loader
     // when loaded.
-    return undefined;
+    return locale;
 }
 /**
  * @skipMangle
@@ -97,10 +100,9 @@
  * @skipMangle
  */
 export function create(key, data) {
-    var _a;
     return {
         localize: createScopedLocalize(data[key]),
-        getConfiguredDefaultLocale: (_a = data.getConfiguredDefaultLocale) !== null && _a !== void 0 ? _a : ((_) => undefined)
+        getConfiguredDefaultLocale: data.getConfiguredDefaultLocale ?? ((_) => undefined)
     };
 }
 /**
@@ -108,13 +110,12 @@
  * @skipMangle
  */
 export function load(name, req, load, config) {
-    var _a;
-    const pluginConfig = (_a = config['vs/nls']) !== null && _a !== void 0 ? _a : {};
+    const pluginConfig = config['vs/nls'] ?? {};
     if (!name || name.length === 0) {
         // TODO: We need to give back the mangled names here
         return load({
             localize: localize,
-            getConfiguredDefaultLocale: () => { var _a; return (_a = pluginConfig.availableLanguages) === null || _a === void 0 ? void 0 : _a['*']; }
+            getConfiguredDefaultLocale: () => pluginConfig.availableLanguages?.['*']
         });
     }
     const language = pluginConfig.availableLanguages ? findLanguageForModule(pluginConfig.availableLanguages, name) : null;
@@ -130,7 +131,7 @@
         else {
             messages.localize = createScopedLocalize(messages[name]);
         }
-        messages.getConfiguredDefaultLocale = () => { var _a; return (_a = pluginConfig.availableLanguages) === null || _a === void 0 ? void 0 : _a['*']; };
+        messages.getConfiguredDefaultLocale = () => pluginConfig.availableLanguages?.['*'];
         load(messages);
     };
     if (typeof pluginConfig.loadBundle === 'function') {
@@ -145,10 +146,9 @@
         });
     }
     else if (pluginConfig.translationServiceUrl && !useDefaultLanguage) {
-        (() => __awaiter(this, void 0, void 0, function* () {
-            var _b;
+        (async () => {
             try {
-                const messages = yield getMessagesFromTranslationsService(pluginConfig.translationServiceUrl, language, name);
+                const messages = await getMessagesFromTranslationsService(pluginConfig.translationServiceUrl, language, name);
                 return messagesLoaded(messages);
             }
             catch (err) {
@@ -162,9 +162,9 @@
                     // Since we were unable to load the specific language, try to load the generic language. Ex. we failed to find a
                     // Swiss German (de-CH), so try to load the generic German (de) messages instead.
                     const genericLanguage = language.split('-')[0];
-                    const messages = yield getMessagesFromTranslationsService(pluginConfig.translationServiceUrl, genericLanguage, name);
+                    const messages = await getMessagesFromTranslationsService(pluginConfig.translationServiceUrl, genericLanguage, name);
                     // We got some messages, so we configure the configuration to use the generic language for this session.
-                    (_b = pluginConfig.availableLanguages) !== null && _b !== void 0 ? _b : (pluginConfig.availableLanguages = {});
+                    pluginConfig.availableLanguages ?? (pluginConfig.availableLanguages = {});
                     pluginConfig.availableLanguages['*'] = genericLanguage;
                     return messagesLoaded(messages);
                 }
@@ -173,7 +173,7 @@
                     return req([name + '.nls'], messagesLoaded);
                 }
             }
-        }))();
+        })();
     }
     else {
         req([name + suffix], messagesLoaded, (err) => {
diff -urN -x '*.map' a/vs/platform/accessibility/browser/accessibilityService.js b/vs/platform/accessibility/browser/accessibilityService.js
--- a/vs/platform/accessibility/browser/accessibilityService.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/accessibility/browser/accessibilityService.js	2023-12-06 14:23:14.387854798 +0000
@@ -12,6 +12,7 @@
     return function (target, key) { decorator(target, key, paramIndex); }
 };
 import { addDisposableListener } from '../../../base/browser/dom.js';
+import { alert } from '../../../base/browser/ui/aria/aria.js';
 import { Emitter } from '../../../base/common/event.js';
 import { Disposable } from '../../../base/common/lifecycle.js';
 import { CONTEXT_ACCESSIBILITY_MODE_ENABLED } from '../common/accessibility.js';
@@ -80,9 +81,22 @@
         const config = this._configMotionReduced;
         return config === 'on' || (config === 'auto' && this._systemMotionReduced);
     }
+    alwaysUnderlineAccessKeys() {
+        return Promise.resolve(false);
+    }
     getAccessibilitySupport() {
         return this._accessibilitySupport;
     }
+    setAccessibilitySupport(accessibilitySupport) {
+        if (this._accessibilitySupport === accessibilitySupport) {
+            return;
+        }
+        this._accessibilitySupport = accessibilitySupport;
+        this._onDidChangeScreenReaderOptimized.fire();
+    }
+    alert(message) {
+        alert(message);
+    }
 };
 AccessibilityService = __decorate([
     __param(0, IContextKeyService),
diff -urN -x '*.map' a/vs/platform/accessibility/common/accessibility.js b/vs/platform/accessibility/common/accessibility.js
--- a/vs/platform/accessibility/common/accessibility.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/accessibility/common/accessibility.js	2023-12-06 14:23:14.387854798 +0000
@@ -6,3 +6,8 @@
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export const IAccessibilityService = createDecorator('accessibilityService');
 export const CONTEXT_ACCESSIBILITY_MODE_ENABLED = new RawContextKey('accessibilityModeEnabled', false);
+export function isAccessibilityInformation(obj) {
+    return obj && typeof obj === 'object'
+        && typeof obj.label === 'string'
+        && (typeof obj.role === 'undefined' || typeof obj.role === 'string');
+}
diff -urN -x '*.map' a/vs/platform/action/common/actionCommonCategories.js b/vs/platform/action/common/actionCommonCategories.js
--- a/vs/platform/action/common/actionCommonCategories.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/action/common/actionCommonCategories.js	2023-12-06 14:23:14.387854798 +0000
@@ -2,12 +2,12 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 export const Categories = Object.freeze({
-    View: { value: localize('view', "View"), original: 'View' },
-    Help: { value: localize('help', "Help"), original: 'Help' },
-    Test: { value: localize('test', "Test"), original: 'Test' },
-    File: { value: localize('file', "File"), original: 'File' },
-    Preferences: { value: localize('preferences', "Preferences"), original: 'Preferences' },
-    Developer: { value: localize({ key: 'developer', comment: ['A developer on Code itself or someone diagnosing issues in Code'] }, "Developer"), original: 'Developer' }
+    View: { value: localizeWithPath('vs/platform/action/common/actionCommonCategories', 'view', "View"), original: 'View' },
+    Help: { value: localizeWithPath('vs/platform/action/common/actionCommonCategories', 'help', "Help"), original: 'Help' },
+    Test: { value: localizeWithPath('vs/platform/action/common/actionCommonCategories', 'test', "Test"), original: 'Test' },
+    File: { value: localizeWithPath('vs/platform/action/common/actionCommonCategories', 'file', "File"), original: 'File' },
+    Preferences: { value: localizeWithPath('vs/platform/action/common/actionCommonCategories', 'preferences', "Preferences"), original: 'Preferences' },
+    Developer: { value: localizeWithPath('vs/platform/action/common/actionCommonCategories', { key: 'developer', comment: ['A developer on Code itself or someone diagnosing issues in Code'] }, "Developer"), original: 'Developer' }
 });
diff -urN -x '*.map' a/vs/platform/actionWidget/browser/actionList.js b/vs/platform/actionWidget/browser/actionList.js
--- a/vs/platform/actionWidget/browser/actionList.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/actionWidget/browser/actionList.js	2023-12-06 14:23:14.387854798 +0000
@@ -7,15 +7,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 /*---------------------------------------------------------------------------------------------
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
@@ -29,7 +20,7 @@
 import { OS } from '../../../base/common/platform.js';
 import { ThemeIcon } from '../../../base/common/themables.js';
 import './actionWidget.css';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 import { IContextViewService } from '../../contextview/browser/contextView.js';
 import { IKeybindingService } from '../../keybinding/common/keybinding.js';
 import { defaultListStyles } from '../../theme/browser/defaultStyles.js';
@@ -45,8 +36,7 @@
         return { container, text };
     }
     renderElement(element, _index, templateData) {
-        var _a, _b;
-        templateData.text.textContent = (_b = (_a = element.group) === null || _a === void 0 ? void 0 : _a.title) !== null && _b !== void 0 ? _b : '';
+        templateData.text.textContent = element.group?.title ?? '';
     }
     disposeTemplate(_templateData) {
         // noop
@@ -70,8 +60,7 @@
         return { container, icon, text, keybinding };
     }
     renderElement(element, _index, data) {
-        var _a, _b, _c;
-        if ((_a = element.group) === null || _a === void 0 ? void 0 : _a.icon) {
+        if (element.group?.icon) {
             data.icon.className = ThemeIcon.asClassName(element.group.icon);
             if (element.group.icon.color) {
                 data.icon.style.color = asCssVariable(element.group.icon.color.id);
@@ -87,18 +76,18 @@
         data.text.textContent = stripNewlines(element.label);
         data.keybinding.set(element.keybinding);
         dom.setVisibility(!!element.keybinding, data.keybinding.element);
-        const actionTitle = (_b = this._keybindingService.lookupKeybinding(acceptSelectedActionCommand)) === null || _b === void 0 ? void 0 : _b.getLabel();
-        const previewTitle = (_c = this._keybindingService.lookupKeybinding(previewSelectedActionCommand)) === null || _c === void 0 ? void 0 : _c.getLabel();
+        const actionTitle = this._keybindingService.lookupKeybinding(acceptSelectedActionCommand)?.getLabel();
+        const previewTitle = this._keybindingService.lookupKeybinding(previewSelectedActionCommand)?.getLabel();
         data.container.classList.toggle('option-disabled', element.disabled);
         if (element.disabled) {
             data.container.title = element.label;
         }
         else if (actionTitle && previewTitle) {
             if (this._supportsPreview && element.canPreview) {
-                data.container.title = localize({ key: 'label-preview', comment: ['placeholders are keybindings, e.g "F2 to apply, Shift+F2 to preview"'] }, "{0} to apply, {1} to preview", actionTitle, previewTitle);
+                data.container.title = localizeWithPath('vs/platform/actionWidget/browser/actionList', { key: 'label-preview', comment: ['placeholders are keybindings, e.g "F2 to apply, Shift+F2 to preview"'] }, "{0} to apply, {1} to preview", actionTitle, previewTitle);
             }
             else {
-                data.container.title = localize({ key: 'label', comment: ['placeholder is a keybinding, e.g "F2 to apply"'] }, "{0} to apply", actionTitle);
+                data.container.title = localizeWithPath('vs/platform/actionWidget/browser/actionList', { key: 'label', comment: ['placeholder is a keybinding, e.g "F2 to apply"'] }, "{0} to apply", actionTitle);
             }
         }
         else {
@@ -150,15 +139,15 @@
             accessibilityProvider: {
                 getAriaLabel: element => {
                     if (element.kind === "action" /* ActionListItemKind.Action */) {
-                        let label = element.label ? stripNewlines(element === null || element === void 0 ? void 0 : element.label) : '';
+                        let label = element.label ? stripNewlines(element?.label) : '';
                         if (element.disabled) {
-                            label = localize({ key: 'customQuickFixWidget.labels', comment: [`Action widget labels for accessibility.`] }, "{0}, Disabled Reason: {1}", label, element.disabled);
+                            label = localizeWithPath('vs/platform/actionWidget/browser/actionList', { key: 'customQuickFixWidget.labels', comment: [`Action widget labels for accessibility.`] }, "{0}, Disabled Reason: {1}", label, element.disabled);
                         }
                         return label;
                     }
                     return null;
                 },
-                getWidgetAriaLabel: () => localize({ key: 'customQuickFixWidget', comment: [`An action widget option`] }, "Action Widget"),
+                getWidgetAriaLabel: () => localizeWithPath('vs/platform/actionWidget/browser/actionList', { key: 'customQuickFixWidget', comment: [`An action widget option`] }, "Action Widget"),
                 getRole: (e) => e.kind === "action" /* ActionListItemKind.Action */ ? 'option' : 'separator',
                 getWidgetRole: () => 'listbox',
             },
@@ -240,7 +229,6 @@
         }
     }
     onFocus() {
-        var _a, _b;
         this._list.domFocus();
         const focused = this._list.getFocus();
         if (focused.length === 0) {
@@ -248,22 +236,20 @@
         }
         const focusIndex = focused[0];
         const element = this._list.element(focusIndex);
-        (_b = (_a = this._delegate).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, element.item);
+        this._delegate.onFocus?.(element.item);
     }
-    onListHover(e) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const element = e.element;
-            if (element && element.item && this.focusCondition(element)) {
-                if (this._delegate.onHover && !element.disabled && element.kind === "action" /* ActionListItemKind.Action */) {
-                    const result = yield this._delegate.onHover(element.item, this.cts.token);
-                    element.canPreview = result ? result.canPreview : undefined;
-                }
-                if (e.index) {
-                    this._list.splice(e.index, 1, [element]);
-                }
+    async onListHover(e) {
+        const element = e.element;
+        if (element && element.item && this.focusCondition(element)) {
+            if (this._delegate.onHover && !element.disabled && element.kind === "action" /* ActionListItemKind.Action */) {
+                const result = await this._delegate.onHover(element.item, this.cts.token);
+                element.canPreview = result ? result.canPreview : undefined;
             }
-            this._list.setFocus(typeof e.index === 'number' ? [e.index] : []);
-        });
+            if (e.index) {
+                this._list.splice(e.index, 1, [element]);
+            }
+        }
+        this._list.setFocus(typeof e.index === 'number' ? [e.index] : []);
     }
     onListClick(e) {
         if (e.element && this.focusCondition(e.element)) {
diff -urN -x '*.map' a/vs/platform/actionWidget/browser/actionWidget.js b/vs/platform/actionWidget/browser/actionWidget.js
--- a/vs/platform/actionWidget/browser/actionWidget.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/actionWidget/browser/actionWidget.js	2023-12-06 14:23:14.387854798 +0000
@@ -15,7 +15,7 @@
 import { ActionBar } from '../../../base/browser/ui/actionbar/actionbar.js';
 import { Disposable, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';
 import './actionWidget.css';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 import { acceptSelectedActionCommand, ActionList, previewSelectedActionCommand } from './actionList.js';
 import { Action2, registerAction2 } from '../../actions/common/actions.js';
 import { IContextKeyService, RawContextKey } from '../../contextkey/common/contextkey.js';
@@ -23,9 +23,9 @@
 import { registerSingleton } from '../../instantiation/common/extensions.js';
 import { createDecorator, IInstantiationService } from '../../instantiation/common/instantiation.js';
 import { inputActiveOptionBackground, registerColor } from '../../theme/common/colorRegistry.js';
-registerColor('actionBar.toggledBackground', { dark: inputActiveOptionBackground, light: inputActiveOptionBackground, hcDark: inputActiveOptionBackground, hcLight: inputActiveOptionBackground, }, localize('actionBar.toggledBackground', 'Background color for toggled action items in action bar.'));
+registerColor('actionBar.toggledBackground', { dark: inputActiveOptionBackground, light: inputActiveOptionBackground, hcDark: inputActiveOptionBackground, hcLight: inputActiveOptionBackground, }, localizeWithPath('vs/platform/actionWidget/browser/actionWidget', 'actionBar.toggledBackground', 'Background color for toggled action items in action bar.'));
 const ActionWidgetContextKeys = {
-    Visible: new RawContextKey('codeActionMenuVisible', false, localize('codeActionMenuVisible', "Whether the action widget list is visible"))
+    Visible: new RawContextKey('codeActionMenuVisible', false, localizeWithPath('vs/platform/actionWidget/browser/actionWidget', 'codeActionMenuVisible', "Whether the action widget list is visible"))
 };
 export const IActionWidgetService = createDecorator('actionWidgetService');
 let ActionWidgetService = class ActionWidgetService extends Disposable {
@@ -46,7 +46,7 @@
             getAnchor: () => anchor,
             render: (container) => {
                 visibleContext.set(true);
-                return this._renderWidget(container, list, actionBarActions !== null && actionBarActions !== void 0 ? actionBarActions : []);
+                return this._renderWidget(container, list, actionBarActions ?? []);
             },
             onHide: (didCancel) => {
                 visibleContext.reset();
@@ -55,24 +55,22 @@
         }, container, false);
     }
     acceptSelected(preview) {
-        var _a;
-        (_a = this._list.value) === null || _a === void 0 ? void 0 : _a.acceptSelected(preview);
+        this._list.value?.acceptSelected(preview);
     }
     focusPrevious() {
-        var _a, _b;
-        (_b = (_a = this._list) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.focusPrevious();
+        this._list?.value?.focusPrevious();
     }
     focusNext() {
-        var _a, _b;
-        (_b = (_a = this._list) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.focusNext();
+        this._list?.value?.focusNext();
     }
     hide() {
-        var _a;
-        (_a = this._list.value) === null || _a === void 0 ? void 0 : _a.hide();
+        this._list.value?.hide();
+        this._list.clear();
+    }
+    clear() {
         this._list.clear();
     }
     _renderWidget(element, list, actionBarActions) {
-        var _a;
         const widget = document.createElement('div');
         widget.classList.add('action-widget');
         element.appendChild(widget);
@@ -106,7 +104,7 @@
                 actionBarWidth = actionBar.getContainer().offsetWidth;
             }
         }
-        const width = (_a = this._list.value) === null || _a === void 0 ? void 0 : _a.layout(actionBarWidth);
+        const width = this._list.value?.layout(actionBarWidth);
         widget.style.width = `${width}px`;
         const focusTracker = renderDisposables.add(dom.trackFocus(element));
         renderDisposables.add(focusTracker.onDidBlur(() => this.hide()));
@@ -122,8 +120,7 @@
         return actionBar;
     }
     _onWidgetClosed(didCancel) {
-        var _a;
-        (_a = this._list.value) === null || _a === void 0 ? void 0 : _a.hide(didCancel);
+        this._list.value?.hide(didCancel);
     }
 };
 ActionWidgetService = __decorate([
@@ -138,7 +135,7 @@
         super({
             id: 'hideCodeActionWidget',
             title: {
-                value: localize('hideCodeActionWidget.title', "Hide action widget"),
+                value: localizeWithPath('vs/platform/actionWidget/browser/actionWidget', 'hideCodeActionWidget.title', "Hide action widget"),
                 original: 'Hide action widget'
             },
             precondition: ActionWidgetContextKeys.Visible,
@@ -158,7 +155,7 @@
         super({
             id: 'selectPrevCodeAction',
             title: {
-                value: localize('selectPrevCodeAction.title', "Select previous action"),
+                value: localizeWithPath('vs/platform/actionWidget/browser/actionWidget', 'selectPrevCodeAction.title', "Select previous action"),
                 original: 'Select previous action'
             },
             precondition: ActionWidgetContextKeys.Visible,
@@ -182,7 +179,7 @@
         super({
             id: 'selectNextCodeAction',
             title: {
-                value: localize('selectNextCodeAction.title', "Select next action"),
+                value: localizeWithPath('vs/platform/actionWidget/browser/actionWidget', 'selectNextCodeAction.title', "Select next action"),
                 original: 'Select next action'
             },
             precondition: ActionWidgetContextKeys.Visible,
@@ -206,7 +203,7 @@
         super({
             id: acceptSelectedActionCommand,
             title: {
-                value: localize('acceptSelected.title', "Accept selected action"),
+                value: localizeWithPath('vs/platform/actionWidget/browser/actionWidget', 'acceptSelected.title', "Accept selected action"),
                 original: 'Accept selected action'
             },
             precondition: ActionWidgetContextKeys.Visible,
@@ -229,7 +226,7 @@
         super({
             id: previewSelectedActionCommand,
             title: {
-                value: localize('previewSelected.title', "Preview selected action"),
+                value: localizeWithPath('vs/platform/actionWidget/browser/actionWidget', 'previewSelected.title', "Preview selected action"),
                 original: 'Preview selected action'
             },
             precondition: ActionWidgetContextKeys.Visible,
diff -urN -x '*.map' a/vs/platform/actions/browser/menuEntryActionViewItem.js b/vs/platform/actions/browser/menuEntryActionViewItem.js
--- a/vs/platform/actions/browser/menuEntryActionViewItem.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/actions/browser/menuEntryActionViewItem.js	2023-12-06 14:23:14.387854798 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { $, addDisposableListener, append, asCSSUrl, EventType, ModifierKeyEmitter, prepend, reset } from '../../../base/browser/dom.js';
 import { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';
 import { ActionViewItem, BaseActionViewItem, SelectActionViewItem } from '../../../base/browser/ui/actionbar/actionViewItems.js';
@@ -29,7 +20,7 @@
 import { combinedDisposable, MutableDisposable, toDisposable } from '../../../base/common/lifecycle.js';
 import { isLinux, isWindows, OS } from '../../../base/common/platform.js';
 import './menuEntryActionViewItem.css';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 import { IMenuService, MenuItemAction, SubmenuItemAction } from '../common/actions.js';
 import { isICommandActionToggleInfo } from '../../action/common/action.js';
 import { IContextKeyService } from '../../contextkey/common/contextkey.js';
@@ -108,7 +99,7 @@
 }
 let MenuEntryActionViewItem = class MenuEntryActionViewItem extends ActionViewItem {
     constructor(action, options, _keybindingService, _notificationService, _contextKeyService, _themeService, _contextMenuService, _accessibilityService) {
-        super(undefined, action, { icon: !!(action.class || action.item.icon), label: !action.class && !action.item.icon, draggable: options === null || options === void 0 ? void 0 : options.draggable, keybinding: options === null || options === void 0 ? void 0 : options.keybinding, hoverDelegate: options === null || options === void 0 ? void 0 : options.hoverDelegate });
+        super(undefined, action, { icon: !!(action.class || action.item.icon), label: !action.class && !action.item.icon, draggable: options?.draggable, keybinding: options?.keybinding, hoverDelegate: options?.hoverDelegate });
         this._keybindingService = _keybindingService;
         this._notificationService = _notificationService;
         this._contextKeyService = _contextKeyService;
@@ -125,17 +116,15 @@
     get _commandAction() {
         return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;
     }
-    onClick(event) {
-        return __awaiter(this, void 0, void 0, function* () {
-            event.preventDefault();
-            event.stopPropagation();
-            try {
-                yield this.actionRunner.run(this._commandAction, this._context);
-            }
-            catch (err) {
-                this._notificationService.error(err);
-            }
-        });
+    async onClick(event) {
+        event.preventDefault();
+        event.stopPropagation();
+        try {
+            await this.actionRunner.run(this._commandAction, this._context);
+        }
+        catch (err) {
+            this._notificationService.error(err);
+        }
     }
     render(container) {
         super.render(container);
@@ -146,8 +135,7 @@
         if (this._menuItemAction.alt) {
             let isMouseOver = false;
             const updateAltState = () => {
-                var _a;
-                const wantsAltCommand = !!((_a = this._menuItemAction.alt) === null || _a === void 0 ? void 0 : _a.enabled) &&
+                const wantsAltCommand = !!this._menuItemAction.alt?.enabled &&
                     (!this._accessibilityService.isMotionReduced() || isMouseOver) && (this._altKey.keyStatus.altKey ||
                     (this._altKey.keyStatus.shiftKey && isMouseOver));
                 if (wantsAltCommand !== this._wantsAltCommand) {
@@ -175,21 +163,20 @@
         }
     }
     getTooltip() {
-        var _a;
         const keybinding = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService);
         const keybindingLabel = keybinding && keybinding.getLabel();
         const tooltip = this._commandAction.tooltip || this._commandAction.label;
         let title = keybindingLabel
-            ? localize('titleAndKb', "{0} ({1})", tooltip, keybindingLabel)
+            ? localizeWithPath('vs/platform/actions/browser/menuEntryActionViewItem', 'titleAndKb', "{0} ({1})", tooltip, keybindingLabel)
             : tooltip;
-        if (!this._wantsAltCommand && ((_a = this._menuItemAction.alt) === null || _a === void 0 ? void 0 : _a.enabled)) {
+        if (!this._wantsAltCommand && this._menuItemAction.alt?.enabled) {
             const altTooltip = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label;
             const altKeybinding = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService);
             const altKeybindingLabel = altKeybinding && altKeybinding.getLabel();
             const altTitleSection = altKeybindingLabel
-                ? localize('titleAndKb', "{0} ({1})", altTooltip, altKeybindingLabel)
+                ? localizeWithPath('vs/platform/actions/browser/menuEntryActionViewItem', 'titleAndKb', "{0} ({1})", altTooltip, altKeybindingLabel)
                 : altTooltip;
-            title = localize('titleAndKbAndAlt', "{0}\n[{1}] {2}", title, UILabelProvider.modifierLabels[OS].altKey, altTitleSection);
+            title = localizeWithPath('vs/platform/actions/browser/menuEntryActionViewItem', 'titleAndKbAndAlt', "{0}\n[{1}] {2}", title, UILabelProvider.modifierLabels[OS].altKey, altTitleSection);
         }
         return title;
     }
@@ -257,8 +244,12 @@
 export { MenuEntryActionViewItem };
 let SubmenuEntryActionViewItem = class SubmenuEntryActionViewItem extends DropdownMenuActionViewItem {
     constructor(action, options, _keybindingService, _contextMenuService, _themeService) {
-        var _a, _b, _c;
-        const dropdownOptions = Object.assign(Object.assign({}, options), { menuAsChild: (_a = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a !== void 0 ? _a : false, classNames: (_b = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b !== void 0 ? _b : (ThemeIcon.isThemeIcon(action.item.icon) ? ThemeIcon.asClassName(action.item.icon) : undefined), keybindingProvider: (_c = options === null || options === void 0 ? void 0 : options.keybindingProvider) !== null && _c !== void 0 ? _c : (action => _keybindingService.lookupKeybinding(action.id)) });
+        const dropdownOptions = {
+            ...options,
+            menuAsChild: options?.menuAsChild ?? false,
+            classNames: options?.classNames ?? (ThemeIcon.isThemeIcon(action.item.icon) ? ThemeIcon.asClassName(action.item.icon) : undefined),
+            keybindingProvider: options?.keybindingProvider ?? (action => _keybindingService.lookupKeybinding(action.id))
+        };
         super(action, { getActions: () => action.actions }, _contextMenuService, dropdownOptions);
         this._keybindingService = _keybindingService;
         this._contextMenuService = _contextMenuService;
@@ -294,8 +285,10 @@
 ], SubmenuEntryActionViewItem);
 export { SubmenuEntryActionViewItem };
 let DropdownWithDefaultActionViewItem = class DropdownWithDefaultActionViewItem extends BaseActionViewItem {
+    get onDidChangeDropdownVisibility() {
+        return this._dropdown.onDidChangeVisibility;
+    }
     constructor(submenuAction, options, _keybindingService, _notificationService, _contextMenuService, _menuService, _instaService, _storageService) {
-        var _a, _b, _c;
         super(null, submenuAction);
         this._keybindingService = _keybindingService;
         this._notificationService = _notificationService;
@@ -308,7 +301,7 @@
         this._storageKey = `${submenuAction.item.submenu.id}_lastActionId`;
         // determine default action
         let defaultAction;
-        const defaultActionId = (options === null || options === void 0 ? void 0 : options.persistLastActionId) ? _storageService.get(this._storageKey, 1 /* StorageScope.WORKSPACE */) : undefined;
+        const defaultActionId = options?.persistLastActionId ? _storageService.get(this._storageKey, 1 /* StorageScope.WORKSPACE */) : undefined;
         if (defaultActionId) {
             defaultAction = submenuAction.actions.find(a => defaultActionId === a.id);
         }
@@ -316,7 +309,13 @@
             defaultAction = submenuAction.actions[0];
         }
         this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, defaultAction, { keybinding: this._getDefaultActionKeybindingLabel(defaultAction) });
-        const dropdownOptions = Object.assign(Object.assign({ keybindingProvider: action => this._keybindingService.lookupKeybinding(action.id) }, options), { menuAsChild: (_a = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a !== void 0 ? _a : true, classNames: (_b = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b !== void 0 ? _b : ['codicon', 'codicon-chevron-down'], actionRunner: (_c = options === null || options === void 0 ? void 0 : options.actionRunner) !== null && _c !== void 0 ? _c : new ActionRunner() });
+        const dropdownOptions = {
+            keybindingProvider: action => this._keybindingService.lookupKeybinding(action.id),
+            ...options,
+            menuAsChild: options?.menuAsChild ?? true,
+            classNames: options?.classNames ?? ['codicon', 'codicon-chevron-down'],
+            actionRunner: options?.actionRunner ?? new ActionRunner(),
+        };
         this._dropdown = new DropdownMenuActionViewItem(submenuAction, submenuAction.actions, this._contextMenuService, dropdownOptions);
         this._dropdown.actionRunner.onDidRun((e) => {
             if (e.action instanceof MenuItemAction) {
@@ -325,17 +324,14 @@
         });
     }
     update(lastAction) {
-        var _a;
-        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.persistLastActionId) {
+        if (this._options?.persistLastActionId) {
             this._storageService.store(this._storageKey, lastAction.id, 1 /* StorageScope.WORKSPACE */, 1 /* StorageTarget.MACHINE */);
         }
         this._defaultAction.dispose();
         this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, lastAction, { keybinding: this._getDefaultActionKeybindingLabel(lastAction) });
         this._defaultAction.actionRunner = new class extends ActionRunner {
-            runAction(action, context) {
-                return __awaiter(this, void 0, void 0, function* () {
-                    yield action.run(undefined);
-                });
+            async runAction(action, context) {
+                await action.run(undefined);
             }
         }();
         if (this._container) {
@@ -343,9 +339,8 @@
         }
     }
     _getDefaultActionKeybindingLabel(defaultAction) {
-        var _a;
         let defaultActionKeybinding;
-        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.renderKeybindingWithDefaultActionLabel) {
+        if (this._options?.renderKeybindingWithDefaultActionLabel) {
             const kb = this._keybindingService.lookupKeybinding(defaultAction.id);
             if (kb) {
                 defaultActionKeybinding = `(${kb.getLabel()})`;
@@ -375,12 +370,11 @@
         const dropdownContainer = $('.dropdown-action-container');
         this._dropdown.render(append(this._container, dropdownContainer));
         this._register(addDisposableListener(dropdownContainer, EventType.KEY_DOWN, (e) => {
-            var _a;
             const event = new StandardKeyboardEvent(e);
             if (event.equals(15 /* KeyCode.LeftArrow */)) {
                 this._defaultAction.element.tabIndex = 0;
                 this._dropdown.setFocusable(false);
-                (_a = this._defaultAction.element) === null || _a === void 0 ? void 0 : _a.focus();
+                this._defaultAction.element?.focus();
                 event.stopPropagation();
             }
         }));
@@ -458,7 +452,7 @@
         }
         else {
             if (action.item.rememberDefaultAction) {
-                return instaService.createInstance(DropdownWithDefaultActionViewItem, action, Object.assign(Object.assign({}, options), { persistLastActionId: true }));
+                return instaService.createInstance(DropdownWithDefaultActionViewItem, action, { ...options, persistLastActionId: true });
             }
             else {
                 return instaService.createInstance(SubmenuEntryActionViewItem, action, options);
diff -urN -x '*.map' a/vs/platform/actions/browser/toolbar.js b/vs/platform/actions/browser/toolbar.js
--- a/vs/platform/actions/browser/toolbar.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/actions/browser/toolbar.js	2023-12-06 14:23:14.387854798 +0000
@@ -17,9 +17,12 @@
 import { Separator, toAction } from '../../../base/common/actions.js';
 import { coalesceInPlace } from '../../../base/common/arrays.js';
 import { intersection } from '../../../base/common/collections.js';
+import { BugIndicatingError } from '../../../base/common/errors.js';
+import { Emitter } from '../../../base/common/event.js';
 import { Iterable } from '../../../base/common/iterator.js';
 import { DisposableStore } from '../../../base/common/lifecycle.js';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
+import { createAndFillInActionBarActions } from './menuEntryActionViewItem.js';
 import { IMenuService, MenuItemAction, SubmenuItemAction } from '../common/actions.js';
 import { IContextKeyService } from '../../contextkey/common/contextkey.js';
 import { IContextMenuService } from '../../contextview/browser/contextView.js';
@@ -35,24 +38,27 @@
  */
 let WorkbenchToolBar = class WorkbenchToolBar extends ToolBar {
     constructor(container, _options, _menuService, _contextKeyService, _contextMenuService, keybindingService, telemetryService) {
-        super(container, _contextMenuService, Object.assign(Object.assign({ 
+        super(container, _contextMenuService, {
             // defaults
-            getKeyBinding: (action) => { var _a; return (_a = keybindingService.lookupKeybinding(action.id)) !== null && _a !== void 0 ? _a : undefined; } }, _options), { 
+            getKeyBinding: (action) => keybindingService.lookupKeybinding(action.id) ?? undefined,
+            // options (override defaults)
+            ..._options,
             // mandatory (overide options)
-            allowContextMenu: true, skipTelemetry: typeof (_options === null || _options === void 0 ? void 0 : _options.telemetrySource) === 'string' }));
+            allowContextMenu: true,
+            skipTelemetry: typeof _options?.telemetrySource === 'string',
+        });
         this._options = _options;
         this._menuService = _menuService;
         this._contextKeyService = _contextKeyService;
         this._contextMenuService = _contextMenuService;
         this._sessionDisposables = this._store.add(new DisposableStore());
         // telemetry logic
-        const telemetrySource = _options === null || _options === void 0 ? void 0 : _options.telemetrySource;
+        const telemetrySource = _options?.telemetrySource;
         if (telemetrySource) {
             this._store.add(this.actionBar.onDidRun(e => telemetryService.publicLog2('workbenchActionExecuted', { id: e.action.id, from: telemetrySource })));
         }
     }
     setActions(_primary, _secondary = [], menuIds) {
-        var _a, _b, _c;
         this._sessionDisposables.clear();
         const primary = _primary.slice(); // for hiding and overflow we set some items to undefined
         const secondary = _secondary.slice();
@@ -61,7 +67,7 @@
         const extraSecondary = [];
         let someAreHidden = false;
         // unless disabled, move all hidden items to secondary group or ignore them
-        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.hiddenItemStrategy) !== -1 /* HiddenItemStrategy.NoHide */) {
+        if (this._options?.hiddenItemStrategy !== -1 /* HiddenItemStrategy.NoHide */) {
             for (let i = 0; i < primary.length; i++) {
                 const action = primary[i];
                 if (!(action instanceof MenuItemAction) && !(action instanceof SubmenuItemAction)) {
@@ -80,15 +86,15 @@
                 if (action.hideActions.isHidden) {
                     someAreHidden = true;
                     primary[i] = undefined;
-                    if (((_b = this._options) === null || _b === void 0 ? void 0 : _b.hiddenItemStrategy) !== 0 /* HiddenItemStrategy.Ignore */) {
+                    if (this._options?.hiddenItemStrategy !== 0 /* HiddenItemStrategy.Ignore */) {
                         extraSecondary[i] = action;
                     }
                 }
             }
         }
         // count for max
-        if (((_c = this._options) === null || _c === void 0 ? void 0 : _c.overflowBehavior) !== undefined) {
-            const exemptedIds = intersection(new Set(this._options.overflowBehavior.exempted), Iterable.map(primary, a => a === null || a === void 0 ? void 0 : a.id));
+        if (this._options?.overflowBehavior !== undefined) {
+            const exemptedIds = intersection(new Set(this._options.overflowBehavior.exempted), Iterable.map(primary, a => a?.id));
             const maxItems = this._options.overflowBehavior.maxItems - exemptedIds.size;
             let count = 0;
             for (let i = 0; i < primary.length; i++) {
@@ -113,7 +119,6 @@
         // add context menu for toggle actions
         if (toggleActions.length > 0) {
             this._sessionDisposables.add(addDisposableListener(this.getElement(), 'contextmenu', e => {
-                var _a, _b, _c, _d, _e;
                 const event = new StandardMouseEvent(e);
                 const action = this.getItemAction(event.target);
                 if (!(action)) {
@@ -123,7 +128,7 @@
                 event.stopPropagation();
                 let noHide = false;
                 // last item cannot be hidden when using ignore strategy
-                if (toggleActionsCheckedCount === 1 && ((_a = this._options) === null || _a === void 0 ? void 0 : _a.hiddenItemStrategy) === 0 /* HiddenItemStrategy.Ignore */) {
+                if (toggleActionsCheckedCount === 1 && this._options?.hiddenItemStrategy === 0 /* HiddenItemStrategy.Ignore */) {
                     noHide = true;
                     for (let i = 0; i < toggleActions.length; i++) {
                         if (toggleActions[i].checked) {
@@ -151,21 +156,21 @@
                 else {
                     hideAction = toAction({
                         id: 'label',
-                        label: localize('hide', "Hide"),
+                        label: localizeWithPath('vs/platform/actions/browser/toolbar', 'hide', "Hide"),
                         enabled: false,
                         run() { }
                     });
                 }
                 const actions = Separator.join([hideAction], toggleActions);
                 // add "Reset Menu" action
-                if (((_b = this._options) === null || _b === void 0 ? void 0 : _b.resetMenu) && !menuIds) {
+                if (this._options?.resetMenu && !menuIds) {
                     menuIds = [this._options.resetMenu];
                 }
                 if (someAreHidden && menuIds) {
                     actions.push(new Separator());
                     actions.push(toAction({
                         id: 'resetThisMenu',
-                        label: localize('resetThisMenu', "Reset Menu"),
+                        label: localizeWithPath('vs/platform/actions/browser/toolbar', 'resetThisMenu', "Reset Menu"),
                         run: () => this._menuService.resetHiddenStates(menuIds)
                     }));
                 }
@@ -173,9 +178,9 @@
                     getAnchor: () => event,
                     getActions: () => actions,
                     // add context menu actions (iff appicable)
-                    menuId: (_c = this._options) === null || _c === void 0 ? void 0 : _c.contextMenu,
-                    menuActionOptions: Object.assign({ renderShortTitle: true }, (_d = this._options) === null || _d === void 0 ? void 0 : _d.menuOptions),
-                    skipTelemetry: typeof ((_e = this._options) === null || _e === void 0 ? void 0 : _e.telemetrySource) === 'string',
+                    menuId: this._options?.contextMenu,
+                    menuActionOptions: { renderShortTitle: true, ...this._options?.menuOptions },
+                    skipTelemetry: typeof this._options?.telemetrySource === 'string',
                     contextKeyService: this._contextKeyService,
                 });
             }));
@@ -190,3 +195,42 @@
     __param(6, ITelemetryService)
 ], WorkbenchToolBar);
 export { WorkbenchToolBar };
+/**
+ * A {@link WorkbenchToolBar workbench toolbar} that is purely driven from a {@link MenuId menu}-identifier.
+ *
+ * *Note* that Manual updates via `setActions` are NOT supported.
+ */
+let MenuWorkbenchToolBar = class MenuWorkbenchToolBar extends WorkbenchToolBar {
+    constructor(container, menuId, options, menuService, contextKeyService, contextMenuService, keybindingService, telemetryService) {
+        super(container, { resetMenu: menuId, ...options }, menuService, contextKeyService, contextMenuService, keybindingService, telemetryService);
+        this._onDidChangeMenuItems = this._store.add(new Emitter());
+        this.onDidChangeMenuItems = this._onDidChangeMenuItems.event;
+        // update logic
+        const menu = this._store.add(menuService.createMenu(menuId, contextKeyService, { emitEventsForSubmenuChanges: true }));
+        const updateToolbar = () => {
+            const primary = [];
+            const secondary = [];
+            createAndFillInActionBarActions(menu, options?.menuOptions, { primary, secondary }, options?.toolbarOptions?.primaryGroup, options?.toolbarOptions?.shouldInlineSubmenu, options?.toolbarOptions?.useSeparatorsInPrimaryActions);
+            super.setActions(primary, secondary);
+        };
+        this._store.add(menu.onDidChange(() => {
+            updateToolbar();
+            this._onDidChangeMenuItems.fire(this);
+        }));
+        updateToolbar();
+    }
+    /**
+     * @deprecated The WorkbenchToolBar does not support this method because it works with menus.
+     */
+    setActions() {
+        throw new BugIndicatingError('This toolbar is populated from a menu.');
+    }
+};
+MenuWorkbenchToolBar = __decorate([
+    __param(3, IMenuService),
+    __param(4, IContextKeyService),
+    __param(5, IContextMenuService),
+    __param(6, IKeybindingService),
+    __param(7, ITelemetryService)
+], MenuWorkbenchToolBar);
+export { MenuWorkbenchToolBar };
diff -urN -x '*.map' a/vs/platform/actions/common/actions.js b/vs/platform/actions/common/actions.js
--- a/vs/platform/actions/common/actions.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/actions/common/actions.js	2023-12-06 14:23:14.387854798 +0000
@@ -11,17 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __rest = (this && this.__rest) || function (s, e) {
-    var t = {};
-    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
-        t[p] = s[p];
-    if (s != null && typeof Object.getOwnPropertySymbols === "function")
-        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
-            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
-                t[p[i]] = s[p[i]];
-        }
-    return t;
-};
 var MenuItemAction_1;
 import { SubmenuAction } from '../../../base/common/actions.js';
 import { ThemeIcon } from '../../../base/common/themables.js';
@@ -40,6 +29,12 @@
 }
 export class MenuId {
     /**
+     * Create or reuse a `MenuId` with the given identifier
+     */
+    static for(identifier) {
+        return MenuId._instances.get(identifier) ?? new MenuId(identifier);
+    }
+    /**
      * Create a new `MenuId` with the unique identifier. Will throw if a menu
      * with the identifier already exists, use `MenuId.for(ident)` or a unique
      * identifier
@@ -310,17 +305,16 @@
 // subscribes to events of Action or modified properties
 let MenuItemAction = MenuItemAction_1 = class MenuItemAction {
     static label(action, options) {
-        return (options === null || options === void 0 ? void 0 : options.renderShortTitle) && action.shortTitle
+        return options?.renderShortTitle && action.shortTitle
             ? (typeof action.shortTitle === 'string' ? action.shortTitle : action.shortTitle.value)
             : (typeof action.title === 'string' ? action.title : action.title.value);
     }
     constructor(item, alt, options, hideActions, contextKeyService, _commandService) {
-        var _a, _b;
         this.hideActions = hideActions;
         this._commandService = _commandService;
         this.id = item.id;
         this.label = MenuItemAction_1.label(item, options);
-        this.tooltip = (_b = (typeof item.tooltip === 'string' ? item.tooltip : (_a = item.tooltip) === null || _a === void 0 ? void 0 : _a.value)) !== null && _b !== void 0 ? _b : '';
+        this.tooltip = (typeof item.tooltip === 'string' ? item.tooltip : item.tooltip?.value) ?? '';
         this.enabled = !item.precondition || contextKeyService.contextMatchesRules(item.precondition);
         this.checked = undefined;
         let icon;
@@ -346,12 +340,11 @@
         this.class = icon && ThemeIcon.asClassName(icon);
     }
     run(...args) {
-        var _a, _b;
         let runArgs = [];
-        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.arg) {
+        if (this._options?.arg) {
             runArgs = [...runArgs, this._options.arg];
         }
-        if ((_b = this._options) === null || _b === void 0 ? void 0 : _b.shouldForwardArgs) {
+        if (this._options?.shouldForwardArgs) {
             runArgs = [...runArgs, ...args];
         }
         return this._commandService.executeCommand(this.id, ...runArgs);
@@ -370,7 +363,7 @@
 export function registerAction2(ctor) {
     const disposables = new DisposableStore();
     const action = new ctor();
-    const _a = action.desc, { f1, menu, keybinding, description } = _a, command = __rest(_a, ["f1", "menu", "keybinding", "description"]);
+    const { f1, menu, keybinding, description, ...command } = action.desc;
     // command
     disposables.add(CommandsRegistry.registerCommand({
         id: command.id,
@@ -380,11 +373,11 @@
     // menu
     if (Array.isArray(menu)) {
         for (const item of menu) {
-            disposables.add(MenuRegistry.appendMenuItem(item.id, Object.assign({ command: Object.assign(Object.assign({}, command), { precondition: item.precondition === null ? undefined : command.precondition }) }, item)));
+            disposables.add(MenuRegistry.appendMenuItem(item.id, { command: { ...command, precondition: item.precondition === null ? undefined : command.precondition }, ...item }));
         }
     }
     else if (menu) {
-        disposables.add(MenuRegistry.appendMenuItem(menu.id, Object.assign({ command: Object.assign(Object.assign({}, command), { precondition: menu.precondition === null ? undefined : command.precondition }) }, menu)));
+        disposables.add(MenuRegistry.appendMenuItem(menu.id, { command: { ...command, precondition: menu.precondition === null ? undefined : command.precondition }, ...menu }));
     }
     if (f1) {
         disposables.add(MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command, when: command.precondition }));
@@ -393,11 +386,19 @@
     // keybinding
     if (Array.isArray(keybinding)) {
         for (const item of keybinding) {
-            disposables.add(KeybindingsRegistry.registerKeybindingRule(Object.assign(Object.assign({}, item), { id: command.id, when: command.precondition ? ContextKeyExpr.and(command.precondition, item.when) : item.when })));
+            disposables.add(KeybindingsRegistry.registerKeybindingRule({
+                ...item,
+                id: command.id,
+                when: command.precondition ? ContextKeyExpr.and(command.precondition, item.when) : item.when
+            }));
         }
     }
     else if (keybinding) {
-        disposables.add(KeybindingsRegistry.registerKeybindingRule(Object.assign(Object.assign({}, keybinding), { id: command.id, when: command.precondition ? ContextKeyExpr.and(command.precondition, keybinding.when) : keybinding.when })));
+        disposables.add(KeybindingsRegistry.registerKeybindingRule({
+            ...keybinding,
+            id: command.id,
+            when: command.precondition ? ContextKeyExpr.and(command.precondition, keybinding.when) : keybinding.when
+        }));
     }
     return disposables;
 }
diff -urN -x '*.map' a/vs/platform/actions/common/menuService.js b/vs/platform/actions/common/menuService.js
--- a/vs/platform/actions/common/menuService.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/actions/common/menuService.js	2023-12-06 14:23:14.387854798 +0000
@@ -21,14 +21,14 @@
 import { Separator, toAction } from '../../../base/common/actions.js';
 import { IStorageService } from '../../storage/common/storage.js';
 import { removeFastWithoutKeepingOrder } from '../../../base/common/arrays.js';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 let MenuService = class MenuService {
     constructor(_commandService, storageService) {
         this._commandService = _commandService;
         this._hiddenStates = new PersistedMenuHideState(storageService);
     }
     createMenu(id, contextKeyService, options) {
-        return new MenuImpl(id, this._hiddenStates, Object.assign({ emitEventsForSubmenuChanges: false, eventDebounceDelay: 50 }, options), this._commandService, contextKeyService);
+        return new MenuImpl(id, this._hiddenStates, { emitEventsForSubmenuChanges: false, eventDebounceDelay: 50, ...options }, this._commandService, contextKeyService);
     }
     resetHiddenStates(ids) {
         this._hiddenStates.reset(ids);
@@ -72,16 +72,14 @@
         this._disposables.dispose();
     }
     _isHiddenByDefault(menu, commandId) {
-        var _a;
-        return (_a = this._hiddenByDefaultCache.get(`${menu.id}/${commandId}`)) !== null && _a !== void 0 ? _a : false;
+        return this._hiddenByDefaultCache.get(`${menu.id}/${commandId}`) ?? false;
     }
     setDefaultState(menu, commandId, hidden) {
         this._hiddenByDefaultCache.set(`${menu.id}/${commandId}`, hidden);
     }
     isHidden(menu, commandId) {
-        var _a, _b;
         const hiddenByDefault = this._isHiddenByDefault(menu, commandId);
-        const state = (_b = (_a = this._data[menu.id]) === null || _a === void 0 ? void 0 : _a.includes(commandId)) !== null && _b !== void 0 ? _b : false;
+        const state = this._data[menu.id]?.includes(commandId) ?? false;
         return hiddenByDefault ? !state : state;
     }
     updateHidden(menu, commandId, hidden) {
@@ -369,7 +367,7 @@
     const title = typeof command.title === 'string' ? command.title : command.title.value;
     const hide = toAction({
         id: `hide/${menu.id}/${id}`,
-        label: localize('hide.label', 'Hide \'{0}\'', title),
+        label: localizeWithPath('vs/platform/actions/common/menuService', 'hide.label', 'Hide \'{0}\'', title),
         run() { states.updateHidden(menu, id, true); }
     });
     const toggle = toAction({
diff -urN -x '*.map' a/vs/platform/audioCues/browser/audioCueService.js b/vs/platform/audioCues/browser/audioCueService.js
--- a/vs/platform/audioCues/browser/audioCueService.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/audioCues/browser/audioCueService.js	2023-12-06 14:23:14.387854798 +0000
@@ -1,6 +1,179 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
+    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
+    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
+    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
+    return c > 3 && r && Object.defineProperty(target, key, r), r;
+};
+var __param = (this && this.__param) || function (paramIndex, decorator) {
+    return function (target, key) { decorator(target, key, paramIndex); }
+};
+import { Disposable, toDisposable } from '../../../base/common/lifecycle.js';
+import { FileAccess } from '../../../base/common/network.js';
+import { IAccessibilityService } from '../../accessibility/common/accessibility.js';
+import { IConfigurationService } from '../../configuration/common/configuration.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
-import { localize } from '../../../nls.js';
+import { Event } from '../../../base/common/event.js';
+import { localizeWithPath } from '../../../nls.js';
+import { observableFromEvent, derived } from '../../../base/common/observable.js';
+import { ITelemetryService } from '../../telemetry/common/telemetry.js';
 export const IAudioCueService = createDecorator('audioCue');
+let AudioCueService = class AudioCueService extends Disposable {
+    constructor(configurationService, accessibilityService, telemetryService) {
+        super();
+        this.configurationService = configurationService;
+        this.accessibilityService = accessibilityService;
+        this.telemetryService = telemetryService;
+        this.sounds = new Map();
+        this.screenReaderAttached = observableFromEvent(this.accessibilityService.onDidChangeScreenReaderOptimized, () => /** @description accessibilityService.onDidChangeScreenReaderOptimized */ this.accessibilityService.isScreenReaderOptimized());
+        this.sentTelemetry = new Set();
+        this.playingSounds = new Set();
+        this.obsoleteAudioCuesEnabled = observableFromEvent(Event.filter(this.configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration('audioCues.enabled')), () => /** @description config: audioCues.enabled */ this.configurationService.getValue('audioCues.enabled'));
+        this.isEnabledCache = new Cache((cue) => {
+            const settingObservable = observableFromEvent(Event.filter(this.configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration(cue.settingsKey)), () => this.configurationService.getValue(cue.settingsKey));
+            return derived(reader => {
+                /** @description audio cue enabled */
+                const setting = settingObservable.read(reader);
+                if (setting === 'on' ||
+                    (setting === 'auto' && this.screenReaderAttached.read(reader))) {
+                    return true;
+                }
+                const obsoleteSetting = this.obsoleteAudioCuesEnabled.read(reader);
+                if (obsoleteSetting === 'on' ||
+                    (obsoleteSetting === 'auto' && this.screenReaderAttached.read(reader))) {
+                    return true;
+                }
+                return false;
+            });
+        });
+    }
+    async playAudioCue(cue, options = {}) {
+        if (this.isEnabled(cue)) {
+            this.sendAudioCueTelemetry(cue, options.source);
+            await this.playSound(cue.sound.getSound(), options.allowManyInParallel);
+        }
+    }
+    async playAudioCues(cues) {
+        for (const cue of cues) {
+            this.sendAudioCueTelemetry('cue' in cue ? cue.cue : cue, 'source' in cue ? cue.source : undefined);
+        }
+        // Some audio cues might reuse sounds. Don't play the same sound twice.
+        const sounds = new Set(cues.map(c => 'cue' in c ? c.cue : c).filter(cue => this.isEnabled(cue)).map(cue => cue.sound.getSound()));
+        await Promise.all(Array.from(sounds).map(sound => this.playSound(sound, true)));
+    }
+    sendAudioCueTelemetry(cue, source) {
+        const isScreenReaderOptimized = this.accessibilityService.isScreenReaderOptimized();
+        const key = cue.name + (source ? `::${source}` : '') + (isScreenReaderOptimized ? '{screenReaderOptimized}' : '');
+        // Only send once per user session
+        if (this.sentTelemetry.has(key) || this.getVolumeInPercent() === 0) {
+            return;
+        }
+        this.sentTelemetry.add(key);
+        this.telemetryService.publicLog2('audioCue.played', {
+            audioCue: cue.name,
+            source: source ?? '',
+            isScreenReaderOptimized,
+        });
+    }
+    getVolumeInPercent() {
+        const volume = this.configurationService.getValue('audioCues.volume');
+        if (typeof volume !== 'number') {
+            return 50;
+        }
+        return Math.max(Math.min(volume, 100), 0);
+    }
+    async playSound(sound, allowManyInParallel = false) {
+        if (!allowManyInParallel && this.playingSounds.has(sound)) {
+            return;
+        }
+        this.playingSounds.add(sound);
+        const url = FileAccess.asBrowserUri(`vs/platform/audioCues/browser/media/${sound.fileName}`).toString(true);
+        try {
+            const sound = this.sounds.get(url);
+            if (sound) {
+                sound.volume = this.getVolumeInPercent() / 100;
+                sound.currentTime = 0;
+                await sound.play();
+            }
+            else {
+                const playedSound = await playAudio(url, this.getVolumeInPercent() / 100);
+                this.sounds.set(url, playedSound);
+            }
+        }
+        catch (e) {
+            console.error('Error while playing sound', e);
+        }
+        finally {
+            this.playingSounds.delete(sound);
+        }
+    }
+    playAudioCueLoop(cue, milliseconds) {
+        let playing = true;
+        const playSound = () => {
+            if (playing) {
+                this.playAudioCue(cue, { allowManyInParallel: true }).finally(() => {
+                    setTimeout(() => {
+                        if (playing) {
+                            playSound();
+                        }
+                    }, milliseconds);
+                });
+            }
+        };
+        playSound();
+        return toDisposable(() => playing = false);
+    }
+    isEnabled(cue) {
+        return this.isEnabledCache.get(cue).get();
+    }
+    onEnabledChanged(cue) {
+        return Event.fromObservableLight(this.isEnabledCache.get(cue));
+    }
+};
+AudioCueService = __decorate([
+    __param(0, IConfigurationService),
+    __param(1, IAccessibilityService),
+    __param(2, ITelemetryService)
+], AudioCueService);
+export { AudioCueService };
+/**
+ * Play the given audio url.
+ * @volume value between 0 and 1
+ */
+function playAudio(url, volume) {
+    return new Promise((resolve, reject) => {
+        const audio = new Audio(url);
+        audio.volume = volume;
+        audio.addEventListener('ended', () => {
+            resolve(audio);
+        });
+        audio.addEventListener('error', (e) => {
+            // When the error event fires, ended might not be called
+            reject(e.error);
+        });
+        audio.play().catch(e => {
+            // When play fails, the error event is not fired.
+            reject(e);
+        });
+    });
+}
+class Cache {
+    constructor(getValue) {
+        this.getValue = getValue;
+        this.map = new Map();
+    }
+    get(arg) {
+        if (this.map.has(arg)) {
+            return this.map.get(arg);
+        }
+        const value = this.getValue(arg);
+        this.map.set(arg, value);
+        return value;
+    }
+}
 /**
  * Corresponds to the audio files in ./media.
 */
@@ -34,6 +207,15 @@
     constructor(randomOneOf) {
         this.randomOneOf = randomOneOf;
     }
+    getSound(deterministic = false) {
+        if (deterministic || this.randomOneOf.length === 1) {
+            return this.randomOneOf[0];
+        }
+        else {
+            const index = Math.floor(Math.random() * this.randomOneOf.length);
+            return this.randomOneOf[index];
+        }
+    }
 }
 export class AudioCue {
     static register(options) {
@@ -42,6 +224,9 @@
         AudioCue._audioCues.add(audioCue);
         return audioCue;
     }
+    static get allAudioCues() {
+        return [...this._audioCues];
+    }
     constructor(sound, name, settingsKey) {
         this.sound = sound;
         this.name = name;
@@ -50,97 +235,97 @@
 }
 AudioCue._audioCues = new Set();
 AudioCue.error = AudioCue.register({
-    name: localize('audioCues.lineHasError.name', 'Error on Line'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.lineHasError.name', 'Error on Line'),
     sound: Sound.error,
     settingsKey: 'audioCues.lineHasError',
 });
 AudioCue.warning = AudioCue.register({
-    name: localize('audioCues.lineHasWarning.name', 'Warning on Line'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.lineHasWarning.name', 'Warning on Line'),
     sound: Sound.warning,
     settingsKey: 'audioCues.lineHasWarning',
 });
 AudioCue.foldedArea = AudioCue.register({
-    name: localize('audioCues.lineHasFoldedArea.name', 'Folded Area on Line'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.lineHasFoldedArea.name', 'Folded Area on Line'),
     sound: Sound.foldedArea,
     settingsKey: 'audioCues.lineHasFoldedArea',
 });
 AudioCue.break = AudioCue.register({
-    name: localize('audioCues.lineHasBreakpoint.name', 'Breakpoint on Line'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.lineHasBreakpoint.name', 'Breakpoint on Line'),
     sound: Sound.break,
     settingsKey: 'audioCues.lineHasBreakpoint',
 });
 AudioCue.inlineSuggestion = AudioCue.register({
-    name: localize('audioCues.lineHasInlineSuggestion.name', 'Inline Suggestion on Line'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.lineHasInlineSuggestion.name', 'Inline Suggestion on Line'),
     sound: Sound.quickFixes,
     settingsKey: 'audioCues.lineHasInlineSuggestion',
 });
 AudioCue.terminalQuickFix = AudioCue.register({
-    name: localize('audioCues.terminalQuickFix.name', 'Terminal Quick Fix'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.terminalQuickFix.name', 'Terminal Quick Fix'),
     sound: Sound.quickFixes,
     settingsKey: 'audioCues.terminalQuickFix',
 });
 AudioCue.onDebugBreak = AudioCue.register({
-    name: localize('audioCues.onDebugBreak.name', 'Debugger Stopped on Breakpoint'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.onDebugBreak.name', 'Debugger Stopped on Breakpoint'),
     sound: Sound.break,
     settingsKey: 'audioCues.onDebugBreak',
 });
 AudioCue.noInlayHints = AudioCue.register({
-    name: localize('audioCues.noInlayHints', 'No Inlay Hints on Line'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.noInlayHints', 'No Inlay Hints on Line'),
     sound: Sound.error,
     settingsKey: 'audioCues.noInlayHints'
 });
 AudioCue.taskCompleted = AudioCue.register({
-    name: localize('audioCues.taskCompleted', 'Task Completed'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.taskCompleted', 'Task Completed'),
     sound: Sound.taskCompleted,
     settingsKey: 'audioCues.taskCompleted'
 });
 AudioCue.taskFailed = AudioCue.register({
-    name: localize('audioCues.taskFailed', 'Task Failed'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.taskFailed', 'Task Failed'),
     sound: Sound.taskFailed,
     settingsKey: 'audioCues.taskFailed'
 });
 AudioCue.terminalCommandFailed = AudioCue.register({
-    name: localize('audioCues.terminalCommandFailed', 'Terminal Command Failed'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.terminalCommandFailed', 'Terminal Command Failed'),
     sound: Sound.error,
     settingsKey: 'audioCues.terminalCommandFailed'
 });
 AudioCue.terminalBell = AudioCue.register({
-    name: localize('audioCues.terminalBell', 'Terminal Bell'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.terminalBell', 'Terminal Bell'),
     sound: Sound.terminalBell,
     settingsKey: 'audioCues.terminalBell'
 });
 AudioCue.notebookCellCompleted = AudioCue.register({
-    name: localize('audioCues.notebookCellCompleted', 'Notebook Cell Completed'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.notebookCellCompleted', 'Notebook Cell Completed'),
     sound: Sound.taskCompleted,
     settingsKey: 'audioCues.notebookCellCompleted'
 });
 AudioCue.notebookCellFailed = AudioCue.register({
-    name: localize('audioCues.notebookCellFailed', 'Notebook Cell Failed'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.notebookCellFailed', 'Notebook Cell Failed'),
     sound: Sound.taskFailed,
     settingsKey: 'audioCues.notebookCellFailed'
 });
 AudioCue.diffLineInserted = AudioCue.register({
-    name: localize('audioCues.diffLineInserted', 'Diff Line Inserted'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.diffLineInserted', 'Diff Line Inserted'),
     sound: Sound.diffLineInserted,
     settingsKey: 'audioCues.diffLineInserted'
 });
 AudioCue.diffLineDeleted = AudioCue.register({
-    name: localize('audioCues.diffLineDeleted', 'Diff Line Deleted'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.diffLineDeleted', 'Diff Line Deleted'),
     sound: Sound.diffLineDeleted,
     settingsKey: 'audioCues.diffLineDeleted'
 });
 AudioCue.diffLineModified = AudioCue.register({
-    name: localize('audioCues.diffLineModified', 'Diff Line Modified'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.diffLineModified', 'Diff Line Modified'),
     sound: Sound.diffLineModified,
     settingsKey: 'audioCues.diffLineModified'
 });
 AudioCue.chatRequestSent = AudioCue.register({
-    name: localize('audioCues.chatRequestSent', 'Chat Request Sent'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.chatRequestSent', 'Chat Request Sent'),
     sound: Sound.chatRequestSent,
     settingsKey: 'audioCues.chatRequestSent'
 });
 AudioCue.chatResponseReceived = AudioCue.register({
-    name: localize('audioCues.chatResponseReceived', 'Chat Response Received'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.chatResponseReceived', 'Chat Response Received'),
     settingsKey: 'audioCues.chatResponseReceived',
     sound: {
         randomOneOf: [
@@ -152,7 +337,7 @@
     }
 });
 AudioCue.chatResponsePending = AudioCue.register({
-    name: localize('audioCues.chatResponsePending', 'Chat Response Pending'),
+    name: localizeWithPath('vs/platform/audioCues/browser/audioCueService', 'audioCues.chatResponsePending', 'Chat Response Pending'),
     sound: Sound.chatResponsePending,
     settingsKey: 'audioCues.chatResponsePending'
 });
diff -urN -x '*.map' a/vs/platform/clipboard/browser/clipboardService.js b/vs/platform/clipboard/browser/clipboardService.js
--- a/vs/platform/clipboard/browser/clipboardService.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/clipboard/browser/clipboardService.js	2023-12-06 14:23:14.387854798 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { isSafari, isWebkitWebView } from '../../../base/browser/browser.js';
 import { $, addDisposableListener } from '../../../base/browser/dom.js';
 import { DeferredPromise } from '../../../base/common/async.js';
@@ -64,93 +55,84 @@
             // see https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#parameters
             navigator.clipboard.write([new ClipboardItem({
                     'text/plain': currentWritePromise.p,
-                })]).catch((err) => __awaiter(this, void 0, void 0, function* () {
+                })]).catch(async (err) => {
                 if (!(err instanceof Error) || err.name !== 'NotAllowedError' || !currentWritePromise.isRejected) {
                     this.logService.error(err);
                 }
-            }));
+            });
         };
         if (this.layoutService.hasContainer) {
             this._register(addDisposableListener(this.layoutService.container, 'click', handler));
             this._register(addDisposableListener(this.layoutService.container, 'keydown', handler));
         }
     }
-    writeText(text, type) {
-        return __awaiter(this, void 0, void 0, function* () {
-            // With type: only in-memory is supported
-            if (type) {
-                this.mapTextToType.set(type, text);
-                return;
-            }
-            if (this.webKitPendingClipboardWritePromise) {
-                // For Safari, we complete this Promise which allows the call to `navigator.clipboard.write()`
-                // above to resolve and successfully copy to the clipboard. If we let this continue, Safari
-                // would throw an error because this call stack doesn't appear to originate from a user gesture.
-                return this.webKitPendingClipboardWritePromise.complete(text);
-            }
-            // Guard access to navigator.clipboard with try/catch
-            // as we have seen DOMExceptions in certain browsers
-            // due to security policies.
-            try {
-                return yield navigator.clipboard.writeText(text);
-            }
-            catch (error) {
-                console.error(error);
-            }
-            // Fallback to textarea and execCommand solution
-            const activeElement = document.activeElement;
-            const textArea = document.body.appendChild($('textarea', { 'aria-hidden': true }));
-            textArea.style.height = '1px';
-            textArea.style.width = '1px';
-            textArea.style.position = 'absolute';
-            textArea.value = text;
-            textArea.focus();
-            textArea.select();
-            document.execCommand('copy');
-            if (activeElement instanceof HTMLElement) {
-                activeElement.focus();
-            }
-            document.body.removeChild(textArea);
+    async writeText(text, type) {
+        // With type: only in-memory is supported
+        if (type) {
+            this.mapTextToType.set(type, text);
             return;
-        });
+        }
+        if (this.webKitPendingClipboardWritePromise) {
+            // For Safari, we complete this Promise which allows the call to `navigator.clipboard.write()`
+            // above to resolve and successfully copy to the clipboard. If we let this continue, Safari
+            // would throw an error because this call stack doesn't appear to originate from a user gesture.
+            return this.webKitPendingClipboardWritePromise.complete(text);
+        }
+        // Guard access to navigator.clipboard with try/catch
+        // as we have seen DOMExceptions in certain browsers
+        // due to security policies.
+        try {
+            return await navigator.clipboard.writeText(text);
+        }
+        catch (error) {
+            console.error(error);
+        }
+        // Fallback to textarea and execCommand solution
+        const activeElement = document.activeElement;
+        const textArea = document.body.appendChild($('textarea', { 'aria-hidden': true }));
+        textArea.style.height = '1px';
+        textArea.style.width = '1px';
+        textArea.style.position = 'absolute';
+        textArea.value = text;
+        textArea.focus();
+        textArea.select();
+        document.execCommand('copy');
+        if (activeElement instanceof HTMLElement) {
+            activeElement.focus();
+        }
+        document.body.removeChild(textArea);
+        return;
     }
-    readText(type) {
-        return __awaiter(this, void 0, void 0, function* () {
-            // With type: only in-memory is supported
-            if (type) {
-                return this.mapTextToType.get(type) || '';
-            }
-            // Guard access to navigator.clipboard with try/catch
-            // as we have seen DOMExceptions in certain browsers
-            // due to security policies.
-            try {
-                return yield navigator.clipboard.readText();
-            }
-            catch (error) {
-                console.error(error);
-                return '';
-            }
-        });
+    async readText(type) {
+        // With type: only in-memory is supported
+        if (type) {
+            return this.mapTextToType.get(type) || '';
+        }
+        // Guard access to navigator.clipboard with try/catch
+        // as we have seen DOMExceptions in certain browsers
+        // due to security policies.
+        try {
+            return await navigator.clipboard.readText();
+        }
+        catch (error) {
+            console.error(error);
+            return '';
+        }
+    }
+    async readFindText() {
+        return this.findText;
+    }
+    async writeFindText(text) {
+        this.findText = text;
+    }
+    async writeResources(resources) {
+        this.resources = resources;
+    }
+    async readResources() {
+        return this.resources;
     }
-    readFindText() {
-        return __awaiter(this, void 0, void 0, function* () {
-            return this.findText;
-        });
-    }
-    writeFindText(text) {
-        return __awaiter(this, void 0, void 0, function* () {
-            this.findText = text;
-        });
-    }
-    writeResources(resources) {
-        return __awaiter(this, void 0, void 0, function* () {
-            this.resources = resources;
-        });
-    }
-    readResources() {
-        return __awaiter(this, void 0, void 0, function* () {
-            return this.resources;
-        });
+    async hasResources() {
+        return this.resources.length > 0;
     }
 };
 BrowserClipboardService = __decorate([
diff -urN -x '*.map' a/vs/platform/commands/common/commands.js b/vs/platform/commands/common/commands.js
--- a/vs/platform/commands/common/commands.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/commands/common/commands.js	2023-12-06 14:23:14.387854798 +0000
@@ -48,7 +48,7 @@
         const ret = toDisposable(() => {
             removeFn();
             const command = this._commands.get(id);
-            if (command === null || command === void 0 ? void 0 : command.isEmpty()) {
+            if (command?.isEmpty()) {
                 this._commands.delete(id);
             }
         });
diff -urN -x '*.map' a/vs/platform/configuration/common/configuration.js b/vs/platform/configuration/common/configuration.js
--- a/vs/platform/configuration/common/configuration.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/configuration/common/configuration.js	2023-12-06 14:23:14.387854798 +0000
@@ -2,8 +2,43 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+import * as types from '../../../base/common/types.js';
+import { URI } from '../../../base/common/uri.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export const IConfigurationService = createDecorator('configurationService');
+export function isConfigurationOverrides(thing) {
+    return thing
+        && typeof thing === 'object'
+        && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')
+        && (!thing.resource || thing.resource instanceof URI);
+}
+export function isConfigurationUpdateOverrides(thing) {
+    return thing
+        && typeof thing === 'object'
+        && (!thing.overrideIdentifiers || Array.isArray(thing.overrideIdentifiers))
+        && !thing.overrideIdentifier
+        && (!thing.resource || thing.resource instanceof URI);
+}
+export function ConfigurationTargetToString(configurationTarget) {
+    switch (configurationTarget) {
+        case 1 /* ConfigurationTarget.APPLICATION */: return 'APPLICATION';
+        case 2 /* ConfigurationTarget.USER */: return 'USER';
+        case 3 /* ConfigurationTarget.USER_LOCAL */: return 'USER_LOCAL';
+        case 4 /* ConfigurationTarget.USER_REMOTE */: return 'USER_REMOTE';
+        case 5 /* ConfigurationTarget.WORKSPACE */: return 'WORKSPACE';
+        case 6 /* ConfigurationTarget.WORKSPACE_FOLDER */: return 'WORKSPACE_FOLDER';
+        case 7 /* ConfigurationTarget.DEFAULT */: return 'DEFAULT';
+        case 8 /* ConfigurationTarget.MEMORY */: return 'MEMORY';
+    }
+}
+export function isConfigured(configValue) {
+    return configValue.applicationValue !== undefined ||
+        configValue.userValue !== undefined ||
+        configValue.userLocalValue !== undefined ||
+        configValue.userRemoteValue !== undefined ||
+        configValue.workspaceValue !== undefined ||
+        configValue.workspaceFolderValue !== undefined;
+}
 export function toValuesTree(properties, conflictReporter) {
     const root = Object.create(null);
     for (const key in properties) {
@@ -81,6 +116,23 @@
     const result = accessSetting(config, path);
     return typeof result === 'undefined' ? defaultValue : result;
 }
+export function merge(base, add, overwrite) {
+    Object.keys(add).forEach(key => {
+        if (key !== '__proto__') {
+            if (key in base) {
+                if (types.isObject(base[key]) && types.isObject(add[key])) {
+                    merge(base[key], add[key], overwrite);
+                }
+                else if (overwrite) {
+                    base[key] = add[key];
+                }
+            }
+            else {
+                base[key] = add[key];
+            }
+        }
+    });
+}
 export function getLanguageTagSettingPlainKey(settingKey) {
     return settingKey.replace(/[\[\]]/g, '');
 }
diff -urN -x '*.map' a/vs/platform/configuration/common/configurationModels.js b/vs/platform/configuration/common/configurationModels.js
--- a/vs/platform/configuration/common/configurationModels.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/configuration/common/configurationModels.js	2023-12-06 14:23:14.387854798 +0000
@@ -3,7 +3,10 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import * as arrays from '../../../base/common/arrays.js';
-import { ResourceMap } from '../../../base/common/map.js';
+import { Emitter, Event } from '../../../base/common/event.js';
+import * as json from '../../../base/common/json.js';
+import { Disposable } from '../../../base/common/lifecycle.js';
+import { getOrSet, ResourceMap } from '../../../base/common/map.js';
 import * as objects from '../../../base/common/objects.js';
 import * as types from '../../../base/common/types.js';
 import { URI } from '../../../base/common/uri.js';
@@ -22,9 +25,8 @@
         this.overrideConfigurations = new Map();
     }
     get rawConfiguration() {
-        var _a;
         if (!this._rawConfiguration) {
-            if ((_a = this.raw) === null || _a === void 0 ? void 0 : _a.length) {
+            if (this.raw?.length) {
                 const rawConfigurationModels = this.raw.map(raw => {
                     if (raw instanceof ConfigurationModel) {
                         return raw;
@@ -69,6 +71,22 @@
             ? section ? getConfigurationValue(overrideContents, section) : overrideContents
             : undefined;
     }
+    getKeysForOverrideIdentifier(identifier) {
+        const keys = [];
+        for (const override of this.overrides) {
+            if (override.identifiers.includes(identifier)) {
+                keys.push(...override.keys);
+            }
+        }
+        return arrays.distinct(keys);
+    }
+    getAllOverrideIdentifiers() {
+        const result = [];
+        for (const override of this.overrides) {
+            result.push(...override.identifiers);
+        }
+        return arrays.distinct(result);
+    }
     override(identifier) {
         let overrideConfigurationModel = this.overrideConfigurations.get(identifier);
         if (!overrideConfigurationModel) {
@@ -78,13 +96,12 @@
         return overrideConfigurationModel;
     }
     merge(...others) {
-        var _a, _b;
         const contents = objects.deepClone(this.contents);
         const overrides = objects.deepClone(this.overrides);
         const keys = [...this.keys];
-        const raws = ((_a = this.raw) === null || _a === void 0 ? void 0 : _a.length) ? [...this.raw] : [this];
+        const raws = this.raw?.length ? [...this.raw] : [this];
         for (const other of others) {
-            raws.push(...(((_b = other.raw) === null || _b === void 0 ? void 0 : _b.length) ? other.raw : [other]));
+            raws.push(...(other.raw?.length ? other.raw : [other]));
             if (other.isEmpty()) {
                 continue;
             }
@@ -215,16 +232,89 @@
         this._raw = null;
         this._configurationModel = null;
         this._restrictedConfigurations = [];
+        this._parseErrors = [];
     }
     get configurationModel() {
         return this._configurationModel || new ConfigurationModel();
     }
+    get restrictedConfigurations() {
+        return this._restrictedConfigurations;
+    }
+    get errors() {
+        return this._parseErrors;
+    }
+    parse(content, options) {
+        if (!types.isUndefinedOrNull(content)) {
+            const raw = this.doParseContent(content);
+            this.parseRaw(raw, options);
+        }
+    }
+    reparse(options) {
+        if (this._raw) {
+            this.parseRaw(this._raw, options);
+        }
+    }
     parseRaw(raw, options) {
         this._raw = raw;
         const { contents, keys, overrides, restricted, hasExcludedProperties } = this.doParseRaw(raw, options);
         this._configurationModel = new ConfigurationModel(contents, keys, overrides, hasExcludedProperties ? [raw] : undefined /* raw has not changed */);
         this._restrictedConfigurations = restricted || [];
     }
+    doParseContent(content) {
+        let raw = {};
+        let currentProperty = null;
+        let currentParent = [];
+        const previousParents = [];
+        const parseErrors = [];
+        function onValue(value) {
+            if (Array.isArray(currentParent)) {
+                currentParent.push(value);
+            }
+            else if (currentProperty !== null) {
+                currentParent[currentProperty] = value;
+            }
+        }
+        const visitor = {
+            onObjectBegin: () => {
+                const object = {};
+                onValue(object);
+                previousParents.push(currentParent);
+                currentParent = object;
+                currentProperty = null;
+            },
+            onObjectProperty: (name) => {
+                currentProperty = name;
+            },
+            onObjectEnd: () => {
+                currentParent = previousParents.pop();
+            },
+            onArrayBegin: () => {
+                const array = [];
+                onValue(array);
+                previousParents.push(currentParent);
+                currentParent = array;
+                currentProperty = null;
+            },
+            onArrayEnd: () => {
+                currentParent = previousParents.pop();
+            },
+            onLiteralValue: onValue,
+            onError: (error, offset, length) => {
+                parseErrors.push({ error, offset, length });
+            }
+        };
+        if (content) {
+            try {
+                json.visit(content, visitor);
+                raw = currentParent[0] || {};
+            }
+            catch (e) {
+                console.error(`Error while parsing settings file ${this._name}: ${e}`);
+                this._parseErrors = [e];
+            }
+        }
+        return raw;
+    }
     doParseRaw(raw, options) {
         const configurationProperties = Registry.as(Extensions.Configuration).getConfigurationProperties();
         const filtered = this.filter(raw, configurationProperties, true, options);
@@ -235,9 +325,8 @@
         return { contents, keys, overrides, restricted: filtered.restricted, hasExcludedProperties: filtered.hasExcludedProperties };
     }
     filter(properties, configurationProperties, filterOverriddenProperties, options) {
-        var _a, _b, _c;
         let hasExcludedProperties = false;
-        if (!(options === null || options === void 0 ? void 0 : options.scopes) && !(options === null || options === void 0 ? void 0 : options.skipRestricted) && !((_a = options === null || options === void 0 ? void 0 : options.exclude) === null || _a === void 0 ? void 0 : _a.length)) {
+        if (!options?.scopes && !options?.skipRestricted && !options?.exclude?.length) {
             return { raw: properties, restricted: [], hasExcludedProperties };
         }
         const raw = {};
@@ -252,13 +341,13 @@
             else {
                 const propertySchema = configurationProperties[key];
                 const scope = propertySchema ? typeof propertySchema.scope !== 'undefined' ? propertySchema.scope : 3 /* ConfigurationScope.WINDOW */ : undefined;
-                if (propertySchema === null || propertySchema === void 0 ? void 0 : propertySchema.restricted) {
+                if (propertySchema?.restricted) {
                     restricted.push(key);
                 }
-                if (!((_b = options.exclude) === null || _b === void 0 ? void 0 : _b.includes(key)) /* Check exclude */
-                    && (((_c = options.include) === null || _c === void 0 ? void 0 : _c.includes(key) /* Check include */)
+                if (!options.exclude?.includes(key) /* Check exclude */
+                    && (options.include?.includes(key) /* Check include */
                         || ((scope === undefined || options.scopes === undefined || options.scopes.includes(scope)) /* Check scopes */
-                            && !(options.skipRestricted && (propertySchema === null || propertySchema === void 0 ? void 0 : propertySchema.restricted))))) /* Check restricted */ {
+                            && !(options.skipRestricted && propertySchema?.restricted)))) /* Check restricted */ {
                     raw[key] = properties[key];
                 }
                 else {
@@ -286,6 +375,41 @@
         return overrides;
     }
 }
+export class UserSettings extends Disposable {
+    constructor(userSettingsResource, parseOptions, extUri, fileService) {
+        super();
+        this.userSettingsResource = userSettingsResource;
+        this.parseOptions = parseOptions;
+        this.fileService = fileService;
+        this._onDidChange = this._register(new Emitter());
+        this.onDidChange = this._onDidChange.event;
+        this.parser = new ConfigurationModelParser(this.userSettingsResource.toString());
+        this._register(this.fileService.watch(extUri.dirname(this.userSettingsResource)));
+        // Also listen to the resource incase the resource is a symlink - https://github.com/microsoft/vscode/issues/118134
+        this._register(this.fileService.watch(this.userSettingsResource));
+        this._register(Event.any(Event.filter(this.fileService.onDidFilesChange, e => e.contains(this.userSettingsResource)), Event.filter(this.fileService.onDidRunOperation, e => (e.isOperation(0 /* FileOperation.CREATE */) || e.isOperation(3 /* FileOperation.COPY */) || e.isOperation(1 /* FileOperation.DELETE */) || e.isOperation(4 /* FileOperation.WRITE */)) && extUri.isEqual(e.resource, userSettingsResource)))(() => this._onDidChange.fire()));
+    }
+    async loadConfiguration() {
+        try {
+            const content = await this.fileService.readFile(this.userSettingsResource);
+            this.parser.parse(content.value.toString() || '{}', this.parseOptions);
+            return this.parser.configurationModel;
+        }
+        catch (e) {
+            return new ConfigurationModel();
+        }
+    }
+    reparse(parseOptions) {
+        if (parseOptions) {
+            this.parseOptions = parseOptions;
+        }
+        this.parser.reparse(this.parseOptions);
+        return this.parser.configurationModel;
+    }
+    getRestrictedSettings() {
+        return this.parser.restrictedConfigurations;
+    }
+}
 class ConfigurationInspectValue {
     constructor(key, overrides, _value, overrideIdentifiers, defaultConfiguration, policyConfiguration, applicationConfiguration, userConfiguration, localUserConfiguration, remoteUserConfiguration, workspaceConfiguration, folderConfigurationModel, memoryConfigurationModel) {
         this.key = key;
@@ -302,6 +426,9 @@
         this.folderConfigurationModel = folderConfigurationModel;
         this.memoryConfigurationModel = memoryConfigurationModel;
     }
+    get value() {
+        return freeze(this._value);
+    }
     inspect(model, section, overrideIdentifier) {
         const inspectValue = model.inspect(section, overrideIdentifier);
         return {
@@ -310,15 +437,114 @@
             get merged() { return freeze(inspectValue.merged); }
         };
     }
+    get defaultInspectValue() {
+        if (!this._defaultInspectValue) {
+            this._defaultInspectValue = this.inspect(this.defaultConfiguration, this.key, this.overrides.overrideIdentifier);
+        }
+        return this._defaultInspectValue;
+    }
+    get defaultValue() {
+        return this.defaultInspectValue.merged;
+    }
+    get default() {
+        return this.defaultInspectValue.value !== undefined || this.defaultInspectValue.override !== undefined ? { value: this.defaultInspectValue.value, override: this.defaultInspectValue.override } : undefined;
+    }
+    get policyInspectValue() {
+        if (this._policyInspectValue === undefined) {
+            this._policyInspectValue = this.policyConfiguration ? this.inspect(this.policyConfiguration, this.key) : null;
+        }
+        return this._policyInspectValue;
+    }
+    get policyValue() {
+        return this.policyInspectValue?.merged;
+    }
+    get policy() {
+        return this.policyInspectValue?.value !== undefined ? { value: this.policyInspectValue.value } : undefined;
+    }
+    get applicationInspectValue() {
+        if (this._applicationInspectValue === undefined) {
+            this._applicationInspectValue = this.applicationConfiguration ? this.inspect(this.applicationConfiguration, this.key) : null;
+        }
+        return this._applicationInspectValue;
+    }
+    get applicationValue() {
+        return this.applicationInspectValue?.merged;
+    }
+    get application() {
+        return this.applicationInspectValue?.value !== undefined || this.applicationInspectValue?.override !== undefined ? { value: this.applicationInspectValue.value, override: this.applicationInspectValue.override } : undefined;
+    }
     get userInspectValue() {
         if (!this._userInspectValue) {
             this._userInspectValue = this.inspect(this.userConfiguration, this.key, this.overrides.overrideIdentifier);
         }
         return this._userInspectValue;
     }
+    get userValue() {
+        return this.userInspectValue.merged;
+    }
     get user() {
         return this.userInspectValue.value !== undefined || this.userInspectValue.override !== undefined ? { value: this.userInspectValue.value, override: this.userInspectValue.override } : undefined;
     }
+    get userLocalInspectValue() {
+        if (!this._userLocalInspectValue) {
+            this._userLocalInspectValue = this.inspect(this.localUserConfiguration, this.key, this.overrides.overrideIdentifier);
+        }
+        return this._userLocalInspectValue;
+    }
+    get userLocalValue() {
+        return this.userLocalInspectValue.merged;
+    }
+    get userLocal() {
+        return this.userLocalInspectValue.value !== undefined || this.userLocalInspectValue.override !== undefined ? { value: this.userLocalInspectValue.value, override: this.userLocalInspectValue.override } : undefined;
+    }
+    get userRemoteInspectValue() {
+        if (!this._userRemoteInspectValue) {
+            this._userRemoteInspectValue = this.inspect(this.remoteUserConfiguration, this.key, this.overrides.overrideIdentifier);
+        }
+        return this._userRemoteInspectValue;
+    }
+    get userRemoteValue() {
+        return this.userRemoteInspectValue.merged;
+    }
+    get userRemote() {
+        return this.userRemoteInspectValue.value !== undefined || this.userRemoteInspectValue.override !== undefined ? { value: this.userRemoteInspectValue.value, override: this.userRemoteInspectValue.override } : undefined;
+    }
+    get workspaceInspectValue() {
+        if (this._workspaceInspectValue === undefined) {
+            this._workspaceInspectValue = this.workspaceConfiguration ? this.inspect(this.workspaceConfiguration, this.key, this.overrides.overrideIdentifier) : null;
+        }
+        return this._workspaceInspectValue;
+    }
+    get workspaceValue() {
+        return this.workspaceInspectValue?.merged;
+    }
+    get workspace() {
+        return this.workspaceInspectValue?.value !== undefined || this.workspaceInspectValue?.override !== undefined ? { value: this.workspaceInspectValue.value, override: this.workspaceInspectValue.override } : undefined;
+    }
+    get workspaceFolderInspectValue() {
+        if (this._workspaceFolderInspectValue === undefined) {
+            this._workspaceFolderInspectValue = this.folderConfigurationModel ? this.inspect(this.folderConfigurationModel, this.key, this.overrides.overrideIdentifier) : null;
+        }
+        return this._workspaceFolderInspectValue;
+    }
+    get workspaceFolderValue() {
+        return this.workspaceFolderInspectValue?.merged;
+    }
+    get workspaceFolder() {
+        return this.workspaceFolderInspectValue?.value !== undefined || this.workspaceFolderInspectValue?.override !== undefined ? { value: this.workspaceFolderInspectValue.value, override: this.workspaceFolderInspectValue.override } : undefined;
+    }
+    get memoryInspectValue() {
+        if (this._memoryInspectValue === undefined) {
+            this._memoryInspectValue = this.inspect(this.memoryConfigurationModel, this.key, this.overrides.overrideIdentifier);
+        }
+        return this._memoryInspectValue;
+    }
+    get memoryValue() {
+        return this.memoryInspectValue.merged;
+    }
+    get memory() {
+        return this.memoryInspectValue.value !== undefined || this.memoryInspectValue.override !== undefined ? { value: this.memoryInspectValue.value, override: this.memoryInspectValue.override } : undefined;
+    }
 }
 export class Configuration {
     constructor(_defaultConfiguration, _policyConfiguration, _applicationConfiguration, _localUserConfiguration, _remoteUserConfiguration = new ConfigurationModel(), _workspaceConfiguration = new ConfigurationModel(), _folderConfigurations = new ResourceMap(), _memoryConfiguration = new ConfigurationModel(), _memoryConfigurationByResource = new ResourceMap()) {
@@ -375,6 +601,135 @@
         }
         return new ConfigurationInspectValue(key, overrides, consolidateConfigurationModel.getValue(key), overrideIdentifiers.size ? [...overrideIdentifiers] : undefined, this._defaultConfiguration, this._policyConfiguration.isEmpty() ? undefined : this._policyConfiguration, this.applicationConfiguration.isEmpty() ? undefined : this.applicationConfiguration, this.userConfiguration, this.localUserConfiguration, this.remoteUserConfiguration, workspace ? this._workspaceConfiguration : undefined, folderConfigurationModel ? folderConfigurationModel : undefined, memoryConfigurationModel);
     }
+    keys(workspace) {
+        const folderConfigurationModel = this.getFolderConfigurationModelForResource(undefined, workspace);
+        return {
+            default: this._defaultConfiguration.keys.slice(0),
+            user: this.userConfiguration.keys.slice(0),
+            workspace: this._workspaceConfiguration.keys.slice(0),
+            workspaceFolder: folderConfigurationModel ? folderConfigurationModel.keys.slice(0) : []
+        };
+    }
+    updateDefaultConfiguration(defaultConfiguration) {
+        this._defaultConfiguration = defaultConfiguration;
+        this._workspaceConsolidatedConfiguration = null;
+        this._foldersConsolidatedConfigurations.clear();
+    }
+    updatePolicyConfiguration(policyConfiguration) {
+        this._policyConfiguration = policyConfiguration;
+    }
+    updateApplicationConfiguration(applicationConfiguration) {
+        this._applicationConfiguration = applicationConfiguration;
+        this._workspaceConsolidatedConfiguration = null;
+        this._foldersConsolidatedConfigurations.clear();
+    }
+    updateLocalUserConfiguration(localUserConfiguration) {
+        this._localUserConfiguration = localUserConfiguration;
+        this._userConfiguration = null;
+        this._workspaceConsolidatedConfiguration = null;
+        this._foldersConsolidatedConfigurations.clear();
+    }
+    updateRemoteUserConfiguration(remoteUserConfiguration) {
+        this._remoteUserConfiguration = remoteUserConfiguration;
+        this._userConfiguration = null;
+        this._workspaceConsolidatedConfiguration = null;
+        this._foldersConsolidatedConfigurations.clear();
+    }
+    updateWorkspaceConfiguration(workspaceConfiguration) {
+        this._workspaceConfiguration = workspaceConfiguration;
+        this._workspaceConsolidatedConfiguration = null;
+        this._foldersConsolidatedConfigurations.clear();
+    }
+    updateFolderConfiguration(resource, configuration) {
+        this._folderConfigurations.set(resource, configuration);
+        this._foldersConsolidatedConfigurations.delete(resource);
+    }
+    deleteFolderConfiguration(resource) {
+        this.folderConfigurations.delete(resource);
+        this._foldersConsolidatedConfigurations.delete(resource);
+    }
+    compareAndUpdateDefaultConfiguration(defaults, keys) {
+        const overrides = [];
+        if (!keys) {
+            const { added, updated, removed } = compare(this._defaultConfiguration, defaults);
+            keys = [...added, ...updated, ...removed];
+        }
+        for (const key of keys) {
+            for (const overrideIdentifier of overrideIdentifiersFromKey(key)) {
+                const fromKeys = this._defaultConfiguration.getKeysForOverrideIdentifier(overrideIdentifier);
+                const toKeys = defaults.getKeysForOverrideIdentifier(overrideIdentifier);
+                const keys = [
+                    ...toKeys.filter(key => fromKeys.indexOf(key) === -1),
+                    ...fromKeys.filter(key => toKeys.indexOf(key) === -1),
+                    ...fromKeys.filter(key => !objects.equals(this._defaultConfiguration.override(overrideIdentifier).getValue(key), defaults.override(overrideIdentifier).getValue(key)))
+                ];
+                overrides.push([overrideIdentifier, keys]);
+            }
+        }
+        this.updateDefaultConfiguration(defaults);
+        return { keys, overrides };
+    }
+    compareAndUpdatePolicyConfiguration(policyConfiguration) {
+        const { added, updated, removed } = compare(this._policyConfiguration, policyConfiguration);
+        const keys = [...added, ...updated, ...removed];
+        if (keys.length) {
+            this.updatePolicyConfiguration(policyConfiguration);
+        }
+        return { keys, overrides: [] };
+    }
+    compareAndUpdateApplicationConfiguration(application) {
+        const { added, updated, removed, overrides } = compare(this.applicationConfiguration, application);
+        const keys = [...added, ...updated, ...removed];
+        if (keys.length) {
+            this.updateApplicationConfiguration(application);
+        }
+        return { keys, overrides };
+    }
+    compareAndUpdateLocalUserConfiguration(user) {
+        const { added, updated, removed, overrides } = compare(this.localUserConfiguration, user);
+        const keys = [...added, ...updated, ...removed];
+        if (keys.length) {
+            this.updateLocalUserConfiguration(user);
+        }
+        return { keys, overrides };
+    }
+    compareAndUpdateRemoteUserConfiguration(user) {
+        const { added, updated, removed, overrides } = compare(this.remoteUserConfiguration, user);
+        const keys = [...added, ...updated, ...removed];
+        if (keys.length) {
+            this.updateRemoteUserConfiguration(user);
+        }
+        return { keys, overrides };
+    }
+    compareAndUpdateWorkspaceConfiguration(workspaceConfiguration) {
+        const { added, updated, removed, overrides } = compare(this.workspaceConfiguration, workspaceConfiguration);
+        const keys = [...added, ...updated, ...removed];
+        if (keys.length) {
+            this.updateWorkspaceConfiguration(workspaceConfiguration);
+        }
+        return { keys, overrides };
+    }
+    compareAndUpdateFolderConfiguration(resource, folderConfiguration) {
+        const currentFolderConfiguration = this.folderConfigurations.get(resource);
+        const { added, updated, removed, overrides } = compare(currentFolderConfiguration, folderConfiguration);
+        const keys = [...added, ...updated, ...removed];
+        if (keys.length || !currentFolderConfiguration) {
+            this.updateFolderConfiguration(resource, folderConfiguration);
+        }
+        return { keys, overrides };
+    }
+    compareAndDeleteFolderConfiguration(folder) {
+        const folderConfig = this.folderConfigurations.get(folder);
+        if (!folderConfig) {
+            throw new Error('Unknown folder');
+        }
+        this.deleteFolderConfiguration(folder);
+        const { added, updated, removed, overrides } = compare(folderConfig, undefined);
+        return { keys: [...added, ...updated, ...removed], overrides };
+    }
+    get defaults() {
+        return this._defaultConfiguration;
+    }
     get applicationConfiguration() {
         return this._applicationConfiguration;
     }
@@ -390,6 +745,12 @@
     get remoteUserConfiguration() {
         return this._remoteUserConfiguration;
     }
+    get workspaceConfiguration() {
+        return this._workspaceConfiguration;
+    }
+    get folderConfigurations() {
+        return this._folderConfigurations;
+    }
     getConsolidatedConfigurationModel(section, overrides, workspace) {
         let configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);
         if (overrides.overrideIdentifier) {
@@ -478,6 +839,30 @@
             }, [])
         };
     }
+    allKeys() {
+        const keys = new Set();
+        this._defaultConfiguration.keys.forEach(key => keys.add(key));
+        this.userConfiguration.keys.forEach(key => keys.add(key));
+        this._workspaceConfiguration.keys.forEach(key => keys.add(key));
+        this._folderConfigurations.forEach(folderConfiguration => folderConfiguration.keys.forEach(key => keys.add(key)));
+        return [...keys.values()];
+    }
+    allOverrideIdentifiers() {
+        const keys = new Set();
+        this._defaultConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key));
+        this.userConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key));
+        this._workspaceConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key));
+        this._folderConfigurations.forEach(folderConfiguration => folderConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key)));
+        return [...keys.values()];
+    }
+    getAllKeysForOverrideIdentifier(overrideIdentifier) {
+        const keys = new Set();
+        this._defaultConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));
+        this.userConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));
+        this._workspaceConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));
+        this._folderConfigurations.forEach(folderConfiguration => folderConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key)));
+        return [...keys.values()];
+    }
     static parse(data) {
         const defaultConfiguration = this.parseConfigurationModel(data.defaults);
         const policyConfiguration = this.parseConfigurationModel(data.policy);
@@ -494,6 +879,26 @@
         return new ConfigurationModel(model.contents, model.keys, model.overrides);
     }
 }
+export function mergeChanges(...changes) {
+    if (changes.length === 0) {
+        return { keys: [], overrides: [] };
+    }
+    if (changes.length === 1) {
+        return changes[0];
+    }
+    const keysSet = new Set();
+    const overridesMap = new Map();
+    for (const change of changes) {
+        change.keys.forEach(key => keysSet.add(key));
+        change.overrides.forEach(([identifier, keys]) => {
+            const result = getOrSet(overridesMap, identifier, new Set());
+            keys.forEach(key => result.add(key));
+        });
+    }
+    const overrides = [];
+    overridesMap.forEach((keys, identifier) => overrides.push([identifier, [...keys.values()]]));
+    return { keys: [...keysSet.values()], overrides };
+}
 export class ConfigurationChangeEvent {
     constructor(change, previous, currentConfiguraiton, currentWorkspace) {
         this.change = change;
@@ -526,7 +931,6 @@
         return this._previousConfiguration;
     }
     affectsConfiguration(section, overrides) {
-        var _a;
         // we have one large string with all keys that have changed. we pad (marker) the section
         // and check that either find it padded or before a segment character
         const needle = this._marker + section;
@@ -545,10 +949,58 @@
             return false;
         }
         if (overrides) {
-            const value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section, overrides, (_a = this.previous) === null || _a === void 0 ? void 0 : _a.workspace) : undefined;
+            const value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section, overrides, this.previous?.workspace) : undefined;
             const value2 = this.currentConfiguraiton.getValue(section, overrides, this.currentWorkspace);
             return !objects.equals(value1, value2);
         }
         return true;
     }
 }
+function compare(from, to) {
+    const { added, removed, updated } = compareConfigurationContents(to?.rawConfiguration, from?.rawConfiguration);
+    const overrides = [];
+    const fromOverrideIdentifiers = from?.getAllOverrideIdentifiers() || [];
+    const toOverrideIdentifiers = to?.getAllOverrideIdentifiers() || [];
+    if (to) {
+        const addedOverrideIdentifiers = toOverrideIdentifiers.filter(key => !fromOverrideIdentifiers.includes(key));
+        for (const identifier of addedOverrideIdentifiers) {
+            overrides.push([identifier, to.getKeysForOverrideIdentifier(identifier)]);
+        }
+    }
+    if (from) {
+        const removedOverrideIdentifiers = fromOverrideIdentifiers.filter(key => !toOverrideIdentifiers.includes(key));
+        for (const identifier of removedOverrideIdentifiers) {
+            overrides.push([identifier, from.getKeysForOverrideIdentifier(identifier)]);
+        }
+    }
+    if (to && from) {
+        for (const identifier of fromOverrideIdentifiers) {
+            if (toOverrideIdentifiers.includes(identifier)) {
+                const result = compareConfigurationContents({ contents: from.getOverrideValue(undefined, identifier) || {}, keys: from.getKeysForOverrideIdentifier(identifier) }, { contents: to.getOverrideValue(undefined, identifier) || {}, keys: to.getKeysForOverrideIdentifier(identifier) });
+                overrides.push([identifier, [...result.added, ...result.removed, ...result.updated]]);
+            }
+        }
+    }
+    return { added, removed, updated, overrides };
+}
+function compareConfigurationContents(to, from) {
+    const added = to
+        ? from ? to.keys.filter(key => from.keys.indexOf(key) === -1) : [...to.keys]
+        : [];
+    const removed = from
+        ? to ? from.keys.filter(key => to.keys.indexOf(key) === -1) : [...from.keys]
+        : [];
+    const updated = [];
+    if (to && from) {
+        for (const key of from.keys) {
+            if (to.keys.indexOf(key) !== -1) {
+                const value1 = getConfigurationValue(from.contents, key);
+                const value2 = getConfigurationValue(to.contents, key);
+                if (!objects.equals(value1, value2)) {
+                    updated.push(key);
+                }
+            }
+        }
+    }
+    return { added, removed, updated };
+}
diff -urN -x '*.map' a/vs/platform/configuration/common/configurationRegistry.js b/vs/platform/configuration/common/configurationRegistry.js
--- a/vs/platform/configuration/common/configurationRegistry.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/configuration/common/configurationRegistry.js	2023-12-06 14:23:14.387854798 +0000
@@ -9,6 +9,11 @@
 import { getLanguageTagSettingPlainKey } from './configuration.js';
 import { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';
 import { Registry } from '../../registry/common/platform.js';
+export var EditPresentationTypes;
+(function (EditPresentationTypes) {
+    EditPresentationTypes["Multiline"] = "multilineText";
+    EditPresentationTypes["Singleline"] = "singlelineText";
+})(EditPresentationTypes || (EditPresentationTypes = {}));
 export const Extensions = {
     Configuration: 'base.contributions.configuration'
 };
@@ -19,16 +24,19 @@
 export const windowSettings = { properties: {}, patternProperties: {} };
 export const resourceSettings = { properties: {}, patternProperties: {} };
 export const resourceLanguageSettingsSchemaId = 'vscode://schemas/settings/resourceLanguage';
+export const configurationDefaultsSchemaId = 'vscode://schemas/settings/configurationDefaults';
 const contributionRegistry = Registry.as(JSONExtensions.JSONContribution);
 class ConfigurationRegistry {
     constructor() {
         this.overrideIdentifiers = new Set();
         this._onDidSchemaChange = new Emitter();
+        this.onDidSchemaChange = this._onDidSchemaChange.event;
         this._onDidUpdateConfiguration = new Emitter();
+        this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event;
         this.configurationDefaultsOverrides = new Map();
         this.defaultLanguageConfigurationOverridesNode = {
             id: 'defaultOverrides',
-            title: nls.localize('defaultLanguageConfigurationOverrides.title', "Default Language Configuration Overrides"),
+            title: nls.localizeWithPath('vs/platform/configuration/common/configurationRegistry', 'defaultLanguageConfigurationOverrides.title', "Default Language Configuration Overrides"),
             properties: {}
         };
         this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode];
@@ -55,6 +63,21 @@
         this._onDidSchemaChange.fire();
         this._onDidUpdateConfiguration.fire({ properties });
     }
+    deregisterConfigurations(configurations) {
+        const properties = new Set();
+        this.doDeregisterConfigurations(configurations, properties);
+        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
+        this._onDidSchemaChange.fire();
+        this._onDidUpdateConfiguration.fire({ properties });
+    }
+    updateConfigurations({ add, remove }) {
+        const properties = new Set();
+        this.doDeregisterConfigurations(remove, properties);
+        this.doRegisterConfigurations(add, false, properties);
+        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
+        this._onDidSchemaChange.fire();
+        this._onDidUpdateConfiguration.fire({ properties });
+    }
     registerDefaultConfigurations(configurationDefaults) {
         const properties = new Set();
         this.doRegisterDefaultConfigurations(configurationDefaults, properties);
@@ -62,26 +85,25 @@
         this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides: true });
     }
     doRegisterDefaultConfigurations(configurationDefaults, bucket) {
-        var _a;
         const overrideIdentifiers = [];
         for (const { overrides, source } of configurationDefaults) {
             for (const key in overrides) {
                 bucket.add(key);
                 if (OVERRIDE_PROPERTY_REGEX.test(key)) {
                     const configurationDefaultOverride = this.configurationDefaultsOverrides.get(key);
-                    const valuesSources = (_a = configurationDefaultOverride === null || configurationDefaultOverride === void 0 ? void 0 : configurationDefaultOverride.valuesSources) !== null && _a !== void 0 ? _a : new Map();
+                    const valuesSources = configurationDefaultOverride?.valuesSources ?? new Map();
                     if (source) {
                         for (const configuration of Object.keys(overrides[key])) {
                             valuesSources.set(configuration, source);
                         }
                     }
-                    const defaultValue = Object.assign(Object.assign({}, ((configurationDefaultOverride === null || configurationDefaultOverride === void 0 ? void 0 : configurationDefaultOverride.value) || {})), overrides[key]);
+                    const defaultValue = { ...(configurationDefaultOverride?.value || {}), ...overrides[key] };
                     this.configurationDefaultsOverrides.set(key, { source, value: defaultValue, valuesSources });
                     const plainKey = getLanguageTagSettingPlainKey(key);
                     const property = {
                         type: 'object',
                         default: defaultValue,
-                        description: nls.localize('defaultLanguageConfiguration.description', "Configure settings to be overridden for the {0} language.", plainKey),
+                        description: nls.localizeWithPath('vs/platform/configuration/common/configurationRegistry', 'defaultLanguageConfiguration.description', "Configure settings to be overridden for the {0} language.", plainKey),
                         $ref: resourceLanguageSettingsSchemaId,
                         defaultDefaultValue: defaultValue,
                         source: types.isString(source) ? undefined : source,
@@ -103,6 +125,65 @@
         }
         this.doRegisterOverrideIdentifiers(overrideIdentifiers);
     }
+    deregisterDefaultConfigurations(defaultConfigurations) {
+        const properties = new Set();
+        this.doDeregisterDefaultConfigurations(defaultConfigurations, properties);
+        this._onDidSchemaChange.fire();
+        this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides: true });
+    }
+    doDeregisterDefaultConfigurations(defaultConfigurations, bucket) {
+        for (const { overrides, source } of defaultConfigurations) {
+            for (const key in overrides) {
+                const configurationDefaultsOverride = this.configurationDefaultsOverrides.get(key);
+                const id = types.isString(source) ? source : source?.id;
+                const configurationDefaultsOverrideSourceId = types.isString(configurationDefaultsOverride?.source) ? configurationDefaultsOverride?.source : configurationDefaultsOverride?.source?.id;
+                if (id !== configurationDefaultsOverrideSourceId) {
+                    continue;
+                }
+                bucket.add(key);
+                this.configurationDefaultsOverrides.delete(key);
+                if (OVERRIDE_PROPERTY_REGEX.test(key)) {
+                    delete this.configurationProperties[key];
+                    delete this.defaultLanguageConfigurationOverridesNode.properties[key];
+                }
+                else {
+                    const property = this.configurationProperties[key];
+                    if (property) {
+                        this.updatePropertyDefaultValue(key, property);
+                        this.updateSchema(key, property);
+                    }
+                }
+            }
+        }
+        this.updateOverridePropertyPatternKey();
+    }
+    deltaConfiguration(delta) {
+        // defaults: remove
+        let defaultsOverrides = false;
+        const properties = new Set();
+        if (delta.removedDefaults) {
+            this.doDeregisterDefaultConfigurations(delta.removedDefaults, properties);
+            defaultsOverrides = true;
+        }
+        // defaults: add
+        if (delta.addedDefaults) {
+            this.doRegisterDefaultConfigurations(delta.addedDefaults, properties);
+            defaultsOverrides = true;
+        }
+        // configurations: remove
+        if (delta.removedConfigurations) {
+            this.doDeregisterConfigurations(delta.removedConfigurations, properties);
+        }
+        // configurations: add
+        if (delta.addedConfigurations) {
+            this.doRegisterConfigurations(delta.addedConfigurations, false, properties);
+        }
+        this._onDidSchemaChange.fire();
+        this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides });
+    }
+    notifyConfigurationSchemaUpdated(...configurations) {
+        this._onDidSchemaChange.fire();
+    }
     registerOverrideIdentifiers(overrideIdentifiers) {
         this.doRegisterOverrideIdentifiers(overrideIdentifiers);
         this._onDidSchemaChange.fire();
@@ -120,8 +201,30 @@
             this.registerJSONConfiguration(configuration);
         });
     }
+    doDeregisterConfigurations(configurations, bucket) {
+        const deregisterConfiguration = (configuration) => {
+            if (configuration.properties) {
+                for (const key in configuration.properties) {
+                    bucket.add(key);
+                    const property = this.configurationProperties[key];
+                    if (property?.policy?.name) {
+                        this.policyConfigurations.delete(property.policy.name);
+                    }
+                    delete this.configurationProperties[key];
+                    this.removeFromSchema(key, configuration.properties[key]);
+                }
+            }
+            configuration.allOf?.forEach(node => deregisterConfiguration(node));
+        };
+        for (const configuration of configurations) {
+            deregisterConfiguration(configuration);
+            const index = this.configurationContributors.indexOf(configuration);
+            if (index !== -1) {
+                this.configurationContributors.splice(index, 1);
+            }
+        }
+    }
     validateAndRegisterProperties(configuration, validate = true, extensionInfo, restrictedProperties, scope = 3 /* ConfigurationScope.WINDOW */, bucket) {
-        var _a;
         scope = types.isUndefinedOrNull(configuration.scope) ? scope : configuration.scope;
         const properties = configuration.properties;
         if (properties) {
@@ -141,7 +244,7 @@
                 }
                 else {
                     property.scope = types.isUndefinedOrNull(property.scope) ? scope : property.scope;
-                    property.restricted = types.isUndefinedOrNull(property.restricted) ? !!(restrictedProperties === null || restrictedProperties === void 0 ? void 0 : restrictedProperties.includes(key)) : property.restricted;
+                    property.restricted = types.isUndefinedOrNull(property.restricted) ? !!restrictedProperties?.includes(key) : property.restricted;
                 }
                 // Add to properties maps
                 // Property is included by default if 'included' is unspecified
@@ -152,7 +255,7 @@
                 }
                 else {
                     this.configurationProperties[key] = properties[key];
-                    if ((_a = properties[key].policy) === null || _a === void 0 ? void 0 : _a.name) {
+                    if (properties[key].policy?.name) {
                         this.policyConfigurations.set(properties[key].policy.name, key);
                     }
                 }
@@ -170,12 +273,22 @@
             }
         }
     }
+    // TODO: @sandy081 - Remove this method and include required info in getConfigurationProperties
+    getConfigurations() {
+        return this.configurationContributors;
+    }
     getConfigurationProperties() {
         return this.configurationProperties;
     }
     getPolicyConfigurations() {
         return this.policyConfigurations;
     }
+    getExcludedConfigurationProperties() {
+        return this.excludedConfigurationProperties;
+    }
+    getConfigurationDefaultsOverrides() {
+        return this.configurationDefaultsOverrides;
+    }
     registerJSONConfiguration(configuration) {
         const register = (configuration) => {
             const properties = configuration.properties;
@@ -185,7 +298,7 @@
                 }
             }
             const subNodes = configuration.allOf;
-            subNodes === null || subNodes === void 0 ? void 0 : subNodes.forEach(register);
+            subNodes?.forEach(register);
         };
         register(configuration);
     }
@@ -213,13 +326,35 @@
                 break;
         }
     }
+    removeFromSchema(key, property) {
+        delete allSettings.properties[key];
+        switch (property.scope) {
+            case 1 /* ConfigurationScope.APPLICATION */:
+                delete applicationSettings.properties[key];
+                break;
+            case 2 /* ConfigurationScope.MACHINE */:
+                delete machineSettings.properties[key];
+                break;
+            case 6 /* ConfigurationScope.MACHINE_OVERRIDABLE */:
+                delete machineOverridableSettings.properties[key];
+                break;
+            case 3 /* ConfigurationScope.WINDOW */:
+                delete windowSettings.properties[key];
+                break;
+            case 4 /* ConfigurationScope.RESOURCE */:
+            case 5 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */:
+                delete resourceSettings.properties[key];
+                delete this.resourceLanguageSettingsSchema.properties[key];
+                break;
+        }
+    }
     updateOverridePropertyPatternKey() {
         for (const overrideIdentifier of this.overrideIdentifiers.values()) {
             const overrideIdentifierProperty = `[${overrideIdentifier}]`;
             const resourceLanguagePropertiesSchema = {
                 type: 'object',
-                description: nls.localize('overrideSettings.defaultDescription', "Configure editor settings to be overridden for a language."),
-                errorMessage: nls.localize('overrideSettings.errorMessage', "This setting does not support per-language configuration."),
+                description: nls.localizeWithPath('vs/platform/configuration/common/configurationRegistry', 'overrideSettings.defaultDescription', "Configure editor settings to be overridden for a language."),
+                errorMessage: nls.localizeWithPath('vs/platform/configuration/common/configurationRegistry', 'overrideSettings.errorMessage', "This setting does not support per-language configuration."),
                 $ref: resourceLanguageSettingsSchemaId,
             };
             this.updatePropertyDefaultValue(overrideIdentifierProperty, resourceLanguagePropertiesSchema);
@@ -234,8 +369,8 @@
     registerOverridePropertyPatternKey() {
         const resourceLanguagePropertiesSchema = {
             type: 'object',
-            description: nls.localize('overrideSettings.defaultDescription', "Configure editor settings to be overridden for a language."),
-            errorMessage: nls.localize('overrideSettings.errorMessage', "This setting does not support per-language configuration."),
+            description: nls.localizeWithPath('vs/platform/configuration/common/configurationRegistry', 'overrideSettings.defaultDescription', "Configure editor settings to be overridden for a language."),
+            errorMessage: nls.localizeWithPath('vs/platform/configuration/common/configurationRegistry', 'overrideSettings.errorMessage', "This setting does not support per-language configuration."),
             $ref: resourceLanguageSettingsSchemaId,
         };
         allSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
@@ -248,8 +383,8 @@
     }
     updatePropertyDefaultValue(key, property) {
         const configurationdefaultOverride = this.configurationDefaultsOverrides.get(key);
-        let defaultValue = configurationdefaultOverride === null || configurationdefaultOverride === void 0 ? void 0 : configurationdefaultOverride.value;
-        let defaultSource = configurationdefaultOverride === null || configurationdefaultOverride === void 0 ? void 0 : configurationdefaultOverride.source;
+        let defaultValue = configurationdefaultOverride?.value;
+        let defaultSource = configurationdefaultOverride?.source;
         if (types.isUndefined(defaultValue)) {
             defaultValue = property.defaultDefaultValue;
             defaultSource = undefined;
@@ -269,7 +404,7 @@
     const identifiers = [];
     if (OVERRIDE_PROPERTY_REGEX.test(key)) {
         let matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);
-        while (matches === null || matches === void 0 ? void 0 : matches.length) {
+        while (matches?.length) {
             const identifier = matches[1].trim();
             if (identifier) {
                 identifiers.push(identifier);
@@ -279,6 +414,9 @@
     }
     return distinct(identifiers);
 }
+export function keyFromOverrideIdentifiers(overrideIdentifiers) {
+    return overrideIdentifiers.reduce((result, overrideIdentifier) => `${result}[${overrideIdentifier}]`, '');
+}
 export function getDefaultValue(type) {
     const t = Array.isArray(type) ? type[0] : type;
     switch (t) {
@@ -300,18 +438,27 @@
 const configurationRegistry = new ConfigurationRegistry();
 Registry.add(Extensions.Configuration, configurationRegistry);
 export function validateProperty(property, schema) {
-    var _a, _b, _c, _d;
     if (!property.trim()) {
-        return nls.localize('config.property.empty', "Cannot register an empty property");
+        return nls.localizeWithPath('vs/platform/configuration/common/configurationRegistry', 'config.property.empty', "Cannot register an empty property");
     }
     if (OVERRIDE_PROPERTY_REGEX.test(property)) {
-        return nls.localize('config.property.languageDefault', "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", property);
+        return nls.localizeWithPath('vs/platform/configuration/common/configurationRegistry', 'config.property.languageDefault', "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", property);
     }
     if (configurationRegistry.getConfigurationProperties()[property] !== undefined) {
-        return nls.localize('config.property.duplicate', "Cannot register '{0}'. This property is already registered.", property);
+        return nls.localizeWithPath('vs/platform/configuration/common/configurationRegistry', 'config.property.duplicate', "Cannot register '{0}'. This property is already registered.", property);
     }
-    if (((_a = schema.policy) === null || _a === void 0 ? void 0 : _a.name) && configurationRegistry.getPolicyConfigurations().get((_b = schema.policy) === null || _b === void 0 ? void 0 : _b.name) !== undefined) {
-        return nls.localize('config.policy.duplicate', "Cannot register '{0}'. The associated policy {1} is already registered with {2}.", property, (_c = schema.policy) === null || _c === void 0 ? void 0 : _c.name, configurationRegistry.getPolicyConfigurations().get((_d = schema.policy) === null || _d === void 0 ? void 0 : _d.name));
+    if (schema.policy?.name && configurationRegistry.getPolicyConfigurations().get(schema.policy?.name) !== undefined) {
+        return nls.localizeWithPath('vs/platform/configuration/common/configurationRegistry', 'config.policy.duplicate', "Cannot register '{0}'. The associated policy {1} is already registered with {2}.", property, schema.policy?.name, configurationRegistry.getPolicyConfigurations().get(schema.policy?.name));
     }
     return null;
 }
+export function getScopes() {
+    const scopes = [];
+    const configurationProperties = configurationRegistry.getConfigurationProperties();
+    for (const key of Object.keys(configurationProperties)) {
+        scopes.push([key, configurationProperties[key].scope]);
+    }
+    scopes.push(['launch', 4 /* ConfigurationScope.RESOURCE */]);
+    scopes.push(['task', 4 /* ConfigurationScope.RESOURCE */]);
+    return scopes;
+}
diff -urN -x '*.map' a/vs/platform/configuration/common/configurations.js b/vs/platform/configuration/common/configurations.js
--- a/vs/platform/configuration/common/configurations.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/configuration/common/configurations.js	2023-12-06 14:23:14.387854798 +0000
@@ -1,19 +1,49 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
+    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
+    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
+    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
+    return c > 3 && r && Object.defineProperty(target, key, r), r;
+};
+var __param = (this && this.__param) || function (paramIndex, decorator) {
+    return function (target, key) { decorator(target, key, paramIndex); }
+};
+import { coalesce } from '../../../base/common/arrays.js';
+import { Emitter, Event } from '../../../base/common/event.js';
 import { Disposable } from '../../../base/common/lifecycle.js';
+import { equals } from '../../../base/common/objects.js';
+import { isEmptyObject } from '../../../base/common/types.js';
 import { ConfigurationModel } from './configurationModels.js';
 import { Extensions } from './configurationRegistry.js';
+import { ILogService } from '../../log/common/log.js';
+import { IPolicyService } from '../../policy/common/policy.js';
 import { Registry } from '../../registry/common/platform.js';
 export class DefaultConfiguration extends Disposable {
     constructor() {
         super(...arguments);
+        this._onDidChangeConfiguration = this._register(new Emitter());
+        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
         this._configurationModel = new ConfigurationModel();
     }
     get configurationModel() {
         return this._configurationModel;
     }
+    async initialize() {
+        this.resetConfigurationModel();
+        this._register(Registry.as(Extensions.Configuration).onDidUpdateConfiguration(({ properties, defaultsOverrides }) => this.onDidUpdateConfiguration(Array.from(properties), defaultsOverrides)));
+        return this.configurationModel;
+    }
     reload() {
         this.resetConfigurationModel();
         return this.configurationModel;
     }
+    onDidUpdateConfiguration(properties, defaultsOverrides) {
+        this.updateConfigurationModel(properties, Registry.as(Extensions.Configuration).getConfigurationProperties());
+        this._onDidChangeConfiguration.fire({ defaults: this.configurationModel, properties });
+    }
     getConfigurationDefaultOverrides() {
         return {};
     }
@@ -39,3 +69,105 @@
         }
     }
 }
+export class NullPolicyConfiguration {
+    constructor() {
+        this.onDidChangeConfiguration = Event.None;
+        this.configurationModel = new ConfigurationModel();
+    }
+    async initialize() { return this.configurationModel; }
+}
+let PolicyConfiguration = class PolicyConfiguration extends Disposable {
+    get configurationModel() { return this._configurationModel; }
+    constructor(defaultConfiguration, policyService, logService) {
+        super();
+        this.defaultConfiguration = defaultConfiguration;
+        this.policyService = policyService;
+        this.logService = logService;
+        this._onDidChangeConfiguration = this._register(new Emitter());
+        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
+        this._configurationModel = new ConfigurationModel();
+    }
+    async initialize() {
+        this.logService.trace('PolicyConfiguration#initialize');
+        this.update(await this.updatePolicyDefinitions(this.defaultConfiguration.configurationModel.keys), false);
+        this._register(this.policyService.onDidChange(policyNames => this.onDidChangePolicies(policyNames)));
+        this._register(this.defaultConfiguration.onDidChangeConfiguration(async ({ properties }) => this.update(await this.updatePolicyDefinitions(properties), true)));
+        return this._configurationModel;
+    }
+    async updatePolicyDefinitions(properties) {
+        this.logService.trace('PolicyConfiguration#updatePolicyDefinitions', properties);
+        const policyDefinitions = {};
+        const keys = [];
+        const configurationProperties = Registry.as(Extensions.Configuration).getConfigurationProperties();
+        for (const key of properties) {
+            const config = configurationProperties[key];
+            if (!config) {
+                // Config is removed. So add it to the list if in case it was registered as policy before
+                keys.push(key);
+                continue;
+            }
+            if (config.policy) {
+                if (config.type !== 'string' && config.type !== 'number') {
+                    this.logService.warn(`Policy ${config.policy.name} has unsupported type ${config.type}`);
+                    continue;
+                }
+                keys.push(key);
+                policyDefinitions[config.policy.name] = { type: config.type };
+            }
+        }
+        if (!isEmptyObject(policyDefinitions)) {
+            await this.policyService.updatePolicyDefinitions(policyDefinitions);
+        }
+        return keys;
+    }
+    onDidChangePolicies(policyNames) {
+        this.logService.trace('PolicyConfiguration#onDidChangePolicies', policyNames);
+        const policyConfigurations = Registry.as(Extensions.Configuration).getPolicyConfigurations();
+        const keys = coalesce(policyNames.map(policyName => policyConfigurations.get(policyName)));
+        this.update(keys, true);
+    }
+    update(keys, trigger) {
+        this.logService.trace('PolicyConfiguration#update', keys);
+        const configurationProperties = Registry.as(Extensions.Configuration).getConfigurationProperties();
+        const changed = [];
+        const wasEmpty = this._configurationModel.isEmpty();
+        for (const key of keys) {
+            const policyName = configurationProperties[key]?.policy?.name;
+            if (policyName) {
+                const policyValue = this.policyService.getPolicyValue(policyName);
+                if (wasEmpty ? policyValue !== undefined : !equals(this._configurationModel.getValue(key), policyValue)) {
+                    changed.push([key, policyValue]);
+                }
+            }
+            else {
+                if (this._configurationModel.getValue(key) !== undefined) {
+                    changed.push([key, undefined]);
+                }
+            }
+        }
+        if (changed.length) {
+            this.logService.trace('PolicyConfiguration#changed', changed);
+            const old = this._configurationModel;
+            this._configurationModel = new ConfigurationModel();
+            for (const key of old.keys) {
+                this._configurationModel.setValue(key, old.getValue(key));
+            }
+            for (const [key, policyValue] of changed) {
+                if (policyValue === undefined) {
+                    this._configurationModel.removeValue(key);
+                }
+                else {
+                    this._configurationModel.setValue(key, policyValue);
+                }
+            }
+            if (trigger) {
+                this._onDidChangeConfiguration.fire(this._configurationModel);
+            }
+        }
+    }
+};
+PolicyConfiguration = __decorate([
+    __param(1, IPolicyService),
+    __param(2, ILogService)
+], PolicyConfiguration);
+export { PolicyConfiguration };
diff -urN -x '*.map' a/vs/platform/contextkey/browser/contextKeyService.js b/vs/platform/contextkey/browser/contextKeyService.js
--- a/vs/platform/contextkey/browser/contextKeyService.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/contextkey/browser/contextKeyService.js	2023-12-06 14:23:14.387854798 +0000
@@ -14,10 +14,10 @@
 import { PauseableEmitter } from '../../../base/common/event.js';
 import { Iterable } from '../../../base/common/iterator.js';
 import { Disposable, MutableDisposable } from '../../../base/common/lifecycle.js';
-import { cloneAndChange } from '../../../base/common/objects.js';
+import { cloneAndChange, distinct } from '../../../base/common/objects.js';
 import { TernarySearchTree } from '../../../base/common/ternarySearchTree.js';
 import { URI } from '../../../base/common/uri.js';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 import { CommandsRegistry } from '../../commands/common/commands.js';
 import { IConfigurationService } from '../../configuration/common/configuration.js';
 import { IContextKeyService, RawContextKey } from '../common/contextkey.js';
@@ -30,7 +30,7 @@
         this._value['_contextId'] = id;
     }
     get value() {
-        return Object.assign({}, this._value);
+        return { ...this._value };
     }
     setValue(key, value) {
         // console.log('SET ' + key + ' = ' + value + ' ON ' + this._id);
@@ -55,6 +55,15 @@
         }
         return ret;
     }
+    updateParent(parent) {
+        this._parent = parent;
+    }
+    collectAllValues() {
+        let result = this._parent ? this._parent.collectAllValues() : Object.create(null);
+        result = { ...result, ...this._value };
+        delete result['_contextId'];
+        return result;
+    }
 }
 class NullContext extends Context {
     constructor() {
@@ -69,6 +78,9 @@
     getValue(key) {
         return undefined;
     }
+    collectAllValues() {
+        return Object.create(null);
+    }
 }
 NullContext.INSTANCE = new NullContext();
 class ConfigAwareContextValuesContainer extends Context {
@@ -137,6 +149,11 @@
     removeValue(key) {
         return super.removeValue(key);
     }
+    collectAllValues() {
+        const result = Object.create(null);
+        this._values.forEach((value, index) => result[index] = value);
+        return { ...result, ...super.collectAllValues() };
+    }
 }
 ConfigAwareContextValuesContainer._keyPrefix = 'config.';
 class ContextKey {
@@ -215,6 +232,9 @@
         this._isDisposed = false;
         this._myContextId = myContextId;
     }
+    get contextId() {
+        return this._myContextId;
+    }
     createKey(key, defaultValue) {
         if (this._isDisposed) {
             throw new Error(`AbstractContextKeyService has been disposed`);
@@ -236,6 +256,12 @@
         }
         return new ScopedContextKeyService(this, domNode);
     }
+    createOverlay(overlay = Iterable.empty()) {
+        if (this._isDisposed) {
+            throw new Error(`AbstractContextKeyService has been disposed`);
+        }
+        return new OverlayContextKeyService(this, overlay);
+    }
     contextMatchesRules(rules) {
         if (this._isDisposed) {
             throw new Error(`AbstractContextKeyService has been disposed`);
@@ -321,6 +347,9 @@
             this._contexts.delete(contextId);
         }
     }
+    updateParent(_parentContextKeyService) {
+        throw new Error('Cannot update parent of root ContextKeyService');
+    }
 };
 ContextKeyService = __decorate([
     __param(0, IConfigurationService)
@@ -378,6 +407,75 @@
         }
         this._parent.disposeContext(contextId);
     }
+    updateParent(parentContextKeyService) {
+        if (this._parent === parentContextKeyService) {
+            return;
+        }
+        const thisContainer = this._parent.getContextValuesContainer(this._myContextId);
+        const oldAllValues = thisContainer.collectAllValues();
+        this._parent = parentContextKeyService;
+        this._updateParentChangeListener();
+        const newParentContainer = this._parent.getContextValuesContainer(this._parent.contextId);
+        thisContainer.updateParent(newParentContainer);
+        const newAllValues = thisContainer.collectAllValues();
+        const allValuesDiff = {
+            ...distinct(oldAllValues, newAllValues),
+            ...distinct(newAllValues, oldAllValues)
+        };
+        const changedKeys = Object.keys(allValuesDiff);
+        this._onDidChangeContext.fire(new ArrayContextKeyChangeEvent(changedKeys));
+    }
+}
+class OverlayContext {
+    constructor(parent, overlay) {
+        this.parent = parent;
+        this.overlay = overlay;
+    }
+    getValue(key) {
+        return this.overlay.has(key) ? this.overlay.get(key) : this.parent.getValue(key);
+    }
+}
+class OverlayContextKeyService {
+    get contextId() {
+        return this.parent.contextId;
+    }
+    get onDidChangeContext() {
+        return this.parent.onDidChangeContext;
+    }
+    constructor(parent, overlay) {
+        this.parent = parent;
+        this.overlay = new Map(overlay);
+    }
+    bufferChangeEvents(callback) {
+        this.parent.bufferChangeEvents(callback);
+    }
+    createKey() {
+        throw new Error('Not supported.');
+    }
+    getContext(target) {
+        return new OverlayContext(this.parent.getContext(target), this.overlay);
+    }
+    getContextValuesContainer(contextId) {
+        const parentContext = this.parent.getContextValuesContainer(contextId);
+        return new OverlayContext(parentContext, this.overlay);
+    }
+    contextMatchesRules(rules) {
+        const context = this.getContextValuesContainer(this.contextId);
+        const result = (rules ? rules.evaluate(context) : true);
+        return result;
+    }
+    getContextKeyValue(key) {
+        return this.overlay.has(key) ? this.overlay.get(key) : this.parent.getContextKeyValue(key);
+    }
+    createScoped() {
+        throw new Error('Not supported.');
+    }
+    createOverlay(overlay = Iterable.empty()) {
+        return new OverlayContextKeyService(this, overlay);
+    }
+    updateParent() {
+        throw new Error('Not supported.');
+    }
 }
 function findContextAttr(domNode) {
     while (domNode) {
@@ -414,7 +512,7 @@
         return [...RawContextKey.all()].sort((a, b) => a.key.localeCompare(b.key));
     },
     description: {
-        description: localize('getContextKeyInfo', "A command that returns information about context keys"),
+        description: localizeWithPath('vs/platform/contextkey/browser/contextKeyService', 'getContextKeyInfo', "A command that returns information about context keys"),
         args: []
     }
 });
diff -urN -x '*.map' a/vs/platform/contextkey/common/contextkey.js b/vs/platform/contextkey/common/contextkey.js
--- a/vs/platform/contextkey/common/contextkey.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/contextkey/common/contextkey.js	2023-12-06 14:23:14.387854798 +0000
@@ -6,7 +6,8 @@
 import { isFalsyOrWhitespace } from '../../../base/common/strings.js';
 import { Scanner } from './scanner.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
+import { illegalArgument } from '../../../base/common/errors.js';
 const CONSTANT_VALUES = new Map();
 CONSTANT_VALUES.set('false', false);
 CONSTANT_VALUES.set('true', true);
@@ -19,18 +20,25 @@
 CONSTANT_VALUES.set('isFirefox', isFirefox);
 CONSTANT_VALUES.set('isChrome', isChrome);
 CONSTANT_VALUES.set('isSafari', isSafari);
+/** allow register constant context keys that are known only after startup; requires running `substituteConstants` on the context key - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127 */
+export function setConstant(key, value) {
+    if (CONSTANT_VALUES.get(key) !== undefined) {
+        throw illegalArgument('contextkey.setConstant(k, v) invoked with already set constant `k`');
+    }
+    CONSTANT_VALUES.set(key, value);
+}
 const hasOwnProperty = Object.prototype.hasOwnProperty;
 const defaultConfig = {
     regexParsingWithErrorRecovery: true
 };
-const errorEmptyString = localize('contextkey.parser.error.emptyString', "Empty context key expression");
-const hintEmptyString = localize('contextkey.parser.error.emptyString.hint', "Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.");
-const errorNoInAfterNot = localize('contextkey.parser.error.noInAfterNot', "'in' after 'not'.");
-const errorClosingParenthesis = localize('contextkey.parser.error.closingParenthesis', "closing parenthesis ')'");
-const errorUnexpectedToken = localize('contextkey.parser.error.unexpectedToken', "Unexpected token");
-const hintUnexpectedToken = localize('contextkey.parser.error.unexpectedToken.hint', "Did you forget to put && or || before the token?");
-const errorUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF', "Unexpected end of expression");
-const hintUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF.hint', "Did you forget to put a context key?");
+const errorEmptyString = localizeWithPath('vs/platform/contextkey/common/contextkey', 'contextkey.parser.error.emptyString', "Empty context key expression");
+const hintEmptyString = localizeWithPath('vs/platform/contextkey/common/contextkey', 'contextkey.parser.error.emptyString.hint', "Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.");
+const errorNoInAfterNot = localizeWithPath('vs/platform/contextkey/common/contextkey', 'contextkey.parser.error.noInAfterNot', "'in' after 'not'.");
+const errorClosingParenthesis = localizeWithPath('vs/platform/contextkey/common/contextkey', 'contextkey.parser.error.closingParenthesis', "closing parenthesis ')'");
+const errorUnexpectedToken = localizeWithPath('vs/platform/contextkey/common/contextkey', 'contextkey.parser.error.unexpectedToken', "Unexpected token");
+const hintUnexpectedToken = localizeWithPath('vs/platform/contextkey/common/contextkey', 'contextkey.parser.error.unexpectedToken.hint', "Did you forget to put && or || before the token?");
+const errorUnexpectedEOF = localizeWithPath('vs/platform/contextkey/common/contextkey', 'contextkey.parser.error.unexpectedEOF', "Unexpected end of expression");
+const hintUnexpectedEOF = localizeWithPath('vs/platform/contextkey/common/contextkey', 'contextkey.parser.error.unexpectedEOF.hint', "Did you forget to put a context key?");
 /**
  * A parser for context key expressions.
  *
@@ -49,6 +57,12 @@
  * ```
  */
 export class Parser {
+    get lexingErrors() {
+        return this._scanner.errors;
+    }
+    get parsingErrors() {
+        return this._parsingErrors;
+    }
     constructor(_config = defaultConfig) {
         this._config = _config;
         // lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`
@@ -124,7 +138,7 @@
                     this._advance();
                     const expr = this._expr();
                     this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);
-                    return expr === null || expr === void 0 ? void 0 : expr.negate();
+                    return expr?.negate();
                 }
                 case 17 /* TokenType.Str */:
                     this._advance();
@@ -372,7 +386,7 @@
         throw this._errExpectedButGot(message, this._peek());
     }
     _errExpectedButGot(expected, got, additionalInfo) {
-        const message = localize('contextkey.parser.error.expectedButGot', "Expected: {0}\nReceived: '{1}'.", expected, Scanner.getLexeme(got));
+        const message = localizeWithPath('vs/platform/contextkey/common/contextkey', 'contextkey.parser.error.expectedButGot', "Expected: {0}\nReceived: '{1}'.", expected, Scanner.getLexeme(got));
         const offset = got.offset;
         const lexeme = Scanner.getLexeme(got);
         this._parsingErrors.push({ message, offset, lexeme, additionalInfo });
@@ -425,6 +439,18 @@
     static or(...expr) {
         return ContextKeyOrExpr.create(expr, null, true);
     }
+    static greater(key, value) {
+        return ContextKeyGreaterExpr.create(key, value);
+    }
+    static greaterEquals(key, value) {
+        return ContextKeyGreaterEqualsExpr.create(key, value);
+    }
+    static smaller(key, value) {
+        return ContextKeySmallerExpr.create(key, value);
+    }
+    static smallerEquals(key, value) {
+        return ContextKeySmallerEqualsExpr.create(key, value);
+    }
     static deserialize(serialized) {
         if (serialized === undefined || serialized === null) { // an empty string needs to be handled by the parser to get a corresponding parsing error reported
             return undefined;
@@ -434,6 +460,31 @@
     }
 }
 ContextKeyExpr._parser = new Parser({ regexParsingWithErrorRecovery: false });
+export function validateWhenClauses(whenClauses) {
+    const parser = new Parser({ regexParsingWithErrorRecovery: false }); // we run with no recovery to guide users to use correct regexes
+    return whenClauses.map(whenClause => {
+        parser.parse(whenClause);
+        if (parser.lexingErrors.length > 0) {
+            return parser.lexingErrors.map((se) => ({
+                errorMessage: se.additionalInfo ?
+                    localizeWithPath('vs/platform/contextkey/common/contextkey', 'contextkey.scanner.errorForLinterWithHint', "Unexpected token. Hint: {0}", se.additionalInfo) :
+                    localizeWithPath('vs/platform/contextkey/common/contextkey', 'contextkey.scanner.errorForLinter', "Unexpected token."),
+                offset: se.offset,
+                length: se.lexeme.length,
+            }));
+        }
+        else if (parser.parsingErrors.length > 0) {
+            return parser.parsingErrors.map((pe) => ({
+                errorMessage: pe.additionalInfo ? `${pe.message}. ${pe.additionalInfo}` : pe.message,
+                offset: pe.offset,
+                length: pe.lexeme.length,
+            }));
+        }
+        else {
+            return [];
+        }
+    });
+}
 export function expressionsAreEqualWithConstantSubstitution(a, b) {
     const aExpr = a ? a.substituteConstants() : undefined;
     const bExpr = b ? b.substituteConstants() : undefined;
@@ -470,6 +521,9 @@
     keys() {
         return [];
     }
+    map(mapFnc) {
+        return this;
+    }
     negate() {
         return ContextKeyTrueExpr.INSTANCE;
     }
@@ -497,6 +551,9 @@
     keys() {
         return [];
     }
+    map(mapFnc) {
+        return this;
+    }
     negate() {
         return ContextKeyFalseExpr.INSTANCE;
     }
@@ -543,6 +600,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapDefined(this.key);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyNotExpr.create(this.key, this);
@@ -599,6 +659,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapEquals(this.key, this.value);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);
@@ -648,6 +711,9 @@
     keys() {
         return [this.key, this.valueKey];
     }
+    map(mapFnc) {
+        return mapFnc.mapIn(this.key, this.valueKey);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);
@@ -689,6 +755,9 @@
     keys() {
         return this._negated.keys();
     }
+    map(mapFnc) {
+        return mapFnc.mapNotIn(this.key, this.valueKey);
+    }
     negate() {
         return this._negated;
     }
@@ -745,6 +814,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapNotEquals(this.key, this.value);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);
@@ -793,6 +865,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapNot(this.key);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyDefinedExpr.create(this.key, this);
@@ -849,6 +924,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapGreater(this.key, this.value);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);
@@ -893,6 +971,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapGreaterEquals(this.key, this.value);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);
@@ -937,6 +1018,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapSmaller(this.key, this.value);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);
@@ -981,6 +1065,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapSmallerEquals(this.key, this.value);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);
@@ -1043,6 +1130,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapRegex(this.key, this.regexp);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyNotRegexExpr.create(this);
@@ -1083,6 +1173,9 @@
     keys() {
         return this._actual.keys();
     }
+    map(mapFnc) {
+        return new ContextKeyNotRegexExpr(this._actual.map(mapFnc));
+    }
     negate() {
         return this._actual;
     }
@@ -1261,6 +1354,9 @@
         }
         return result;
     }
+    map(mapFnc) {
+        return new ContextKeyAndExpr(this.expr.map(expr => expr.map(mapFnc)), null);
+    }
     negate() {
         if (!this.negated) {
             const result = [];
@@ -1400,6 +1496,9 @@
         }
         return result;
     }
+    map(mapFnc) {
+        return new ContextKeyOrExpr(this.expr.map(expr => expr.map(mapFnc)), null);
+    }
     negate() {
         if (!this.negated) {
             const result = [];
@@ -1433,7 +1532,7 @@
         this._defaultValue = defaultValue;
         // collect all context keys into a central place
         if (typeof metaOrHide === 'object') {
-            RawContextKey._info.push(Object.assign(Object.assign({}, metaOrHide), { key }));
+            RawContextKey._info.push({ ...metaOrHide, key });
         }
         else if (metaOrHide !== true) {
             RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });
@@ -1451,6 +1550,9 @@
     isEqualTo(value) {
         return ContextKeyEqualsExpr.create(this.key, value);
     }
+    notEqualsTo(value) {
+        return ContextKeyNotEqualsExpr.create(this.key, value);
+    }
 }
 RawContextKey._info = [];
 export const IContextKeyService = createDecorator('contextKeyService');
diff -urN -x '*.map' a/vs/platform/contextkey/common/contextkeys.js b/vs/platform/contextkey/common/contextkeys.js
--- a/vs/platform/contextkey/common/contextkeys.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/contextkey/common/contextkeys.js	2023-12-06 14:23:14.387854798 +0000
@@ -3,16 +3,16 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { isIOS, isLinux, isMacintosh, isMobile, isWeb, isWindows } from '../../../base/common/platform.js';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 import { RawContextKey } from './contextkey.js';
-export const IsMacContext = new RawContextKey('isMac', isMacintosh, localize('isMac', "Whether the operating system is macOS"));
-export const IsLinuxContext = new RawContextKey('isLinux', isLinux, localize('isLinux', "Whether the operating system is Linux"));
-export const IsWindowsContext = new RawContextKey('isWindows', isWindows, localize('isWindows', "Whether the operating system is Windows"));
-export const IsWebContext = new RawContextKey('isWeb', isWeb, localize('isWeb', "Whether the platform is a web browser"));
-export const IsMacNativeContext = new RawContextKey('isMacNative', isMacintosh && !isWeb, localize('isMacNative', "Whether the operating system is macOS on a non-browser platform"));
-export const IsIOSContext = new RawContextKey('isIOS', isIOS, localize('isIOS', "Whether the operating system is iOS"));
-export const IsMobileContext = new RawContextKey('isMobile', isMobile, localize('isMobile', "Whether the platform is a mobile web browser"));
+export const IsMacContext = new RawContextKey('isMac', isMacintosh, localizeWithPath('vs/platform/contextkey/common/contextkeys', 'isMac', "Whether the operating system is macOS"));
+export const IsLinuxContext = new RawContextKey('isLinux', isLinux, localizeWithPath('vs/platform/contextkey/common/contextkeys', 'isLinux', "Whether the operating system is Linux"));
+export const IsWindowsContext = new RawContextKey('isWindows', isWindows, localizeWithPath('vs/platform/contextkey/common/contextkeys', 'isWindows', "Whether the operating system is Windows"));
+export const IsWebContext = new RawContextKey('isWeb', isWeb, localizeWithPath('vs/platform/contextkey/common/contextkeys', 'isWeb', "Whether the platform is a web browser"));
+export const IsMacNativeContext = new RawContextKey('isMacNative', isMacintosh && !isWeb, localizeWithPath('vs/platform/contextkey/common/contextkeys', 'isMacNative', "Whether the operating system is macOS on a non-browser platform"));
+export const IsIOSContext = new RawContextKey('isIOS', isIOS, localizeWithPath('vs/platform/contextkey/common/contextkeys', 'isIOS', "Whether the operating system is iOS"));
+export const IsMobileContext = new RawContextKey('isMobile', isMobile, localizeWithPath('vs/platform/contextkey/common/contextkeys', 'isMobile', "Whether the platform is a mobile web browser"));
 export const IsDevelopmentContext = new RawContextKey('isDevelopment', false, true);
-export const ProductQualityContext = new RawContextKey('productQualityType', '', localize('productQualityType', "Quality type of VS Code"));
+export const ProductQualityContext = new RawContextKey('productQualityType', '', localizeWithPath('vs/platform/contextkey/common/contextkeys', 'productQualityType', "Quality type of VS Code"));
 export const InputFocusedContextKey = 'inputFocus';
-export const InputFocusedContext = new RawContextKey(InputFocusedContextKey, false, localize('inputFocus', "Whether keyboard focus is inside an input box"));
+export const InputFocusedContext = new RawContextKey(InputFocusedContextKey, false, localizeWithPath('vs/platform/contextkey/common/contextkeys', 'inputFocus', "Whether keyboard focus is inside an input box"));
diff -urN -x '*.map' a/vs/platform/contextkey/common/scanner.js b/vs/platform/contextkey/common/scanner.js
--- a/vs/platform/contextkey/common/scanner.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/contextkey/common/scanner.js	2023-12-06 14:23:14.387854798 +0000
@@ -3,21 +3,21 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { illegalState } from '../../../base/common/errors.js';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 function hintDidYouMean(...meant) {
     switch (meant.length) {
         case 1:
-            return localize('contextkey.scanner.hint.didYouMean1', "Did you mean {0}?", meant[0]);
+            return localizeWithPath('vs/platform/contextkey/common/scanner', 'contextkey.scanner.hint.didYouMean1', "Did you mean {0}?", meant[0]);
         case 2:
-            return localize('contextkey.scanner.hint.didYouMean2', "Did you mean {0} or {1}?", meant[0], meant[1]);
+            return localizeWithPath('vs/platform/contextkey/common/scanner', 'contextkey.scanner.hint.didYouMean2', "Did you mean {0} or {1}?", meant[0], meant[1]);
         case 3:
-            return localize('contextkey.scanner.hint.didYouMean3', "Did you mean {0}, {1} or {2}?", meant[0], meant[1], meant[2]);
+            return localizeWithPath('vs/platform/contextkey/common/scanner', 'contextkey.scanner.hint.didYouMean3', "Did you mean {0}, {1} or {2}?", meant[0], meant[1], meant[2]);
         default: // we just don't expect that many
             return undefined;
     }
 }
-const hintDidYouForgetToOpenOrCloseQuote = localize('contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote', "Did you forget to open or close the quote?");
-const hintDidYouForgetToEscapeSlash = localize('contextkey.scanner.hint.didYouForgetToEscapeSlash', "Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/\'.");
+const hintDidYouForgetToOpenOrCloseQuote = localizeWithPath('vs/platform/contextkey/common/scanner', 'contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote', "Did you forget to open or close the quote?");
+const hintDidYouForgetToEscapeSlash = localizeWithPath('vs/platform/contextkey/common/scanner', 'contextkey.scanner.hint.didYouForgetToEscapeSlash', "Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/\'.");
 /**
  * A simple scanner for context keys.
  *
@@ -91,6 +91,9 @@
                 throw illegalState(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);
         }
     }
+    get errors() {
+        return this._errors;
+    }
     reset(value) {
         this._input = value;
         this._start = 0;
diff -urN -x '*.map' a/vs/platform/contextview/browser/contextMenuHandler.js b/vs/platform/contextview/browser/contextMenuHandler.js
--- a/vs/platform/contextview/browser/contextMenuHandler.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/contextview/browser/contextMenuHandler.js	2023-12-06 14:23:14.387854798 +0000
@@ -38,7 +38,6 @@
             anchorAlignment: delegate.anchorAlignment,
             anchorAxisAlignment: delegate.anchorAxisAlignment,
             render: (container) => {
-                var _a;
                 this.lastContainer = container;
                 const className = delegate.getMenuClassName ? delegate.getMenuClassName() : '';
                 if (className) {
@@ -54,7 +53,7 @@
                     this.block.style.width = '100%';
                     this.block.style.height = '100%';
                     this.block.style.zIndex = '-1';
-                    (_a = this.blockDisposable) === null || _a === void 0 ? void 0 : _a.dispose();
+                    this.blockDisposable?.dispose();
                     this.blockDisposable = addDisposableListener(this.block, EventType.MOUSE_DOWN, e => e.stopPropagation());
                 }
                 const menuDisposables = new DisposableStore();
@@ -91,19 +90,18 @@
                 return combinedDisposable(menuDisposables, menu);
             },
             focus: () => {
-                menu === null || menu === void 0 ? void 0 : menu.focus(!!delegate.autoSelectFirstItem);
+                menu?.focus(!!delegate.autoSelectFirstItem);
             },
             onHide: (didCancel) => {
-                var _a, _b, _c;
-                (_a = delegate.onHide) === null || _a === void 0 ? void 0 : _a.call(delegate, !!didCancel);
+                delegate.onHide?.(!!didCancel);
                 if (this.block) {
                     this.block.remove();
                     this.block = null;
                 }
-                (_b = this.blockDisposable) === null || _b === void 0 ? void 0 : _b.dispose();
+                this.blockDisposable?.dispose();
                 this.blockDisposable = null;
                 if (!!this.lastContainer && (getActiveElement() === this.lastContainer || isAncestor(getActiveElement(), this.lastContainer))) {
-                    (_c = this.focusToReturn) === null || _c === void 0 ? void 0 : _c.focus();
+                    this.focusToReturn?.focus();
                 }
                 this.lastContainer = null;
             }
diff -urN -x '*.map' a/vs/platform/contextview/browser/contextMenuService.js b/vs/platform/contextview/browser/contextMenuService.js
--- a/vs/platform/contextview/browser/contextMenuService.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/contextview/browser/contextMenuService.js	2023-12-06 14:23:14.387854798 +0000
@@ -40,7 +40,9 @@
         this.contextKeyService = contextKeyService;
         this._contextMenuHandler = undefined;
         this._onDidShowContextMenu = this._store.add(new Emitter());
+        this.onDidShowContextMenu = this._onDidShowContextMenu.event;
         this._onDidHideContextMenu = this._store.add(new Emitter());
+        this.onDidHideContextMenu = this._onDidHideContextMenu.event;
     }
     configure(options) {
         this.contextMenuHandler.configure(options);
@@ -48,11 +50,13 @@
     // ContextMenu
     showContextMenu(delegate) {
         delegate = ContextMenuMenuDelegate.transform(delegate, this.menuService, this.contextKeyService);
-        this.contextMenuHandler.showContextMenu(Object.assign(Object.assign({}, delegate), { onHide: (didCancel) => {
-                var _a;
-                (_a = delegate.onHide) === null || _a === void 0 ? void 0 : _a.call(delegate, didCancel);
+        this.contextMenuHandler.showContextMenu({
+            ...delegate,
+            onHide: (didCancel) => {
+                delegate.onHide?.(didCancel);
                 this._onDidHideContextMenu.fire();
-            } }));
+            }
+        });
         ModifierKeyEmitter.getInstance().resetKeyStatus();
         this._onDidShowContextMenu.fire();
     }
@@ -76,10 +80,12 @@
             return delegate;
         }
         const { menuId, menuActionOptions, contextKeyService } = delegate;
-        return Object.assign(Object.assign({}, delegate), { getActions: () => {
+        return {
+            ...delegate,
+            getActions: () => {
                 const target = [];
                 if (menuId) {
-                    const menu = menuService.createMenu(menuId, contextKeyService !== null && contextKeyService !== void 0 ? contextKeyService : globalContextKeyService);
+                    const menu = menuService.createMenu(menuId, contextKeyService ?? globalContextKeyService);
                     createAndFillInContextMenuActions(menu, menuActionOptions, target);
                     menu.dispose();
                 }
@@ -89,7 +95,8 @@
                 else {
                     return Separator.join(delegate.getActions(), target);
                 }
-            } });
+            }
+        };
     }
     ContextMenuMenuDelegate.transform = transform;
 })(ContextMenuMenuDelegate || (ContextMenuMenuDelegate = {}));
diff -urN -x '*.map' a/vs/platform/dialogs/common/dialogs.js b/vs/platform/dialogs/common/dialogs.js
--- a/vs/platform/dialogs/common/dialogs.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/dialogs/common/dialogs.js	2023-12-06 14:23:14.387854798 +0000
@@ -1,2 +1,208 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { basename } from '../../../base/common/resources.js';
+import Severity from '../../../base/common/severity.js';
+import { localizeWithPath } from '../../../nls.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { mnemonicButtonLabel } from '../../../base/common/labels.js';
+import { isLinux, isMacintosh, isWindows } from '../../../base/common/platform.js';
+import { deepClone } from '../../../base/common/objects.js';
 export const IDialogService = createDecorator('dialogService');
+var DialogKind;
+(function (DialogKind) {
+    DialogKind[DialogKind["Confirmation"] = 1] = "Confirmation";
+    DialogKind[DialogKind["Prompt"] = 2] = "Prompt";
+    DialogKind[DialogKind["Input"] = 3] = "Input";
+})(DialogKind || (DialogKind = {}));
+export class AbstractDialogHandler {
+    getConfirmationButtons(dialog) {
+        return this.getButtons(dialog, DialogKind.Confirmation);
+    }
+    getPromptButtons(dialog) {
+        return this.getButtons(dialog, DialogKind.Prompt);
+    }
+    getInputButtons(dialog) {
+        return this.getButtons(dialog, DialogKind.Input);
+    }
+    getButtons(dialog, kind) {
+        // We put buttons in the order of "default" button first and "cancel"
+        // button last. There maybe later processing when presenting the buttons
+        // based on OS standards.
+        const buttons = [];
+        switch (kind) {
+            case DialogKind.Confirmation: {
+                const confirmationDialog = dialog;
+                if (confirmationDialog.primaryButton) {
+                    buttons.push(confirmationDialog.primaryButton);
+                }
+                else {
+                    buttons.push(localizeWithPath('vs/platform/dialogs/common/dialogs', { key: 'yesButton', comment: ['&& denotes a mnemonic'] }, "&&Yes"));
+                }
+                if (confirmationDialog.cancelButton) {
+                    buttons.push(confirmationDialog.cancelButton);
+                }
+                else {
+                    buttons.push(localizeWithPath('vs/platform/dialogs/common/dialogs', 'cancelButton', "Cancel"));
+                }
+                break;
+            }
+            case DialogKind.Prompt: {
+                const promptDialog = dialog;
+                if (Array.isArray(promptDialog.buttons) && promptDialog.buttons.length > 0) {
+                    buttons.push(...promptDialog.buttons.map(button => button.label));
+                }
+                if (promptDialog.cancelButton) {
+                    if (promptDialog.cancelButton === true) {
+                        buttons.push(localizeWithPath('vs/platform/dialogs/common/dialogs', 'cancelButton', "Cancel"));
+                    }
+                    else if (typeof promptDialog.cancelButton === 'string') {
+                        buttons.push(promptDialog.cancelButton);
+                    }
+                    else {
+                        if (promptDialog.cancelButton.label) {
+                            buttons.push(promptDialog.cancelButton.label);
+                        }
+                        else {
+                            buttons.push(localizeWithPath('vs/platform/dialogs/common/dialogs', 'cancelButton', "Cancel"));
+                        }
+                    }
+                }
+                if (buttons.length === 0) {
+                    buttons.push(localizeWithPath('vs/platform/dialogs/common/dialogs', { key: 'okButton', comment: ['&& denotes a mnemonic'] }, "&&OK"));
+                }
+                break;
+            }
+            case DialogKind.Input: {
+                const inputDialog = dialog;
+                if (inputDialog.primaryButton) {
+                    buttons.push(inputDialog.primaryButton);
+                }
+                else {
+                    buttons.push(localizeWithPath('vs/platform/dialogs/common/dialogs', { key: 'okButton', comment: ['&& denotes a mnemonic'] }, "&&OK"));
+                }
+                if (inputDialog.cancelButton) {
+                    buttons.push(inputDialog.cancelButton);
+                }
+                else {
+                    buttons.push(localizeWithPath('vs/platform/dialogs/common/dialogs', 'cancelButton', "Cancel"));
+                }
+                break;
+            }
+        }
+        return buttons;
+    }
+    getDialogType(type) {
+        if (typeof type === 'string') {
+            return type;
+        }
+        if (typeof type === 'number') {
+            return (type === Severity.Info) ? 'info' : (type === Severity.Error) ? 'error' : (type === Severity.Warning) ? 'warning' : 'none';
+        }
+        return undefined;
+    }
+    async getPromptResult(prompt, buttonIndex, checkboxChecked) {
+        const promptButtons = [...(prompt.buttons ?? [])];
+        if (prompt.cancelButton && typeof prompt.cancelButton !== 'string' && typeof prompt.cancelButton !== 'boolean') {
+            promptButtons.push(prompt.cancelButton);
+        }
+        const result = await promptButtons[buttonIndex]?.run({ checkboxChecked });
+        return { result, checkboxChecked };
+    }
+}
+export const IFileDialogService = createDecorator('fileDialogService');
+const MAX_CONFIRM_FILES = 10;
+export function getFileNamesMessage(fileNamesOrResources) {
+    const message = [];
+    message.push(...fileNamesOrResources.slice(0, MAX_CONFIRM_FILES).map(fileNameOrResource => typeof fileNameOrResource === 'string' ? fileNameOrResource : basename(fileNameOrResource)));
+    if (fileNamesOrResources.length > MAX_CONFIRM_FILES) {
+        if (fileNamesOrResources.length - MAX_CONFIRM_FILES === 1) {
+            message.push(localizeWithPath('vs/platform/dialogs/common/dialogs', 'moreFile', "...1 additional file not shown"));
+        }
+        else {
+            message.push(localizeWithPath('vs/platform/dialogs/common/dialogs', 'moreFiles', "...{0} additional files not shown", fileNamesOrResources.length - MAX_CONFIRM_FILES));
+        }
+    }
+    message.push('');
+    return message.join('\n');
+}
+/**
+ * A utility method to ensure the options for the message box dialog
+ * are using properties that are consistent across all platforms and
+ * specific to the platform where necessary.
+ */
+export function massageMessageBoxOptions(options, productService) {
+    const massagedOptions = deepClone(options);
+    let buttons = (massagedOptions.buttons ?? []).map(button => mnemonicButtonLabel(button));
+    let buttonIndeces = (options.buttons || []).map((button, index) => index);
+    let defaultId = 0; // by default the first button is default button
+    let cancelId = massagedOptions.cancelId ?? buttons.length - 1; // by default the last button is cancel button
+    // Apply HIG per OS when more than one button is used
+    if (buttons.length > 1) {
+        const cancelButton = typeof cancelId === 'number' ? buttons[cancelId] : undefined;
+        if (isLinux || isMacintosh) {
+            // Linux: the GNOME HIG (https://developer.gnome.org/hig/patterns/feedback/dialogs.html?highlight=dialog)
+            // recommend the following:
+            // "Always ensure that the cancel button appears first, before the affirmative button. In left-to-right
+            //  locales, this is on the left. This button order ensures that users become aware of, and are reminded
+            //  of, the ability to cancel prior to encountering the affirmative button."
+            //
+            // Electron APIs do not reorder buttons for us, so we ensure a reverse order of buttons and a position
+            // of the cancel button (if provided) that matches the HIG
+            // macOS: the HIG (https://developer.apple.com/design/human-interface-guidelines/components/presentation/alerts)
+            // recommend the following:
+            // "Place buttons where people expect. In general, place the button people are most likely to choose on the trailing side in a
+            //  row of buttons or at the top in a stack of buttons. Always place the default button on the trailing side of a row or at the
+            //  top of a stack. Cancel buttons are typically on the leading side of a row or at the bottom of a stack."
+            //
+            // However: it seems that older macOS versions where 3 buttons were presented in a row differ from this
+            // recommendation. In fact, cancel buttons were placed to the left of the default button and secondary
+            // buttons on the far left. To support these older macOS versions we have to manually shuffle the cancel
+            // button in the same way as we do on Linux. This will not have any impact on newer macOS versions where
+            // shuffling is done for us.
+            if (typeof cancelButton === 'string' && buttons.length > 1 && cancelId !== 1) {
+                buttons.splice(cancelId, 1);
+                buttons.splice(1, 0, cancelButton);
+                const cancelButtonIndex = buttonIndeces[cancelId];
+                buttonIndeces.splice(cancelId, 1);
+                buttonIndeces.splice(1, 0, cancelButtonIndex);
+                cancelId = 1;
+            }
+            if (isLinux && buttons.length > 1) {
+                buttons = buttons.reverse();
+                buttonIndeces = buttonIndeces.reverse();
+                defaultId = buttons.length - 1;
+                if (typeof cancelButton === 'string') {
+                    cancelId = defaultId - 1;
+                }
+            }
+        }
+        else if (isWindows) {
+            // Windows: the HIG (https://learn.microsoft.com/en-us/windows/win32/uxguide/win-dialog-box)
+            // recommend the following:
+            // "One of the following sets of concise commands: Yes/No, Yes/No/Cancel, [Do it]/Cancel,
+            //  [Do it]/[Don't do it], [Do it]/[Don't do it]/Cancel."
+            //
+            // Electron APIs do not reorder buttons for us, so we ensure the position of the cancel button
+            // (if provided) that matches the HIG
+            if (typeof cancelButton === 'string' && buttons.length > 1 && cancelId !== buttons.length - 1 /* last action */) {
+                buttons.splice(cancelId, 1);
+                buttons.push(cancelButton);
+                const buttonIndex = buttonIndeces[cancelId];
+                buttonIndeces.splice(cancelId, 1);
+                buttonIndeces.push(buttonIndex);
+                cancelId = buttons.length - 1;
+            }
+        }
+    }
+    massagedOptions.buttons = buttons;
+    massagedOptions.defaultId = defaultId;
+    massagedOptions.cancelId = cancelId;
+    massagedOptions.noLink = true;
+    massagedOptions.title = massagedOptions.title || productService.nameLong;
+    return {
+        options: massagedOptions,
+        buttonIndeces
+    };
+}
diff -urN -x '*.map' a/vs/platform/dnd/browser/dnd.js b/vs/platform/dnd/browser/dnd.js
--- a/vs/platform/dnd/browser/dnd.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/dnd/browser/dnd.js	2023-12-06 14:23:14.387854798 +0000
@@ -1,10 +1,258 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { DataTransfers } from '../../../base/browser/dnd.js';
+import { coalesce } from '../../../base/common/arrays.js';
+import { DeferredPromise } from '../../../base/common/async.js';
+import { VSBuffer } from '../../../base/common/buffer.js';
+import { ResourceMap } from '../../../base/common/map.js';
+import { parse } from '../../../base/common/marshalling.js';
+import { Schemas } from '../../../base/common/network.js';
+import { isWeb } from '../../../base/common/platform.js';
+import { URI } from '../../../base/common/uri.js';
+import { localizeWithPath } from '../../../nls.js';
+import { IDialogService } from '../../dialogs/common/dialogs.js';
+import { HTMLFileSystemProvider } from '../../files/browser/htmlFileSystemProvider.js';
+import { WebFileSystemAccess } from '../../files/browser/webFileSystemAccess.js';
+import { ByteSize, IFileService } from '../../files/common/files.js';
+import { IInstantiationService } from '../../instantiation/common/instantiation.js';
+import { extractSelection } from '../../opener/common/opener.js';
 import { Registry } from '../../registry/common/platform.js';
 //#region Editor / Resources DND
 export const CodeDataTransfers = {
     EDITORS: 'CodeEditors',
     FILES: 'CodeFiles'
 };
+export function extractEditorsDropData(e) {
+    const editors = [];
+    if (e.dataTransfer && e.dataTransfer.types.length > 0) {
+        // Data Transfer: Code Editors
+        const rawEditorsData = e.dataTransfer.getData(CodeDataTransfers.EDITORS);
+        if (rawEditorsData) {
+            try {
+                editors.push(...parse(rawEditorsData));
+            }
+            catch (error) {
+                // Invalid transfer
+            }
+        }
+        // Data Transfer: Resources
+        else {
+            try {
+                const rawResourcesData = e.dataTransfer.getData(DataTransfers.RESOURCES);
+                editors.push(...createDraggedEditorInputFromRawResourcesData(rawResourcesData));
+            }
+            catch (error) {
+                // Invalid transfer
+            }
+        }
+        // Check for native file transfer
+        if (e.dataTransfer?.files) {
+            for (let i = 0; i < e.dataTransfer.files.length; i++) {
+                const file = e.dataTransfer.files[i];
+                if (file && file.path /* Electron only */) {
+                    try {
+                        editors.push({ resource: URI.file(file.path), isExternal: true, allowWorkspaceOpen: true });
+                    }
+                    catch (error) {
+                        // Invalid URI
+                    }
+                }
+            }
+        }
+        // Check for CodeFiles transfer
+        const rawCodeFiles = e.dataTransfer.getData(CodeDataTransfers.FILES);
+        if (rawCodeFiles) {
+            try {
+                const codeFiles = JSON.parse(rawCodeFiles);
+                for (const codeFile of codeFiles) {
+                    editors.push({ resource: URI.file(codeFile), isExternal: true, allowWorkspaceOpen: true });
+                }
+            }
+            catch (error) {
+                // Invalid transfer
+            }
+        }
+        // Workbench contributions
+        const contributions = Registry.as(Extensions.DragAndDropContribution).getAll();
+        for (const contribution of contributions) {
+            const data = e.dataTransfer.getData(contribution.dataFormatKey);
+            if (data) {
+                try {
+                    editors.push(...contribution.getEditorInputs(data));
+                }
+                catch (error) {
+                    // Invalid transfer
+                }
+            }
+        }
+    }
+    // Prevent duplicates: it is possible that we end up with the same
+    // dragged editor multiple times because multiple data transfers
+    // are being used (https://github.com/microsoft/vscode/issues/128925)
+    const coalescedEditors = [];
+    const seen = new ResourceMap();
+    for (const editor of editors) {
+        if (!editor.resource) {
+            coalescedEditors.push(editor);
+        }
+        else if (!seen.has(editor.resource)) {
+            coalescedEditors.push(editor);
+            seen.set(editor.resource, true);
+        }
+    }
+    return coalescedEditors;
+}
+export async function extractEditorsAndFilesDropData(accessor, e) {
+    const editors = extractEditorsDropData(e);
+    // Web: Check for file transfer
+    if (e.dataTransfer && isWeb && containsDragType(e, DataTransfers.FILES)) {
+        const files = e.dataTransfer.items;
+        if (files) {
+            const instantiationService = accessor.get(IInstantiationService);
+            const filesData = await instantiationService.invokeFunction(accessor => extractFilesDropData(accessor, e));
+            for (const fileData of filesData) {
+                editors.push({ resource: fileData.resource, contents: fileData.contents?.toString(), isExternal: true, allowWorkspaceOpen: fileData.isDirectory });
+            }
+        }
+    }
+    return editors;
+}
+export function createDraggedEditorInputFromRawResourcesData(rawResourcesData) {
+    const editors = [];
+    if (rawResourcesData) {
+        const resourcesRaw = JSON.parse(rawResourcesData);
+        for (const resourceRaw of resourcesRaw) {
+            if (resourceRaw.indexOf(':') > 0) { // mitigate https://github.com/microsoft/vscode/issues/124946
+                const { selection, uri } = extractSelection(URI.parse(resourceRaw));
+                editors.push({ resource: uri, options: { selection } });
+            }
+        }
+    }
+    return editors;
+}
+async function extractFilesDropData(accessor, event) {
+    // Try to extract via `FileSystemHandle`
+    if (WebFileSystemAccess.supported(window)) {
+        const items = event.dataTransfer?.items;
+        if (items) {
+            return extractFileTransferData(accessor, items);
+        }
+    }
+    // Try to extract via `FileList`
+    const files = event.dataTransfer?.files;
+    if (!files) {
+        return [];
+    }
+    return extractFileListData(accessor, files);
+}
+async function extractFileTransferData(accessor, items) {
+    const fileSystemProvider = accessor.get(IFileService).getProvider(Schemas.file);
+    if (!(fileSystemProvider instanceof HTMLFileSystemProvider)) {
+        return []; // only supported when running in web
+    }
+    const results = [];
+    for (let i = 0; i < items.length; i++) {
+        const file = items[i];
+        if (file) {
+            const result = new DeferredPromise();
+            results.push(result);
+            (async () => {
+                try {
+                    const handle = await file.getAsFileSystemHandle();
+                    if (!handle) {
+                        result.complete(undefined);
+                        return;
+                    }
+                    if (WebFileSystemAccess.isFileSystemFileHandle(handle)) {
+                        result.complete({
+                            resource: await fileSystemProvider.registerFileHandle(handle),
+                            isDirectory: false
+                        });
+                    }
+                    else if (WebFileSystemAccess.isFileSystemDirectoryHandle(handle)) {
+                        result.complete({
+                            resource: await fileSystemProvider.registerDirectoryHandle(handle),
+                            isDirectory: true
+                        });
+                    }
+                    else {
+                        result.complete(undefined);
+                    }
+                }
+                catch (error) {
+                    result.complete(undefined);
+                }
+            })();
+        }
+    }
+    return coalesce(await Promise.all(results.map(result => result.p)));
+}
+export async function extractFileListData(accessor, files) {
+    const dialogService = accessor.get(IDialogService);
+    const results = [];
+    for (let i = 0; i < files.length; i++) {
+        const file = files.item(i);
+        if (file) {
+            // Skip for very large files because this operation is unbuffered
+            if (file.size > 100 * ByteSize.MB) {
+                dialogService.warn(localizeWithPath('vs/platform/dnd/browser/dnd', 'fileTooLarge', "File is too large to open as untitled editor. Please upload it first into the file explorer and then try again."));
+                continue;
+            }
+            const result = new DeferredPromise();
+            results.push(result);
+            const reader = new FileReader();
+            reader.onerror = () => result.complete(undefined);
+            reader.onabort = () => result.complete(undefined);
+            reader.onload = async (event) => {
+                const name = file.name;
+                const loadResult = event.target?.result ?? undefined;
+                if (typeof name !== 'string' || typeof loadResult === 'undefined') {
+                    result.complete(undefined);
+                    return;
+                }
+                result.complete({
+                    resource: URI.from({ scheme: Schemas.untitled, path: name }),
+                    contents: typeof loadResult === 'string' ? VSBuffer.fromString(loadResult) : VSBuffer.wrap(new Uint8Array(loadResult))
+                });
+            };
+            // Start reading
+            reader.readAsArrayBuffer(file);
+        }
+    }
+    return coalesce(await Promise.all(results.map(result => result.p)));
+}
+//#endregion
+export function containsDragType(event, ...dragTypesToFind) {
+    if (!event.dataTransfer) {
+        return false;
+    }
+    const dragTypes = event.dataTransfer.types;
+    const lowercaseDragTypes = [];
+    for (let i = 0; i < dragTypes.length; i++) {
+        lowercaseDragTypes.push(dragTypes[i].toLowerCase()); // somehow the types are lowercase
+    }
+    for (const dragType of dragTypesToFind) {
+        if (lowercaseDragTypes.indexOf(dragType.toLowerCase()) >= 0) {
+            return true;
+        }
+    }
+    return false;
+}
 class DragAndDropContributionRegistry {
+    constructor() {
+        this._contributions = new Map();
+    }
+    register(contribution) {
+        if (this._contributions.has(contribution.dataFormatKey)) {
+            throw new Error(`A drag and drop contributiont with key '${contribution.dataFormatKey}' was already registered.`);
+        }
+        this._contributions.set(contribution.dataFormatKey, contribution);
+    }
+    getAll() {
+        return this._contributions.values();
+    }
 }
 export const Extensions = {
     DragAndDropContribution: 'workbench.contributions.dragAndDrop'
@@ -25,12 +273,24 @@
     hasData(proto) {
         return proto && proto === this.proto;
     }
+    clearData(proto) {
+        if (this.hasData(proto)) {
+            this.proto = undefined;
+            this.data = undefined;
+        }
+    }
     getData(proto) {
         if (this.hasData(proto)) {
             return this.data;
         }
         return undefined;
     }
+    setData(data, proto) {
+        if (proto) {
+            this.data = data;
+            this.proto = proto;
+        }
+    }
 }
 LocalSelectionTransfer.INSTANCE = new LocalSelectionTransfer();
 //#endregion
diff -urN -x '*.map' a/vs/platform/editor/common/editor.js b/vs/platform/editor/common/editor.js
--- a/vs/platform/editor/common/editor.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/editor/common/editor.js	2023-12-06 14:23:14.387854798 +0000
@@ -1,3 +1,42 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+export var EditorActivation;
+(function (EditorActivation) {
+    /**
+     * Activate the editor after it opened. This will automatically restore
+     * the editor if it is minimized.
+     */
+    EditorActivation[EditorActivation["ACTIVATE"] = 1] = "ACTIVATE";
+    /**
+     * Only restore the editor if it is minimized but do not activate it.
+     *
+     * Note: will only work in combination with the `preserveFocus: true` option.
+     * Otherwise, if focus moves into the editor, it will activate and restore
+     * automatically.
+     */
+    EditorActivation[EditorActivation["RESTORE"] = 2] = "RESTORE";
+    /**
+     * Preserve the current active editor.
+     *
+     * Note: will only work in combination with the `preserveFocus: true` option.
+     * Otherwise, if focus moves into the editor, it will activate and restore
+     * automatically.
+     */
+    EditorActivation[EditorActivation["PRESERVE"] = 3] = "PRESERVE";
+})(EditorActivation || (EditorActivation = {}));
+export var EditorResolution;
+(function (EditorResolution) {
+    /**
+     * Displays a picker and allows the user to decide which editor to use.
+     */
+    EditorResolution[EditorResolution["PICK"] = 0] = "PICK";
+    /**
+     * Only exclusive editors are considered.
+     */
+    EditorResolution[EditorResolution["EXCLUSIVE_ONLY"] = 1] = "EXCLUSIVE_ONLY";
+})(EditorResolution || (EditorResolution = {}));
 export var EditorOpenSource;
 (function (EditorOpenSource) {
     /**
diff -urN -x '*.map' a/vs/platform/environment/common/argv.js b/vs/platform/environment/common/argv.js
--- a/vs/platform/environment/common/argv.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/environment/common/argv.js	2023-12-06 14:23:14.387854798 +0000
@@ -0,0 +1,5 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+export {};
diff -urN -x '*.map' a/vs/platform/environment/common/environment.js b/vs/platform/environment/common/environment.js
--- a/vs/platform/environment/common/environment.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/environment/common/environment.js	2023-12-06 14:23:14.387854798 +0000
@@ -1,2 +1,7 @@
-import { createDecorator } from '../../instantiation/common/instantiation.js';
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { createDecorator, refineServiceDecorator } from '../../instantiation/common/instantiation.js';
 export const IEnvironmentService = createDecorator('environmentService');
+export const INativeEnvironmentService = refineServiceDecorator(IEnvironmentService);
diff -urN -x '*.map' a/vs/platform/extensions/common/extensions.js b/vs/platform/extensions/common/extensions.js
--- a/vs/platform/extensions/common/extensions.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/extensions/common/extensions.js	2023-12-06 14:23:14.387854798 +0000
@@ -1,3 +1,42 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import * as strings from '../../../base/common/strings.js';
+import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { getRemoteName } from '../../remote/common/remoteHosts.js';
+export const USER_MANIFEST_CACHE_FILE = 'extensions.user.cache';
+export const BUILTIN_MANIFEST_CACHE_FILE = 'extensions.builtin.cache';
+export const UNDEFINED_PUBLISHER = 'undefined_publisher';
+export const ALL_EXTENSION_KINDS = ['ui', 'workspace', 'web'];
+export function getWorkspaceSupportTypeMessage(supportType) {
+    if (typeof supportType === 'object' && supportType !== null) {
+        if (supportType.supported !== true) {
+            return supportType.description;
+        }
+    }
+    return undefined;
+}
+export const EXTENSION_CATEGORIES = [
+    'Azure',
+    'Data Science',
+    'Debuggers',
+    'Extension Packs',
+    'Education',
+    'Formatters',
+    'Keymaps',
+    'Language Packs',
+    'Linters',
+    'Machine Learning',
+    'Notebooks',
+    'Programming Languages',
+    'SCM Providers',
+    'Snippets',
+    'Testing',
+    'Themes',
+    'Visualization',
+    'Other',
+];
 /**
  * **!Do not construct directly!**
  *
@@ -19,6 +58,23 @@
         this.value = value;
         this._lower = value.toLowerCase();
     }
+    static equals(a, b) {
+        if (typeof a === 'undefined' || a === null) {
+            return (typeof b === 'undefined' || b === null);
+        }
+        if (typeof b === 'undefined' || b === null) {
+            return false;
+        }
+        if (typeof a === 'string' || typeof b === 'string') {
+            // At least one of the arguments is an extension id in string form,
+            // so we have to use the string comparison which ignores case.
+            const aValue = (typeof a === 'string' ? a : a.value);
+            const bValue = (typeof b === 'string' ? b : b.value);
+            return strings.equalsIgnoreCase(aValue, bValue);
+        }
+        // Now we know both arguments are ExtensionIdentifier
+        return (a._lower === b._lower);
+    }
     /**
      * Gives the value by which to index (for equality).
      */
@@ -30,6 +86,9 @@
     }
 }
 export class ExtensionIdentifierSet {
+    get size() {
+        return this._set.size;
+    }
     constructor(iterable) {
         this._set = new Set();
         if (iterable) {
@@ -41,7 +100,56 @@
     add(id) {
         this._set.add(ExtensionIdentifier.toKey(id));
     }
+    delete(extensionId) {
+        return this._set.delete(ExtensionIdentifier.toKey(extensionId));
+    }
     has(id) {
         return this._set.has(ExtensionIdentifier.toKey(id));
     }
 }
+export class ExtensionIdentifierMap {
+    constructor() {
+        this._map = new Map();
+    }
+    clear() {
+        this._map.clear();
+    }
+    delete(id) {
+        this._map.delete(ExtensionIdentifier.toKey(id));
+    }
+    get(id) {
+        return this._map.get(ExtensionIdentifier.toKey(id));
+    }
+    has(id) {
+        return this._map.has(ExtensionIdentifier.toKey(id));
+    }
+    set(id, value) {
+        this._map.set(ExtensionIdentifier.toKey(id), value);
+    }
+    values() {
+        return this._map.values();
+    }
+    forEach(callbackfn) {
+        this._map.forEach(callbackfn);
+    }
+    [Symbol.iterator]() {
+        return this._map[Symbol.iterator]();
+    }
+}
+export function isApplicationScopedExtension(manifest) {
+    return isLanguagePackExtension(manifest);
+}
+export function isLanguagePackExtension(manifest) {
+    return manifest.contributes && manifest.contributes.localizations ? manifest.contributes.localizations.length > 0 : false;
+}
+export function isAuthenticationProviderExtension(manifest) {
+    return manifest.contributes && manifest.contributes.authentication ? manifest.contributes.authentication.length > 0 : false;
+}
+export function isResolverExtension(manifest, remoteAuthority) {
+    if (remoteAuthority) {
+        const activationEvent = `onResolveRemoteAuthority:${getRemoteName(remoteAuthority)}`;
+        return !!manifest.activationEvents?.includes(activationEvent);
+    }
+    return false;
+}
+export const IBuiltinExtensionsScannerService = createDecorator('IBuiltinExtensionsScannerService');
diff -urN -x '*.map' a/vs/platform/files/browser/htmlFileSystemProvider.js b/vs/platform/files/browser/htmlFileSystemProvider.js
--- a/vs/platform/files/browser/htmlFileSystemProvider.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/files/browser/htmlFileSystemProvider.js	2023-12-06 14:23:14.387854798 +0000
@@ -0,0 +1,378 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { localizeWithPath } from '../../../nls.js';
+import { URI } from '../../../base/common/uri.js';
+import { VSBuffer } from '../../../base/common/buffer.js';
+import { Event } from '../../../base/common/event.js';
+import { Disposable } from '../../../base/common/lifecycle.js';
+import { Schemas } from '../../../base/common/network.js';
+import { basename, extname, normalize } from '../../../base/common/path.js';
+import { isLinux } from '../../../base/common/platform.js';
+import { extUri, extUriIgnorePathCase } from '../../../base/common/resources.js';
+import { newWriteableStream } from '../../../base/common/stream.js';
+import { createFileSystemProviderError, FileSystemProviderError, FileSystemProviderErrorCode, FileType } from '../common/files.js';
+import { WebFileSystemAccess } from './webFileSystemAccess.js';
+export class HTMLFileSystemProvider {
+    get capabilities() {
+        if (!this._capabilities) {
+            this._capabilities =
+                2 /* FileSystemProviderCapabilities.FileReadWrite */ |
+                    16 /* FileSystemProviderCapabilities.FileReadStream */;
+            if (isLinux) {
+                this._capabilities |= 1024 /* FileSystemProviderCapabilities.PathCaseSensitive */;
+            }
+        }
+        return this._capabilities;
+    }
+    //#endregion
+    constructor(indexedDB, store, logService) {
+        this.indexedDB = indexedDB;
+        this.store = store;
+        this.logService = logService;
+        //#region Events (unsupported)
+        this.onDidChangeCapabilities = Event.None;
+        this.onDidChangeFile = Event.None;
+        //#endregion
+        //#region File Capabilities
+        this.extUri = isLinux ? extUri : extUriIgnorePathCase;
+        //#endregion
+        //#region File/Directoy Handle Registry
+        this._files = new Map();
+        this._directories = new Map();
+    }
+    //#region File Metadata Resolving
+    async stat(resource) {
+        try {
+            const handle = await this.getHandle(resource);
+            if (!handle) {
+                throw this.createFileSystemProviderError(resource, 'No such file or directory, stat', FileSystemProviderErrorCode.FileNotFound);
+            }
+            if (WebFileSystemAccess.isFileSystemFileHandle(handle)) {
+                const file = await handle.getFile();
+                return {
+                    type: FileType.File,
+                    mtime: file.lastModified,
+                    ctime: 0,
+                    size: file.size
+                };
+            }
+            return {
+                type: FileType.Directory,
+                mtime: 0,
+                ctime: 0,
+                size: 0
+            };
+        }
+        catch (error) {
+            throw this.toFileSystemProviderError(error);
+        }
+    }
+    async readdir(resource) {
+        try {
+            const handle = await this.getDirectoryHandle(resource);
+            if (!handle) {
+                throw this.createFileSystemProviderError(resource, 'No such file or directory, readdir', FileSystemProviderErrorCode.FileNotFound);
+            }
+            const result = [];
+            for await (const [name, child] of handle) {
+                result.push([name, WebFileSystemAccess.isFileSystemFileHandle(child) ? FileType.File : FileType.Directory]);
+            }
+            return result;
+        }
+        catch (error) {
+            throw this.toFileSystemProviderError(error);
+        }
+    }
+    //#endregion
+    //#region File Reading/Writing
+    readFileStream(resource, opts, token) {
+        const stream = newWriteableStream(data => VSBuffer.concat(data.map(data => VSBuffer.wrap(data))).buffer, {
+            // Set a highWaterMark to prevent the stream
+            // for file upload to produce large buffers
+            // in-memory
+            highWaterMark: 10
+        });
+        (async () => {
+            try {
+                const handle = await this.getFileHandle(resource);
+                if (!handle) {
+                    throw this.createFileSystemProviderError(resource, 'No such file or directory, readFile', FileSystemProviderErrorCode.FileNotFound);
+                }
+                const file = await handle.getFile();
+                // Partial file: implemented simply via `readFile`
+                if (typeof opts.length === 'number' || typeof opts.position === 'number') {
+                    let buffer = new Uint8Array(await file.arrayBuffer());
+                    if (typeof opts?.position === 'number') {
+                        buffer = buffer.slice(opts.position);
+                    }
+                    if (typeof opts?.length === 'number') {
+                        buffer = buffer.slice(0, opts.length);
+                    }
+                    stream.end(buffer);
+                }
+                // Entire file
+                else {
+                    const reader = file.stream().getReader();
+                    let res = await reader.read();
+                    while (!res.done) {
+                        if (token.isCancellationRequested) {
+                            break;
+                        }
+                        // Write buffer into stream but make sure to wait
+                        // in case the `highWaterMark` is reached
+                        await stream.write(res.value);
+                        if (token.isCancellationRequested) {
+                            break;
+                        }
+                        res = await reader.read();
+                    }
+                    stream.end(undefined);
+                }
+            }
+            catch (error) {
+                stream.error(this.toFileSystemProviderError(error));
+                stream.end();
+            }
+        })();
+        return stream;
+    }
+    async readFile(resource) {
+        try {
+            const handle = await this.getFileHandle(resource);
+            if (!handle) {
+                throw this.createFileSystemProviderError(resource, 'No such file or directory, readFile', FileSystemProviderErrorCode.FileNotFound);
+            }
+            const file = await handle.getFile();
+            return new Uint8Array(await file.arrayBuffer());
+        }
+        catch (error) {
+            throw this.toFileSystemProviderError(error);
+        }
+    }
+    async writeFile(resource, content, opts) {
+        try {
+            let handle = await this.getFileHandle(resource);
+            // Validate target unless { create: true, overwrite: true }
+            if (!opts.create || !opts.overwrite) {
+                if (handle) {
+                    if (!opts.overwrite) {
+                        throw this.createFileSystemProviderError(resource, 'File already exists, writeFile', FileSystemProviderErrorCode.FileExists);
+                    }
+                }
+                else {
+                    if (!opts.create) {
+                        throw this.createFileSystemProviderError(resource, 'No such file, writeFile', FileSystemProviderErrorCode.FileNotFound);
+                    }
+                }
+            }
+            // Create target as needed
+            if (!handle) {
+                const parent = await this.getDirectoryHandle(this.extUri.dirname(resource));
+                if (!parent) {
+                    throw this.createFileSystemProviderError(resource, 'No such parent directory, writeFile', FileSystemProviderErrorCode.FileNotFound);
+                }
+                handle = await parent.getFileHandle(this.extUri.basename(resource), { create: true });
+                if (!handle) {
+                    throw this.createFileSystemProviderError(resource, 'Unable to create file , writeFile', FileSystemProviderErrorCode.Unknown);
+                }
+            }
+            // Write to target overwriting any existing contents
+            const writable = await handle.createWritable();
+            await writable.write(content);
+            await writable.close();
+        }
+        catch (error) {
+            throw this.toFileSystemProviderError(error);
+        }
+    }
+    //#endregion
+    //#region Move/Copy/Delete/Create Folder
+    async mkdir(resource) {
+        try {
+            const parent = await this.getDirectoryHandle(this.extUri.dirname(resource));
+            if (!parent) {
+                throw this.createFileSystemProviderError(resource, 'No such parent directory, mkdir', FileSystemProviderErrorCode.FileNotFound);
+            }
+            await parent.getDirectoryHandle(this.extUri.basename(resource), { create: true });
+        }
+        catch (error) {
+            throw this.toFileSystemProviderError(error);
+        }
+    }
+    async delete(resource, opts) {
+        try {
+            const parent = await this.getDirectoryHandle(this.extUri.dirname(resource));
+            if (!parent) {
+                throw this.createFileSystemProviderError(resource, 'No such parent directory, delete', FileSystemProviderErrorCode.FileNotFound);
+            }
+            return parent.removeEntry(this.extUri.basename(resource), { recursive: opts.recursive });
+        }
+        catch (error) {
+            throw this.toFileSystemProviderError(error);
+        }
+    }
+    async rename(from, to, opts) {
+        try {
+            if (this.extUri.isEqual(from, to)) {
+                return; // no-op if the paths are the same
+            }
+            // Implement file rename by write + delete
+            const fileHandle = await this.getFileHandle(from);
+            if (fileHandle) {
+                const file = await fileHandle.getFile();
+                const contents = new Uint8Array(await file.arrayBuffer());
+                await this.writeFile(to, contents, { create: true, overwrite: opts.overwrite, unlock: false, atomic: false });
+                await this.delete(from, { recursive: false, useTrash: false, atomic: false });
+            }
+            // File API does not support any real rename otherwise
+            else {
+                throw this.createFileSystemProviderError(from, localizeWithPath('vs/platform/files/browser/htmlFileSystemProvider', 'fileSystemRenameError', "Rename is only supported for files."), FileSystemProviderErrorCode.Unavailable);
+            }
+        }
+        catch (error) {
+            throw this.toFileSystemProviderError(error);
+        }
+    }
+    //#endregion
+    //#region File Watching (unsupported)
+    watch(resource, opts) {
+        return Disposable.None;
+    }
+    registerFileHandle(handle) {
+        return this.registerHandle(handle, this._files);
+    }
+    registerDirectoryHandle(handle) {
+        return this.registerHandle(handle, this._directories);
+    }
+    get directories() {
+        return this._directories.values();
+    }
+    async registerHandle(handle, map) {
+        let handleId = `/${handle.name}`;
+        // Compute a valid handle ID in case this exists already
+        if (map.has(handleId) && !await map.get(handleId)?.isSameEntry(handle)) {
+            const fileExt = extname(handle.name);
+            const fileName = basename(handle.name, fileExt);
+            let handleIdCounter = 1;
+            do {
+                handleId = `/${fileName}-${handleIdCounter++}${fileExt}`;
+            } while (map.has(handleId) && !await map.get(handleId)?.isSameEntry(handle));
+        }
+        map.set(handleId, handle);
+        // Remember in IndexDB for future lookup
+        try {
+            await this.indexedDB?.runInTransaction(this.store, 'readwrite', objectStore => objectStore.put(handle, handleId));
+        }
+        catch (error) {
+            this.logService.error(error);
+        }
+        return URI.from({ scheme: Schemas.file, path: handleId });
+    }
+    async getHandle(resource) {
+        // First: try to find a well known handle first
+        let handle = await this.doGetHandle(resource);
+        // Second: walk up parent directories and resolve handle if possible
+        if (!handle) {
+            const parent = await this.getDirectoryHandle(this.extUri.dirname(resource));
+            if (parent) {
+                const name = extUri.basename(resource);
+                try {
+                    handle = await parent.getFileHandle(name);
+                }
+                catch (error) {
+                    try {
+                        handle = await parent.getDirectoryHandle(name);
+                    }
+                    catch (error) {
+                        // Ignore
+                    }
+                }
+            }
+        }
+        return handle;
+    }
+    async getFileHandle(resource) {
+        const handle = await this.doGetHandle(resource);
+        if (handle instanceof FileSystemFileHandle) {
+            return handle;
+        }
+        const parent = await this.getDirectoryHandle(this.extUri.dirname(resource));
+        try {
+            return await parent?.getFileHandle(extUri.basename(resource));
+        }
+        catch (error) {
+            return undefined; // guard against possible DOMException
+        }
+    }
+    async getDirectoryHandle(resource) {
+        const handle = await this.doGetHandle(resource);
+        if (handle instanceof FileSystemDirectoryHandle) {
+            return handle;
+        }
+        const parentUri = this.extUri.dirname(resource);
+        if (this.extUri.isEqual(parentUri, resource)) {
+            return undefined; // return when root is reached to prevent infinite recursion
+        }
+        const parent = await this.getDirectoryHandle(parentUri);
+        try {
+            return await parent?.getDirectoryHandle(extUri.basename(resource));
+        }
+        catch (error) {
+            return undefined; // guard against possible DOMException
+        }
+    }
+    async doGetHandle(resource) {
+        // We store file system handles with the `handle.name`
+        // and as such require the resource to be on the root
+        if (this.extUri.dirname(resource).path !== '/') {
+            return undefined;
+        }
+        const handleId = resource.path.replace(/\/$/, ''); // remove potential slash from the end of the path
+        // First: check if we have a known handle stored in memory
+        const inMemoryHandle = this._files.get(handleId) ?? this._directories.get(handleId);
+        if (inMemoryHandle) {
+            return inMemoryHandle;
+        }
+        // Second: check if we have a persisted handle in IndexedDB
+        const persistedHandle = await this.indexedDB?.runInTransaction(this.store, 'readonly', store => store.get(handleId));
+        if (WebFileSystemAccess.isFileSystemHandle(persistedHandle)) {
+            let hasPermissions = await persistedHandle.queryPermission() === 'granted';
+            try {
+                if (!hasPermissions) {
+                    hasPermissions = await persistedHandle.requestPermission() === 'granted';
+                }
+            }
+            catch (error) {
+                this.logService.error(error); // this can fail with a DOMException
+            }
+            if (hasPermissions) {
+                if (WebFileSystemAccess.isFileSystemFileHandle(persistedHandle)) {
+                    this._files.set(handleId, persistedHandle);
+                }
+                else if (WebFileSystemAccess.isFileSystemDirectoryHandle(persistedHandle)) {
+                    this._directories.set(handleId, persistedHandle);
+                }
+                return persistedHandle;
+            }
+        }
+        // Third: fail with an error
+        throw this.createFileSystemProviderError(resource, 'No file system handle registered', FileSystemProviderErrorCode.Unavailable);
+    }
+    //#endregion
+    toFileSystemProviderError(error) {
+        if (error instanceof FileSystemProviderError) {
+            return error; // avoid double conversion
+        }
+        let code = FileSystemProviderErrorCode.Unknown;
+        if (error.name === 'NotAllowedError') {
+            error = new Error(localizeWithPath('vs/platform/files/browser/htmlFileSystemProvider', 'fileSystemNotAllowedError', "Insufficient permissions. Please retry and allow the operation."));
+            code = FileSystemProviderErrorCode.Unavailable;
+        }
+        return createFileSystemProviderError(error, code);
+    }
+    createFileSystemProviderError(resource, msg, code) {
+        return createFileSystemProviderError(new Error(`${msg} (${normalize(resource.path)})`), code);
+    }
+}
diff -urN -x '*.map' a/vs/platform/files/browser/webFileSystemAccess.js b/vs/platform/files/browser/webFileSystemAccess.js
--- a/vs/platform/files/browser/webFileSystemAccess.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/files/browser/webFileSystemAccess.js	2023-12-06 14:23:14.387854798 +0000
@@ -0,0 +1,35 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+/**
+ * Typings for the https://wicg.github.io/file-system-access
+ *
+ * Use `supported(window)` to find out if the browser supports this kind of API.
+ */
+export var WebFileSystemAccess;
+(function (WebFileSystemAccess) {
+    function supported(obj) {
+        if (typeof obj?.showDirectoryPicker === 'function') {
+            return true;
+        }
+        return false;
+    }
+    WebFileSystemAccess.supported = supported;
+    function isFileSystemHandle(handle) {
+        const candidate = handle;
+        if (!candidate) {
+            return false;
+        }
+        return typeof candidate.kind === 'string' && typeof candidate.queryPermission === 'function' && typeof candidate.requestPermission === 'function';
+    }
+    WebFileSystemAccess.isFileSystemHandle = isFileSystemHandle;
+    function isFileSystemFileHandle(handle) {
+        return handle.kind === 'file';
+    }
+    WebFileSystemAccess.isFileSystemFileHandle = isFileSystemFileHandle;
+    function isFileSystemDirectoryHandle(handle) {
+        return handle.kind === 'directory';
+    }
+    WebFileSystemAccess.isFileSystemDirectoryHandle = isFileSystemDirectoryHandle;
+})(WebFileSystemAccess || (WebFileSystemAccess = {}));
diff -urN -x '*.map' a/vs/platform/files/common/files.js b/vs/platform/files/common/files.js
--- a/vs/platform/files/common/files.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/files/common/files.js	2023-12-06 14:23:14.391854805 +0000
@@ -1,3 +1,376 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { TernarySearchTree } from '../../../base/common/ternarySearchTree.js';
+import { sep } from '../../../base/common/path.js';
+import { startsWithIgnoreCase } from '../../../base/common/strings.js';
+import { isNumber } from '../../../base/common/types.js';
+import { URI } from '../../../base/common/uri.js';
+import { localizeWithPath } from '../../../nls.js';
+import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { isWeb } from '../../../base/common/platform.js';
+import { Schemas } from '../../../base/common/network.js';
+//#region file service & providers
+export const IFileService = createDecorator('fileService');
+export function isFileOpenForWriteOptions(options) {
+    return options.create === true;
+}
+export var FileType;
+(function (FileType) {
+    /**
+     * File is unknown (neither file, directory nor symbolic link).
+     */
+    FileType[FileType["Unknown"] = 0] = "Unknown";
+    /**
+     * File is a normal file.
+     */
+    FileType[FileType["File"] = 1] = "File";
+    /**
+     * File is a directory.
+     */
+    FileType[FileType["Directory"] = 2] = "Directory";
+    /**
+     * File is a symbolic link.
+     *
+     * Note: even when the file is a symbolic link, you can test for
+     * `FileType.File` and `FileType.Directory` to know the type of
+     * the target the link points to.
+     */
+    FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
+})(FileType || (FileType = {}));
+export var FilePermission;
+(function (FilePermission) {
+    /**
+     * File is readonly. Components like editors should not
+     * offer to edit the contents.
+     */
+    FilePermission[FilePermission["Readonly"] = 1] = "Readonly";
+    /**
+     * File is locked. Components like editors should offer
+     * to edit the contents and ask the user upon saving to
+     * remove the lock.
+     */
+    FilePermission[FilePermission["Locked"] = 2] = "Locked";
+})(FilePermission || (FilePermission = {}));
+export function hasReadWriteCapability(provider) {
+    return !!(provider.capabilities & 2 /* FileSystemProviderCapabilities.FileReadWrite */);
+}
+export function hasFileFolderCopyCapability(provider) {
+    return !!(provider.capabilities & 8 /* FileSystemProviderCapabilities.FileFolderCopy */);
+}
+export function hasFileCloneCapability(provider) {
+    return !!(provider.capabilities & 131072 /* FileSystemProviderCapabilities.FileClone */);
+}
+export function hasOpenReadWriteCloseCapability(provider) {
+    return !!(provider.capabilities & 4 /* FileSystemProviderCapabilities.FileOpenReadWriteClose */);
+}
+export function hasFileReadStreamCapability(provider) {
+    return !!(provider.capabilities & 16 /* FileSystemProviderCapabilities.FileReadStream */);
+}
+export function hasFileAtomicReadCapability(provider) {
+    if (!hasReadWriteCapability(provider)) {
+        return false; // we require the `FileReadWrite` capability too
+    }
+    return !!(provider.capabilities & 16384 /* FileSystemProviderCapabilities.FileAtomicRead */);
+}
+export function hasFileAtomicWriteCapability(provider) {
+    if (!hasReadWriteCapability(provider)) {
+        return false; // we require the `FileReadWrite` capability too
+    }
+    return !!(provider.capabilities & 32768 /* FileSystemProviderCapabilities.FileAtomicWrite */);
+}
+export function hasFileAtomicDeleteCapability(provider) {
+    return !!(provider.capabilities & 65536 /* FileSystemProviderCapabilities.FileAtomicDelete */);
+}
+export function hasReadonlyCapability(provider) {
+    return !!(provider.capabilities & 2048 /* FileSystemProviderCapabilities.Readonly */);
+}
+export var FileSystemProviderErrorCode;
+(function (FileSystemProviderErrorCode) {
+    FileSystemProviderErrorCode["FileExists"] = "EntryExists";
+    FileSystemProviderErrorCode["FileNotFound"] = "EntryNotFound";
+    FileSystemProviderErrorCode["FileNotADirectory"] = "EntryNotADirectory";
+    FileSystemProviderErrorCode["FileIsADirectory"] = "EntryIsADirectory";
+    FileSystemProviderErrorCode["FileExceedsStorageQuota"] = "EntryExceedsStorageQuota";
+    FileSystemProviderErrorCode["FileTooLarge"] = "EntryTooLarge";
+    FileSystemProviderErrorCode["FileWriteLocked"] = "EntryWriteLocked";
+    FileSystemProviderErrorCode["NoPermissions"] = "NoPermissions";
+    FileSystemProviderErrorCode["Unavailable"] = "Unavailable";
+    FileSystemProviderErrorCode["Unknown"] = "Unknown";
+})(FileSystemProviderErrorCode || (FileSystemProviderErrorCode = {}));
+export class FileSystemProviderError extends Error {
+    static create(error, code) {
+        const providerError = new FileSystemProviderError(error.toString(), code);
+        markAsFileSystemProviderError(providerError, code);
+        return providerError;
+    }
+    constructor(message, code) {
+        super(message);
+        this.code = code;
+    }
+}
+export function createFileSystemProviderError(error, code) {
+    return FileSystemProviderError.create(error, code);
+}
+export function ensureFileSystemProviderError(error) {
+    if (!error) {
+        return createFileSystemProviderError(localizeWithPath('vs/platform/files/common/files', 'unknownError', "Unknown Error"), FileSystemProviderErrorCode.Unknown); // https://github.com/microsoft/vscode/issues/72798
+    }
+    return error;
+}
+export function markAsFileSystemProviderError(error, code) {
+    error.name = code ? `${code} (FileSystemError)` : `FileSystemError`;
+    return error;
+}
+export function toFileSystemProviderErrorCode(error) {
+    // Guard against abuse
+    if (!error) {
+        return FileSystemProviderErrorCode.Unknown;
+    }
+    // FileSystemProviderError comes with the code
+    if (error instanceof FileSystemProviderError) {
+        return error.code;
+    }
+    // Any other error, check for name match by assuming that the error
+    // went through the markAsFileSystemProviderError() method
+    const match = /^(.+) \(FileSystemError\)$/.exec(error.name);
+    if (!match) {
+        return FileSystemProviderErrorCode.Unknown;
+    }
+    switch (match[1]) {
+        case FileSystemProviderErrorCode.FileExists: return FileSystemProviderErrorCode.FileExists;
+        case FileSystemProviderErrorCode.FileIsADirectory: return FileSystemProviderErrorCode.FileIsADirectory;
+        case FileSystemProviderErrorCode.FileNotADirectory: return FileSystemProviderErrorCode.FileNotADirectory;
+        case FileSystemProviderErrorCode.FileNotFound: return FileSystemProviderErrorCode.FileNotFound;
+        case FileSystemProviderErrorCode.FileTooLarge: return FileSystemProviderErrorCode.FileTooLarge;
+        case FileSystemProviderErrorCode.FileWriteLocked: return FileSystemProviderErrorCode.FileWriteLocked;
+        case FileSystemProviderErrorCode.NoPermissions: return FileSystemProviderErrorCode.NoPermissions;
+        case FileSystemProviderErrorCode.Unavailable: return FileSystemProviderErrorCode.Unavailable;
+    }
+    return FileSystemProviderErrorCode.Unknown;
+}
+export function toFileOperationResult(error) {
+    // FileSystemProviderError comes with the result already
+    if (error instanceof FileOperationError) {
+        return error.fileOperationResult;
+    }
+    // Otherwise try to find from code
+    switch (toFileSystemProviderErrorCode(error)) {
+        case FileSystemProviderErrorCode.FileNotFound:
+            return 1 /* FileOperationResult.FILE_NOT_FOUND */;
+        case FileSystemProviderErrorCode.FileIsADirectory:
+            return 0 /* FileOperationResult.FILE_IS_DIRECTORY */;
+        case FileSystemProviderErrorCode.FileNotADirectory:
+            return 9 /* FileOperationResult.FILE_NOT_DIRECTORY */;
+        case FileSystemProviderErrorCode.FileWriteLocked:
+            return 5 /* FileOperationResult.FILE_WRITE_LOCKED */;
+        case FileSystemProviderErrorCode.NoPermissions:
+            return 6 /* FileOperationResult.FILE_PERMISSION_DENIED */;
+        case FileSystemProviderErrorCode.FileExists:
+            return 4 /* FileOperationResult.FILE_MOVE_CONFLICT */;
+        case FileSystemProviderErrorCode.FileTooLarge:
+            return 7 /* FileOperationResult.FILE_TOO_LARGE */;
+        default:
+            return 10 /* FileOperationResult.FILE_OTHER_ERROR */;
+    }
+}
+export class FileOperationEvent {
+    constructor(resource, operation, target) {
+        this.resource = resource;
+        this.operation = operation;
+        this.target = target;
+    }
+    isOperation(operation) {
+        return this.operation === operation;
+    }
+}
+export class FileChangesEvent {
+    constructor(changes, ignorePathCasing) {
+        this.added = undefined;
+        this.updated = undefined;
+        this.deleted = undefined;
+        /**
+         * @deprecated use the `contains` or `affects` method to efficiently find
+         * out if the event relates to a given resource. these methods ensure:
+         * - that there is no expensive lookup needed (by using a `TernarySearchTree`)
+         * - correctly handles `FileChangeType.DELETED` events
+         */
+        this.rawAdded = [];
+        /**
+        * @deprecated use the `contains` or `affects` method to efficiently find
+        * out if the event relates to a given resource. these methods ensure:
+        * - that there is no expensive lookup needed (by using a `TernarySearchTree`)
+        * - correctly handles `FileChangeType.DELETED` events
+        */
+        this.rawUpdated = [];
+        /**
+        * @deprecated use the `contains` or `affects` method to efficiently find
+        * out if the event relates to a given resource. these methods ensure:
+        * - that there is no expensive lookup needed (by using a `TernarySearchTree`)
+        * - correctly handles `FileChangeType.DELETED` events
+        */
+        this.rawDeleted = [];
+        const entriesByType = new Map();
+        for (const change of changes) {
+            const array = entriesByType.get(change.type);
+            if (array) {
+                array.push([change.resource, change]);
+            }
+            else {
+                entriesByType.set(change.type, [[change.resource, change]]);
+            }
+            switch (change.type) {
+                case 1 /* FileChangeType.ADDED */:
+                    this.rawAdded.push(change.resource);
+                    break;
+                case 0 /* FileChangeType.UPDATED */:
+                    this.rawUpdated.push(change.resource);
+                    break;
+                case 2 /* FileChangeType.DELETED */:
+                    this.rawDeleted.push(change.resource);
+                    break;
+            }
+        }
+        for (const [key, value] of entriesByType) {
+            switch (key) {
+                case 1 /* FileChangeType.ADDED */:
+                    this.added = TernarySearchTree.forUris(() => ignorePathCasing);
+                    this.added.fill(value);
+                    break;
+                case 0 /* FileChangeType.UPDATED */:
+                    this.updated = TernarySearchTree.forUris(() => ignorePathCasing);
+                    this.updated.fill(value);
+                    break;
+                case 2 /* FileChangeType.DELETED */:
+                    this.deleted = TernarySearchTree.forUris(() => ignorePathCasing);
+                    this.deleted.fill(value);
+                    break;
+            }
+        }
+    }
+    /**
+     * Find out if the file change events match the provided resource.
+     *
+     * Note: when passing `FileChangeType.DELETED`, we consider a match
+     * also when the parent of the resource got deleted.
+     */
+    contains(resource, ...types) {
+        return this.doContains(resource, { includeChildren: false }, ...types);
+    }
+    /**
+     * Find out if the file change events either match the provided
+     * resource, or contain a child of this resource.
+     */
+    affects(resource, ...types) {
+        return this.doContains(resource, { includeChildren: true }, ...types);
+    }
+    doContains(resource, options, ...types) {
+        if (!resource) {
+            return false;
+        }
+        const hasTypesFilter = types.length > 0;
+        // Added
+        if (!hasTypesFilter || types.includes(1 /* FileChangeType.ADDED */)) {
+            if (this.added?.get(resource)) {
+                return true;
+            }
+            if (options.includeChildren && this.added?.findSuperstr(resource)) {
+                return true;
+            }
+        }
+        // Updated
+        if (!hasTypesFilter || types.includes(0 /* FileChangeType.UPDATED */)) {
+            if (this.updated?.get(resource)) {
+                return true;
+            }
+            if (options.includeChildren && this.updated?.findSuperstr(resource)) {
+                return true;
+            }
+        }
+        // Deleted
+        if (!hasTypesFilter || types.includes(2 /* FileChangeType.DELETED */)) {
+            if (this.deleted?.findSubstr(resource) /* deleted also considers parent folders */) {
+                return true;
+            }
+            if (options.includeChildren && this.deleted?.findSuperstr(resource)) {
+                return true;
+            }
+        }
+        return false;
+    }
+    /**
+     * Returns if this event contains added files.
+     */
+    gotAdded() {
+        return !!this.added;
+    }
+    /**
+     * Returns if this event contains deleted files.
+     */
+    gotDeleted() {
+        return !!this.deleted;
+    }
+    /**
+     * Returns if this event contains updated files.
+     */
+    gotUpdated() {
+        return !!this.updated;
+    }
+}
+export function isParent(path, candidate, ignoreCase) {
+    if (!path || !candidate || path === candidate) {
+        return false;
+    }
+    if (candidate.length > path.length) {
+        return false;
+    }
+    if (candidate.charAt(candidate.length - 1) !== sep) {
+        candidate += sep;
+    }
+    if (ignoreCase) {
+        return startsWithIgnoreCase(path, candidate);
+    }
+    return path.indexOf(candidate) === 0;
+}
+export class FileOperationError extends Error {
+    constructor(message, fileOperationResult, options) {
+        super(message);
+        this.fileOperationResult = fileOperationResult;
+        this.options = options;
+    }
+}
+export class TooLargeFileOperationError extends FileOperationError {
+    constructor(message, fileOperationResult, size, options) {
+        super(message, fileOperationResult, options);
+        this.fileOperationResult = fileOperationResult;
+        this.size = size;
+    }
+}
+export class NotModifiedSinceFileOperationError extends FileOperationError {
+    constructor(message, stat, options) {
+        super(message, 2 /* FileOperationResult.FILE_NOT_MODIFIED_SINCE */, options);
+        this.stat = stat;
+    }
+}
+//#endregion
+//#region Settings
+export const AutoSaveConfiguration = {
+    OFF: 'off',
+    AFTER_DELAY: 'afterDelay',
+    ON_FOCUS_CHANGE: 'onFocusChange',
+    ON_WINDOW_CHANGE: 'onWindowChange'
+};
+export const HotExitConfiguration = {
+    OFF: 'off',
+    ON_EXIT: 'onExit',
+    ON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'
+};
+export const FILES_ASSOCIATIONS_CONFIG = 'files.associations';
+export const FILES_EXCLUDE_CONFIG = 'files.exclude';
+export const FILES_READONLY_INCLUDE_CONFIG = 'files.readonlyInclude';
+export const FILES_READONLY_EXCLUDE_CONFIG = 'files.readonlyExclude';
+export const FILES_READONLY_FROM_PERMISSIONS_CONFIG = 'files.readonlyFromPermissions';
 //#endregion
 //#region Utilities
 export var FileKind;
@@ -6,4 +379,75 @@
     FileKind[FileKind["FOLDER"] = 1] = "FOLDER";
     FileKind[FileKind["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
 })(FileKind || (FileKind = {}));
+/**
+ * A hint to disable etag checking for reading/writing.
+ */
+export const ETAG_DISABLED = '';
+export function etag(stat) {
+    if (typeof stat.size !== 'number' || typeof stat.mtime !== 'number') {
+        return undefined;
+    }
+    return stat.mtime.toString(29) + stat.size.toString(31);
+}
+export async function whenProviderRegistered(file, fileService) {
+    if (fileService.hasProvider(URI.from({ scheme: file.scheme }))) {
+        return;
+    }
+    return new Promise(resolve => {
+        const disposable = fileService.onDidChangeFileSystemProviderRegistrations(e => {
+            if (e.scheme === file.scheme && e.added) {
+                disposable.dispose();
+                resolve();
+            }
+        });
+    });
+}
+/**
+ * Helper to format a raw byte size into a human readable label.
+ */
+export class ByteSize {
+    static formatSize(size) {
+        if (!isNumber(size)) {
+            size = 0;
+        }
+        if (size < ByteSize.KB) {
+            return localizeWithPath('vs/platform/files/common/files', 'sizeB', "{0}B", size.toFixed(0));
+        }
+        if (size < ByteSize.MB) {
+            return localizeWithPath('vs/platform/files/common/files', 'sizeKB', "{0}KB", (size / ByteSize.KB).toFixed(2));
+        }
+        if (size < ByteSize.GB) {
+            return localizeWithPath('vs/platform/files/common/files', 'sizeMB', "{0}MB", (size / ByteSize.MB).toFixed(2));
+        }
+        if (size < ByteSize.TB) {
+            return localizeWithPath('vs/platform/files/common/files', 'sizeGB', "{0}GB", (size / ByteSize.GB).toFixed(2));
+        }
+        return localizeWithPath('vs/platform/files/common/files', 'sizeTB', "{0}TB", (size / ByteSize.TB).toFixed(2));
+    }
+}
+ByteSize.KB = 1024;
+ByteSize.MB = ByteSize.KB * ByteSize.KB;
+ByteSize.GB = ByteSize.MB * ByteSize.KB;
+ByteSize.TB = ByteSize.GB * ByteSize.KB;
+export function getLargeFileConfirmationLimit(arg) {
+    const isRemote = typeof arg === 'string' || arg?.scheme === Schemas.vscodeRemote;
+    const isLocal = typeof arg !== 'string' && arg?.scheme === Schemas.file;
+    if (isLocal) {
+        // Local almost has no limit in file size
+        return 1024 * ByteSize.MB;
+    }
+    if (isRemote) {
+        // With a remote, pick a low limit to avoid
+        // potentially costly file transfers
+        return 10 * ByteSize.MB;
+    }
+    if (isWeb) {
+        // Web: we cannot know for sure if a cost
+        // is associated with the file transfer
+        // so we pick a reasonably small limit
+        return 50 * ByteSize.MB;
+    }
+    // Local desktop: almost no limit in file size
+    return 1024 * ByteSize.MB;
+}
 //#endregion
diff -urN -x '*.map' a/vs/platform/history/browser/contextScopedHistoryWidget.js b/vs/platform/history/browser/contextScopedHistoryWidget.js
--- a/vs/platform/history/browser/contextScopedHistoryWidget.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/history/browser/contextScopedHistoryWidget.js	2023-12-06 14:23:14.391854805 +0000
@@ -13,11 +13,12 @@
 };
 import { FindInput } from '../../../base/browser/ui/findinput/findInput.js';
 import { ReplaceInput } from '../../../base/browser/ui/findinput/replaceInput.js';
+import { HistoryInputBox } from '../../../base/browser/ui/inputbox/inputBox.js';
 import { ContextKeyExpr, IContextKeyService, RawContextKey } from '../../contextkey/common/contextkey.js';
 import { KeybindingsRegistry } from '../../keybinding/common/keybindingsRegistry.js';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 import { DisposableStore, toDisposable } from '../../../base/common/lifecycle.js';
-export const historyNavigationVisible = new RawContextKey('suggestWidgetVisible', false, localize('suggestWidgetVisible', "Whether suggestion are visible"));
+export const historyNavigationVisible = new RawContextKey('suggestWidgetVisible', false, localizeWithPath('vs/platform/history/browser/contextScopedHistoryWidget', 'suggestWidgetVisible', "Whether suggestion are visible"));
 const HistoryNavigationWidgetFocusContext = 'historyNavigationWidgetFocus';
 const HistoryNavigationForwardsEnablementContext = 'historyNavigationForwardsEnabled';
 const HistoryNavigationBackwardsEnablementContext = 'historyNavigationBackwardsEnabled';
@@ -60,6 +61,17 @@
         }
     };
 }
+let ContextScopedHistoryInputBox = class ContextScopedHistoryInputBox extends HistoryInputBox {
+    constructor(container, contextViewProvider, options, contextKeyService) {
+        super(container, contextViewProvider, options);
+        const scopedContextKeyService = this._register(contextKeyService.createScoped(this.element));
+        this._register(registerAndCreateHistoryNavigationContext(scopedContextKeyService, this));
+    }
+};
+ContextScopedHistoryInputBox = __decorate([
+    __param(3, IContextKeyService)
+], ContextScopedHistoryInputBox);
+export { ContextScopedHistoryInputBox };
 let ContextScopedFindInput = class ContextScopedFindInput extends FindInput {
     constructor(container, contextViewProvider, options, contextKeyService) {
         super(container, contextViewProvider, options);
@@ -89,7 +101,7 @@
     primary: 16 /* KeyCode.UpArrow */,
     secondary: [512 /* KeyMod.Alt */ | 16 /* KeyCode.UpArrow */],
     handler: (accessor) => {
-        lastFocusedWidget === null || lastFocusedWidget === void 0 ? void 0 : lastFocusedWidget.showPreviousValue();
+        lastFocusedWidget?.showPreviousValue();
     }
 });
 KeybindingsRegistry.registerCommandAndKeybindingRule({
@@ -99,6 +111,6 @@
     primary: 18 /* KeyCode.DownArrow */,
     secondary: [512 /* KeyMod.Alt */ | 18 /* KeyCode.DownArrow */],
     handler: (accessor) => {
-        lastFocusedWidget === null || lastFocusedWidget === void 0 ? void 0 : lastFocusedWidget.showNextValue();
+        lastFocusedWidget?.showNextValue();
     }
 });
diff -urN -x '*.map' a/vs/platform/history/browser/historyWidgetKeybindingHint.js b/vs/platform/history/browser/historyWidgetKeybindingHint.js
--- a/vs/platform/history/browser/historyWidgetKeybindingHint.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/history/browser/historyWidgetKeybindingHint.js	2023-12-06 14:23:14.391854805 +0000
@@ -3,6 +3,5 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 export function showHistoryKeybindingHint(keybindingService) {
-    var _a, _b;
-    return ((_a = keybindingService.lookupKeybinding('history.showPrevious')) === null || _a === void 0 ? void 0 : _a.getElectronAccelerator()) === 'Up' && ((_b = keybindingService.lookupKeybinding('history.showNext')) === null || _b === void 0 ? void 0 : _b.getElectronAccelerator()) === 'Down';
+    return keybindingService.lookupKeybinding('history.showPrevious')?.getElectronAccelerator() === 'Up' && keybindingService.lookupKeybinding('history.showNext')?.getElectronAccelerator() === 'Down';
 }
diff -urN -x '*.map' a/vs/platform/instantiation/common/graph.js b/vs/platform/instantiation/common/graph.js
--- a/vs/platform/instantiation/common/graph.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/instantiation/common/graph.js	2023-12-06 14:23:14.391854805 +0000
@@ -48,6 +48,9 @@
         }
         return node;
     }
+    lookup(data) {
+        return this._nodes.get(this._hashFn(data));
+    }
     isEmpty() {
         return this._nodes.size === 0;
     }
diff -urN -x '*.map' a/vs/platform/instantiation/common/instantiation.js b/vs/platform/instantiation/common/instantiation.js
--- a/vs/platform/instantiation/common/instantiation.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/instantiation/common/instantiation.js	2023-12-06 14:23:14.391854805 +0000
@@ -40,3 +40,6 @@
     _util.serviceIds.set(serviceId, id);
     return id;
 }
+export function refineServiceDecorator(serviceIdentifier) {
+    return serviceIdentifier;
+}
diff -urN -x '*.map' a/vs/platform/instantiation/common/instantiationService.js b/vs/platform/instantiation/common/instantiationService.js
--- a/vs/platform/instantiation/common/instantiationService.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/instantiation/common/instantiationService.js	2023-12-06 14:23:14.391854805 +0000
@@ -14,21 +14,19 @@
 const _enableAllTracing = false;
 class CyclicDependencyError extends Error {
     constructor(graph) {
-        var _a;
         super('cyclic dependency between services');
-        this.message = (_a = graph.findCycleSlow()) !== null && _a !== void 0 ? _a : `UNABLE to detect cycle, dumping graph: \n${graph.toString()}`;
+        this.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: \n${graph.toString()}`;
     }
 }
 export class InstantiationService {
     constructor(_services = new ServiceCollection(), _strict = false, _parent, _enableTracing = _enableAllTracing) {
-        var _a;
         this._services = _services;
         this._strict = _strict;
         this._parent = _parent;
         this._enableTracing = _enableTracing;
         this._activeInstantiations = new Set();
         this._services.set(IInstantiationService, this);
-        this._globalGraph = _enableTracing ? (_a = _parent === null || _parent === void 0 ? void 0 : _parent._globalGraph) !== null && _a !== void 0 ? _a : new Graph(e => e) : undefined;
+        this._globalGraph = _enableTracing ? _parent?._globalGraph ?? new Graph(e => e) : undefined;
     }
     createChild(services) {
         return new InstantiationService(services, this._strict, this, this._enableTracing);
@@ -142,7 +140,6 @@
         }
     }
     _createAndCacheServiceInstance(id, desc, _trace) {
-        var _a;
         const graph = new Graph(data => data.id.toString());
         let cycleCount = 0;
         const stack = [{ id, desc, _trace }];
@@ -160,11 +157,13 @@
                     this._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);
                 }
                 // take note of all service dependencies
-                (_a = this._globalGraph) === null || _a === void 0 ? void 0 : _a.insertEdge(String(item.id), String(dependency.id));
+                this._globalGraph?.insertEdge(String(item.id), String(dependency.id));
                 if (instanceOrDesc instanceof SyncDescriptor) {
                     const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };
+                    if (!graph.lookup(d)) {
+                        stack.push(d);
+                    }
                     graph.insertEdge(item, d);
-                    stack.push(d);
                 }
             }
         }
diff -urN -x '*.map' a/vs/platform/instantiation/common/serviceCollection.js b/vs/platform/instantiation/common/serviceCollection.js
--- a/vs/platform/instantiation/common/serviceCollection.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/instantiation/common/serviceCollection.js	2023-12-06 14:23:14.391854805 +0000
@@ -14,6 +14,9 @@
         this._entries.set(id, instanceOrDescriptor);
         return result;
     }
+    has(id) {
+        return this._entries.has(id);
+    }
     get(id) {
         return this._entries.get(id);
     }
diff -urN -x '*.map' a/vs/platform/jsonschemas/common/jsonContributionRegistry.js b/vs/platform/jsonschemas/common/jsonContributionRegistry.js
--- a/vs/platform/jsonschemas/common/jsonContributionRegistry.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/jsonschemas/common/jsonContributionRegistry.js	2023-12-06 14:23:14.391854805 +0000
@@ -16,6 +16,7 @@
 class JSONContributionRegistry {
     constructor() {
         this._onDidChangeSchema = new Emitter();
+        this.onDidChangeSchema = this._onDidChangeSchema.event;
         this.schemasById = {};
     }
     registerSchema(uri, unresolvedSchemaContent) {
@@ -25,6 +26,11 @@
     notifySchemaChanged(uri) {
         this._onDidChangeSchema.fire(uri);
     }
+    getSchemaContributions() {
+        return {
+            schemas: this.schemasById,
+        };
+    }
 }
 const jsonContributionRegistry = new JSONContributionRegistry();
 platform.Registry.add(Extensions.JSONContribution, jsonContributionRegistry);
diff -urN -x '*.map' a/vs/platform/keybinding/common/abstractKeybindingService.js b/vs/platform/keybinding/common/abstractKeybindingService.js
--- a/vs/platform/keybinding/common/abstractKeybindingService.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/keybinding/common/abstractKeybindingService.js	2023-12-06 14:23:14.391854805 +0000
@@ -2,6 +2,7 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+import * as arrays from '../../../base/common/arrays.js';
 import { IntervalTimer, TimeoutTimer } from '../../../base/common/async.js';
 import { illegalState } from '../../../base/common/errors.js';
 import { Emitter, Event } from '../../../base/common/event.js';
@@ -36,14 +37,30 @@
     dispose() {
         super.dispose();
     }
+    getDefaultKeybindingsContent() {
+        return '';
+    }
+    toggleLogging() {
+        this._logging = !this._logging;
+        return this._logging;
+    }
     _log(str) {
         if (this._logging) {
             this._logService.info(`[KeybindingService]: ${str}`);
         }
     }
+    getDefaultKeybindings() {
+        return this._getResolver().getDefaultKeybindings();
+    }
     getKeybindings() {
         return this._getResolver().getKeybindings();
     }
+    customKeybindingsCount() {
+        return 0;
+    }
+    lookupKeybindings(commandId) {
+        return arrays.coalesce(this._getResolver().lookupKeybindings(commandId).map(item => item.resolvedKeybinding));
+    }
     lookupKeybinding(commandId, context) {
         const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);
         if (!result) {
@@ -94,11 +111,11 @@
                 throw illegalState('impossible');
             case 1:
                 // TODO@ulugbekna: revise this message and the one below (at least, fix terminology)
-                this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', "({0}) was pressed. Waiting for second key of chord...", keypressLabel));
+                this._currentChordStatusMessage = this._notificationService.status(nls.localizeWithPath('vs/platform/keybinding/common/abstractKeybindingService', 'first.chord', "({0}) was pressed. Waiting for second key of chord...", keypressLabel));
                 break;
             default: {
                 const fullKeypressLabel = this._currentChords.map(({ label }) => label).join(', ');
-                this._currentChordStatusMessage = this._notificationService.status(nls.localize('next.chord', "({0}) was pressed. Waiting for next key of chord...", fullKeypressLabel));
+                this._currentChordStatusMessage = this._notificationService.status(nls.localizeWithPath('vs/platform/keybinding/common/abstractKeybindingService', 'next.chord', "({0}) was pressed. Waiting for next key of chord...", fullKeypressLabel));
             }
         }
         this._scheduleLeaveChordMode();
@@ -115,6 +132,16 @@
         this._currentChords = [];
         IME.enable();
     }
+    dispatchByUserSettingsLabel(userSettingsLabel, target) {
+        this._log(`/ Dispatching keybinding triggered via menu entry accelerator - ${userSettingsLabel}`);
+        const keybindings = this.resolveUserBinding(userSettingsLabel);
+        if (keybindings.length === 0) {
+            this._log(`\\ Could not resolve - ${userSettingsLabel}`);
+        }
+        else {
+            this._doDispatch(keybindings[0], target, /*isSingleModiferChord*/ false);
+        }
+    }
     _dispatch(e, target) {
         return this._doDispatch(this.resolveKeyboardEvent(e), target, /*isSingleModiferChord*/ false);
     }
@@ -164,7 +191,6 @@
         return false;
     }
     _doDispatch(userKeypress, target, isSingleModiferChord = false) {
-        var _a;
         let shouldPreventDefault = false;
         if (userKeypress.hasMultipleChords()) { // warn - because user can press a single chord at a time
             console.warn('Unexpected keyboard event mapped to multiple chords');
@@ -198,7 +224,7 @@
                 if (this.inChordMode) {
                     const currentChordsLabel = this._currentChords.map(({ label }) => label).join(', ');
                     this._log(`+ Leaving multi-chord mode: Nothing bound to "${currentChordsLabel}, ${keypressLabel}".`);
-                    this._notificationService.status(nls.localize('missing.chord', "The key combination ({0}, {1}) is not a command.", currentChordsLabel, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });
+                    this._notificationService.status(nls.localizeWithPath('vs/platform/keybinding/common/abstractKeybindingService', 'missing.chord', "The key combination ({0}, {1}) is not a command.", currentChordsLabel, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });
                     this._leaveChordMode();
                     shouldPreventDefault = true;
                 }
@@ -217,7 +243,7 @@
                     if (this.inChordMode) {
                         const currentChordsLabel = this._currentChords.map(({ label }) => label).join(', ');
                         this._log(`+ Leaving chord mode: Nothing bound to "${currentChordsLabel}, ${keypressLabel}".`);
-                        this._notificationService.status(nls.localize('missing.chord', "The key combination ({0}, {1}) is not a command.", currentChordsLabel, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });
+                        this._notificationService.status(nls.localizeWithPath('vs/platform/keybinding/common/abstractKeybindingService', 'missing.chord', "The key combination ({0}, {1}) is not a command.", currentChordsLabel, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });
                         this._leaveChordMode();
                         shouldPreventDefault = true;
                     }
@@ -237,7 +263,7 @@
                         this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));
                     }
                     if (!HIGH_FREQ_COMMANDS.test(resolveResult.commandId)) {
-                        this._telemetryService.publicLog2('workbenchActionExecuted', { id: resolveResult.commandId, from: 'keybinding', detail: (_a = userKeypress.getUserSettingsLabel()) !== null && _a !== void 0 ? _a : undefined });
+                        this._telemetryService.publicLog2('workbenchActionExecuted', { id: resolveResult.commandId, from: 'keybinding', detail: userKeypress.getUserSettingsLabel() ?? undefined });
                     }
                 }
                 return shouldPreventDefault;
diff -urN -x '*.map' a/vs/platform/keybinding/common/baseResolvedKeybinding.js b/vs/platform/keybinding/common/baseResolvedKeybinding.js
--- a/vs/platform/keybinding/common/baseResolvedKeybinding.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/keybinding/common/baseResolvedKeybinding.js	2023-12-06 14:23:14.391854805 +0000
@@ -35,6 +35,9 @@
     getUserSettingsLabel() {
         return UserSettingsLabelProvider.toLabel(this._os, this._chords, (keybinding) => this._getUserSettingsLabel(keybinding));
     }
+    isWYSIWYG() {
+        return this._chords.every((keybinding) => this._isWYSIWYG(keybinding));
+    }
     hasMultipleChords() {
         return (this._chords.length > 1);
     }
diff -urN -x '*.map' a/vs/platform/keybinding/common/keybindingResolver.js b/vs/platform/keybinding/common/keybindingResolver.js
--- a/vs/platform/keybinding/common/keybindingResolver.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/keybinding/common/keybindingResolver.js	2023-12-06 14:23:14.391854805 +0000
@@ -20,7 +20,6 @@
     defaultKeybindings, 
     /** user's keybindings */
     overrides, log) {
-        var _a;
         this._log = log;
         this._defaultKeybindings = defaultKeybindings;
         this._defaultBoundCommands = new Map();
@@ -40,7 +39,7 @@
                 continue;
             }
             // substitute with constants that are registered after startup - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127
-            const when = (_a = k.when) === null || _a === void 0 ? void 0 : _a.substituteConstants();
+            const when = k.when?.substituteConstants();
             if (when && when.type === 0 /* ContextKeyExprType.False */) {
                 // when condition is false
                 continue;
@@ -196,9 +195,28 @@
         }
         return implies(a, b);
     }
+    getDefaultBoundCommands() {
+        return this._defaultBoundCommands;
+    }
+    getDefaultKeybindings() {
+        return this._defaultKeybindings;
+    }
     getKeybindings() {
         return this._keybindings;
     }
+    lookupKeybindings(commandId) {
+        const items = this._lookupMap.get(commandId);
+        if (typeof items === 'undefined' || items.length === 0) {
+            return [];
+        }
+        // Reverse to get the most specific item first
+        const result = [];
+        let resultLen = 0;
+        for (let i = items.length - 1; i >= 0; i--) {
+            result[resultLen++] = items[i];
+        }
+        return result;
+    }
     lookupPrimaryKeybinding(commandId, context) {
         const items = this._lookupMap.get(commandId);
         if (typeof items === 'undefined' || items.length === 0) {
diff -urN -x '*.map' a/vs/platform/keybinding/common/keybindingsRegistry.js b/vs/platform/keybinding/common/keybindingsRegistry.js
--- a/vs/platform/keybinding/common/keybindingsRegistry.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/keybinding/common/keybindingsRegistry.js	2023-12-06 14:23:14.391854805 +0000
@@ -58,6 +58,26 @@
         }
         return result;
     }
+    setExtensionKeybindings(rules) {
+        const result = [];
+        let keybindingsLen = 0;
+        for (const rule of rules) {
+            if (rule.keybinding) {
+                result[keybindingsLen++] = {
+                    keybinding: rule.keybinding,
+                    command: rule.id,
+                    commandArgs: rule.args,
+                    when: rule.when,
+                    weight1: rule.weight,
+                    weight2: 0,
+                    extensionId: rule.extensionId || null,
+                    isBuiltinExtension: rule.isBuiltinExtension || false
+                };
+            }
+        }
+        this._extensionKeybindings = result;
+        this._cachedMergedKeybindings = null;
+    }
     registerCommandAndKeybindingRule(desc) {
         return combinedDisposable(this.registerKeybindingRule(desc), CommandsRegistry.registerCommand(desc));
     }
diff -urN -x '*.map' a/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js b/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js
--- a/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js	2023-12-06 14:23:14.391854805 +0000
@@ -50,6 +50,9 @@
         const result = KeyCodeUtils.toUserSettingsUS(chord.keyCode);
         return (result ? result.toLowerCase() : result);
     }
+    _isWYSIWYG() {
+        return true;
+    }
     _getChordDispatch(chord) {
         return USLayoutResolvedKeybinding.getDispatchStr(chord);
     }
diff -urN -x '*.map' a/vs/platform/label/common/label.js b/vs/platform/label/common/label.js
--- a/vs/platform/label/common/label.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/label/common/label.js	2023-12-06 14:23:14.391854805 +0000
@@ -1,2 +1,6 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export const ILabelService = createDecorator('labelService');
diff -urN -x '*.map' a/vs/platform/list/browser/listService.js b/vs/platform/list/browser/listService.js
--- a/vs/platform/list/browser/listService.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/list/browser/listService.js	2023-12-06 14:23:14.391854805 +0000
@@ -21,7 +21,7 @@
 import { CompressibleObjectTree, ObjectTree } from '../../../base/browser/ui/tree/objectTree.js';
 import { Emitter, Event } from '../../../base/common/event.js';
 import { combinedDisposable, Disposable, DisposableStore, dispose, toDisposable } from '../../../base/common/lifecycle.js';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 import { IConfigurationService } from '../../configuration/common/configuration.js';
 import { Extensions as ConfigurationExtensions } from '../../configuration/common/configurationRegistry.js';
 import { ContextKeyExpr, IContextKeyService, RawContextKey } from '../../contextkey/common/contextkey.js';
@@ -43,13 +43,12 @@
         this._hasCreatedStyleController = false;
     }
     setLastFocusedList(widget) {
-        var _a, _b;
         if (widget === this._lastFocusedWidget) {
             return;
         }
-        (_a = this._lastFocusedWidget) === null || _a === void 0 ? void 0 : _a.getHTMLElement().classList.remove('last-focused');
+        this._lastFocusedWidget?.getHTMLElement().classList.remove('last-focused');
         this._lastFocusedWidget = widget;
-        (_b = this._lastFocusedWidget) === null || _b === void 0 ? void 0 : _b.getHTMLElement().classList.add('last-focused');
+        this._lastFocusedWidget?.getHTMLElement().classList.add('last-focused');
     }
     register(widget, extraContextKeys) {
         if (!this._hasCreatedStyleController) {
@@ -171,18 +170,31 @@
     }
 }
 function toWorkbenchListOptions(accessor, options) {
-    var _a;
     const configurationService = accessor.get(IConfigurationService);
     const keybindingService = accessor.get(IKeybindingService);
     const disposables = new DisposableStore();
-    const result = Object.assign(Object.assign({}, options), { keyboardNavigationDelegate: { mightProducePrintableCharacter(e) { return keybindingService.mightProducePrintableCharacter(e); } }, smoothScrolling: Boolean(configurationService.getValue(listSmoothScrolling)), mouseWheelScrollSensitivity: configurationService.getValue(mouseWheelScrollSensitivityKey), fastScrollSensitivity: configurationService.getValue(fastScrollSensitivityKey), multipleSelectionController: (_a = options.multipleSelectionController) !== null && _a !== void 0 ? _a : disposables.add(new MultipleSelectionController(configurationService)), keyboardNavigationEventFilter: createKeyboardNavigationEventFilter(keybindingService), scrollByPage: Boolean(configurationService.getValue(scrollByPageKey)) });
+    const result = {
+        ...options,
+        keyboardNavigationDelegate: { mightProducePrintableCharacter(e) { return keybindingService.mightProducePrintableCharacter(e); } },
+        smoothScrolling: Boolean(configurationService.getValue(listSmoothScrolling)),
+        mouseWheelScrollSensitivity: configurationService.getValue(mouseWheelScrollSensitivityKey),
+        fastScrollSensitivity: configurationService.getValue(fastScrollSensitivityKey),
+        multipleSelectionController: options.multipleSelectionController ?? disposables.add(new MultipleSelectionController(configurationService)),
+        keyboardNavigationEventFilter: createKeyboardNavigationEventFilter(keybindingService),
+        scrollByPage: Boolean(configurationService.getValue(scrollByPageKey))
+    };
     return [result, disposables];
 }
 let WorkbenchList = class WorkbenchList extends List {
+    get onDidOpen() { return this.navigator.onDidOpen; }
     constructor(user, container, delegate, renderers, options, contextKeyService, listService, configurationService, instantiationService) {
         const horizontalScrolling = typeof options.horizontalScrolling !== 'undefined' ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
         const [workbenchListOptions, workbenchListOptionsDisposable] = instantiationService.invokeFunction(toWorkbenchListOptions, options);
-        super(user, container, delegate, renderers, Object.assign(Object.assign({ keyboardSupport: false }, workbenchListOptions), { horizontalScrolling }));
+        super(user, container, delegate, renderers, {
+            keyboardSupport: false,
+            ...workbenchListOptions,
+            horizontalScrolling,
+        });
         this.disposables.add(workbenchListOptionsDisposable);
         this.contextKeyService = createScopedContextKeyService(contextKeyService, this);
         this.disposables.add(createScrollObserver(this.contextKeyService, this));
@@ -219,29 +231,29 @@
             let options = {};
             if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === undefined) {
                 const horizontalScrolling = Boolean(configurationService.getValue(horizontalScrollingKey));
-                options = Object.assign(Object.assign({}, options), { horizontalScrolling });
+                options = { ...options, horizontalScrolling };
             }
             if (e.affectsConfiguration(scrollByPageKey)) {
                 const scrollByPage = Boolean(configurationService.getValue(scrollByPageKey));
-                options = Object.assign(Object.assign({}, options), { scrollByPage });
+                options = { ...options, scrollByPage };
             }
             if (e.affectsConfiguration(listSmoothScrolling)) {
                 const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));
-                options = Object.assign(Object.assign({}, options), { smoothScrolling });
+                options = { ...options, smoothScrolling };
             }
             if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {
                 const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);
-                options = Object.assign(Object.assign({}, options), { mouseWheelScrollSensitivity });
+                options = { ...options, mouseWheelScrollSensitivity };
             }
             if (e.affectsConfiguration(fastScrollSensitivityKey)) {
                 const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);
-                options = Object.assign(Object.assign({}, options), { fastScrollSensitivity });
+                options = { ...options, fastScrollSensitivity };
             }
             if (Object.keys(options).length > 0) {
                 this.updateOptions(options);
             }
         }));
-        this.navigator = new ListResourceNavigator(this, Object.assign({ configurationService }, options));
+        this.navigator = new ListResourceNavigator(this, { configurationService, ...options });
         this.disposables.add(this.navigator);
     }
     updateOptions(options) {
@@ -256,6 +268,9 @@
     updateStyles(styles) {
         this.style(styles ? getListStyles(styles) : defaultListStyles);
     }
+    get useAltAsMultipleSelectionModifier() {
+        return this._useAltAsMultipleSelectionModifier;
+    }
 };
 WorkbenchList = __decorate([
     __param(5, IContextKeyService),
@@ -265,10 +280,15 @@
 ], WorkbenchList);
 export { WorkbenchList };
 let WorkbenchPagedList = class WorkbenchPagedList extends PagedList {
+    get onDidOpen() { return this.navigator.onDidOpen; }
     constructor(user, container, delegate, renderers, options, contextKeyService, listService, configurationService, instantiationService) {
         const horizontalScrolling = typeof options.horizontalScrolling !== 'undefined' ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
         const [workbenchListOptions, workbenchListOptionsDisposable] = instantiationService.invokeFunction(toWorkbenchListOptions, options);
-        super(user, container, delegate, renderers, Object.assign(Object.assign({ keyboardSupport: false }, workbenchListOptions), { horizontalScrolling }));
+        super(user, container, delegate, renderers, {
+            keyboardSupport: false,
+            ...workbenchListOptions,
+            horizontalScrolling,
+        });
         this.disposables = new DisposableStore();
         this.disposables.add(workbenchListOptionsDisposable);
         this.contextKeyService = createScopedContextKeyService(contextKeyService, this);
@@ -289,29 +309,29 @@
             let options = {};
             if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === undefined) {
                 const horizontalScrolling = Boolean(configurationService.getValue(horizontalScrollingKey));
-                options = Object.assign(Object.assign({}, options), { horizontalScrolling });
+                options = { ...options, horizontalScrolling };
             }
             if (e.affectsConfiguration(scrollByPageKey)) {
                 const scrollByPage = Boolean(configurationService.getValue(scrollByPageKey));
-                options = Object.assign(Object.assign({}, options), { scrollByPage });
+                options = { ...options, scrollByPage };
             }
             if (e.affectsConfiguration(listSmoothScrolling)) {
                 const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));
-                options = Object.assign(Object.assign({}, options), { smoothScrolling });
+                options = { ...options, smoothScrolling };
             }
             if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {
                 const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);
-                options = Object.assign(Object.assign({}, options), { mouseWheelScrollSensitivity });
+                options = { ...options, mouseWheelScrollSensitivity };
             }
             if (e.affectsConfiguration(fastScrollSensitivityKey)) {
                 const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);
-                options = Object.assign(Object.assign({}, options), { fastScrollSensitivity });
+                options = { ...options, fastScrollSensitivity };
             }
             if (Object.keys(options).length > 0) {
                 this.updateOptions(options);
             }
         }));
-        this.navigator = new ListResourceNavigator(this, Object.assign({ configurationService }, options));
+        this.navigator = new ListResourceNavigator(this, { configurationService, ...options });
         this.disposables.add(this.navigator);
     }
     updateOptions(options) {
@@ -326,6 +346,9 @@
     updateStyles(styles) {
         this.style(styles ? getListStyles(styles) : defaultListStyles);
     }
+    get useAltAsMultipleSelectionModifier() {
+        return this._useAltAsMultipleSelectionModifier;
+    }
     dispose() {
         this.disposables.dispose();
         super.dispose();
@@ -339,10 +362,15 @@
 ], WorkbenchPagedList);
 export { WorkbenchPagedList };
 let WorkbenchTable = class WorkbenchTable extends Table {
+    get onDidOpen() { return this.navigator.onDidOpen; }
     constructor(user, container, delegate, columns, renderers, options, contextKeyService, listService, configurationService, instantiationService) {
         const horizontalScrolling = typeof options.horizontalScrolling !== 'undefined' ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
         const [workbenchListOptions, workbenchListOptionsDisposable] = instantiationService.invokeFunction(toWorkbenchListOptions, options);
-        super(user, container, delegate, columns, renderers, Object.assign(Object.assign({ keyboardSupport: false }, workbenchListOptions), { horizontalScrolling }));
+        super(user, container, delegate, columns, renderers, {
+            keyboardSupport: false,
+            ...workbenchListOptions,
+            horizontalScrolling,
+        });
         this.disposables.add(workbenchListOptionsDisposable);
         this.contextKeyService = createScopedContextKeyService(contextKeyService, this);
         this.disposables.add(createScrollObserver(this.contextKeyService, this));
@@ -379,29 +407,29 @@
             let options = {};
             if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === undefined) {
                 const horizontalScrolling = Boolean(configurationService.getValue(horizontalScrollingKey));
-                options = Object.assign(Object.assign({}, options), { horizontalScrolling });
+                options = { ...options, horizontalScrolling };
             }
             if (e.affectsConfiguration(scrollByPageKey)) {
                 const scrollByPage = Boolean(configurationService.getValue(scrollByPageKey));
-                options = Object.assign(Object.assign({}, options), { scrollByPage });
+                options = { ...options, scrollByPage };
             }
             if (e.affectsConfiguration(listSmoothScrolling)) {
                 const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));
-                options = Object.assign(Object.assign({}, options), { smoothScrolling });
+                options = { ...options, smoothScrolling };
             }
             if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {
                 const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);
-                options = Object.assign(Object.assign({}, options), { mouseWheelScrollSensitivity });
+                options = { ...options, mouseWheelScrollSensitivity };
             }
             if (e.affectsConfiguration(fastScrollSensitivityKey)) {
                 const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);
-                options = Object.assign(Object.assign({}, options), { fastScrollSensitivity });
+                options = { ...options, fastScrollSensitivity };
             }
             if (Object.keys(options).length > 0) {
                 this.updateOptions(options);
             }
         }));
-        this.navigator = new TableResourceNavigator(this, Object.assign({ configurationService }, options));
+        this.navigator = new TableResourceNavigator(this, { configurationService, ...options });
         this.disposables.add(this.navigator);
     }
     updateOptions(options) {
@@ -416,6 +444,9 @@
     updateStyles(styles) {
         this.style(styles ? getListStyles(styles) : defaultListStyles);
     }
+    get useAltAsMultipleSelectionModifier() {
+        return this._useAltAsMultipleSelectionModifier;
+    }
     dispose() {
         this.disposables.dispose();
         super.dispose();
@@ -428,9 +459,15 @@
     __param(9, IInstantiationService)
 ], WorkbenchTable);
 export { WorkbenchTable };
+export function getSelectionKeyboardEvent(typeArg = 'keydown', preserveFocus, pinned) {
+    const e = new KeyboardEvent(typeArg);
+    e.preserveFocus = preserveFocus;
+    e.pinned = pinned;
+    e.__forceEvent = true;
+    return e;
+}
 class ResourceNavigator extends Disposable {
     constructor(widget, options) {
-        var _a;
         super();
         this.widget = widget;
         this._onDidOpen = this._register(new Emitter());
@@ -438,16 +475,16 @@
         this._register(Event.filter(this.widget.onDidChangeSelection, e => e.browserEvent instanceof KeyboardEvent)(e => this.onSelectionFromKeyboard(e)));
         this._register(this.widget.onPointer((e) => this.onPointer(e.element, e.browserEvent)));
         this._register(this.widget.onMouseDblClick((e) => this.onMouseDblClick(e.element, e.browserEvent)));
-        if (typeof (options === null || options === void 0 ? void 0 : options.openOnSingleClick) !== 'boolean' && (options === null || options === void 0 ? void 0 : options.configurationService)) {
-            this.openOnSingleClick = (options === null || options === void 0 ? void 0 : options.configurationService.getValue(openModeSettingKey)) !== 'doubleClick';
-            this._register(options === null || options === void 0 ? void 0 : options.configurationService.onDidChangeConfiguration(e => {
+        if (typeof options?.openOnSingleClick !== 'boolean' && options?.configurationService) {
+            this.openOnSingleClick = options?.configurationService.getValue(openModeSettingKey) !== 'doubleClick';
+            this._register(options?.configurationService.onDidChangeConfiguration(e => {
                 if (e.affectsConfiguration(openModeSettingKey)) {
-                    this.openOnSingleClick = (options === null || options === void 0 ? void 0 : options.configurationService.getValue(openModeSettingKey)) !== 'doubleClick';
+                    this.openOnSingleClick = options?.configurationService.getValue(openModeSettingKey) !== 'doubleClick';
                 }
             }));
         }
         else {
-            this.openOnSingleClick = (_a = options === null || options === void 0 ? void 0 : options.openOnSingleClick) !== null && _a !== void 0 ? _a : true;
+            this.openOnSingleClick = options?.openOnSingleClick ?? true;
         }
     }
     onSelectionFromKeyboard(event) {
@@ -528,8 +565,7 @@
         super(widget, options);
     }
     getSelectedElement() {
-        var _a;
-        return (_a = this.widget.getSelection()[0]) !== null && _a !== void 0 ? _a : undefined;
+        return this.widget.getSelection()[0] ?? undefined;
     }
 }
 function createKeyboardNavigationEventFilter(keybindingService) {
@@ -552,6 +588,9 @@
     };
 }
 let WorkbenchObjectTree = class WorkbenchObjectTree extends ObjectTree {
+    get contextKeyService() { return this.internals.contextKeyService; }
+    get useAltAsMultipleSelectionModifier() { return this.internals.useAltAsMultipleSelectionModifier; }
+    get onDidOpen() { return this.internals.onDidOpen; }
     constructor(user, container, delegate, renderers, options, instantiationService, contextKeyService, listService, configurationService) {
         const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options);
         super(user, container, delegate, renderers, treeOptions);
@@ -572,6 +611,9 @@
 ], WorkbenchObjectTree);
 export { WorkbenchObjectTree };
 let WorkbenchCompressibleObjectTree = class WorkbenchCompressibleObjectTree extends CompressibleObjectTree {
+    get contextKeyService() { return this.internals.contextKeyService; }
+    get useAltAsMultipleSelectionModifier() { return this.internals.useAltAsMultipleSelectionModifier; }
+    get onDidOpen() { return this.internals.onDidOpen; }
     constructor(user, container, delegate, renderers, options, instantiationService, contextKeyService, listService, configurationService) {
         const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options);
         super(user, container, delegate, renderers, treeOptions);
@@ -595,6 +637,9 @@
 ], WorkbenchCompressibleObjectTree);
 export { WorkbenchCompressibleObjectTree };
 let WorkbenchDataTree = class WorkbenchDataTree extends DataTree {
+    get contextKeyService() { return this.internals.contextKeyService; }
+    get useAltAsMultipleSelectionModifier() { return this.internals.useAltAsMultipleSelectionModifier; }
+    get onDidOpen() { return this.internals.onDidOpen; }
     constructor(user, container, delegate, renderers, dataSource, options, instantiationService, contextKeyService, listService, configurationService) {
         const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options);
         super(user, container, delegate, renderers, dataSource, treeOptions);
@@ -618,6 +663,8 @@
 ], WorkbenchDataTree);
 export { WorkbenchDataTree };
 let WorkbenchAsyncDataTree = class WorkbenchAsyncDataTree extends AsyncDataTree {
+    get contextKeyService() { return this.internals.contextKeyService; }
+    get useAltAsMultipleSelectionModifier() { return this.internals.useAltAsMultipleSelectionModifier; }
     get onDidOpen() { return this.internals.onDidOpen; }
     constructor(user, container, delegate, renderers, dataSource, options, instantiationService, contextKeyService, listService, configurationService) {
         const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options);
@@ -642,6 +689,9 @@
 ], WorkbenchAsyncDataTree);
 export { WorkbenchAsyncDataTree };
 let WorkbenchCompressibleAsyncDataTree = class WorkbenchCompressibleAsyncDataTree extends CompressibleAsyncDataTree {
+    get contextKeyService() { return this.internals.contextKeyService; }
+    get useAltAsMultipleSelectionModifier() { return this.internals.useAltAsMultipleSelectionModifier; }
+    get onDidOpen() { return this.internals.onDidOpen; }
     constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options, instantiationService, contextKeyService, listService, configurationService) {
         const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options);
         super(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, treeOptions);
@@ -689,7 +739,6 @@
     return undefined;
 }
 function workbenchTreeDataPreamble(accessor, options) {
-    var _a;
     const configurationService = accessor.get(IConfigurationService);
     const contextViewService = accessor.get(IContextViewService);
     const contextKeyService = accessor.get(IContextKeyService);
@@ -725,15 +774,28 @@
     return {
         getTypeNavigationMode,
         disposable,
-        options: Object.assign(Object.assign({ 
+        options: {
             // ...options, // TODO@Joao why is this not splatted here?
-            keyboardSupport: false }, workbenchListOptions), { indent: typeof configurationService.getValue(treeIndentKey) === 'number' ? configurationService.getValue(treeIndentKey) : undefined, renderIndentGuides, smoothScrolling: Boolean(configurationService.getValue(listSmoothScrolling)), defaultFindMode: getDefaultTreeFindMode(configurationService), defaultFindMatchType: getDefaultTreeFindMatchType(configurationService), horizontalScrolling, scrollByPage: Boolean(configurationService.getValue(scrollByPageKey)), paddingBottom: paddingBottom, hideTwistiesOfChildlessElements: options.hideTwistiesOfChildlessElements, expandOnlyOnTwistieClick: (_a = options.expandOnlyOnTwistieClick) !== null && _a !== void 0 ? _a : (configurationService.getValue(treeExpandMode) === 'doubleClick'), contextViewProvider: contextViewService, findWidgetStyles: defaultFindWidgetStyles })
+            keyboardSupport: false,
+            ...workbenchListOptions,
+            indent: typeof configurationService.getValue(treeIndentKey) === 'number' ? configurationService.getValue(treeIndentKey) : undefined,
+            renderIndentGuides,
+            smoothScrolling: Boolean(configurationService.getValue(listSmoothScrolling)),
+            defaultFindMode: getDefaultTreeFindMode(configurationService),
+            defaultFindMatchType: getDefaultTreeFindMatchType(configurationService),
+            horizontalScrolling,
+            scrollByPage: Boolean(configurationService.getValue(scrollByPageKey)),
+            paddingBottom: paddingBottom,
+            hideTwistiesOfChildlessElements: options.hideTwistiesOfChildlessElements,
+            expandOnlyOnTwistieClick: options.expandOnlyOnTwistieClick ?? (configurationService.getValue(treeExpandMode) === 'doubleClick'),
+            contextViewProvider: contextViewService,
+            findWidgetStyles: defaultFindWidgetStyles,
+        }
     };
 }
 let WorkbenchTreeInternals = class WorkbenchTreeInternals {
     get onDidOpen() { return this.navigator.onDidOpen; }
     constructor(tree, options, getTypeNavigationMode, overrideStyles, contextKeyService, listService, configurationService) {
-        var _a;
         this.tree = tree;
         this.disposables = [];
         this.contextKeyService = createScopedContextKeyService(contextKeyService, tree);
@@ -743,7 +805,7 @@
         const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);
         listSelectionNavigation.set(Boolean(options.selectionNavigation));
         this.listSupportFindWidget = WorkbenchListSupportsFind.bindTo(this.contextKeyService);
-        this.listSupportFindWidget.set((_a = options.findWidgetEnabled) !== null && _a !== void 0 ? _a : true);
+        this.listSupportFindWidget.set(options.findWidgetEnabled ?? true);
         this.hasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);
         this.hasDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);
         this.hasMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);
@@ -788,46 +850,46 @@
             }
             if (e.affectsConfiguration(treeIndentKey)) {
                 const indent = configurationService.getValue(treeIndentKey);
-                newOptions = Object.assign(Object.assign({}, newOptions), { indent });
+                newOptions = { ...newOptions, indent };
             }
             if (e.affectsConfiguration(treeRenderIndentGuidesKey) && options.renderIndentGuides === undefined) {
                 const renderIndentGuides = configurationService.getValue(treeRenderIndentGuidesKey);
-                newOptions = Object.assign(Object.assign({}, newOptions), { renderIndentGuides });
+                newOptions = { ...newOptions, renderIndentGuides };
             }
             if (e.affectsConfiguration(listSmoothScrolling)) {
                 const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));
-                newOptions = Object.assign(Object.assign({}, newOptions), { smoothScrolling });
+                newOptions = { ...newOptions, smoothScrolling };
             }
             if (e.affectsConfiguration(defaultFindModeSettingKey) || e.affectsConfiguration(keyboardNavigationSettingKey)) {
                 const defaultFindMode = getDefaultTreeFindMode(configurationService);
-                newOptions = Object.assign(Object.assign({}, newOptions), { defaultFindMode });
+                newOptions = { ...newOptions, defaultFindMode };
             }
             if (e.affectsConfiguration(typeNavigationModeSettingKey) || e.affectsConfiguration(keyboardNavigationSettingKey)) {
                 const typeNavigationMode = getTypeNavigationMode();
-                newOptions = Object.assign(Object.assign({}, newOptions), { typeNavigationMode });
+                newOptions = { ...newOptions, typeNavigationMode };
             }
             if (e.affectsConfiguration(defaultFindMatchTypeSettingKey)) {
                 const defaultFindMatchType = getDefaultTreeFindMatchType(configurationService);
-                newOptions = Object.assign(Object.assign({}, newOptions), { defaultFindMatchType });
+                newOptions = { ...newOptions, defaultFindMatchType };
             }
             if (e.affectsConfiguration(horizontalScrollingKey) && options.horizontalScrolling === undefined) {
                 const horizontalScrolling = Boolean(configurationService.getValue(horizontalScrollingKey));
-                newOptions = Object.assign(Object.assign({}, newOptions), { horizontalScrolling });
+                newOptions = { ...newOptions, horizontalScrolling };
             }
             if (e.affectsConfiguration(scrollByPageKey)) {
                 const scrollByPage = Boolean(configurationService.getValue(scrollByPageKey));
-                newOptions = Object.assign(Object.assign({}, newOptions), { scrollByPage });
+                newOptions = { ...newOptions, scrollByPage };
             }
             if (e.affectsConfiguration(treeExpandMode) && options.expandOnlyOnTwistieClick === undefined) {
-                newOptions = Object.assign(Object.assign({}, newOptions), { expandOnlyOnTwistieClick: configurationService.getValue(treeExpandMode) === 'doubleClick' });
+                newOptions = { ...newOptions, expandOnlyOnTwistieClick: configurationService.getValue(treeExpandMode) === 'doubleClick' };
             }
             if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {
                 const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);
-                newOptions = Object.assign(Object.assign({}, newOptions), { mouseWheelScrollSensitivity });
+                newOptions = { ...newOptions, mouseWheelScrollSensitivity };
             }
             if (e.affectsConfiguration(fastScrollSensitivityKey)) {
                 const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);
-                newOptions = Object.assign(Object.assign({}, newOptions), { fastScrollSensitivity });
+                newOptions = { ...newOptions, fastScrollSensitivity };
             }
             if (Object.keys(newOptions).length > 0) {
                 tree.updateOptions(newOptions);
@@ -837,9 +899,12 @@
                 tree.updateOptions({ typeNavigationMode: getTypeNavigationMode() });
             }
         }));
-        this.navigator = new TreeResourceNavigator(tree, Object.assign({ configurationService }, options));
+        this.navigator = new TreeResourceNavigator(tree, { configurationService, ...options });
         this.disposables.push(this.navigator);
     }
+    get useAltAsMultipleSelectionModifier() {
+        return this._useAltAsMultipleSelectionModifier;
+    }
     updateOptions(options) {
         if (options.multipleSelectionSupport !== undefined) {
             this.listSupportsMultiSelect.set(!!options.multipleSelectionSupport);
@@ -861,18 +926,18 @@
 configurationRegistry.registerConfiguration({
     id: 'workbench',
     order: 7,
-    title: localize('workbenchConfigurationTitle', "Workbench"),
+    title: localizeWithPath('vs/platform/list/browser/listService', 'workbenchConfigurationTitle', "Workbench"),
     type: 'object',
     properties: {
         [multiSelectModifierSettingKey]: {
             type: 'string',
             enum: ['ctrlCmd', 'alt'],
             markdownEnumDescriptions: [
-                localize('multiSelectModifier.ctrlCmd', "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
-                localize('multiSelectModifier.alt', "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
+                localizeWithPath('vs/platform/list/browser/listService', 'multiSelectModifier.ctrlCmd', "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
+                localizeWithPath('vs/platform/list/browser/listService', 'multiSelectModifier.alt', "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
             ],
             default: 'ctrlCmd',
-            description: localize({
+            description: localizeWithPath('vs/platform/list/browser/listService', {
                 key: 'multiSelectModifier',
                 comment: [
                     '- `ctrlCmd` refers to a value the setting can take and should not be localized.',
@@ -884,7 +949,7 @@
             type: 'string',
             enum: ['singleClick', 'doubleClick'],
             default: 'singleClick',
-            description: localize({
+            description: localizeWithPath('vs/platform/list/browser/listService', {
                 key: 'openModeModifier',
                 comment: ['`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized.']
             }, "Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.")
@@ -892,85 +957,85 @@
         [horizontalScrollingKey]: {
             type: 'boolean',
             default: false,
-            description: localize('horizontalScrolling setting', "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
+            description: localizeWithPath('vs/platform/list/browser/listService', 'horizontalScrolling setting', "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
         },
         [scrollByPageKey]: {
             type: 'boolean',
             default: false,
-            description: localize('list.scrollByPage', "Controls whether clicks in the scrollbar scroll page by page.")
+            description: localizeWithPath('vs/platform/list/browser/listService', 'list.scrollByPage', "Controls whether clicks in the scrollbar scroll page by page.")
         },
         [treeIndentKey]: {
             type: 'number',
             default: 8,
             minimum: 4,
             maximum: 40,
-            description: localize('tree indent setting', "Controls tree indentation in pixels.")
+            description: localizeWithPath('vs/platform/list/browser/listService', 'tree indent setting', "Controls tree indentation in pixels.")
         },
         [treeRenderIndentGuidesKey]: {
             type: 'string',
             enum: ['none', 'onHover', 'always'],
             default: 'onHover',
-            description: localize('render tree indent guides', "Controls whether the tree should render indent guides.")
+            description: localizeWithPath('vs/platform/list/browser/listService', 'render tree indent guides', "Controls whether the tree should render indent guides.")
         },
         [listSmoothScrolling]: {
             type: 'boolean',
             default: false,
-            description: localize('list smoothScrolling setting', "Controls whether lists and trees have smooth scrolling."),
+            description: localizeWithPath('vs/platform/list/browser/listService', 'list smoothScrolling setting', "Controls whether lists and trees have smooth scrolling."),
         },
         [mouseWheelScrollSensitivityKey]: {
             type: 'number',
             default: 1,
-            markdownDescription: localize('Mouse Wheel Scroll Sensitivity', "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.")
+            markdownDescription: localizeWithPath('vs/platform/list/browser/listService', 'Mouse Wheel Scroll Sensitivity', "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.")
         },
         [fastScrollSensitivityKey]: {
             type: 'number',
             default: 5,
-            markdownDescription: localize('Fast Scroll Sensitivity', "Scrolling speed multiplier when pressing `Alt`.")
+            markdownDescription: localizeWithPath('vs/platform/list/browser/listService', 'Fast Scroll Sensitivity', "Scrolling speed multiplier when pressing `Alt`.")
         },
         [defaultFindModeSettingKey]: {
             type: 'string',
             enum: ['highlight', 'filter'],
             enumDescriptions: [
-                localize('defaultFindModeSettingKey.highlight', "Highlight elements when searching. Further up and down navigation will traverse only the highlighted elements."),
-                localize('defaultFindModeSettingKey.filter', "Filter elements when searching.")
+                localizeWithPath('vs/platform/list/browser/listService', 'defaultFindModeSettingKey.highlight', "Highlight elements when searching. Further up and down navigation will traverse only the highlighted elements."),
+                localizeWithPath('vs/platform/list/browser/listService', 'defaultFindModeSettingKey.filter', "Filter elements when searching.")
             ],
             default: 'highlight',
-            description: localize('defaultFindModeSettingKey', "Controls the default find mode for lists and trees in the workbench.")
+            description: localizeWithPath('vs/platform/list/browser/listService', 'defaultFindModeSettingKey', "Controls the default find mode for lists and trees in the workbench.")
         },
         [keyboardNavigationSettingKey]: {
             type: 'string',
             enum: ['simple', 'highlight', 'filter'],
             enumDescriptions: [
-                localize('keyboardNavigationSettingKey.simple', "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
-                localize('keyboardNavigationSettingKey.highlight', "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
-                localize('keyboardNavigationSettingKey.filter', "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
+                localizeWithPath('vs/platform/list/browser/listService', 'keyboardNavigationSettingKey.simple', "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
+                localizeWithPath('vs/platform/list/browser/listService', 'keyboardNavigationSettingKey.highlight', "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
+                localizeWithPath('vs/platform/list/browser/listService', 'keyboardNavigationSettingKey.filter', "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
             ],
             default: 'highlight',
-            description: localize('keyboardNavigationSettingKey', "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter."),
+            description: localizeWithPath('vs/platform/list/browser/listService', 'keyboardNavigationSettingKey', "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter."),
             deprecated: true,
-            deprecationMessage: localize('keyboardNavigationSettingKeyDeprecated', "Please use 'workbench.list.defaultFindMode' and	'workbench.list.typeNavigationMode' instead.")
+            deprecationMessage: localizeWithPath('vs/platform/list/browser/listService', 'keyboardNavigationSettingKeyDeprecated', "Please use 'workbench.list.defaultFindMode' and	'workbench.list.typeNavigationMode' instead.")
         },
         [defaultFindMatchTypeSettingKey]: {
             type: 'string',
             enum: ['fuzzy', 'contiguous'],
             enumDescriptions: [
-                localize('defaultFindMatchTypeSettingKey.fuzzy', "Use fuzzy matching when searching."),
-                localize('defaultFindMatchTypeSettingKey.contiguous', "Use contiguous matching when searching.")
+                localizeWithPath('vs/platform/list/browser/listService', 'defaultFindMatchTypeSettingKey.fuzzy', "Use fuzzy matching when searching."),
+                localizeWithPath('vs/platform/list/browser/listService', 'defaultFindMatchTypeSettingKey.contiguous', "Use contiguous matching when searching.")
             ],
             default: 'fuzzy',
-            description: localize('defaultFindMatchTypeSettingKey', "Controls the type of matching used when searching lists and trees in the workbench.")
+            description: localizeWithPath('vs/platform/list/browser/listService', 'defaultFindMatchTypeSettingKey', "Controls the type of matching used when searching lists and trees in the workbench.")
         },
         [treeExpandMode]: {
             type: 'string',
             enum: ['singleClick', 'doubleClick'],
             default: 'singleClick',
-            description: localize('expand mode', "Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable."),
+            description: localizeWithPath('vs/platform/list/browser/listService', 'expand mode', "Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable."),
         },
         [typeNavigationModeSettingKey]: {
             type: 'string',
             enum: ['automatic', 'trigger'],
             default: 'automatic',
-            markdownDescription: localize('typeNavigationMode2', "Controls how type navigation works in lists and trees in the workbench. When set to `trigger`, type navigation begins once the `list.triggerTypeNavigation` command is run."),
+            markdownDescription: localizeWithPath('vs/platform/list/browser/listService', 'typeNavigationMode2', "Controls how type navigation works in lists and trees in the workbench. When set to `trigger`, type navigation begins once the `list.triggerTypeNavigation` command is run."),
         }
     }
 });
diff -urN -x '*.map' a/vs/platform/log/common/log.js b/vs/platform/log/common/log.js
--- a/vs/platform/log/common/log.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/log/common/log.js	2023-12-06 14:23:14.391854805 +0000
@@ -1,8 +1,26 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { toErrorMessage } from '../../../base/common/errorMessage.js';
 import { Emitter } from '../../../base/common/event.js';
+import { hash } from '../../../base/common/hash.js';
 import { Disposable } from '../../../base/common/lifecycle.js';
+import { ResourceMap } from '../../../base/common/map.js';
+import { isWindows } from '../../../base/common/platform.js';
+import { joinPath } from '../../../base/common/resources.js';
+import { isNumber, isString } from '../../../base/common/types.js';
+import { URI } from '../../../base/common/uri.js';
 import { RawContextKey } from '../../contextkey/common/contextkey.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export const ILogService = createDecorator('logService');
+export const ILoggerService = createDecorator('loggerService');
+function now() {
+    return new Date().toISOString();
+}
+export function isLogLevel(thing) {
+    return isNumber(thing);
+}
 export var LogLevel;
 (function (LogLevel) {
     LogLevel[LogLevel["Off"] = 0] = "Off";
@@ -13,6 +31,44 @@
     LogLevel[LogLevel["Error"] = 5] = "Error";
 })(LogLevel || (LogLevel = {}));
 export const DEFAULT_LOG_LEVEL = LogLevel.Info;
+export function log(logger, level, message) {
+    switch (level) {
+        case LogLevel.Trace:
+            logger.trace(message);
+            break;
+        case LogLevel.Debug:
+            logger.debug(message);
+            break;
+        case LogLevel.Info:
+            logger.info(message);
+            break;
+        case LogLevel.Warning:
+            logger.warn(message);
+            break;
+        case LogLevel.Error:
+            logger.error(message);
+            break;
+        case LogLevel.Off: /* do nothing */ break;
+        default: throw new Error(`Invalid log level ${level}`);
+    }
+}
+function format(args, verbose = false) {
+    let result = '';
+    for (let i = 0; i < args.length; i++) {
+        let a = args[i];
+        if (a instanceof Error) {
+            a = toErrorMessage(a, verbose);
+        }
+        if (typeof a === 'object') {
+            try {
+                a = JSON.stringify(a);
+            }
+            catch (e) { }
+        }
+        result += (i > 0 ? ' ' : '') + a;
+    }
+    return result;
+}
 export class AbstractLogger extends Disposable {
     constructor() {
         super(...arguments);
@@ -33,6 +89,111 @@
         return this.level !== LogLevel.Off && this.level <= level;
     }
 }
+export class AbstractMessageLogger extends AbstractLogger {
+    constructor(logAlways) {
+        super();
+        this.logAlways = logAlways;
+    }
+    checkLogLevel(level) {
+        return this.logAlways || super.checkLogLevel(level);
+    }
+    trace(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Trace)) {
+            this.log(LogLevel.Trace, format([message, ...args], true));
+        }
+    }
+    debug(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Debug)) {
+            this.log(LogLevel.Debug, format([message, ...args]));
+        }
+    }
+    info(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Info)) {
+            this.log(LogLevel.Info, format([message, ...args]));
+        }
+    }
+    warn(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Warning)) {
+            this.log(LogLevel.Warning, format([message, ...args]));
+        }
+    }
+    error(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Error)) {
+            if (message instanceof Error) {
+                const array = Array.prototype.slice.call(arguments);
+                array[0] = message.stack;
+                this.log(LogLevel.Error, format(array));
+            }
+            else {
+                this.log(LogLevel.Error, format([message, ...args]));
+            }
+        }
+    }
+    flush() { }
+}
+export class ConsoleMainLogger extends AbstractLogger {
+    constructor(logLevel = DEFAULT_LOG_LEVEL) {
+        super();
+        this.setLevel(logLevel);
+        this.useColors = !isWindows;
+    }
+    trace(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Trace)) {
+            if (this.useColors) {
+                console.log(`\x1b[90m[main ${now()}]\x1b[0m`, message, ...args);
+            }
+            else {
+                console.log(`[main ${now()}]`, message, ...args);
+            }
+        }
+    }
+    debug(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Debug)) {
+            if (this.useColors) {
+                console.log(`\x1b[90m[main ${now()}]\x1b[0m`, message, ...args);
+            }
+            else {
+                console.log(`[main ${now()}]`, message, ...args);
+            }
+        }
+    }
+    info(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Info)) {
+            if (this.useColors) {
+                console.log(`\x1b[90m[main ${now()}]\x1b[0m`, message, ...args);
+            }
+            else {
+                console.log(`[main ${now()}]`, message, ...args);
+            }
+        }
+    }
+    warn(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Warning)) {
+            if (this.useColors) {
+                console.warn(`\x1b[93m[main ${now()}]\x1b[0m`, message, ...args);
+            }
+            else {
+                console.warn(`[main ${now()}]`, message, ...args);
+            }
+        }
+    }
+    error(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Error)) {
+            if (this.useColors) {
+                console.error(`\x1b[91m[main ${now()}]\x1b[0m`, message, ...args);
+            }
+            else {
+                console.error(`[main ${now()}]`, message, ...args);
+            }
+        }
+    }
+    dispose() {
+        // noop
+    }
+    flush() {
+        // noop
+    }
+}
 export class ConsoleLogger extends AbstractLogger {
     constructor(logLevel = DEFAULT_LOG_LEVEL, useColors = true) {
         super();
@@ -92,6 +253,53 @@
     dispose() {
         // noop
     }
+    flush() {
+        // noop
+    }
+}
+export class AdapterLogger extends AbstractLogger {
+    constructor(adapter, logLevel = DEFAULT_LOG_LEVEL) {
+        super();
+        this.adapter = adapter;
+        this.setLevel(logLevel);
+    }
+    trace(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Trace)) {
+            this.adapter.log(LogLevel.Trace, [this.extractMessage(message), ...args]);
+        }
+    }
+    debug(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Debug)) {
+            this.adapter.log(LogLevel.Debug, [this.extractMessage(message), ...args]);
+        }
+    }
+    info(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Info)) {
+            this.adapter.log(LogLevel.Info, [this.extractMessage(message), ...args]);
+        }
+    }
+    warn(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Warning)) {
+            this.adapter.log(LogLevel.Warning, [this.extractMessage(message), ...args]);
+        }
+    }
+    error(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Error)) {
+            this.adapter.log(LogLevel.Error, [this.extractMessage(message), ...args]);
+        }
+    }
+    extractMessage(msg) {
+        if (typeof msg === 'string') {
+            return msg;
+        }
+        return toErrorMessage(msg, this.checkLogLevel(LogLevel.Trace));
+    }
+    dispose() {
+        // noop
+    }
+    flush() {
+        // noop
+    }
 }
 export class MultiplexLogger extends AbstractLogger {
     constructor(loggers) {
@@ -132,12 +340,166 @@
             logger.error(message, ...args);
         }
     }
+    flush() {
+        for (const logger of this.loggers) {
+            logger.flush();
+        }
+    }
     dispose() {
         for (const logger of this.loggers) {
             logger.dispose();
         }
     }
 }
+export class AbstractLoggerService extends Disposable {
+    constructor(logLevel, logsHome, loggerResources) {
+        super();
+        this.logLevel = logLevel;
+        this.logsHome = logsHome;
+        this._loggers = new ResourceMap();
+        this._onDidChangeLoggers = this._register(new Emitter);
+        this.onDidChangeLoggers = this._onDidChangeLoggers.event;
+        this._onDidChangeLogLevel = this._register(new Emitter);
+        this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
+        this._onDidChangeVisibility = this._register(new Emitter);
+        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
+        if (loggerResources) {
+            for (const loggerResource of loggerResources) {
+                this._loggers.set(loggerResource.resource, { logger: undefined, info: loggerResource });
+            }
+        }
+    }
+    getLoggerEntry(resourceOrId) {
+        if (isString(resourceOrId)) {
+            return [...this._loggers.values()].find(logger => logger.info.id === resourceOrId);
+        }
+        return this._loggers.get(resourceOrId);
+    }
+    getLogger(resourceOrId) {
+        return this.getLoggerEntry(resourceOrId)?.logger;
+    }
+    createLogger(idOrResource, options) {
+        const resource = this.toResource(idOrResource);
+        const id = isString(idOrResource) ? idOrResource : (options?.id ?? hash(resource.toString()).toString(16));
+        let logger = this._loggers.get(resource)?.logger;
+        const logLevel = options?.logLevel === 'always' ? LogLevel.Trace : options?.logLevel;
+        if (!logger) {
+            logger = this.doCreateLogger(resource, logLevel ?? this.getLogLevel(resource) ?? this.logLevel, { ...options, id });
+        }
+        const loggerEntry = {
+            logger,
+            info: { resource, id, logLevel, name: options?.name, hidden: options?.hidden, extensionId: options?.extensionId, when: options?.when }
+        };
+        this.registerLogger(loggerEntry.info);
+        // TODO: @sandy081 Remove this once registerLogger can take ILogger
+        this._loggers.set(resource, loggerEntry);
+        return logger;
+    }
+    toResource(idOrResource) {
+        return isString(idOrResource) ? joinPath(this.logsHome, `${idOrResource}.log`) : idOrResource;
+    }
+    setLogLevel(arg1, arg2) {
+        if (URI.isUri(arg1)) {
+            const resource = arg1;
+            const logLevel = arg2;
+            const logger = this._loggers.get(resource);
+            if (logger && logLevel !== logger.info.logLevel) {
+                logger.info.logLevel = logLevel === this.logLevel ? undefined : logLevel;
+                logger.logger?.setLevel(logLevel);
+                this._loggers.set(logger.info.resource, logger);
+                this._onDidChangeLogLevel.fire([resource, logLevel]);
+            }
+        }
+        else {
+            this.logLevel = arg1;
+            for (const [resource, logger] of this._loggers.entries()) {
+                if (this._loggers.get(resource)?.info.logLevel === undefined) {
+                    logger.logger?.setLevel(this.logLevel);
+                }
+            }
+            this._onDidChangeLogLevel.fire(this.logLevel);
+        }
+    }
+    setVisibility(resourceOrId, visibility) {
+        const logger = this.getLoggerEntry(resourceOrId);
+        if (logger && visibility !== !logger.info.hidden) {
+            logger.info.hidden = !visibility;
+            this._loggers.set(logger.info.resource, logger);
+            this._onDidChangeVisibility.fire([logger.info.resource, visibility]);
+        }
+    }
+    getLogLevel(resource) {
+        let logLevel;
+        if (resource) {
+            logLevel = this._loggers.get(resource)?.info.logLevel;
+        }
+        return logLevel ?? this.logLevel;
+    }
+    registerLogger(resource) {
+        const existing = this._loggers.get(resource.resource);
+        if (existing) {
+            if (existing.info.hidden !== resource.hidden) {
+                this.setVisibility(resource.resource, !resource.hidden);
+            }
+        }
+        else {
+            this._loggers.set(resource.resource, { info: resource, logger: undefined });
+            this._onDidChangeLoggers.fire({ added: [resource], removed: [] });
+        }
+    }
+    deregisterLogger(resource) {
+        const existing = this._loggers.get(resource);
+        if (existing) {
+            if (existing.logger) {
+                existing.logger.dispose();
+            }
+            this._loggers.delete(resource);
+            this._onDidChangeLoggers.fire({ added: [], removed: [existing.info] });
+        }
+    }
+    *getRegisteredLoggers() {
+        for (const entry of this._loggers.values()) {
+            yield entry.info;
+        }
+    }
+    getRegisteredLogger(resource) {
+        return this._loggers.get(resource)?.info;
+    }
+    dispose() {
+        this._loggers.forEach(logger => logger.logger?.dispose());
+        this._loggers.clear();
+        super.dispose();
+    }
+}
+export class NullLogger {
+    constructor() {
+        this.onDidChangeLogLevel = new Emitter().event;
+    }
+    setLevel(level) { }
+    getLevel() { return LogLevel.Info; }
+    trace(message, ...args) { }
+    debug(message, ...args) { }
+    info(message, ...args) { }
+    warn(message, ...args) { }
+    error(message, ...args) { }
+    critical(message, ...args) { }
+    dispose() { }
+    flush() { }
+}
+export class NullLogService extends NullLogger {
+}
+export function getLogLevel(environmentService) {
+    if (environmentService.verbose) {
+        return LogLevel.Trace;
+    }
+    if (typeof environmentService.logLevel === 'string') {
+        const logLevel = parseLogLevel(environmentService.logLevel.toLowerCase());
+        if (logLevel !== undefined) {
+            return logLevel;
+        }
+    }
+    return DEFAULT_LOG_LEVEL;
+}
 export function LogLevelToString(logLevel) {
     switch (logLevel) {
         case LogLevel.Trace: return 'trace';
@@ -148,5 +510,24 @@
         case LogLevel.Off: return 'off';
     }
 }
+export function parseLogLevel(logLevel) {
+    switch (logLevel) {
+        case 'trace':
+            return LogLevel.Trace;
+        case 'debug':
+            return LogLevel.Debug;
+        case 'info':
+            return LogLevel.Info;
+        case 'warn':
+            return LogLevel.Warning;
+        case 'error':
+            return LogLevel.Error;
+        case 'critical':
+            return LogLevel.Error;
+        case 'off':
+            return LogLevel.Off;
+    }
+    return undefined;
+}
 // Contexts
 export const CONTEXT_LOG_LEVEL = new RawContextKey('logLevel', LogLevelToString(LogLevel.Info));
diff -urN -x '*.map' a/vs/platform/log/common/logService.js b/vs/platform/log/common/logService.js
--- a/vs/platform/log/common/logService.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/log/common/logService.js	2023-12-06 14:23:14.391854805 +0000
@@ -34,4 +34,7 @@
     error(message, ...args) {
         this.logger.error(message, ...args);
     }
+    flush() {
+        this.logger.flush();
+    }
 }
diff -urN -x '*.map' a/vs/platform/markers/common/markerService.js b/vs/platform/markers/common/markerService.js
--- a/vs/platform/markers/common/markerService.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/markers/common/markerService.js	2023-12-06 14:23:14.391854805 +0000
@@ -31,7 +31,7 @@
     }
     get(resource, owner) {
         const ownerMap = this._byResource.get(resource);
-        return ownerMap === null || ownerMap === void 0 ? void 0 : ownerMap.get(owner);
+        return ownerMap?.get(owner);
     }
     delete(resource, owner) {
         let removedA = false;
@@ -50,12 +50,11 @@
         return removedA && removedB;
     }
     values(key) {
-        var _a, _b, _c, _d;
         if (typeof key === 'string') {
-            return (_b = (_a = this._byOwner.get(key)) === null || _a === void 0 ? void 0 : _a.values()) !== null && _b !== void 0 ? _b : Iterable.empty();
+            return this._byOwner.get(key)?.values() ?? Iterable.empty();
         }
         if (URI.isUri(key)) {
-            return (_d = (_c = this._byResource.get(key)) === null || _c === void 0 ? void 0 : _c.values()) !== null && _d !== void 0 ? _d : Iterable.empty();
+            return this._byResource.get(key)?.values() ?? Iterable.empty();
         }
         return Iterable.map(Iterable.concat(...this._byOwner.values()), map => map[1]);
     }
@@ -133,6 +132,9 @@
         this._stats.dispose();
         this._onMarkerChanged.dispose();
     }
+    getStatistics() {
+        return this._stats;
+    }
     remove(owner, resources) {
         for (const resource of resources || []) {
             this.changeOne(owner, resource, []);
@@ -266,7 +268,7 @@
         }
         else {
             // of one resource OR owner
-            const iterable = this._data.values(resource !== null && resource !== void 0 ? resource : owner);
+            const iterable = this._data.values(resource ?? owner);
             const result = [];
             for (const markers of iterable) {
                 for (const data of markers) {
diff -urN -x '*.map' a/vs/platform/markers/common/markers.js b/vs/platform/markers/common/markers.js
--- a/vs/platform/markers/common/markers.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/markers/common/markers.js	2023-12-06 14:23:14.391854805 +0000
@@ -3,7 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import Severity from '../../../base/common/severity.js';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export var MarkerSeverity;
 (function (MarkerSeverity) {
@@ -18,9 +18,9 @@
     }
     MarkerSeverity.compare = compare;
     const _displayStrings = Object.create(null);
-    _displayStrings[MarkerSeverity.Error] = localize('sev.error', "Error");
-    _displayStrings[MarkerSeverity.Warning] = localize('sev.warning', "Warning");
-    _displayStrings[MarkerSeverity.Info] = localize('sev.info', "Info");
+    _displayStrings[MarkerSeverity.Error] = localizeWithPath('vs/platform/markers/common/markers', 'sev.error', "Error");
+    _displayStrings[MarkerSeverity.Warning] = localizeWithPath('vs/platform/markers/common/markers', 'sev.warning', "Warning");
+    _displayStrings[MarkerSeverity.Info] = localizeWithPath('vs/platform/markers/common/markers', 'sev.info', "Info");
     function toString(a) {
         return _displayStrings[a] || '';
     }
diff -urN -x '*.map' a/vs/platform/notification/common/notification.js b/vs/platform/notification/common/notification.js
--- a/vs/platform/notification/common/notification.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/notification/common/notification.js	2023-12-06 14:23:14.391854805 +0000
@@ -1,6 +1,74 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { Event } from '../../../base/common/event.js';
 import BaseSeverity from '../../../base/common/severity.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export var Severity = BaseSeverity;
 export const INotificationService = createDecorator('notificationService');
+export var NotificationPriority;
+(function (NotificationPriority) {
+    /**
+     * Default priority: notification will be visible unless do not disturb mode is enabled.
+     */
+    NotificationPriority[NotificationPriority["DEFAULT"] = 0] = "DEFAULT";
+    /**
+     * Silent priority: notification will only be visible from the notifications center.
+     */
+    NotificationPriority[NotificationPriority["SILENT"] = 1] = "SILENT";
+    /**
+     * Urgent priority: notification will be visible even when do not disturb mode is enabled.
+     */
+    NotificationPriority[NotificationPriority["URGENT"] = 2] = "URGENT";
+})(NotificationPriority || (NotificationPriority = {}));
+export var NeverShowAgainScope;
+(function (NeverShowAgainScope) {
+    /**
+     * Will never show this notification on the current workspace again.
+     */
+    NeverShowAgainScope[NeverShowAgainScope["WORKSPACE"] = 0] = "WORKSPACE";
+    /**
+     * Will never show this notification on any workspace of the same
+     * profile again.
+     */
+    NeverShowAgainScope[NeverShowAgainScope["PROFILE"] = 1] = "PROFILE";
+    /**
+     * Will never show this notification on any workspace across all
+     * profiles again.
+     */
+    NeverShowAgainScope[NeverShowAgainScope["APPLICATION"] = 2] = "APPLICATION";
+})(NeverShowAgainScope || (NeverShowAgainScope = {}));
+export var NotificationsFilter;
+(function (NotificationsFilter) {
+    /**
+     * No filter is enabled.
+     */
+    NotificationsFilter[NotificationsFilter["OFF"] = 0] = "OFF";
+    /**
+     * All notifications are configured as silent. See
+     * `INotificationProperties.silent` for more info.
+     */
+    NotificationsFilter[NotificationsFilter["SILENT"] = 1] = "SILENT";
+    /**
+     * All notifications are silent except error notifications.
+    */
+    NotificationsFilter[NotificationsFilter["ERROR"] = 2] = "ERROR";
+})(NotificationsFilter || (NotificationsFilter = {}));
 export class NoOpNotification {
+    constructor() {
+        this.progress = new NoOpProgress();
+        this.onDidClose = Event.None;
+        this.onDidChangeVisibility = Event.None;
+    }
+    updateSeverity(severity) { }
+    updateMessage(message) { }
+    updateActions(actions) { }
+    close() { }
+}
+export class NoOpProgress {
+    infinite() { }
+    done() { }
+    total(value) { }
+    worked(value) { }
 }
diff -urN -x '*.map' a/vs/platform/opener/browser/link.js b/vs/platform/opener/browser/link.js
--- a/vs/platform/opener/browser/link.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/opener/browser/link.js	2023-12-06 14:23:14.391854805 +0000
@@ -11,7 +11,7 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-import { $, append, EventHelper } from '../../../base/browser/dom.js';
+import { $, append, EventHelper, clearNode } from '../../../base/browser/dom.js';
 import { DomEmitter } from '../../../base/browser/event.js';
 import { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';
 import { EventType as TouchEventType, Gesture } from '../../../base/browser/touch.js';
@@ -42,13 +42,29 @@
         }
         this._enabled = enabled;
     }
+    set link(link) {
+        if (typeof link.label === 'string') {
+            this.el.textContent = link.label;
+        }
+        else {
+            clearNode(this.el);
+            this.el.appendChild(link.label);
+        }
+        this.el.href = link.href;
+        if (typeof link.tabIndex !== 'undefined') {
+            this.el.tabIndex = link.tabIndex;
+        }
+        if (typeof link.title !== 'undefined') {
+            this.el.title = link.title;
+        }
+        this._link = link;
+    }
     constructor(container, _link, options = {}, openerService) {
-        var _a;
         super();
         this._link = _link;
         this._enabled = true;
         this.el = append(container, $('a.monaco-link', {
-            tabIndex: (_a = _link.tabIndex) !== null && _a !== void 0 ? _a : 0,
+            tabIndex: _link.tabIndex ?? 0,
             href: _link.href,
             title: _link.title
         }, _link.label));
@@ -65,7 +81,7 @@
                 return;
             }
             EventHelper.stop(e, true);
-            if (options === null || options === void 0 ? void 0 : options.opener) {
+            if (options?.opener) {
                 options.opener(this._link.href);
             }
             else {
diff -urN -x '*.map' a/vs/platform/opener/common/opener.js b/vs/platform/opener/common/opener.js
--- a/vs/platform/opener/common/opener.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/opener/common/opener.js	2023-12-06 14:23:14.391854805 +0000
@@ -18,6 +18,16 @@
     return schemes.some(scheme => matchesScheme(target, scheme));
 }
 /**
+ * Encodes selection into the `URI`.
+ *
+ * IMPORTANT: you MUST use `extractSelection` to separate the selection
+ * again from the original `URI` before passing the `URI` into any
+ * component that is not aware of selections.
+ */
+export function withSelection(uri, selection) {
+    return uri.with({ fragment: `${selection.startLineNumber},${selection.startColumn}${selection.endLineNumber ? `-${selection.endLineNumber}${selection.endColumn ? `,${selection.endColumn}` : ''}` : ''}` });
+}
+/**
  * file:///some/file.js#73
  * file:///some/file.js#L73
  * file:///some/file.js#73,84
diff -urN -x '*.map' a/vs/platform/policy/common/policy.js b/vs/platform/policy/common/policy.js
--- a/vs/platform/policy/common/policy.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/policy/common/policy.js	2023-12-06 14:23:14.391854805 +0000
@@ -1 +1,40 @@
-export {};
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { Emitter, Event } from '../../../base/common/event.js';
+import { Iterable } from '../../../base/common/iterator.js';
+import { Disposable } from '../../../base/common/lifecycle.js';
+import { createDecorator } from '../../instantiation/common/instantiation.js';
+export const IPolicyService = createDecorator('policy');
+export class AbstractPolicyService extends Disposable {
+    constructor() {
+        super(...arguments);
+        this.policyDefinitions = {};
+        this.policies = new Map();
+        this._onDidChange = this._register(new Emitter());
+        this.onDidChange = this._onDidChange.event;
+    }
+    async updatePolicyDefinitions(policyDefinitions) {
+        const size = Object.keys(this.policyDefinitions).length;
+        this.policyDefinitions = { ...policyDefinitions, ...this.policyDefinitions };
+        if (size !== Object.keys(this.policyDefinitions).length) {
+            await this._updatePolicyDefinitions(policyDefinitions);
+        }
+        return Iterable.reduce(this.policies.entries(), (r, [name, value]) => ({ ...r, [name]: value }), {});
+    }
+    getPolicyValue(name) {
+        return this.policies.get(name);
+    }
+    serialize() {
+        return Iterable.reduce(Object.entries(this.policyDefinitions), (r, [name, definition]) => ({ ...r, [name]: { definition, value: this.policies.get(name) } }), {});
+    }
+}
+export class NullPolicyService {
+    constructor() {
+        this.onDidChange = Event.None;
+    }
+    async updatePolicyDefinitions() { return {}; }
+    getPolicyValue() { return undefined; }
+    serialize() { return undefined; }
+}
diff -urN -x '*.map' a/vs/platform/product/common/productService.js b/vs/platform/product/common/productService.js
--- a/vs/platform/product/common/productService.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/product/common/productService.js	2023-12-06 14:23:14.391854805 +0000
@@ -0,0 +1,7 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { createDecorator } from '../../instantiation/common/instantiation.js';
+export const IProductService = createDecorator('productService');
+export const productSchemaId = 'vscode://schemas/vscode-product';
diff -urN -x '*.map' a/vs/platform/progress/common/progress.js b/vs/platform/progress/common/progress.js
--- a/vs/platform/progress/common/progress.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/progress/common/progress.js	2023-12-06 14:23:14.391854805 +0000
@@ -1,3 +1,19 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
+    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
+    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
+    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
+    return c > 3 && r && Object.defineProperty(target, key, r), r;
+};
+var __param = (this && this.__param) || function (paramIndex, decorator) {
+    return function (target, key) { decorator(target, key, paramIndex); }
+};
+import { DeferredPromise } from '../../../base/common/async.js';
+import { CancellationTokenSource } from '../../../base/common/cancellation.js';
+import { Disposable, DisposableStore, toDisposable } from '../../../base/common/lifecycle.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export const IProgressService = createDecorator('progressService');
 export const emptyProgressRunner = Object.freeze({
@@ -6,9 +22,10 @@
     done() { }
 });
 export class Progress {
+    get value() { return this._value; }
     constructor(callback, opts) {
         this.callback = callback;
-        this.report = (opts === null || opts === void 0 ? void 0 : opts.async)
+        this.report = opts?.async
             ? this._reportAsync.bind(this)
             : this._reportSync.bind(this);
     }
@@ -25,4 +42,71 @@
     }
 }
 Progress.None = Object.freeze({ report() { } });
+/**
+ * RAII-style progress instance that allows imperative reporting and hides
+ * once `dispose()` is called.
+ */
+let UnmanagedProgress = class UnmanagedProgress extends Disposable {
+    constructor(options, progressService) {
+        super();
+        this.deferred = new DeferredPromise();
+        progressService.withProgress(options, reporter => {
+            this.reporter = reporter;
+            if (this.lastStep) {
+                reporter.report(this.lastStep);
+            }
+            return this.deferred.p;
+        });
+        this._register(toDisposable(() => this.deferred.complete()));
+    }
+    report(step) {
+        if (this.reporter) {
+            this.reporter.report(step);
+        }
+        else {
+            this.lastStep = step;
+        }
+    }
+};
+UnmanagedProgress = __decorate([
+    __param(1, IProgressService)
+], UnmanagedProgress);
+export { UnmanagedProgress };
+export class LongRunningOperation extends Disposable {
+    constructor(progressIndicator) {
+        super();
+        this.progressIndicator = progressIndicator;
+        this.currentOperationId = 0;
+        this.currentOperationDisposables = this._register(new DisposableStore());
+    }
+    start(progressDelay) {
+        // Stop any previous operation
+        this.stop();
+        // Start new
+        const newOperationId = ++this.currentOperationId;
+        const newOperationToken = new CancellationTokenSource();
+        this.currentProgressTimeout = setTimeout(() => {
+            if (newOperationId === this.currentOperationId) {
+                this.currentProgressRunner = this.progressIndicator.show(true);
+            }
+        }, progressDelay);
+        this.currentOperationDisposables.add(toDisposable(() => clearTimeout(this.currentProgressTimeout)));
+        this.currentOperationDisposables.add(toDisposable(() => newOperationToken.cancel()));
+        this.currentOperationDisposables.add(toDisposable(() => this.currentProgressRunner ? this.currentProgressRunner.done() : undefined));
+        return {
+            id: newOperationId,
+            token: newOperationToken.token,
+            stop: () => this.doStop(newOperationId),
+            isCurrent: () => this.currentOperationId === newOperationId
+        };
+    }
+    stop() {
+        this.doStop(this.currentOperationId);
+    }
+    doStop(operationId) {
+        if (this.currentOperationId === operationId) {
+            this.currentOperationDisposables.clear();
+        }
+    }
+}
 export const IEditorProgressService = createDecorator('editorProgressService');
diff -urN -x '*.map' a/vs/platform/quickinput/browser/commandsQuickAccess.js b/vs/platform/quickinput/browser/commandsQuickAccess.js
--- a/vs/platform/quickinput/browser/commandsQuickAccess.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/quickinput/browser/commandsQuickAccess.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,334 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
-    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
-    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
-    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
-    return c > 3 && r && Object.defineProperty(target, key, r), r;
-};
-var __param = (this && this.__param) || function (paramIndex, decorator) {
-    return function (target, key) { decorator(target, key, paramIndex); }
-};
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var AbstractCommandsQuickAccessProvider_1, CommandsHistory_1;
-import { toErrorMessage } from '../../../base/common/errorMessage.js';
-import { isCancellationError } from '../../../base/common/errors.js';
-import { matchesContiguousSubString, matchesPrefix, matchesWords, or } from '../../../base/common/filters.js';
-import { createSingleCallFunction } from '../../../base/common/functional.js';
-import { Disposable } from '../../../base/common/lifecycle.js';
-import { LRUCache } from '../../../base/common/map.js';
-import { TfIdfCalculator, normalizeTfIdfScores } from '../../../base/common/tfIdf.js';
-import { localize } from '../../../nls.js';
-import { ICommandService } from '../../commands/common/commands.js';
-import { IConfigurationService } from '../../configuration/common/configuration.js';
-import { IDialogService } from '../../dialogs/common/dialogs.js';
-import { IInstantiationService } from '../../instantiation/common/instantiation.js';
-import { IKeybindingService } from '../../keybinding/common/keybinding.js';
-import { PickerQuickAccessProvider } from './pickerQuickAccess.js';
-import { IStorageService } from '../../storage/common/storage.js';
-import { ITelemetryService } from '../../telemetry/common/telemetry.js';
-let AbstractCommandsQuickAccessProvider = AbstractCommandsQuickAccessProvider_1 = class AbstractCommandsQuickAccessProvider extends PickerQuickAccessProvider {
-    constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {
-        super(AbstractCommandsQuickAccessProvider_1.PREFIX, options);
-        this.instantiationService = instantiationService;
-        this.keybindingService = keybindingService;
-        this.commandService = commandService;
-        this.telemetryService = telemetryService;
-        this.dialogService = dialogService;
-        this.commandsHistory = this._register(this.instantiationService.createInstance(CommandsHistory));
-        this.options = options;
-    }
-    _getPicks(filter, _disposables, token, runOptions) {
-        var _a, _b, _c, _d;
-        return __awaiter(this, void 0, void 0, function* () {
-            // Ask subclass for all command picks
-            const allCommandPicks = yield this.getCommandPicks(token);
-            if (token.isCancellationRequested) {
-                return [];
-            }
-            const runTfidf = createSingleCallFunction(() => {
-                const tfidf = new TfIdfCalculator();
-                tfidf.updateDocuments(allCommandPicks.map(commandPick => ({
-                    key: commandPick.commandId,
-                    textChunks: [commandPick.label + (commandPick.commandAlias ? ` ${commandPick.commandAlias}` : '')]
-                })));
-                const result = tfidf.calculateScores(filter, token);
-                return normalizeTfIdfScores(result)
-                    .filter(score => score.score > AbstractCommandsQuickAccessProvider_1.TFIDF_THRESHOLD)
-                    .slice(0, AbstractCommandsQuickAccessProvider_1.TFIDF_MAX_RESULTS);
-            });
-            // Filter
-            const filteredCommandPicks = [];
-            for (const commandPick of allCommandPicks) {
-                const labelHighlights = (_a = AbstractCommandsQuickAccessProvider_1.WORD_FILTER(filter, commandPick.label)) !== null && _a !== void 0 ? _a : undefined;
-                const aliasHighlights = commandPick.commandAlias ? (_b = AbstractCommandsQuickAccessProvider_1.WORD_FILTER(filter, commandPick.commandAlias)) !== null && _b !== void 0 ? _b : undefined : undefined;
-                // Add if matching in label or alias
-                if (labelHighlights || aliasHighlights) {
-                    commandPick.highlights = {
-                        label: labelHighlights,
-                        detail: this.options.showAlias ? aliasHighlights : undefined
-                    };
-                    filteredCommandPicks.push(commandPick);
-                }
-                // Also add if we have a 100% command ID match
-                else if (filter === commandPick.commandId) {
-                    filteredCommandPicks.push(commandPick);
-                }
-                // Handle tf-idf scoring for the rest if there's a filter
-                else if (filter.length >= 3) {
-                    const tfidf = runTfidf();
-                    if (token.isCancellationRequested) {
-                        return [];
-                    }
-                    // Add if we have a tf-idf score
-                    const tfidfScore = tfidf.find(score => score.key === commandPick.commandId);
-                    if (tfidfScore) {
-                        commandPick.tfIdfScore = tfidfScore.score;
-                        filteredCommandPicks.push(commandPick);
-                    }
-                }
-            }
-            // Add description to commands that have duplicate labels
-            const mapLabelToCommand = new Map();
-            for (const commandPick of filteredCommandPicks) {
-                const existingCommandForLabel = mapLabelToCommand.get(commandPick.label);
-                if (existingCommandForLabel) {
-                    commandPick.description = commandPick.commandId;
-                    existingCommandForLabel.description = existingCommandForLabel.commandId;
-                }
-                else {
-                    mapLabelToCommand.set(commandPick.label, commandPick);
-                }
-            }
-            // Sort by MRU order and fallback to name otherwise
-            filteredCommandPicks.sort((commandPickA, commandPickB) => {
-                // If a result came from tf-idf, we want to put that towards the bottom
-                if (commandPickA.tfIdfScore && commandPickB.tfIdfScore) {
-                    if (commandPickA.tfIdfScore === commandPickB.tfIdfScore) {
-                        return commandPickA.label.localeCompare(commandPickB.label); // prefer lexicographically smaller command
-                    }
-                    return commandPickB.tfIdfScore - commandPickA.tfIdfScore; // prefer higher tf-idf score
-                }
-                else if (commandPickA.tfIdfScore) {
-                    return 1; // first command has a score but other doesn't so other wins
-                }
-                else if (commandPickB.tfIdfScore) {
-                    return -1; // other command has a score but first doesn't so first wins
-                }
-                const commandACounter = this.commandsHistory.peek(commandPickA.commandId);
-                const commandBCounter = this.commandsHistory.peek(commandPickB.commandId);
-                if (commandACounter && commandBCounter) {
-                    return commandACounter > commandBCounter ? -1 : 1; // use more recently used command before older
-                }
-                if (commandACounter) {
-                    return -1; // first command was used, so it wins over the non used one
-                }
-                if (commandBCounter) {
-                    return 1; // other command was used so it wins over the command
-                }
-                if (this.options.suggestedCommandIds) {
-                    const commandASuggestion = this.options.suggestedCommandIds.has(commandPickA.commandId);
-                    const commandBSuggestion = this.options.suggestedCommandIds.has(commandPickB.commandId);
-                    if (commandASuggestion && commandBSuggestion) {
-                        return 0; // honor the order of the array
-                    }
-                    if (commandASuggestion) {
-                        return -1; // first command was suggested, so it wins over the non suggested one
-                    }
-                    if (commandBSuggestion) {
-                        return 1; // other command was suggested so it wins over the command
-                    }
-                }
-                // both commands were never used, so we sort by name
-                return commandPickA.label.localeCompare(commandPickB.label);
-            });
-            const commandPicks = [];
-            let addOtherSeparator = false;
-            let addSuggestedSeparator = true;
-            let addCommonlyUsedSeparator = !!this.options.suggestedCommandIds;
-            for (let i = 0; i < filteredCommandPicks.length; i++) {
-                const commandPick = filteredCommandPicks[i];
-                // Separator: recently used
-                if (i === 0 && this.commandsHistory.peek(commandPick.commandId)) {
-                    commandPicks.push({ type: 'separator', label: localize('recentlyUsed', "recently used") });
-                    addOtherSeparator = true;
-                }
-                if (addSuggestedSeparator && commandPick.tfIdfScore !== undefined) {
-                    commandPicks.push({ type: 'separator', label: localize('suggested', "similar commands") });
-                    addSuggestedSeparator = false;
-                }
-                // Separator: commonly used
-                if (addCommonlyUsedSeparator && commandPick.tfIdfScore === undefined && !this.commandsHistory.peek(commandPick.commandId) && ((_c = this.options.suggestedCommandIds) === null || _c === void 0 ? void 0 : _c.has(commandPick.commandId))) {
-                    commandPicks.push({ type: 'separator', label: localize('commonlyUsed', "commonly used") });
-                    addOtherSeparator = true;
-                    addCommonlyUsedSeparator = false;
-                }
-                // Separator: other commands
-                if (addOtherSeparator && commandPick.tfIdfScore === undefined && !this.commandsHistory.peek(commandPick.commandId) && !((_d = this.options.suggestedCommandIds) === null || _d === void 0 ? void 0 : _d.has(commandPick.commandId))) {
-                    commandPicks.push({ type: 'separator', label: localize('morecCommands', "other commands") });
-                    addOtherSeparator = false;
-                }
-                // Command
-                commandPicks.push(this.toCommandPick(commandPick, runOptions));
-            }
-            if (!this.hasAdditionalCommandPicks(filter, token)) {
-                return commandPicks;
-            }
-            return {
-                picks: commandPicks,
-                additionalPicks: (() => __awaiter(this, void 0, void 0, function* () {
-                    var _e;
-                    const additionalCommandPicks = yield this.getAdditionalCommandPicks(allCommandPicks, filteredCommandPicks, filter, token);
-                    if (token.isCancellationRequested) {
-                        return [];
-                    }
-                    const commandPicks = additionalCommandPicks.map(commandPick => this.toCommandPick(commandPick, runOptions));
-                    // Basically, if we haven't already added a separator, we add one before the additional picks so long
-                    // as one hasn't been added to the start of the array.
-                    if (addSuggestedSeparator && ((_e = commandPicks[0]) === null || _e === void 0 ? void 0 : _e.type) !== 'separator') {
-                        commandPicks.unshift({ type: 'separator', label: localize('suggested', "similar commands") });
-                    }
-                    return commandPicks;
-                }))()
-            };
-        });
-    }
-    toCommandPick(commandPick, runOptions) {
-        if (commandPick.type === 'separator') {
-            return commandPick;
-        }
-        const keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);
-        const ariaLabel = keybinding ?
-            localize('commandPickAriaLabelWithKeybinding', "{0}, {1}", commandPick.label, keybinding.getAriaLabel()) :
-            commandPick.label;
-        return Object.assign(Object.assign({}, commandPick), { ariaLabel, detail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : undefined, keybinding, accept: () => __awaiter(this, void 0, void 0, function* () {
-                var _a, _b;
-                // Add to history
-                this.commandsHistory.push(commandPick.commandId);
-                // Telementry
-                this.telemetryService.publicLog2('workbenchActionExecuted', {
-                    id: commandPick.commandId,
-                    from: (_a = runOptions === null || runOptions === void 0 ? void 0 : runOptions.from) !== null && _a !== void 0 ? _a : 'quick open'
-                });
-                // Run
-                try {
-                    ((_b = commandPick.args) === null || _b === void 0 ? void 0 : _b.length)
-                        ? yield this.commandService.executeCommand(commandPick.commandId, ...commandPick.args)
-                        : yield this.commandService.executeCommand(commandPick.commandId);
-                }
-                catch (error) {
-                    if (!isCancellationError(error)) {
-                        this.dialogService.error(localize('canNotRun', "Command '{0}' resulted in an error", commandPick.label), toErrorMessage(error));
-                    }
-                }
-            }) });
-    }
-};
-AbstractCommandsQuickAccessProvider.PREFIX = '>';
-AbstractCommandsQuickAccessProvider.TFIDF_THRESHOLD = 0.5;
-AbstractCommandsQuickAccessProvider.TFIDF_MAX_RESULTS = 5;
-AbstractCommandsQuickAccessProvider.WORD_FILTER = or(matchesPrefix, matchesWords, matchesContiguousSubString);
-AbstractCommandsQuickAccessProvider = AbstractCommandsQuickAccessProvider_1 = __decorate([
-    __param(1, IInstantiationService),
-    __param(2, IKeybindingService),
-    __param(3, ICommandService),
-    __param(4, ITelemetryService),
-    __param(5, IDialogService)
-], AbstractCommandsQuickAccessProvider);
-export { AbstractCommandsQuickAccessProvider };
-let CommandsHistory = CommandsHistory_1 = class CommandsHistory extends Disposable {
-    constructor(storageService, configurationService) {
-        super();
-        this.storageService = storageService;
-        this.configurationService = configurationService;
-        this.configuredCommandsHistoryLength = 0;
-        this.updateConfiguration();
-        this.load();
-        this.registerListeners();
-    }
-    registerListeners() {
-        this._register(this.configurationService.onDidChangeConfiguration(e => this.updateConfiguration(e)));
-    }
-    updateConfiguration(e) {
-        if (e && !e.affectsConfiguration('workbench.commandPalette.history')) {
-            return;
-        }
-        this.configuredCommandsHistoryLength = CommandsHistory_1.getConfiguredCommandHistoryLength(this.configurationService);
-        if (CommandsHistory_1.cache && CommandsHistory_1.cache.limit !== this.configuredCommandsHistoryLength) {
-            CommandsHistory_1.cache.limit = this.configuredCommandsHistoryLength;
-            CommandsHistory_1.saveState(this.storageService);
-        }
-    }
-    load() {
-        const raw = this.storageService.get(CommandsHistory_1.PREF_KEY_CACHE, 0 /* StorageScope.PROFILE */);
-        let serializedCache;
-        if (raw) {
-            try {
-                serializedCache = JSON.parse(raw);
-            }
-            catch (error) {
-                // invalid data
-            }
-        }
-        const cache = CommandsHistory_1.cache = new LRUCache(this.configuredCommandsHistoryLength, 1);
-        if (serializedCache) {
-            let entries;
-            if (serializedCache.usesLRU) {
-                entries = serializedCache.entries;
-            }
-            else {
-                entries = serializedCache.entries.sort((a, b) => a.value - b.value);
-            }
-            entries.forEach(entry => cache.set(entry.key, entry.value));
-        }
-        CommandsHistory_1.counter = this.storageService.getNumber(CommandsHistory_1.PREF_KEY_COUNTER, 0 /* StorageScope.PROFILE */, CommandsHistory_1.counter);
-    }
-    push(commandId) {
-        if (!CommandsHistory_1.cache) {
-            return;
-        }
-        CommandsHistory_1.cache.set(commandId, CommandsHistory_1.counter++); // set counter to command
-        CommandsHistory_1.saveState(this.storageService);
-    }
-    peek(commandId) {
-        var _a;
-        return (_a = CommandsHistory_1.cache) === null || _a === void 0 ? void 0 : _a.peek(commandId);
-    }
-    static saveState(storageService) {
-        if (!CommandsHistory_1.cache) {
-            return;
-        }
-        const serializedCache = { usesLRU: true, entries: [] };
-        CommandsHistory_1.cache.forEach((value, key) => serializedCache.entries.push({ key, value }));
-        storageService.store(CommandsHistory_1.PREF_KEY_CACHE, JSON.stringify(serializedCache), 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);
-        storageService.store(CommandsHistory_1.PREF_KEY_COUNTER, CommandsHistory_1.counter, 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);
-    }
-    static getConfiguredCommandHistoryLength(configurationService) {
-        var _a, _b;
-        const config = configurationService.getValue();
-        const configuredCommandHistoryLength = (_b = (_a = config.workbench) === null || _a === void 0 ? void 0 : _a.commandPalette) === null || _b === void 0 ? void 0 : _b.history;
-        if (typeof configuredCommandHistoryLength === 'number') {
-            return configuredCommandHistoryLength;
-        }
-        return CommandsHistory_1.DEFAULT_COMMANDS_HISTORY_LENGTH;
-    }
-};
-CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH = 50;
-CommandsHistory.PREF_KEY_CACHE = 'commandPalette.mru.cache';
-CommandsHistory.PREF_KEY_COUNTER = 'commandPalette.mru.counter';
-CommandsHistory.counter = 1;
-CommandsHistory = CommandsHistory_1 = __decorate([
-    __param(0, IStorageService),
-    __param(1, IConfigurationService)
-], CommandsHistory);
-export { CommandsHistory };
diff -urN -x '*.map' a/vs/platform/quickinput/browser/helpQuickAccess.js b/vs/platform/quickinput/browser/helpQuickAccess.js
--- a/vs/platform/quickinput/browser/helpQuickAccess.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/quickinput/browser/helpQuickAccess.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,74 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
-    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
-    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
-    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
-    return c > 3 && r && Object.defineProperty(target, key, r), r;
-};
-var __param = (this && this.__param) || function (paramIndex, decorator) {
-    return function (target, key) { decorator(target, key, paramIndex); }
-};
-var HelpQuickAccessProvider_1;
-import { localize } from '../../../nls.js';
-import { Registry } from '../../registry/common/platform.js';
-import { DisposableStore } from '../../../base/common/lifecycle.js';
-import { IKeybindingService } from '../../keybinding/common/keybinding.js';
-import { Extensions } from '../common/quickAccess.js';
-import { IQuickInputService } from '../common/quickInput.js';
-let HelpQuickAccessProvider = HelpQuickAccessProvider_1 = class HelpQuickAccessProvider {
-    constructor(quickInputService, keybindingService) {
-        this.quickInputService = quickInputService;
-        this.keybindingService = keybindingService;
-        this.registry = Registry.as(Extensions.Quickaccess);
-    }
-    provide(picker) {
-        const disposables = new DisposableStore();
-        // Open a picker with the selected value if picked
-        disposables.add(picker.onDidAccept(() => {
-            const [item] = picker.selectedItems;
-            if (item) {
-                this.quickInputService.quickAccess.show(item.prefix, { preserveValue: true });
-            }
-        }));
-        // Also open a picker when we detect the user typed the exact
-        // name of a provider (e.g. `?term` for terminals)
-        disposables.add(picker.onDidChangeValue(value => {
-            const providerDescriptor = this.registry.getQuickAccessProvider(value.substr(HelpQuickAccessProvider_1.PREFIX.length));
-            if (providerDescriptor && providerDescriptor.prefix && providerDescriptor.prefix !== HelpQuickAccessProvider_1.PREFIX) {
-                this.quickInputService.quickAccess.show(providerDescriptor.prefix, { preserveValue: true });
-            }
-        }));
-        // Fill in all providers
-        picker.items = this.getQuickAccessProviders().filter(p => p.prefix !== HelpQuickAccessProvider_1.PREFIX);
-        return disposables;
-    }
-    getQuickAccessProviders() {
-        const providers = this.registry
-            .getQuickAccessProviders()
-            .sort((providerA, providerB) => providerA.prefix.localeCompare(providerB.prefix))
-            .flatMap(provider => this.createPicks(provider));
-        return providers;
-    }
-    createPicks(provider) {
-        return provider.helpEntries.map(helpEntry => {
-            const prefix = helpEntry.prefix || provider.prefix;
-            const label = prefix || '\u2026' /* ... */;
-            return {
-                prefix,
-                label,
-                keybinding: helpEntry.commandId ? this.keybindingService.lookupKeybinding(helpEntry.commandId) : undefined,
-                ariaLabel: localize('helpPickAriaLabel', "{0}, {1}", label, helpEntry.description),
-                description: helpEntry.description
-            };
-        });
-    }
-};
-HelpQuickAccessProvider.PREFIX = '?';
-HelpQuickAccessProvider = HelpQuickAccessProvider_1 = __decorate([
-    __param(0, IQuickInputService),
-    __param(1, IKeybindingService)
-], HelpQuickAccessProvider);
-export { HelpQuickAccessProvider };
diff -urN -x '*.map' a/vs/platform/quickinput/browser/pickerQuickAccess.js b/vs/platform/quickinput/browser/pickerQuickAccess.js
--- a/vs/platform/quickinput/browser/pickerQuickAccess.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/quickinput/browser/pickerQuickAccess.js	1970-01-01 00:00:00.000000000 +0000
@@ -1,268 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-import { timeout } from '../../../base/common/async.js';
-import { CancellationTokenSource } from '../../../base/common/cancellation.js';
-import { Disposable, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';
-import { isFunction } from '../../../base/common/types.js';
-export var TriggerAction;
-(function (TriggerAction) {
-    /**
-     * Do nothing after the button was clicked.
-     */
-    TriggerAction[TriggerAction["NO_ACTION"] = 0] = "NO_ACTION";
-    /**
-     * Close the picker.
-     */
-    TriggerAction[TriggerAction["CLOSE_PICKER"] = 1] = "CLOSE_PICKER";
-    /**
-     * Update the results of the picker.
-     */
-    TriggerAction[TriggerAction["REFRESH_PICKER"] = 2] = "REFRESH_PICKER";
-    /**
-     * Remove the item from the picker.
-     */
-    TriggerAction[TriggerAction["REMOVE_ITEM"] = 3] = "REMOVE_ITEM";
-})(TriggerAction || (TriggerAction = {}));
-function isPicksWithActive(obj) {
-    const candidate = obj;
-    return Array.isArray(candidate.items);
-}
-function isFastAndSlowPicks(obj) {
-    const candidate = obj;
-    return !!candidate.picks && candidate.additionalPicks instanceof Promise;
-}
-export class PickerQuickAccessProvider extends Disposable {
-    constructor(prefix, options) {
-        super();
-        this.prefix = prefix;
-        this.options = options;
-    }
-    provide(picker, token, runOptions) {
-        var _a;
-        const disposables = new DisposableStore();
-        // Apply options if any
-        picker.canAcceptInBackground = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.canAcceptInBackground);
-        // Disable filtering & sorting, we control the results
-        picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
-        // Set initial picks and update on type
-        let picksCts = undefined;
-        const picksDisposable = disposables.add(new MutableDisposable());
-        const updatePickerItems = () => __awaiter(this, void 0, void 0, function* () {
-            const picksDisposables = picksDisposable.value = new DisposableStore();
-            // Cancel any previous ask for picks and busy
-            picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);
-            picker.busy = false;
-            // Create new cancellation source for this run
-            picksCts = new CancellationTokenSource(token);
-            // Collect picks and support both long running and short or combined
-            const picksToken = picksCts.token;
-            const picksFilter = picker.value.substr(this.prefix.length).trim();
-            const providedPicks = this._getPicks(picksFilter, picksDisposables, picksToken, runOptions);
-            const applyPicks = (picks, skipEmpty) => {
-                var _a;
-                let items;
-                let activeItem = undefined;
-                if (isPicksWithActive(picks)) {
-                    items = picks.items;
-                    activeItem = picks.active;
-                }
-                else {
-                    items = picks;
-                }
-                if (items.length === 0) {
-                    if (skipEmpty) {
-                        return false;
-                    }
-                    // We show the no results pick if we have no input to prevent completely empty pickers #172613
-                    if ((picksFilter.length > 0 || picker.hideInput) && ((_a = this.options) === null || _a === void 0 ? void 0 : _a.noResultsPick)) {
-                        if (isFunction(this.options.noResultsPick)) {
-                            items = [this.options.noResultsPick(picksFilter)];
-                        }
-                        else {
-                            items = [this.options.noResultsPick];
-                        }
-                    }
-                }
-                picker.items = items;
-                if (activeItem) {
-                    picker.activeItems = [activeItem];
-                }
-                return true;
-            };
-            const applyFastAndSlowPicks = (fastAndSlowPicks) => __awaiter(this, void 0, void 0, function* () {
-                let fastPicksApplied = false;
-                let slowPicksApplied = false;
-                yield Promise.all([
-                    // Fast Picks: if `mergeDelay` is configured, in order to reduce
-                    // amount of flicker, we race against the slow picks over some delay
-                    // and then set the fast picks.
-                    // If the slow picks are faster, we reduce the flicker by only
-                    // setting the items once.
-                    (() => __awaiter(this, void 0, void 0, function* () {
-                        if (typeof fastAndSlowPicks.mergeDelay === 'number') {
-                            yield timeout(fastAndSlowPicks.mergeDelay);
-                            if (picksToken.isCancellationRequested) {
-                                return;
-                            }
-                        }
-                        if (!slowPicksApplied) {
-                            fastPicksApplied = applyPicks(fastAndSlowPicks.picks, true /* skip over empty to reduce flicker */);
-                        }
-                    }))(),
-                    // Slow Picks: we await the slow picks and then set them at
-                    // once together with the fast picks, but only if we actually
-                    // have additional results.
-                    (() => __awaiter(this, void 0, void 0, function* () {
-                        picker.busy = true;
-                        try {
-                            const awaitedAdditionalPicks = yield fastAndSlowPicks.additionalPicks;
-                            if (picksToken.isCancellationRequested) {
-                                return;
-                            }
-                            let picks;
-                            let activePick = undefined;
-                            if (isPicksWithActive(fastAndSlowPicks.picks)) {
-                                picks = fastAndSlowPicks.picks.items;
-                                activePick = fastAndSlowPicks.picks.active;
-                            }
-                            else {
-                                picks = fastAndSlowPicks.picks;
-                            }
-                            let additionalPicks;
-                            let additionalActivePick = undefined;
-                            if (isPicksWithActive(awaitedAdditionalPicks)) {
-                                additionalPicks = awaitedAdditionalPicks.items;
-                                additionalActivePick = awaitedAdditionalPicks.active;
-                            }
-                            else {
-                                additionalPicks = awaitedAdditionalPicks;
-                            }
-                            if (additionalPicks.length > 0 || !fastPicksApplied) {
-                                // If we do not have any activePick or additionalActivePick
-                                // we try to preserve the currently active pick from the
-                                // fast results. This fixes an issue where the user might
-                                // have made a pick active before the additional results
-                                // kick in.
-                                // See https://github.com/microsoft/vscode/issues/102480
-                                let fallbackActivePick = undefined;
-                                if (!activePick && !additionalActivePick) {
-                                    const fallbackActivePickCandidate = picker.activeItems[0];
-                                    if (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) {
-                                        fallbackActivePick = fallbackActivePickCandidate;
-                                    }
-                                }
-                                applyPicks({
-                                    items: [...picks, ...additionalPicks],
-                                    active: activePick || additionalActivePick || fallbackActivePick
-                                });
-                            }
-                        }
-                        finally {
-                            if (!picksToken.isCancellationRequested) {
-                                picker.busy = false;
-                            }
-                            slowPicksApplied = true;
-                        }
-                    }))()
-                ]);
-            });
-            // No Picks
-            if (providedPicks === null) {
-                // Ignore
-            }
-            // Fast and Slow Picks
-            else if (isFastAndSlowPicks(providedPicks)) {
-                yield applyFastAndSlowPicks(providedPicks);
-            }
-            // Fast Picks
-            else if (!(providedPicks instanceof Promise)) {
-                applyPicks(providedPicks);
-            }
-            // Slow Picks
-            else {
-                picker.busy = true;
-                try {
-                    const awaitedPicks = yield providedPicks;
-                    if (picksToken.isCancellationRequested) {
-                        return;
-                    }
-                    if (isFastAndSlowPicks(awaitedPicks)) {
-                        yield applyFastAndSlowPicks(awaitedPicks);
-                    }
-                    else {
-                        applyPicks(awaitedPicks);
-                    }
-                }
-                finally {
-                    if (!picksToken.isCancellationRequested) {
-                        picker.busy = false;
-                    }
-                }
-            }
-        });
-        disposables.add(picker.onDidChangeValue(() => updatePickerItems()));
-        updatePickerItems();
-        // Accept the pick on accept and hide picker
-        disposables.add(picker.onDidAccept(event => {
-            const [item] = picker.selectedItems;
-            if (typeof (item === null || item === void 0 ? void 0 : item.accept) === 'function') {
-                if (!event.inBackground) {
-                    picker.hide(); // hide picker unless we accept in background
-                }
-                item.accept(picker.keyMods, event);
-            }
-        }));
-        // Trigger the pick with button index if button triggered
-        disposables.add(picker.onDidTriggerItemButton(({ button, item }) => __awaiter(this, void 0, void 0, function* () {
-            var _b, _c;
-            if (typeof item.trigger === 'function') {
-                const buttonIndex = (_c = (_b = item.buttons) === null || _b === void 0 ? void 0 : _b.indexOf(button)) !== null && _c !== void 0 ? _c : -1;
-                if (buttonIndex >= 0) {
-                    const result = item.trigger(buttonIndex, picker.keyMods);
-                    const action = (typeof result === 'number') ? result : yield result;
-                    if (token.isCancellationRequested) {
-                        return;
-                    }
-                    switch (action) {
-                        case TriggerAction.NO_ACTION:
-                            break;
-                        case TriggerAction.CLOSE_PICKER:
-                            picker.hide();
-                            break;
-                        case TriggerAction.REFRESH_PICKER:
-                            updatePickerItems();
-                            break;
-                        case TriggerAction.REMOVE_ITEM: {
-                            const index = picker.items.indexOf(item);
-                            if (index !== -1) {
-                                const items = picker.items.slice();
-                                const removed = items.splice(index, 1);
-                                const activeItems = picker.activeItems.filter(activeItem => activeItem !== removed[0]);
-                                const keepScrollPositionBefore = picker.keepScrollPosition;
-                                picker.keepScrollPosition = true;
-                                picker.items = items;
-                                if (activeItems) {
-                                    picker.activeItems = activeItems;
-                                }
-                                picker.keepScrollPosition = keepScrollPositionBefore;
-                            }
-                            break;
-                        }
-                    }
-                }
-            }
-        })));
-        return disposables;
-    }
-}
diff -urN -x '*.map' a/vs/platform/quickinput/browser/quickAccess.js b/vs/platform/quickinput/browser/quickAccess.js
--- a/vs/platform/quickinput/browser/quickAccess.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/quickinput/browser/quickAccess.js	2023-12-06 14:23:14.391854805 +0000
@@ -29,20 +29,22 @@
         this.lastAcceptedPickerValues = new Map();
         this.visibleQuickAccess = undefined;
     }
+    pick(value = '', options) {
+        return this.doShowOrPick(value, true, options);
+    }
     show(value = '', options) {
         this.doShowOrPick(value, false, options);
     }
     doShowOrPick(value, pick, options) {
-        var _a;
         // Find provider for the value to show
         const [provider, descriptor] = this.getOrInstantiateProvider(value);
         // Return early if quick access is already showing on that same prefix
         const visibleQuickAccess = this.visibleQuickAccess;
-        const visibleDescriptor = visibleQuickAccess === null || visibleQuickAccess === void 0 ? void 0 : visibleQuickAccess.descriptor;
+        const visibleDescriptor = visibleQuickAccess?.descriptor;
         if (visibleQuickAccess && descriptor && visibleDescriptor === descriptor) {
             // Apply value only if it is more specific than the prefix
             // from the provider and we are not instructed to preserve
-            if (value !== descriptor.prefix && !(options === null || options === void 0 ? void 0 : options.preserveValue)) {
+            if (value !== descriptor.prefix && !options?.preserveValue) {
                 visibleQuickAccess.picker.value = value;
             }
             // Always adjust selection
@@ -50,7 +52,7 @@
             return;
         }
         // Rewrite the filter value based on certain rules unless disabled
-        if (descriptor && !(options === null || options === void 0 ? void 0 : options.preserveValue)) {
+        if (descriptor && !options?.preserveValue) {
             let newValue = undefined;
             // If we have a visible provider with a value, take it's filter value but
             // rewrite to new provider prefix in case they differ
@@ -62,7 +64,7 @@
             }
             // Otherwise, take a default value as instructed
             if (!newValue) {
-                const defaultFilterValue = provider === null || provider === void 0 ? void 0 : provider.defaultFilterValue;
+                const defaultFilterValue = provider?.defaultFilterValue;
                 if (defaultFilterValue === DefaultQuickAccessFilterValue.LAST) {
                     newValue = this.lastAcceptedPickerValues.get(descriptor);
                 }
@@ -80,13 +82,13 @@
         const picker = disposables.add(this.quickInputService.createQuickPick());
         picker.value = value;
         this.adjustValueSelection(picker, descriptor, options);
-        picker.placeholder = descriptor === null || descriptor === void 0 ? void 0 : descriptor.placeholder;
-        picker.quickNavigate = options === null || options === void 0 ? void 0 : options.quickNavigateConfiguration;
+        picker.placeholder = descriptor?.placeholder;
+        picker.quickNavigate = options?.quickNavigateConfiguration;
         picker.hideInput = !!picker.quickNavigate && !visibleQuickAccess; // only hide input if there was no picker opened already
-        if (typeof (options === null || options === void 0 ? void 0 : options.itemActivation) === 'number' || (options === null || options === void 0 ? void 0 : options.quickNavigateConfiguration)) {
-            picker.itemActivation = (_a = options === null || options === void 0 ? void 0 : options.itemActivation) !== null && _a !== void 0 ? _a : ItemActivation.SECOND /* quick nav is always second */;
+        if (typeof options?.itemActivation === 'number' || options?.quickNavigateConfiguration) {
+            picker.itemActivation = options?.itemActivation ?? ItemActivation.SECOND /* quick nav is always second */;
         }
-        picker.contextKey = descriptor === null || descriptor === void 0 ? void 0 : descriptor.contextKey;
+        picker.contextKey = descriptor?.contextKey;
         picker.filterValue = (value) => value.substring(descriptor ? descriptor.prefix.length : 0);
         // Pick mode: setup a promise that can be resolved
         // with the selected items and prevent execution
@@ -99,13 +101,13 @@
             }));
         }
         // Register listeners
-        disposables.add(this.registerPickerListeners(picker, provider, descriptor, value, options === null || options === void 0 ? void 0 : options.providerOptions));
+        disposables.add(this.registerPickerListeners(picker, provider, descriptor, value, options?.providerOptions));
         // Ask provider to fill the picker as needed if we have one
         // and pass over a cancellation token that will indicate when
         // the picker is hiding without a pick being made.
         const cts = disposables.add(new CancellationTokenSource());
         if (provider) {
-            disposables.add(provider.provide(picker, cts.token, options === null || options === void 0 ? void 0 : options.providerOptions));
+            disposables.add(provider.provide(picker, cts.token, options?.providerOptions));
         }
         // Finally, trigger disposal and cancellation when the picker
         // hides depending on items selected or not.
@@ -116,7 +118,7 @@
             // Start to dispose once picker hides
             disposables.dispose();
             // Resolve pick promise with selected items
-            pickPromise === null || pickPromise === void 0 ? void 0 : pickPromise.complete(picker.selectedItems.slice(0));
+            pickPromise?.complete(picker.selectedItems.slice(0));
         });
         // Finally, show the picker. This is important because a provider
         // may not call this and then our disposables would leak that rely
@@ -124,19 +126,18 @@
         picker.show();
         // Pick mode: return with promise
         if (pick) {
-            return pickPromise === null || pickPromise === void 0 ? void 0 : pickPromise.p;
+            return pickPromise?.p;
         }
     }
     adjustValueSelection(picker, descriptor, options) {
-        var _a;
         let valueSelection;
         // Preserve: just always put the cursor at the end
-        if (options === null || options === void 0 ? void 0 : options.preserveValue) {
+        if (options?.preserveValue) {
             valueSelection = [picker.value.length, picker.value.length];
         }
         // Otherwise: select the value up until the prefix
         else {
-            valueSelection = [(_a = descriptor === null || descriptor === void 0 ? void 0 : descriptor.prefix.length) !== null && _a !== void 0 ? _a : 0, picker.value.length];
+            valueSelection = [descriptor?.prefix.length ?? 0, picker.value.length];
         }
         picker.valueSelection = valueSelection;
     }
diff -urN -x '*.map' a/vs/platform/quickinput/browser/quickInput.js b/vs/platform/quickinput/browser/quickInput.js
--- a/vs/platform/quickinput/browser/quickInput.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/quickinput/browser/quickInput.js	2023-12-06 14:23:14.391854805 +0000
@@ -2,15 +2,6 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import * as dom from '../../../base/browser/dom.js';
 import { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';
 import { Toggle } from '../../../base/browser/ui/toggle/toggle.js';
@@ -24,13 +15,13 @@
 import Severity from '../../../base/common/severity.js';
 import { ThemeIcon } from '../../../base/common/themables.js';
 import './media/quickInput.css';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 import { ItemActivation, NO_KEY_MODS, QuickInputHideReason } from '../common/quickInput.js';
 import { QuickInputListFocus } from './quickInputList.js';
 import { getIconClass, renderQuickInputDescription } from './quickInputUtils.js';
 export const backButton = {
     iconClass: ThemeIcon.asClassName(Codicon.quickInputBack),
-    tooltip: localize('quickInput.back', "Back"),
+    tooltip: localizeWithPath('vs/platform/quickinput/browser/quickInput', 'quickInput.back', "Back"),
     handle: -1 // TODO
 };
 class QuickInput extends Disposable {
@@ -52,7 +43,9 @@
         this.onDidHideEmitter = this._register(new Emitter());
         this.onDisposeEmitter = this._register(new Emitter());
         this.visibleDisposables = this._register(new DisposableStore());
+        this.onDidTriggerButton = this.onDidTriggerButtonEmitter.event;
         this.onDidHide = this.onDidHideEmitter.event;
+        this.onDispose = this.onDisposeEmitter.event;
     }
     get title() {
         return this._title;
@@ -68,6 +61,19 @@
         this._description = description;
         this.update();
     }
+    get widget() {
+        return this._widget;
+    }
+    set widget(widget) {
+        if (!(widget instanceof HTMLElement)) {
+            return;
+        }
+        if (this._widget !== widget) {
+            this._widget = widget;
+            this._widgetUpdated = true;
+            this.update();
+        }
+    }
     get step() {
         return this._steps;
     }
@@ -125,7 +131,7 @@
         return this._toggles;
     }
     set toggles(toggles) {
-        this._toggles = toggles !== null && toggles !== void 0 ? toggles : [];
+        this._toggles = toggles ?? [];
         this.togglesUpdated = true;
         this.update();
     }
@@ -183,7 +189,6 @@
         this.onDidHideEmitter.fire({ reason });
     }
     update() {
-        var _a, _b;
         if (!this.visible) {
             return;
         }
@@ -228,18 +233,18 @@
             this.ui.leftActionBar.clear();
             const leftButtons = this.buttons.filter(button => button === backButton);
             this.ui.leftActionBar.push(leftButtons.map((button, index) => {
-                const action = new Action(`id-${index}`, '', button.iconClass || getIconClass(button.iconPath), true, () => __awaiter(this, void 0, void 0, function* () {
+                const action = new Action(`id-${index}`, '', button.iconClass || getIconClass(button.iconPath), true, async () => {
                     this.onDidTriggerButtonEmitter.fire(button);
-                }));
+                });
                 action.tooltip = button.tooltip || '';
                 return action;
             }), { icon: true, label: false });
             this.ui.rightActionBar.clear();
             const rightButtons = this.buttons.filter(button => button !== backButton);
             this.ui.rightActionBar.push(rightButtons.map((button, index) => {
-                const action = new Action(`id-${index}`, '', button.iconClass || getIconClass(button.iconPath), true, () => __awaiter(this, void 0, void 0, function* () {
+                const action = new Action(`id-${index}`, '', button.iconClass || getIconClass(button.iconPath), true, async () => {
                     this.onDidTriggerButtonEmitter.fire(button);
-                }));
+                });
                 action.tooltip = button.tooltip || '';
                 return action;
             }), { icon: true, label: false });
@@ -249,7 +254,7 @@
             // HACK: Filter out toggles here that are not concrete Toggle objects. This is to workaround
             // a layering issue as quick input's interface is in common but Toggle is in browser and
             // it requires a HTMLElement on its interface
-            const concreteToggles = (_b = (_a = this.toggles) === null || _a === void 0 ? void 0 : _a.filter(opts => opts instanceof Toggle)) !== null && _b !== void 0 ? _b : [];
+            const concreteToggles = this.toggles?.filter(opts => opts instanceof Toggle) ?? [];
             this.ui.inputBox.toggles = concreteToggles;
         }
         this.ui.ignoreFocusOut = this.ignoreFocusOut;
@@ -288,7 +293,7 @@
     }
     getSteps() {
         if (this.step && this.totalSteps) {
-            return localize('quickInput.steps', "{0}/{1}", this.step, this.totalSteps);
+            return localizeWithPath('vs/platform/quickinput/browser/quickInput', 'quickInput.steps', "{0}/{1}", this.step, this.totalSteps);
         }
         if (this.step) {
             return String(this.step);
@@ -317,7 +322,7 @@
         super.dispose();
     }
 }
-QuickInput.noPromptMessage = localize('inputModeEntry', "Press 'Enter' to confirm your input or 'Escape' to cancel");
+QuickInput.noPromptMessage = localizeWithPath('vs/platform/quickinput/browser/quickInput', 'inputModeEntry', "Press 'Enter' to confirm your input or 'Escape' to cancel");
 export class QuickPick extends QuickInput {
     constructor() {
         super(...arguments);
@@ -355,6 +360,7 @@
         this.onDidChangeValue = this.onDidChangeValueEmitter.event;
         this.onWillAccept = this.onWillAcceptEmitter.event;
         this.onDidAccept = this.onDidAcceptEmitter.event;
+        this.onDidCustom = this.onDidCustomEmitter.event;
         this.onDidChangeActive = this.onDidChangeActiveEmitter.event;
         this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event;
         this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event;
@@ -542,6 +548,12 @@
         this._ok = showOkButton;
         this.update();
     }
+    inputHasFocus() {
+        return this.visible ? this.ui.inputBox.hasFocus() : false;
+    }
+    focusOnInput() {
+        this.ui.inputBox.setFocus();
+    }
     get hideInput() {
         return !!this._hideInput;
     }
@@ -549,6 +561,20 @@
         this._hideInput = hideInput;
         this.update();
     }
+    get hideCountBadge() {
+        return !!this._hideCountBadge;
+    }
+    set hideCountBadge(hideCountBadge) {
+        this._hideCountBadge = hideCountBadge;
+        this.update();
+    }
+    get hideCheckAll() {
+        return !!this._hideCheckAll;
+    }
+    set hideCheckAll(hideCheckAll) {
+        this._hideCheckAll = hideCheckAll;
+        this.update();
+    }
     trySelectFirst() {
         if (this.autoFocusOnList) {
             if (!this.canSelectMany) {
@@ -787,7 +813,7 @@
             }
         }
         if (this.ui.list.ariaLabel !== ariaLabel) {
-            this.ui.list.ariaLabel = ariaLabel !== null && ariaLabel !== void 0 ? ariaLabel : null;
+            this.ui.list.ariaLabel = ariaLabel ?? null;
         }
         this.ui.list.matchOnDescription = this.matchOnDescription;
         this.ui.list.matchOnDetail = this.matchOnDetail;
@@ -864,7 +890,7 @@
         }
     }
 }
-QuickPick.DEFAULT_ARIA_LABEL = localize('quickInputBox.ariaLabel', "Type to narrow down results.");
+QuickPick.DEFAULT_ARIA_LABEL = localizeWithPath('vs/platform/quickinput/browser/quickInput', 'quickInputBox.ariaLabel', "Type to narrow down results.");
 export class InputBox extends QuickInput {
     constructor() {
         super(...arguments);
@@ -883,6 +909,11 @@
         this._value = value || '';
         this.update();
     }
+    set valueSelection(valueSelection) {
+        this._valueSelection = valueSelection;
+        this.valueSelectionUpdated = true;
+        this.update();
+    }
     get placeholder() {
         return this._placeholder;
     }
@@ -897,6 +928,16 @@
         this._password = password;
         this.update();
     }
+    get prompt() {
+        return this._prompt;
+    }
+    set prompt(prompt) {
+        this._prompt = prompt;
+        this.noValidationMessage = prompt
+            ? localizeWithPath('vs/platform/quickinput/browser/quickInput', 'inputModeEntryDescription', "{0} (Press 'Enter' to confirm or 'Escape' to cancel)", prompt)
+            : QuickInput.noPromptMessage;
+        this.update();
+    }
     show() {
         if (!this.visible) {
             this.visibleDisposables.add(this.ui.inputBox.onDidChange(value => {
@@ -940,3 +981,16 @@
         }
     }
 }
+export class QuickWidget extends QuickInput {
+    update() {
+        if (!this.visible) {
+            return;
+        }
+        const visibilities = {
+            title: !!this.title || !!this.step || !!this.buttons.length,
+            description: !!this.description || !!this.step
+        };
+        this.ui.setVisibilities(visibilities);
+        super.update();
+    }
+}
diff -urN -x '*.map' a/vs/platform/quickinput/browser/quickInputBox.js b/vs/platform/quickinput/browser/quickInputBox.js
--- a/vs/platform/quickinput/browser/quickInputBox.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/quickinput/browser/quickInputBox.js	2023-12-06 14:23:14.391854805 +0000
@@ -47,6 +47,9 @@
     isSelectionAtEnd() {
         return this.findInput.inputBox.isSelectionAtEnd();
     }
+    setPlaceholder(placeholder) {
+        this.findInput.inputBox.setPlaceHolder(placeholder);
+    }
     get placeholder() {
         return this.findInput.inputBox.inputElement.getAttribute('placeholder') || '';
     }
@@ -73,9 +76,15 @@
     set toggles(toggles) {
         this.findInput.setAdditionalToggles(toggles);
     }
+    hasFocus() {
+        return this.findInput.inputBox.hasFocus();
+    }
     setAttribute(name, value) {
         this.findInput.inputBox.inputElement.setAttribute(name, value);
     }
+    removeAttribute(name) {
+        this.findInput.inputBox.inputElement.removeAttribute(name);
+    }
     showDecoration(decoration) {
         if (decoration === Severity.Ignore) {
             this.findInput.clearMessage();
diff -urN -x '*.map' a/vs/platform/quickinput/browser/quickInputController.js b/vs/platform/quickinput/browser/quickInputController.js
--- a/vs/platform/quickinput/browser/quickInputController.js	2023-12-06 14:22:33.835782473 +0000
+++ b/vs/platform/quickinput/browser/quickInputController.js	2023-12-06 14:23:14.391854805 +0000
@@ -8,14 +8,15 @@
 import { CountBadge } from '../../../base/browser/ui/countBadge/countBadge.js';
 import { ProgressBar } from '../../../base/browser/ui/progressbar/progressbar.js';
 import { CancellationToken } from '../../../base/common/cancellation.js';
-import { Emitter } from '../../../base/common/event.js';
+import { Emitter, Event } from '../../../base/common/event.js';
 import { Disposable, dispose } from '../../../base/common/lifecycle.js';
 import Severity from '../../../base/common/severity.js';
-import { localize } from '../../../nls.js';
+import { isString } from '../../../base/common/types.js';
+import { localizeWithPath } from '../../../nls.js';
 import { QuickInputHideReason } from '../common/quickInput.js';
 import { QuickInputBox } from './quickInputBox.js';
-import { QuickInputList } from './quickInputList.js';
-import { QuickPick, backButton, InputBox } from './quickInput.js';
+import { QuickInputList, QuickInputListFocus } from './quickInputList.js';
+import { QuickPick, backButton, InputBox, QuickWidget } from './quickInput.js';
 const $ = dom.$;
 export class QuickInputController extends Disposable {
     constructor(options, themeService) {
@@ -32,6 +33,7 @@
         this.onShow = this.onShowEmitter.event;
         this.onHideEmitter = this._register(new Emitter());
         this.onHide = this.onHideEmitter.event;
+        this.backButton = backButton;
         this.idPrefix = options.idPrefix;
         this.parentElement = options.container;
         this.styles = options.styles;
@@ -64,7 +66,7 @@
         const headerContainer = dom.append(container, $('.quick-input-header'));
         const checkAll = dom.append(headerContainer, $('input.quick-input-check-all'));
         checkAll.type = 'checkbox';
-        checkAll.setAttribute('aria-label', localize('quickInput.checkAll', "Toggle all checkboxes"));
+        checkAll.setAttribute('aria-label', localizeWithPath('vs/platform/quickinput/browser/quickInputController', 'quickInput.checkAll', "Toggle all checkboxes"));
         this._register(dom.addStandardDisposableListener(checkAll, dom.EventType.CHANGE, e => {
             const checked = checkAll.checked;
             list.setAllVisibleChecked(checked);
@@ -82,19 +84,19 @@
         const visibleCountContainer = dom.append(filterContainer, $('.quick-input-visible-count'));
         visibleCountContainer.setAttribute('aria-live', 'polite');
         visibleCountContainer.setAttribute('aria-atomic', 'true');
-        const visibleCount = new CountBadge(visibleCountContainer, { countFormat: localize({ key: 'quickInput.visibleCount', comment: ['This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers.'] }, "{0} Results") }, this.styles.countBadge);
+        const visibleCount = new CountBadge(visibleCountContainer, { countFormat: localizeWithPath('vs/platform/quickinput/browser/quickInputController', { key: 'quickInput.visibleCount', comment: ['This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers.'] }, "{0} Results") }, this.styles.countBadge);
         const countContainer = dom.append(filterContainer, $('.quick-input-count'));
         countContainer.setAttribute('aria-live', 'polite');
-        const count = new CountBadge(countContainer, { countFormat: localize({ key: 'quickInput.countSelected', comment: ['This tells the user how many items are selected in a list of items to select from. The items can be anything.'] }, "{0} Selected") }, this.styles.countBadge);
+        const count = new CountBadge(countContainer, { countFormat: localizeWithPath('vs/platform/quickinput/browser/quickInputController', { key: 'quickInput.countSelected', comment: ['This tells the user how many items are selected in a list of items to select from. The items can be anything.'] }, "{0} Selected") }, this.styles.countBadge);
         const okContainer = dom.append(headerContainer, $('.quick-input-action'));
         const ok = this._register(new Button(okContainer, this.styles.button));
-        ok.label = localize('ok', "OK");
+        ok.label = localizeWithPath('vs/platform/quickinput/browser/quickInputController', 'ok', "OK");
         this._register(ok.onDidClick(e => {
             this.onDidAcceptEmitter.fire();
         }));
         const customButtonContainer = dom.append(headerContainer, $('.quick-input-action'));
         const customButton = this._register(new Button(customButtonContainer, this.styles.button));
-        customButton.label = localize('custom', "Custom");
+        customButton.label = localizeWithPath('vs/platform/quickinput/browser/quickInputController', 'custom', "Custom");
         this._register(customButton.onDidClick(e => {
             this.onDidCustomEmitter.fire();
         }));
@@ -108,8 +110,7 @@
         const list = this._register(new QuickInputList(container, listId, this.options, this.themeService));
         inputBox.setAttribute('aria-controls', listId);
         this._register(list.onDidChangeFocus(() => {
-            var _a;
-            inputBox.setAttribute('aria-activedescendant', (_a = list.getActiveDescendant()) !== null && _a !== void 0 ? _a : '');
+            inputBox.setAttribute('aria-activedescendant', list.getActiveDescendant() ?? '');
         }));
         this._register(list.onChangedAllVisibleChecked(checked => {
             checkAll.checked = checked;
@@ -255,9 +256,8 @@
     pick(picks, options = {}, token = CancellationToken.None) {
         return new Promise((doResolve, reject) => {
             let resolve = (result) => {
-                var _a;
                 resolve = doResolve;
-                (_a = options.onKeyMods) === null || _a === void 0 ? void 0 : _a.call(options, input.keyMods);
+                options.onKeyMods?.(input.keyMods);
                 doResolve(result);
             };
             if (token.isCancellationRequested) {
@@ -296,7 +296,9 @@
                         }
                     }
                 }),
-                input.onDidTriggerItemButton(event => options.onDidTriggerItemButton && options.onDidTriggerItemButton(Object.assign(Object.assign({}, event), { removeItem: () => {
+                input.onDidTriggerItemButton(event => options.onDidTriggerItemButton && options.onDidTriggerItemButton({
+                    ...event,
+                    removeItem: () => {
                         const index = input.items.indexOf(event.item);
                         if (index !== -1) {
                             const items = input.items.slice();
@@ -310,8 +312,9 @@
                             }
                             input.keepScrollPosition = keepScrollPositionBefore;
                         }
-                    } }))),
-                input.onDidTriggerSeparatorButton(event => { var _a; return (_a = options.onDidTriggerSeparatorButton) === null || _a === void 0 ? void 0 : _a.call(options, event); }),
+                    }
+                })),
+                input.onDidTriggerSeparatorButton(event => options.onDidTriggerSeparatorButton?.(event)),
                 input.onDidChangeValue(value => {
                     if (activeItem && !value && (input.activeItems.length !== 1 || input.activeItems[0] !== activeItem)) {
                         input.activeItems = [activeItem];
@@ -356,6 +359,78 @@
             });
         });
     }
+    setValidationOnInput(input, validationResult) {
+        if (validationResult && isString(validationResult)) {
+            input.severity = Severity.Error;
+            input.validationMessage = validationResult;
+        }
+        else if (validationResult && !isString(validationResult)) {
+            input.severity = validationResult.severity;
+            input.validationMessage = validationResult.content;
+        }
+        else {
+            input.severity = Severity.Ignore;
+            input.validationMessage = undefined;
+        }
+    }
+    input(options = {}, token = CancellationToken.None) {
+        return new Promise((resolve) => {
+            if (token.isCancellationRequested) {
+                resolve(undefined);
+                return;
+            }
+            const input = this.createInputBox();
+            const validateInput = options.validateInput || (() => Promise.resolve(undefined));
+            const onDidValueChange = Event.debounce(input.onDidChangeValue, (last, cur) => cur, 100);
+            let validationValue = options.value || '';
+            let validation = Promise.resolve(validateInput(validationValue));
+            const disposables = [
+                input,
+                onDidValueChange(value => {
+                    if (value !== validationValue) {
+                        validation = Promise.resolve(validateInput(value));
+                        validationValue = value;
+                    }
+                    validation.then(result => {
+                        if (value === validationValue) {
+                            this.setValidationOnInput(input, result);
+                        }
+                    });
+                }),
+                input.onDidAccept(() => {
+                    const value = input.value;
+                    if (value !== validationValue) {
+                        validation = Promise.resolve(validateInput(value));
+                        validationValue = value;
+                    }
+                    validation.then(result => {
+                        if (!result || (!isString(result) && result.severity !== Severity.Error)) {
+                            resolve(value);
+                            input.hide();
+                        }
+                        else if (value === validationValue) {
+                            this.setValidationOnInput(input, result);
+                        }
+                    });
+                }),
+                token.onCancellationRequested(() => {
+                    input.hide();
+                }),
+                input.onDidHide(() => {
+                    dispose(disposables);
+                    resolve(undefined);
+                }),
+            ];
+            input.title = options.title;
+            input.value = options.value || '';
+            input.valueSelection = options.valueSelection;
+            input.prompt = options.prompt;
+            input.placeholder = options.placeHolder;
+            input.password = !!options.password;
+            input.ignoreFocusOut = !!options.ignoreFocusLost;
+            input.show();
+        });
+    }
     createQuickPick() {
         const ui = this.getUI();
         return new QuickPick(ui);
@@ -364,12 +439,16 @@
         const ui = this.getUI();
         return new InputBox(ui);
     }
+    createQuickWidget() {
+        const ui = this.getUI();
+        return new QuickWidget(ui);
+    }
     show(controller) {
         const ui = this.getUI();
         this.onShowEmitter.fire();
         const oldController = this.controller;
         this.controller = controller;
-        oldController === null || oldController === void 0 ? void 0 : oldController.didHide();
+        oldController?.didHide();
         this.setEnabled(true);
         ui.leftActionBar.clear();
         ui.title.textContent = '';
@@ -394,7 +473,7 @@
         ui.ignoreFocusOut = false;
         ui.inputBox.toggles = undefined;
         const backKeybindingLabel = this.options.backKeybindingLabel();
-        backButton.tooltip = backKeybindingLabel ? localize('quickInput.backWithKeybinding', "Back ({0})", backKeybindingLabel) : localize('quickInput.back', "Back");
+        backButton.tooltip = backKeybindingLabel ? localizeWithPath('vs/platform/quickinput/browser/quickInputController', 'quickInput.backWithKeybinding', "Back ({0})", backKeybindingLabel) : localizeWithPath('vs/platform/quickinput/browser/quickInputController', 'quickInput.back', "Back");
         ui.container.style.display = '';
         this.updateLayout();
         ui.inputBox.setFocus();
@@ -434,21 +513,20 @@
         }
     }
     hide(reason) {
-        var _a, _b, _c;
         const controller = this.controller;
         if (!controller) {
             return;
         }
-        const focusChanged = !dom.isAncestor(document.activeElement, (_b = (_a = this.ui) === null || _a === void 0 ? void 0 : _a.container) !== null && _b !== void 0 ? _b : null);
+        const focusChanged = !dom.isAncestor(document.activeElement, this.ui?.container ?? null);
         this.controller = null;
         this.onHideEmitter.fire();
         this.getUI().container.style.display = 'none';
         if (!focusChanged) {
             let currentElement = this.previousFocusElement;
             while (currentElement && !currentElement.offsetParent) {
-                currentElement = (_c = currentElement.parentElement) !== null && _c !== void 0 ? _c : undefined;
+                currentElement = currentElement.parentElement ?? undefined;
             }
-            if (currentElement === null || currentElement === void 0 ? void 0 : currentElement.offsetParent) {
+            if (currentElement?.offsetParent) {
                 currentElement.focus();
                 this.previousFocusElement = undefined;
             }
@@ -458,6 +536,45 @@
         }
         controller.didHide(reason);
     }
+    focus() {
+        if (this.isDisplayed()) {
+            const ui = this.getUI();
+            if (ui.inputBox.enabled) {
+                ui.inputBox.setFocus();
+            }
+            else {
+                ui.list.domFocus();
+            }
+        }
+    }
+    toggle() {
+        if (this.isDisplayed() && this.controller instanceof QuickPick && this.controller.canSelectMany) {
+            this.getUI().list.toggleCheckbox();
+        }
+    }
+    navigate(next, quickNavigate) {
+        if (this.isDisplayed() && this.getUI().list.isDisplayed()) {
+            this.getUI().list.focus(next ? QuickInputListFocus.Next : QuickInputListFocus.Previous);
+            if (quickNavigate && this.controller instanceof QuickPick) {
+                this.controller.quickNavigate = quickNavigate;
+            }
+        }
+    }
+    async accept(keyMods = { alt: false, ctrlCmd: false }) {
+        // When accepting the item programmatically, it is important that
+        // we update `keyMods` either from the provided set or unset it
+        // because the accept did not happen from mouse or keyboard
+        // interaction on the list itself
+        this.keyMods.alt = keyMods.alt;
+        this.keyMods.ctrlCmd = keyMods.ctrlCmd;
+        this.onDidAcceptEmitter.fire();
+    }
+    async back() {
+        this.onDidTriggerButtonEmitter.fire(this.backButton);
+    }
+    async cancel() {
+        this.hide();
+    }
     layout(dimension, titleBarOffset) {
         this.dimension = dimension;
         this.titleBarOffset = titleBarOffset;
@@ -481,9 +598,9 @@
     updateStyles() {
         if (this.ui) {
             const { quickInputTitleBackground, quickInputBackground, quickInputForeground, widgetBorder, widgetShadow, } = this.styles.widget;
-            this.ui.titleBar.style.backgroundColor = quickInputTitleBackground !== null && quickInputTitleBackground !== void 0 ? quickInputTitleBackground : '';
-            this.ui.container.style.backgroundColor = quickInputBackground !== null && quickInputBackground !== void 0 ? quickInputBackground : '';
-            this.ui.container.style.color = quickInputForeground !== null && quickInputForeground !== void 0 ? quickInputForeground : '';
+            this.ui.titleBar.style.backgroundColor = quickInputTitleBackground ?? '';
+            this.ui.container.style.backgroundColor = quickInputBackground ?? '';
+            this.ui.container.style.color = quickInputForeground ?? '';
             this.ui.container.style.border = widgetBorder ? `1px solid ${widgetBorder}` : '';
             this.ui.container.style.boxShadow = widgetShadow ? `0 0 8px 2px ${widgetShadow}` : '';
             this.ui.list.style(this.styles.list);
diff -urN -x '*.map' a/vs/platform/quickinput/browser/quickInputList.js b/vs/platform/quickinput/browser/quickInputList.js
--- a/vs/platform/quickinput/browser/quickInputList.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/quickinput/browser/quickInputList.js	2023-12-06 14:23:14.391854805 +0000
@@ -8,15 +8,6 @@
     else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
     return c > 3 && r && Object.defineProperty(target, key, r), r;
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import * as dom from '../../../base/browser/dom.js';
 import { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';
 import { ActionBar } from '../../../base/browser/ui/actionbar/actionbar.js';
@@ -33,7 +24,7 @@
 import * as platform from '../../../base/common/platform.js';
 import { ltrim } from '../../../base/common/strings.js';
 import './media/quickInput.css';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 import { getIconClass } from './quickInputUtils.js';
 import { Lazy } from '../../../base/common/lazy.js';
 import { URI } from '../../../base/common/uri.js';
@@ -41,7 +32,6 @@
 const $ = dom.$;
 class ListElement {
     constructor(mainItem, previous, index, hasCheckbox, fireButtonTriggered, fireSeparatorButtonTriggered, onCheckedEmitter) {
-        var _a, _b, _c;
         // state will get updated later
         this._checked = false;
         this._hidden = false;
@@ -63,14 +53,13 @@
             }
             this.saneDescription = this.item.description;
             this.saneDetail = this.item.detail;
-            this._labelHighlights = (_a = this.item.highlights) === null || _a === void 0 ? void 0 : _a.label;
-            this._descriptionHighlights = (_b = this.item.highlights) === null || _b === void 0 ? void 0 : _b.description;
-            this._detailHighlights = (_c = this.item.highlights) === null || _c === void 0 ? void 0 : _c.detail;
+            this._labelHighlights = this.item.highlights?.label;
+            this._descriptionHighlights = this.item.highlights?.description;
+            this._detailHighlights = this.item.highlights?.detail;
             this.saneTooltip = this.item.tooltip;
         }
         this._init = new Lazy(() => {
-            var _a;
-            const saneLabel = (_a = mainItem.label) !== null && _a !== void 0 ? _a : '';
+            const saneLabel = mainItem.label ?? '';
             const saneSortLabel = parseLabelWithIcons(saneLabel).text.trim();
             const saneAriaLabel = mainItem.ariaLabel || [saneLabel, this.saneDescription, this.saneDetail]
                 .map(s => getCodiconAriaLabel(s))
@@ -189,22 +178,21 @@
         return data;
     }
     renderElement(element, index, data) {
-        var _a, _b, _c, _d;
         data.element = element;
-        element.element = (_a = data.entry) !== null && _a !== void 0 ? _a : undefined;
+        element.element = data.entry ?? undefined;
         const mainItem = element.item ? element.item : element.separator;
         data.checkbox.checked = element.checked;
         data.toDisposeElement.push(element.onChecked(checked => data.checkbox.checked = checked));
         const { labelHighlights, descriptionHighlights, detailHighlights } = element;
-        if ((_b = element.item) === null || _b === void 0 ? void 0 : _b.iconPath) {
-            const icon = isDark(this.themeService.getColorTheme().type) ? element.item.iconPath.dark : ((_c = element.item.iconPath.light) !== null && _c !== void 0 ? _c : element.item.iconPath.dark);
+        if (element.item?.iconPath) {
+            const icon = isDark(this.themeService.getColorTheme().type) ? element.item.iconPath.dark : (element.item.iconPath.light ?? element.item.iconPath.dark);
             const iconUrl = URI.revive(icon);
             data.icon.className = 'quick-input-list-icon';
             data.icon.style.backgroundImage = dom.asCSSUrl(iconUrl);
         }
         else {
             data.icon.style.backgroundImage = '';
-            data.icon.className = ((_d = element.item) === null || _d === void 0 ? void 0 : _d.iconClass) ? `quick-input-list-icon ${element.item.iconClass}` : '';
+            data.icon.className = element.item?.iconClass ? `quick-input-list-icon ${element.item.iconClass}` : '';
         }
         // Label
         const options = {
@@ -322,6 +310,7 @@
         this.matchOnDetail = false;
         this.matchOnLabel = true;
         this.matchOnLabelMode = 'fuzzy';
+        this.matchOnMeta = true;
         this.sortByLabel = true;
         this._onChangedAllVisibleChecked = new Emitter();
         this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event;
@@ -350,10 +339,13 @@
         this.list = options.createList('QuickInput', this.container, delegate, [new ListElementRenderer(themeService)], {
             identityProvider: {
                 getId: element => {
-                    var _a, _b, _c, _d, _e, _f, _g, _h;
                     // always prefer item over separator because if item is defined, it must be the main item type
                     // always prefer a defined id if one was specified and use label as a fallback
-                    return (_h = (_f = (_d = (_b = (_a = element.item) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = element.item) === null || _c === void 0 ? void 0 : _c.label) !== null && _d !== void 0 ? _d : (_e = element.separator) === null || _e === void 0 ? void 0 : _e.id) !== null && _f !== void 0 ? _f : (_g = element.separator) === null || _g === void 0 ? void 0 : _g.label) !== null && _h !== void 0 ? _h : '';
+                    return element.item?.id
+                        ?? element.item?.label
+                        ?? element.separator?.id
+                        ?? element.separator?.label
+                        ?? '';
                 }
             },
             setRowLineHeight: false,
@@ -420,8 +412,7 @@
             const delayer = new ThrottledDelayer(options.hoverDelegate.delay);
             // onMouseOver triggers every time a new element has been moused over
             // even if it's on the same list item.
-            this.disposables.push(this.list.onMouseOver((e) => __awaiter(this, void 0, void 0, function* () {
-                var _a;
+            this.disposables.push(this.list.onMouseOver(async (e) => {
                 // If we hover over an anchor element, we don't want to show the hover because
                 // the anchor may have a tooltip that we want to show instead.
                 if (e.browserEvent.target instanceof HTMLAnchorElement) {
@@ -432,15 +423,15 @@
                 // anchors are an exception as called out above so we skip them here
                 !(e.browserEvent.relatedTarget instanceof HTMLAnchorElement) &&
                     // check if the mouse is still over the same element
-                    dom.isAncestor(e.browserEvent.relatedTarget, (_a = e.element) === null || _a === void 0 ? void 0 : _a.element)) {
+                    dom.isAncestor(e.browserEvent.relatedTarget, e.element?.element)) {
                     return;
                 }
                 try {
-                    yield delayer.trigger(() => __awaiter(this, void 0, void 0, function* () {
+                    await delayer.trigger(async () => {
                         if (e.element) {
                             this.showHover(e.element);
                         }
-                    }));
+                    });
                 }
                 catch (e) {
                     // Ignore cancellation errors due to mouse out
@@ -448,13 +439,12 @@
                         throw e;
                     }
                 }
-            })));
+            }));
             this.disposables.push(this.list.onMouseOut(e => {
-                var _a;
                 // onMouseOut triggers every time a new element has been moused over
                 // even if it's on the same list item. We only want one event, so we
                 // check if the mouse is still over the same element.
-                if (dom.isAncestor(e.browserEvent.relatedTarget, (_a = e.element) === null || _a === void 0 ? void 0 : _a.element)) {
+                if (dom.isAncestor(e.browserEvent.relatedTarget, e.element?.element)) {
                     return;
                 }
                 delayer.cancel();
@@ -541,7 +531,6 @@
         const elementsToIndexes = new Map();
         const hasCheckbox = this.parent.classList.contains('show-checkboxes');
         this.elements = inputElements.reduce((result, item, index) => {
-            var _a;
             const previous = index > 0 ? inputElements[index - 1] : undefined;
             if (item.type === 'separator') {
                 if (!item.buttons) {
@@ -552,7 +541,7 @@
             const element = new ListElement(item, previous, index, hasCheckbox, fireButtonTriggered, fireSeparatorButtonTriggered, this._listElementChecked);
             const resultIndex = result.length;
             result.push(element);
-            elementsToIndexes.set((_a = element.item) !== null && _a !== void 0 ? _a : element.separator, resultIndex);
+            elementsToIndexes.set(element.item ?? element.separator, resultIndex);
             return result;
         }, []);
         this.elementsToIndexes = elementsToIndexes;
@@ -560,6 +549,9 @@
         this.list.splice(0, this.list.length, this.elements);
         this._onChangedVisibleCount.fire(this.elements.length);
     }
+    getElementsCount() {
+        return this.inputElements.length;
+    }
     getFocusedElements() {
         return this.list.getFocusedElements()
             .map(e => e.item);
@@ -578,6 +570,10 @@
     getActiveDescendant() {
         return this.list.getHTMLElement().getAttribute('aria-activedescendant');
     }
+    getSelectedElements() {
+        return this.list.getSelectedElements()
+            .map(e => e.item);
+    }
     setSelectedElements(items) {
         this.list.setSelection(items
             .filter(item => this.elementsToIndexes.has(item))
@@ -666,13 +662,12 @@
      * @param element The element to show the hover for
      */
     showHover(element) {
-        var _a, _b, _c;
         if (this.options.hoverDelegate === undefined) {
             return;
         }
         if (this._lastHover && !this._lastHover.isDisposed) {
-            (_b = (_a = this.options.hoverDelegate).onDidHideHover) === null || _b === void 0 ? void 0 : _b.call(_a);
-            (_c = this._lastHover) === null || _c === void 0 ? void 0 : _c.dispose();
+            this.options.hoverDelegate.onDidHideHover?.();
+            this._lastHover?.dispose();
         }
         if (!element.element || !element.saneTooltip) {
             return;
@@ -720,16 +715,15 @@
         else {
             let currentSeparator;
             this.elements.forEach(element => {
-                var _a, _b, _c, _d;
                 let labelHighlights;
                 if (this.matchOnLabelMode === 'fuzzy') {
-                    labelHighlights = this.matchOnLabel ? (_a = matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneLabel))) !== null && _a !== void 0 ? _a : undefined : undefined;
+                    labelHighlights = this.matchOnLabel ? matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneLabel)) ?? undefined : undefined;
                 }
                 else {
-                    labelHighlights = this.matchOnLabel ? (_b = matchesContiguousIconAware(queryWithWhitespace, parseLabelWithIcons(element.saneLabel))) !== null && _b !== void 0 ? _b : undefined : undefined;
+                    labelHighlights = this.matchOnLabel ? matchesContiguousIconAware(queryWithWhitespace, parseLabelWithIcons(element.saneLabel)) ?? undefined : undefined;
                 }
-                const descriptionHighlights = this.matchOnDescription ? (_c = matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDescription || ''))) !== null && _c !== void 0 ? _c : undefined : undefined;
-                const detailHighlights = this.matchOnDetail ? (_d = matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDetail || ''))) !== null && _d !== void 0 ? _d : undefined : undefined;
+                const descriptionHighlights = this.matchOnDescription ? matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDescription || '')) ?? undefined : undefined;
+                const detailHighlights = this.matchOnDetail ? matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDetail || '')) ?? undefined : undefined;
                 if (labelHighlights || descriptionHighlights || detailHighlights) {
                     element.labelHighlights = labelHighlights;
                     element.descriptionHighlights = descriptionHighlights;
@@ -769,8 +763,7 @@
             });
         }
         this.elementsToIndexes = shownElements.reduce((map, element, index) => {
-            var _a;
-            map.set((_a = element.item) !== null && _a !== void 0 ? _a : element.separator, index);
+            map.set(element.item ?? element.separator, index);
             return map;
         }, new Map());
         this.list.splice(0, this.list.length, shownElements);
@@ -822,7 +815,7 @@
     }
     toggleHover() {
         const element = this.list.getFocusedElements()[0];
-        if (!(element === null || element === void 0 ? void 0 : element.saneTooltip)) {
+        if (!element?.saneTooltip) {
             return;
         }
         // if there's a hover already, hide it (toggle off)
@@ -900,11 +893,10 @@
 }
 class QuickInputAccessibilityProvider {
     getWidgetAriaLabel() {
-        return localize('quickInput', "Quick Input");
+        return localizeWithPath('vs/platform/quickinput/browser/quickInputList', 'quickInput', "Quick Input");
     }
     getAriaLabel(element) {
-        var _a;
-        return ((_a = element.separator) === null || _a === void 0 ? void 0 : _a.label)
+        return element.separator?.label
             ? `${element.saneAriaLabel}, ${element.separator.label}`
             : element.saneAriaLabel;
     }
diff -urN -x '*.map' a/vs/platform/quickinput/browser/quickInputService.js b/vs/platform/quickinput/browser/quickInputService.js
--- a/vs/platform/quickinput/browser/quickInputService.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/quickinput/browser/quickInputService.js	2023-12-06 14:23:14.391854805 +0000
@@ -24,6 +24,7 @@
 import { IThemeService, Themable } from '../../theme/common/themeService.js';
 import { QuickInputController } from './quickInputController.js';
 let QuickInputService = class QuickInputService extends Themable {
+    get backButton() { return this.controller.backButton; }
     get controller() {
         if (!this._controller) {
             this._controller = this._register(this.createController());
@@ -43,7 +44,9 @@
         this.contextKeyService = contextKeyService;
         this.layoutService = layoutService;
         this._onShow = this._register(new Emitter());
+        this.onShow = this._onShow.event;
         this._onHide = this._register(new Emitter());
+        this.onHide = this._onHide.event;
         this.contexts = new Map();
     }
     createController(host = this.layoutService, options) {
@@ -64,7 +67,10 @@
             createList: (user, container, delegate, renderers, options) => this.instantiationService.createInstance(WorkbenchList, user, container, delegate, renderers, options),
             styles: this.computeStyles()
         };
-        const controller = this._register(new QuickInputController(Object.assign(Object.assign({}, defaultOptions), options), this.themeService));
+        const controller = this._register(new QuickInputController({
+            ...defaultOptions,
+            ...options
+        }, this.themeService));
         controller.layout(host.dimension, host.offset.quickPickTop);
         // Layout changes
         this._register(host.onDidLayout(dimension => controller.layout(dimension, host.offset.quickPickTop)));
@@ -93,7 +99,7 @@
             return; // already active context
         }
         this.resetContextKeys();
-        key === null || key === void 0 ? void 0 : key.set(true);
+        key?.set(true);
     }
     resetContextKeys() {
         this.contexts.forEach(context => {
@@ -105,12 +111,36 @@
     pick(picks, options = {}, token = CancellationToken.None) {
         return this.controller.pick(picks, options, token);
     }
+    input(options = {}, token = CancellationToken.None) {
+        return this.controller.input(options, token);
+    }
     createQuickPick() {
         return this.controller.createQuickPick();
     }
     createInputBox() {
         return this.controller.createInputBox();
     }
+    createQuickWidget() {
+        return this.controller.createQuickWidget();
+    }
+    focus() {
+        this.controller.focus();
+    }
+    toggle() {
+        this.controller.toggle();
+    }
+    navigate(next, quickNavigate) {
+        this.controller.navigate(next, quickNavigate);
+    }
+    accept(keyMods) {
+        return this.controller.accept(keyMods);
+    }
+    back() {
+        return this.controller.back();
+    }
+    cancel() {
+        return this.controller.cancel();
+    }
     updateStyles() {
         if (this.hasController) {
             this.controller.applyStyles(this.computeStyles());
diff -urN -x '*.map' a/vs/platform/quickinput/browser/quickInputUtils.js b/vs/platform/quickinput/browser/quickInputUtils.js
--- a/vs/platform/quickinput/browser/quickInputUtils.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/quickinput/browser/quickInputUtils.js	2023-12-06 14:23:14.391854805 +0000
@@ -11,7 +11,7 @@
 import { IdGenerator } from '../../../base/common/idGenerator.js';
 import { parseLinkedText } from '../../../base/common/linkedText.js';
 import './media/quickInput.css';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 const iconPathToClass = {};
 const iconClassGenerator = new IdGenerator('quick-input-button-icon-');
 export function getIconClass(iconPath) {
@@ -42,7 +42,7 @@
         else {
             let title = node.title;
             if (!title && node.href.startsWith('command:')) {
-                title = localize('executeCommand', "Click to execute command '{0}'", node.href.substring('command:'.length));
+                title = localizeWithPath('vs/platform/quickinput/browser/quickInputUtils', 'executeCommand', "Click to execute command '{0}'", node.href.substring('command:'.length));
             }
             else if (!title) {
                 title = node.href;
diff -urN -x '*.map' a/vs/platform/quickinput/common/quickAccess.js b/vs/platform/quickinput/common/quickAccess.js
--- a/vs/platform/quickinput/common/quickAccess.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/quickinput/common/quickAccess.js	2023-12-06 14:23:14.391854805 +0000
@@ -49,5 +49,15 @@
         const result = prefix ? (this.providers.find(provider => prefix.startsWith(provider.prefix)) || undefined) : undefined;
         return result || this.defaultProvider;
     }
+    clear() {
+        const providers = [...this.providers];
+        const defaultProvider = this.defaultProvider;
+        this.providers = [];
+        this.defaultProvider = undefined;
+        return () => {
+            this.providers = providers;
+            this.defaultProvider = defaultProvider;
+        };
+    }
 }
 Registry.add(Extensions.Quickaccess, new QuickAccessRegistry());
diff -urN -x '*.map' a/vs/platform/quickinput/common/quickInput.js b/vs/platform/quickinput/common/quickInput.js
--- a/vs/platform/quickinput/common/quickInput.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/quickinput/common/quickInput.js	2023-12-06 14:23:14.391854805 +0000
@@ -3,6 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { Schemas } from '../../../base/common/network.js';
 export const NO_KEY_MODS = { ctrlCmd: false, alt: false };
 export var QuickInputHideReason;
 (function (QuickInputHideReason) {
@@ -30,6 +31,24 @@
     constructor(options) {
         this.options = options;
     }
+    getItemLabel(entry) {
+        return entry.label;
+    }
+    getItemDescription(entry) {
+        if (this.options?.skipDescription) {
+            return undefined;
+        }
+        return entry.description;
+    }
+    getItemPath(entry) {
+        if (this.options?.skipPath) {
+            return undefined;
+        }
+        if (entry.resource?.scheme === Schemas.file) {
+            return entry.resource.fsPath;
+        }
+        return entry.resource?.path;
+    }
 }
 export const quickPickItemScorerAccessor = new QuickPickItemScorerAccessor();
 //#endregion
diff -urN -x '*.map' a/vs/platform/registry/common/platform.js b/vs/platform/registry/common/platform.js
--- a/vs/platform/registry/common/platform.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/registry/common/platform.js	2023-12-06 14:23:14.391854805 +0000
@@ -14,6 +14,9 @@
         Assert.ok(!this.data.has(id), 'There is already an extension with this id');
         this.data.set(id, data);
     }
+    knows(id) {
+        return this.data.has(id);
+    }
     as(id) {
         return this.data.get(id) || null;
     }
diff -urN -x '*.map' a/vs/platform/remote/common/remoteHosts.js b/vs/platform/remote/common/remoteHosts.js
--- a/vs/platform/remote/common/remoteHosts.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/remote/common/remoteHosts.js	2023-12-06 14:23:14.391854805 +0000
@@ -0,0 +1,60 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { Schemas } from '../../../base/common/network.js';
+export function getRemoteAuthority(uri) {
+    return uri.scheme === Schemas.vscodeRemote ? uri.authority : undefined;
+}
+export function getRemoteName(authority) {
+    if (!authority) {
+        return undefined;
+    }
+    const pos = authority.indexOf('+');
+    if (pos < 0) {
+        // e.g. localhost:8000
+        return authority;
+    }
+    return authority.substr(0, pos);
+}
+/**
+ * The root path to use when accessing the remote server. The path contains the quality and commit of the current build.
+ * @param product
+ * @returns
+ */
+export function getRemoteServerRootPath(product) {
+    return `/${product.quality ?? 'oss'}-${product.commit ?? 'dev'}`;
+}
+export function parseAuthorityWithPort(authority) {
+    const { host, port } = parseAuthority(authority);
+    if (typeof port === 'undefined') {
+        throw new Error(`Remote authority doesn't contain a port!`);
+    }
+    return { host, port };
+}
+export function parseAuthorityWithOptionalPort(authority, defaultPort) {
+    let { host, port } = parseAuthority(authority);
+    if (typeof port === 'undefined') {
+        port = defaultPort;
+    }
+    return { host, port };
+}
+function parseAuthority(authority) {
+    // check for ipv6 with port
+    const m1 = authority.match(/^(\[[0-9a-z:]+\]):(\d+)$/);
+    if (m1) {
+        return { host: m1[1], port: parseInt(m1[2], 10) };
+    }
+    // check for ipv6 without port
+    const m2 = authority.match(/^(\[[0-9a-z:]+\])$/);
+    if (m2) {
+        return { host: m2[1], port: undefined };
+    }
+    // anything with a trailing port
+    const m3 = authority.match(/(.*):(\d+)$/);
+    if (m3) {
+        return { host: m3[1], port: parseInt(m3[2], 10) };
+    }
+    // doesn't contain a port
+    return { host: authority, port: undefined };
+}
diff -urN -x '*.map' a/vs/platform/storage/common/storage.js b/vs/platform/storage/common/storage.js
--- a/vs/platform/storage/common/storage.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/storage/common/storage.js	2023-12-06 14:23:14.391854805 +0000
@@ -1,8 +1,16 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { Promises, RunOnceScheduler, runWhenIdle } from '../../../base/common/async.js';
 import { Emitter, Event, PauseableEmitter } from '../../../base/common/event.js';
-import { Disposable } from '../../../base/common/lifecycle.js';
+import { Disposable, dispose, MutableDisposable } from '../../../base/common/lifecycle.js';
+import { mark } from '../../../base/common/performance.js';
 import { isUndefinedOrNull } from '../../../base/common/types.js';
 import { InMemoryStorageDatabase, Storage, StorageHint } from '../../../base/parts/storage/common/storage.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { isUserDataProfile } from '../../userDataProfile/common/userDataProfile.js';
+export const IS_NEW_KEY = '__$__isNewStorageMarker';
 export const TARGET_KEY = '__$__targetStorageMarker';
 export const IStorageService = createDecorator('storageService');
 export var WillSaveStateReason;
@@ -34,8 +42,11 @@
         this.options = options;
         this._onDidChangeValue = this._register(new PauseableEmitter());
         this._onDidChangeTarget = this._register(new PauseableEmitter());
+        this.onDidChangeTarget = this._onDidChangeTarget.event;
         this._onWillSaveState = this._register(new Emitter());
         this.onWillSaveState = this._onWillSaveState.event;
+        this.flushWhenIdleScheduler = this._register(new RunOnceScheduler(() => this.doFlushWhenIdle(), this.options.flushInterval));
+        this.runFlushWhenIdle = this._register(new MutableDisposable());
         this._workspaceKeyTargets = undefined;
         this._profileKeyTargets = undefined;
         this._applicationKeyTargets = undefined;
@@ -43,6 +54,45 @@
     onDidChangeValue(scope, key, disposable) {
         return Event.filter(this._onDidChangeValue.event, e => e.scope === scope && (key === undefined || e.key === key), disposable);
     }
+    doFlushWhenIdle() {
+        this.runFlushWhenIdle.value = runWhenIdle(() => {
+            if (this.shouldFlushWhenIdle()) {
+                this.flush();
+            }
+            // repeat
+            this.flushWhenIdleScheduler.schedule();
+        });
+    }
+    shouldFlushWhenIdle() {
+        return true;
+    }
+    stopFlushWhenIdle() {
+        dispose([this.runFlushWhenIdle, this.flushWhenIdleScheduler]);
+    }
+    initialize() {
+        if (!this.initializationPromise) {
+            this.initializationPromise = (async () => {
+                // Init all storage locations
+                mark('code/willInitStorage');
+                try {
+                    await this.doInitialize(); // Ask subclasses to initialize storage
+                }
+                finally {
+                    mark('code/didInitStorage');
+                }
+                // On some OS we do not get enough time to persist state on shutdown (e.g. when
+                // Windows restarts after applying updates). In other cases, VSCode might crash,
+                // so we periodically save state to reduce the chance of loosing any state.
+                // In the browser we do not have support for long running unload sequences. As such,
+                // we cannot ask for saving state in that moment, because that would result in a
+                // long running operation.
+                // Instead, periodically ask customers to save save. The library will be clever enough
+                // to only save state that has actually changed.
+                this.flushWhenIdleScheduler.schedule();
+            })();
+        }
+        return this.initializationPromise;
+    }
     emitDidChangeValue(scope, event) {
         const { key, external } = event;
         // Specially handle `TARGET_KEY`
@@ -67,17 +117,27 @@
             this._onDidChangeValue.fire({ scope, key, target: this.getKeyTargets(scope)[key], external });
         }
     }
+    emitWillSaveState(reason) {
+        this._onWillSaveState.fire({ reason });
+    }
     get(key, scope, fallbackValue) {
-        var _a;
-        return (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.get(key, fallbackValue);
+        return this.getStorage(scope)?.get(key, fallbackValue);
     }
     getBoolean(key, scope, fallbackValue) {
-        var _a;
-        return (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.getBoolean(key, fallbackValue);
+        return this.getStorage(scope)?.getBoolean(key, fallbackValue);
     }
     getNumber(key, scope, fallbackValue) {
-        var _a;
-        return (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.getNumber(key, fallbackValue);
+        return this.getStorage(scope)?.getNumber(key, fallbackValue);
+    }
+    getObject(key, scope, fallbackValue) {
+        return this.getStorage(scope)?.getObject(key, fallbackValue);
+    }
+    storeAll(entries, external) {
+        this.withPausedEmitters(() => {
+            for (const entry of entries) {
+                this.store(entry.key, entry.value, entry.scope, entry.target, external);
+            }
+        });
     }
     store(key, value, scope, target, external = false) {
         // We remove the key for undefined/null values
@@ -87,21 +147,19 @@
         }
         // Update our datastructures but send events only after
         this.withPausedEmitters(() => {
-            var _a;
             // Update key-target map
             this.updateKeyTarget(key, scope, target);
             // Store actual value
-            (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.set(key, value, external);
+            this.getStorage(scope)?.set(key, value, external);
         });
     }
     remove(key, scope, external = false) {
         // Update our datastructures but send events only after
         this.withPausedEmitters(() => {
-            var _a;
             // Update key-target map
             this.updateKeyTarget(key, scope, undefined);
             // Remove actual key
-            (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.delete(key, external);
+            this.getStorage(scope)?.delete(key, external);
         });
     }
     withPausedEmitters(fn) {
@@ -117,21 +175,31 @@
             this._onDidChangeTarget.resume();
         }
     }
+    keys(scope, target) {
+        const keys = [];
+        const keyTargets = this.getKeyTargets(scope);
+        for (const key of Object.keys(keyTargets)) {
+            const keyTarget = keyTargets[key];
+            if (keyTarget === target) {
+                keys.push(key);
+            }
+        }
+        return keys;
+    }
     updateKeyTarget(key, scope, target, external = false) {
-        var _a, _b;
         // Add
         const keyTargets = this.getKeyTargets(scope);
         if (typeof target === 'number') {
             if (keyTargets[key] !== target) {
                 keyTargets[key] = target;
-                (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.set(TARGET_KEY, JSON.stringify(keyTargets), external);
+                this.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets), external);
             }
         }
         // Remove
         else {
             if (typeof keyTargets[key] === 'number') {
                 delete keyTargets[key];
-                (_b = this.getStorage(scope)) === null || _b === void 0 ? void 0 : _b.set(TARGET_KEY, JSON.stringify(keyTargets), external);
+                this.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets), external);
             }
         }
     }
@@ -167,8 +235,87 @@
         const storage = this.getStorage(scope);
         return storage ? loadKeyTargets(storage) : Object.create(null);
     }
+    isNew(scope) {
+        return this.getBoolean(IS_NEW_KEY, scope) === true;
+    }
+    async flush(reason = WillSaveStateReason.NONE) {
+        // Signal event to collect changes
+        this._onWillSaveState.fire({ reason });
+        const applicationStorage = this.getStorage(-1 /* StorageScope.APPLICATION */);
+        const profileStorage = this.getStorage(0 /* StorageScope.PROFILE */);
+        const workspaceStorage = this.getStorage(1 /* StorageScope.WORKSPACE */);
+        switch (reason) {
+            // Unspecific reason: just wait when data is flushed
+            case WillSaveStateReason.NONE:
+                await Promises.settled([
+                    applicationStorage?.whenFlushed() ?? Promise.resolve(),
+                    profileStorage?.whenFlushed() ?? Promise.resolve(),
+                    workspaceStorage?.whenFlushed() ?? Promise.resolve()
+                ]);
+                break;
+            // Shutdown: we want to flush as soon as possible
+            // and not hit any delays that might be there
+            case WillSaveStateReason.SHUTDOWN:
+                await Promises.settled([
+                    applicationStorage?.flush(0) ?? Promise.resolve(),
+                    profileStorage?.flush(0) ?? Promise.resolve(),
+                    workspaceStorage?.flush(0) ?? Promise.resolve()
+                ]);
+                break;
+        }
+    }
+    async log() {
+        const applicationItems = this.getStorage(-1 /* StorageScope.APPLICATION */)?.items ?? new Map();
+        const profileItems = this.getStorage(0 /* StorageScope.PROFILE */)?.items ?? new Map();
+        const workspaceItems = this.getStorage(1 /* StorageScope.WORKSPACE */)?.items ?? new Map();
+        return logStorage(applicationItems, profileItems, workspaceItems, this.getLogDetails(-1 /* StorageScope.APPLICATION */) ?? '', this.getLogDetails(0 /* StorageScope.PROFILE */) ?? '', this.getLogDetails(1 /* StorageScope.WORKSPACE */) ?? '');
+    }
+    async optimize(scope) {
+        // Await pending data to be flushed to the DB
+        // before attempting to optimize the DB
+        await this.flush();
+        return this.getStorage(scope)?.optimize();
+    }
+    async switch(to, preserveData) {
+        // Signal as event so that clients can store data before we switch
+        this.emitWillSaveState(WillSaveStateReason.NONE);
+        if (isUserDataProfile(to)) {
+            return this.switchToProfile(to, preserveData);
+        }
+        return this.switchToWorkspace(to, preserveData);
+    }
+    canSwitchProfile(from, to) {
+        if (from.id === to.id) {
+            return false; // both profiles are same
+        }
+        if (isProfileUsingDefaultStorage(to) && isProfileUsingDefaultStorage(from)) {
+            return false; // both profiles are using default
+        }
+        return true;
+    }
+    switchData(oldStorage, newStorage, scope) {
+        this.withPausedEmitters(() => {
+            // Signal storage keys that have changed
+            const handledkeys = new Set();
+            for (const [key, oldValue] of oldStorage) {
+                handledkeys.add(key);
+                const newValue = newStorage.get(key);
+                if (newValue !== oldValue) {
+                    this.emitDidChangeValue(scope, { key, external: true });
+                }
+            }
+            for (const [key] of newStorage.items) {
+                if (!handledkeys.has(key)) {
+                    this.emitDidChangeValue(scope, { key, external: true });
+                }
+            }
+        });
+    }
 }
 AbstractStorageService.DEFAULT_FLUSH_INTERVAL = 60 * 1000; // every minute
+export function isProfileUsingDefaultStorage(profile) {
+    return profile.isDefault || !!profile.useDefaultFlags?.globalState;
+}
 export class InMemoryStorageService extends AbstractStorageService {
     constructor() {
         super();
@@ -189,4 +336,86 @@
                 return this.workspaceStorage;
         }
     }
+    getLogDetails(scope) {
+        switch (scope) {
+            case -1 /* StorageScope.APPLICATION */:
+                return 'inMemory (application)';
+            case 0 /* StorageScope.PROFILE */:
+                return 'inMemory (profile)';
+            default:
+                return 'inMemory (workspace)';
+        }
+    }
+    async doInitialize() { }
+    async switchToProfile() {
+        // no-op when in-memory
+    }
+    async switchToWorkspace() {
+        // no-op when in-memory
+    }
+    shouldFlushWhenIdle() {
+        return false;
+    }
+    hasScope(scope) {
+        return false;
+    }
+}
+export async function logStorage(application, profile, workspace, applicationPath, profilePath, workspacePath) {
+    const safeParse = (value) => {
+        try {
+            return JSON.parse(value);
+        }
+        catch (error) {
+            return value;
+        }
+    };
+    const applicationItems = new Map();
+    const applicationItemsParsed = new Map();
+    application.forEach((value, key) => {
+        applicationItems.set(key, value);
+        applicationItemsParsed.set(key, safeParse(value));
+    });
+    const profileItems = new Map();
+    const profileItemsParsed = new Map();
+    profile.forEach((value, key) => {
+        profileItems.set(key, value);
+        profileItemsParsed.set(key, safeParse(value));
+    });
+    const workspaceItems = new Map();
+    const workspaceItemsParsed = new Map();
+    workspace.forEach((value, key) => {
+        workspaceItems.set(key, value);
+        workspaceItemsParsed.set(key, safeParse(value));
+    });
+    if (applicationPath !== profilePath) {
+        console.group(`Storage: Application (path: ${applicationPath})`);
+    }
+    else {
+        console.group(`Storage: Application & Profile (path: ${applicationPath}, default profile)`);
+    }
+    const applicationValues = [];
+    applicationItems.forEach((value, key) => {
+        applicationValues.push({ key, value });
+    });
+    console.table(applicationValues);
+    console.groupEnd();
+    console.log(applicationItemsParsed);
+    if (applicationPath !== profilePath) {
+        console.group(`Storage: Profile (path: ${profilePath}, profile specific)`);
+        const profileValues = [];
+        profileItems.forEach((value, key) => {
+            profileValues.push({ key, value });
+        });
+        console.table(profileValues);
+        console.groupEnd();
+        console.log(profileItemsParsed);
+    }
+    console.group(`Storage: Workspace (path: ${workspacePath})`);
+    const workspaceValues = [];
+    workspaceItems.forEach((value, key) => {
+        workspaceValues.push({ key, value });
+    });
+    console.table(workspaceValues);
+    console.groupEnd();
+    console.log(workspaceItemsParsed);
 }
diff -urN -x '*.map' a/vs/platform/telemetry/common/telemetry.js b/vs/platform/telemetry/common/telemetry.js
--- a/vs/platform/telemetry/common/telemetry.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/telemetry/common/telemetry.js	2023-12-06 14:23:14.391854805 +0000
@@ -4,3 +4,14 @@
  *--------------------------------------------------------------------------------------------*/
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export const ITelemetryService = createDecorator('telemetryService');
+export const ICustomEndpointTelemetryService = createDecorator('customEndpointTelemetryService');
+// Keys
+export const currentSessionDateStorageKey = 'telemetry.currentSessionDate';
+export const firstSessionDateStorageKey = 'telemetry.firstSessionDate';
+export const lastSessionDateStorageKey = 'telemetry.lastSessionDate';
+export const machineIdKey = 'telemetry.machineId';
+// Configuration Keys
+export const TELEMETRY_SECTION_ID = 'telemetry';
+export const TELEMETRY_SETTING_ID = 'telemetry.telemetryLevel';
+export const TELEMETRY_CRASH_REPORTER_SETTING_ID = 'telemetry.enableCrashReporter';
+export const TELEMETRY_OLD_SETTING_ID = 'telemetry.enableTelemetry';
diff -urN -x '*.map' a/vs/platform/theme/browser/defaultStyles.js b/vs/platform/theme/browser/defaultStyles.js
--- a/vs/platform/theme/browser/defaultStyles.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/theme/browser/defaultStyles.js	2023-12-06 14:23:14.391854805 +0000
@@ -1,7 +1,7 @@
 import { keybindingLabelBackground, keybindingLabelBorder, keybindingLabelBottomBorder, keybindingLabelForeground, asCssVariable, widgetShadow, buttonForeground, buttonSeparator, buttonBackground, buttonHoverBackground, buttonSecondaryForeground, buttonSecondaryBackground, buttonSecondaryHoverBackground, buttonBorder, progressBarBackground, inputActiveOptionBorder, inputActiveOptionForeground, inputActiveOptionBackground, editorWidgetBackground, editorWidgetForeground, contrastBorder, checkboxBorder, checkboxBackground, checkboxForeground, problemsErrorIconForeground, problemsWarningIconForeground, problemsInfoIconForeground, inputBackground, inputForeground, inputBorder, textLinkForeground, inputValidationInfoBorder, inputValidationInfoBackground, inputValidationInfoForeground, inputValidationWarningBorder, inputValidationWarningBackground, inputValidationWarningForeground, inputValidationErrorBorder, inputValidationErrorBackground, inputValidationErrorForeground, listFilterWidgetBackground, listFilterWidgetNoMatchesOutline, listFilterWidgetOutline, listFilterWidgetShadow, badgeBackground, badgeForeground, breadcrumbsBackground, breadcrumbsForeground, breadcrumbsFocusForeground, breadcrumbsActiveSelectionForeground, activeContrastBorder, listActiveSelectionBackground, listActiveSelectionForeground, listActiveSelectionIconForeground, listDropBackground, listFocusAndSelectionOutline, listFocusBackground, listFocusForeground, listFocusOutline, listHoverBackground, listHoverForeground, listInactiveFocusBackground, listInactiveFocusOutline, listInactiveSelectionBackground, listInactiveSelectionForeground, listInactiveSelectionIconForeground, tableColumnsBorder, tableOddRowsBackgroundColor, treeIndentGuidesStroke, asCssVariableWithDefault, editorWidgetBorder, focusBorder, pickerGroupForeground, quickInputListFocusBackground, quickInputListFocusForeground, quickInputListFocusIconForeground, selectBackground, selectBorder, selectForeground, selectListBackground, treeInactiveIndentGuidesStroke, menuBorder, menuForeground, menuBackground, menuSelectionForeground, menuSelectionBackground, menuSelectionBorder, menuSeparatorBackground, scrollbarShadow, scrollbarSliderActiveBackground, scrollbarSliderBackground, scrollbarSliderHoverBackground } from '../common/colorRegistry.js';
 import { Color } from '../../../base/common/color.js';
 function overrideStyles(override, styles) {
-    const result = Object.assign({}, styles);
+    const result = { ...styles };
     for (const key in override) {
         const val = override[key];
         result[key] = val !== undefined ? asCssVariable(val) : undefined;
@@ -15,6 +15,9 @@
     keybindingLabelBottomBorder: asCssVariable(keybindingLabelBottomBorder),
     keybindingLabelShadow: asCssVariable(widgetShadow)
 };
+export function getKeybindingLabelStyles(override) {
+    return overrideStyles(override, defaultKeybindingLabelStyles);
+}
 export const defaultButtonStyles = {
     buttonForeground: asCssVariable(buttonForeground),
     buttonSeparator: asCssVariable(buttonSeparator),
@@ -25,19 +28,31 @@
     buttonSecondaryHoverBackground: asCssVariable(buttonSecondaryHoverBackground),
     buttonBorder: asCssVariable(buttonBorder),
 };
+export function getButtonStyles(override) {
+    return overrideStyles(override, defaultButtonStyles);
+}
 export const defaultProgressBarStyles = {
     progressBarBackground: asCssVariable(progressBarBackground)
 };
+export function getProgressBarStyles(override) {
+    return overrideStyles(override, defaultProgressBarStyles);
+}
 export const defaultToggleStyles = {
     inputActiveOptionBorder: asCssVariable(inputActiveOptionBorder),
     inputActiveOptionForeground: asCssVariable(inputActiveOptionForeground),
     inputActiveOptionBackground: asCssVariable(inputActiveOptionBackground)
 };
+export function getToggleStyles(override) {
+    return overrideStyles(override, defaultToggleStyles);
+}
 export const defaultCheckboxStyles = {
     checkboxBackground: asCssVariable(checkboxBackground),
     checkboxBorder: asCssVariable(checkboxBorder),
     checkboxForeground: asCssVariable(checkboxForeground)
 };
+export function getCheckboxStyles(override) {
+    return overrideStyles(override, defaultCheckboxStyles);
+}
 export const defaultDialogStyles = {
     dialogBackground: asCssVariable(editorWidgetBackground),
     dialogForeground: asCssVariable(editorWidgetForeground),
@@ -48,6 +63,9 @@
     infoIconForeground: asCssVariable(problemsInfoIconForeground),
     textLinkForeground: asCssVariable(textLinkForeground)
 };
+export function getDialogStyle(override) {
+    return overrideStyles(override, defaultDialogStyles);
+}
 export const defaultInputBoxStyles = {
     inputBackground: asCssVariable(inputBackground),
     inputForeground: asCssVariable(inputForeground),
@@ -62,6 +80,9 @@
     inputValidationErrorBackground: asCssVariable(inputValidationErrorBackground),
     inputValidationErrorForeground: asCssVariable(inputValidationErrorForeground)
 };
+export function getInputBoxStyle(override) {
+    return overrideStyles(override, defaultInputBoxStyles);
+}
 export const defaultFindWidgetStyles = {
     listFilterWidgetBackground: asCssVariable(listFilterWidgetBackground),
     listFilterWidgetOutline: asCssVariable(listFilterWidgetOutline),
@@ -75,6 +96,9 @@
     badgeForeground: asCssVariable(badgeForeground),
     badgeBorder: asCssVariable(contrastBorder)
 };
+export function getCountBadgeStyle(override) {
+    return overrideStyles(override, defaultCountBadgeStyles);
+}
 export const defaultBreadcrumbsWidgetStyles = {
     breadcrumbsBackground: asCssVariable(breadcrumbsBackground),
     breadcrumbsForeground: asCssVariable(breadcrumbsForeground),
@@ -82,6 +106,9 @@
     breadcrumbsFocusForeground: asCssVariable(breadcrumbsFocusForeground),
     breadcrumbsFocusAndSelectionForeground: asCssVariable(breadcrumbsActiveSelectionForeground)
 };
+export function getBreadcrumbsWidgetStyles(override) {
+    return overrideStyles(override, defaultBreadcrumbsWidgetStyles);
+}
 export const defaultListStyles = {
     listBackground: undefined,
     listInactiveFocusForeground: undefined,
@@ -146,6 +173,9 @@
     treeIndentGuidesStroke: undefined,
     treeInactiveIndentGuidesStroke: undefined,
 };
+export function getSelectBoxStyles(override) {
+    return overrideStyles(override, defaultSelectBoxStyles);
+}
 export const defaultMenuStyles = {
     shadowColor: asCssVariable(widgetShadow),
     borderColor: asCssVariable(menuBorder),
@@ -160,3 +190,6 @@
     scrollbarSliderHoverBackground: asCssVariable(scrollbarSliderHoverBackground),
     scrollbarSliderActiveBackground: asCssVariable(scrollbarSliderActiveBackground)
 };
+export function getMenuStyles(override) {
+    return overrideStyles(override, defaultMenuStyles);
+}
diff -urN -x '*.map' a/vs/platform/theme/common/colorRegistry.js b/vs/platform/theme/common/colorRegistry.js
--- a/vs/platform/theme/common/colorRegistry.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/theme/common/colorRegistry.js	2023-12-06 14:23:14.391854805 +0000
@@ -49,6 +49,16 @@
         this._onDidChangeSchema.fire();
         return id;
     }
+    deregisterColor(id) {
+        delete this.colorsById[id];
+        delete this.colorSchema.properties[id];
+        const index = this.colorReferenceSchema.enum.indexOf(id);
+        if (index !== -1) {
+            this.colorReferenceSchema.enum.splice(index, 1);
+            this.colorReferenceSchema.enumDescriptions.splice(index, 1);
+        }
+        this._onDidChangeSchema.fire();
+    }
     getColors() {
         return Object.keys(this.colorsById).map(id => this.colorsById[id]);
     }
@@ -63,6 +73,9 @@
     getColorSchema() {
         return this.colorSchema;
     }
+    getColorReferenceSchema() {
+        return this.colorReferenceSchema;
+    }
     toString() {
         const sorter = (a, b) => {
             const cat1 = a.indexOf('.') === -1 ? 0 : 1;
@@ -80,264 +93,267 @@
 export function registerColor(id, defaults, description, needsTransparency, deprecationMessage) {
     return colorRegistry.registerColor(id, defaults, description, needsTransparency, deprecationMessage);
 }
+export function getColorRegistry() {
+    return colorRegistry;
+}
 // ----- base colors
-export const foreground = registerColor('foreground', { dark: '#CCCCCC', light: '#616161', hcDark: '#FFFFFF', hcLight: '#292929' }, nls.localize('foreground', "Overall foreground color. This color is only used if not overridden by a component."));
-export const disabledForeground = registerColor('disabledForeground', { dark: '#CCCCCC80', light: '#61616180', hcDark: '#A5A5A5', hcLight: '#7F7F7F' }, nls.localize('disabledForeground', "Overall foreground for disabled elements. This color is only used if not overridden by a component."));
-export const errorForeground = registerColor('errorForeground', { dark: '#F48771', light: '#A1260D', hcDark: '#F48771', hcLight: '#B5200D' }, nls.localize('errorForeground', "Overall foreground color for error messages. This color is only used if not overridden by a component."));
-export const descriptionForeground = registerColor('descriptionForeground', { light: '#717171', dark: transparent(foreground, 0.7), hcDark: transparent(foreground, 0.7), hcLight: transparent(foreground, 0.7) }, nls.localize('descriptionForeground', "Foreground color for description text providing additional information, for example for a label."));
-export const iconForeground = registerColor('icon.foreground', { dark: '#C5C5C5', light: '#424242', hcDark: '#FFFFFF', hcLight: '#292929' }, nls.localize('iconForeground', "The default color for icons in the workbench."));
-export const focusBorder = registerColor('focusBorder', { dark: '#007FD4', light: '#0090F1', hcDark: '#F38518', hcLight: '#006BBD' }, nls.localize('focusBorder', "Overall border color for focused elements. This color is only used if not overridden by a component."));
-export const contrastBorder = registerColor('contrastBorder', { light: null, dark: null, hcDark: '#6FC3DF', hcLight: '#0F4A85' }, nls.localize('contrastBorder', "An extra border around elements to separate them from others for greater contrast."));
-export const activeContrastBorder = registerColor('contrastActiveBorder', { light: null, dark: null, hcDark: focusBorder, hcLight: focusBorder }, nls.localize('activeContrastBorder', "An extra border around active elements to separate them from others for greater contrast."));
-export const selectionBackground = registerColor('selection.background', { light: null, dark: null, hcDark: null, hcLight: null }, nls.localize('selectionBackground', "The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor."));
+export const foreground = registerColor('foreground', { dark: '#CCCCCC', light: '#616161', hcDark: '#FFFFFF', hcLight: '#292929' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'foreground', "Overall foreground color. This color is only used if not overridden by a component."));
+export const disabledForeground = registerColor('disabledForeground', { dark: '#CCCCCC80', light: '#61616180', hcDark: '#A5A5A5', hcLight: '#7F7F7F' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'disabledForeground', "Overall foreground for disabled elements. This color is only used if not overridden by a component."));
+export const errorForeground = registerColor('errorForeground', { dark: '#F48771', light: '#A1260D', hcDark: '#F48771', hcLight: '#B5200D' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'errorForeground', "Overall foreground color for error messages. This color is only used if not overridden by a component."));
+export const descriptionForeground = registerColor('descriptionForeground', { light: '#717171', dark: transparent(foreground, 0.7), hcDark: transparent(foreground, 0.7), hcLight: transparent(foreground, 0.7) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'descriptionForeground', "Foreground color for description text providing additional information, for example for a label."));
+export const iconForeground = registerColor('icon.foreground', { dark: '#C5C5C5', light: '#424242', hcDark: '#FFFFFF', hcLight: '#292929' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'iconForeground', "The default color for icons in the workbench."));
+export const focusBorder = registerColor('focusBorder', { dark: '#007FD4', light: '#0090F1', hcDark: '#F38518', hcLight: '#006BBD' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'focusBorder', "Overall border color for focused elements. This color is only used if not overridden by a component."));
+export const contrastBorder = registerColor('contrastBorder', { light: null, dark: null, hcDark: '#6FC3DF', hcLight: '#0F4A85' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'contrastBorder', "An extra border around elements to separate them from others for greater contrast."));
+export const activeContrastBorder = registerColor('contrastActiveBorder', { light: null, dark: null, hcDark: focusBorder, hcLight: focusBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'activeContrastBorder', "An extra border around active elements to separate them from others for greater contrast."));
+export const selectionBackground = registerColor('selection.background', { light: null, dark: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'selectionBackground', "The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor."));
 // ------ text colors
-export const textSeparatorForeground = registerColor('textSeparator.foreground', { light: '#0000002e', dark: '#ffffff2e', hcDark: Color.black, hcLight: '#292929' }, nls.localize('textSeparatorForeground', "Color for text separators."));
-export const textLinkForeground = registerColor('textLink.foreground', { light: '#006AB1', dark: '#3794FF', hcDark: '#3794FF', hcLight: '#0F4A85' }, nls.localize('textLinkForeground', "Foreground color for links in text."));
-export const textLinkActiveForeground = registerColor('textLink.activeForeground', { light: '#006AB1', dark: '#3794FF', hcDark: '#3794FF', hcLight: '#0F4A85' }, nls.localize('textLinkActiveForeground', "Foreground color for links in text when clicked on and on mouse hover."));
-export const textPreformatForeground = registerColor('textPreformat.foreground', { light: '#A31515', dark: '#D7BA7D', hcDark: '#D7BA7D', hcLight: '#292929' }, nls.localize('textPreformatForeground', "Foreground color for preformatted text segments."));
-export const textBlockQuoteBackground = registerColor('textBlockQuote.background', { light: '#7f7f7f1a', dark: '#7f7f7f1a', hcDark: null, hcLight: '#F2F2F2' }, nls.localize('textBlockQuoteBackground', "Background color for block quotes in text."));
-export const textBlockQuoteBorder = registerColor('textBlockQuote.border', { light: '#007acc80', dark: '#007acc80', hcDark: Color.white, hcLight: '#292929' }, nls.localize('textBlockQuoteBorder', "Border color for block quotes in text."));
-export const textCodeBlockBackground = registerColor('textCodeBlock.background', { light: '#dcdcdc66', dark: '#0a0a0a66', hcDark: Color.black, hcLight: '#F2F2F2' }, nls.localize('textCodeBlockBackground', "Background color for code blocks in text."));
+export const textSeparatorForeground = registerColor('textSeparator.foreground', { light: '#0000002e', dark: '#ffffff2e', hcDark: Color.black, hcLight: '#292929' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'textSeparatorForeground', "Color for text separators."));
+export const textLinkForeground = registerColor('textLink.foreground', { light: '#006AB1', dark: '#3794FF', hcDark: '#3794FF', hcLight: '#0F4A85' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'textLinkForeground', "Foreground color for links in text."));
+export const textLinkActiveForeground = registerColor('textLink.activeForeground', { light: '#006AB1', dark: '#3794FF', hcDark: '#3794FF', hcLight: '#0F4A85' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'textLinkActiveForeground', "Foreground color for links in text when clicked on and on mouse hover."));
+export const textPreformatForeground = registerColor('textPreformat.foreground', { light: '#A31515', dark: '#D7BA7D', hcDark: '#D7BA7D', hcLight: '#292929' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'textPreformatForeground', "Foreground color for preformatted text segments."));
+export const textBlockQuoteBackground = registerColor('textBlockQuote.background', { light: '#7f7f7f1a', dark: '#7f7f7f1a', hcDark: null, hcLight: '#F2F2F2' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'textBlockQuoteBackground', "Background color for block quotes in text."));
+export const textBlockQuoteBorder = registerColor('textBlockQuote.border', { light: '#007acc80', dark: '#007acc80', hcDark: Color.white, hcLight: '#292929' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'textBlockQuoteBorder', "Border color for block quotes in text."));
+export const textCodeBlockBackground = registerColor('textCodeBlock.background', { light: '#dcdcdc66', dark: '#0a0a0a66', hcDark: Color.black, hcLight: '#F2F2F2' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'textCodeBlockBackground', "Background color for code blocks in text."));
 // ----- widgets
-export const widgetShadow = registerColor('widget.shadow', { dark: transparent(Color.black, .36), light: transparent(Color.black, .16), hcDark: null, hcLight: null }, nls.localize('widgetShadow', 'Shadow color of widgets such as find/replace inside the editor.'));
-export const widgetBorder = registerColor('widget.border', { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('widgetBorder', 'Border color of widgets such as find/replace inside the editor.'));
-export const inputBackground = registerColor('input.background', { dark: '#3C3C3C', light: Color.white, hcDark: Color.black, hcLight: Color.white }, nls.localize('inputBoxBackground', "Input box background."));
-export const inputForeground = registerColor('input.foreground', { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, nls.localize('inputBoxForeground', "Input box foreground."));
-export const inputBorder = registerColor('input.border', { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('inputBoxBorder', "Input box border."));
-export const inputActiveOptionBorder = registerColor('inputOption.activeBorder', { dark: '#007ACC', light: '#007ACC', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('inputBoxActiveOptionBorder', "Border color of activated options in input fields."));
-export const inputActiveOptionHoverBackground = registerColor('inputOption.hoverBackground', { dark: '#5a5d5e80', light: '#b8b8b850', hcDark: null, hcLight: null }, nls.localize('inputOption.hoverBackground', "Background color of activated options in input fields."));
-export const inputActiveOptionBackground = registerColor('inputOption.activeBackground', { dark: transparent(focusBorder, 0.4), light: transparent(focusBorder, 0.2), hcDark: Color.transparent, hcLight: Color.transparent }, nls.localize('inputOption.activeBackground', "Background hover color of options in input fields."));
-export const inputActiveOptionForeground = registerColor('inputOption.activeForeground', { dark: Color.white, light: Color.black, hcDark: foreground, hcLight: foreground }, nls.localize('inputOption.activeForeground', "Foreground color of activated options in input fields."));
-export const inputPlaceholderForeground = registerColor('input.placeholderForeground', { light: transparent(foreground, 0.5), dark: transparent(foreground, 0.5), hcDark: transparent(foreground, 0.7), hcLight: transparent(foreground, 0.7) }, nls.localize('inputPlaceholderForeground', "Input box foreground color for placeholder text."));
-export const inputValidationInfoBackground = registerColor('inputValidation.infoBackground', { dark: '#063B49', light: '#D6ECF2', hcDark: Color.black, hcLight: Color.white }, nls.localize('inputValidationInfoBackground', "Input validation background color for information severity."));
-export const inputValidationInfoForeground = registerColor('inputValidation.infoForeground', { dark: null, light: null, hcDark: null, hcLight: foreground }, nls.localize('inputValidationInfoForeground', "Input validation foreground color for information severity."));
-export const inputValidationInfoBorder = registerColor('inputValidation.infoBorder', { dark: '#007acc', light: '#007acc', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('inputValidationInfoBorder', "Input validation border color for information severity."));
-export const inputValidationWarningBackground = registerColor('inputValidation.warningBackground', { dark: '#352A05', light: '#F6F5D2', hcDark: Color.black, hcLight: Color.white }, nls.localize('inputValidationWarningBackground', "Input validation background color for warning severity."));
-export const inputValidationWarningForeground = registerColor('inputValidation.warningForeground', { dark: null, light: null, hcDark: null, hcLight: foreground }, nls.localize('inputValidationWarningForeground', "Input validation foreground color for warning severity."));
-export const inputValidationWarningBorder = registerColor('inputValidation.warningBorder', { dark: '#B89500', light: '#B89500', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('inputValidationWarningBorder', "Input validation border color for warning severity."));
-export const inputValidationErrorBackground = registerColor('inputValidation.errorBackground', { dark: '#5A1D1D', light: '#F2DEDE', hcDark: Color.black, hcLight: Color.white }, nls.localize('inputValidationErrorBackground', "Input validation background color for error severity."));
-export const inputValidationErrorForeground = registerColor('inputValidation.errorForeground', { dark: null, light: null, hcDark: null, hcLight: foreground }, nls.localize('inputValidationErrorForeground', "Input validation foreground color for error severity."));
-export const inputValidationErrorBorder = registerColor('inputValidation.errorBorder', { dark: '#BE1100', light: '#BE1100', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('inputValidationErrorBorder', "Input validation border color for error severity."));
-export const selectBackground = registerColor('dropdown.background', { dark: '#3C3C3C', light: Color.white, hcDark: Color.black, hcLight: Color.white }, nls.localize('dropdownBackground', "Dropdown background."));
-export const selectListBackground = registerColor('dropdown.listBackground', { dark: null, light: null, hcDark: Color.black, hcLight: Color.white }, nls.localize('dropdownListBackground', "Dropdown list background."));
-export const selectForeground = registerColor('dropdown.foreground', { dark: '#F0F0F0', light: foreground, hcDark: Color.white, hcLight: foreground }, nls.localize('dropdownForeground', "Dropdown foreground."));
-export const selectBorder = registerColor('dropdown.border', { dark: selectBackground, light: '#CECECE', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('dropdownBorder', "Dropdown border."));
-export const buttonForeground = registerColor('button.foreground', { dark: Color.white, light: Color.white, hcDark: Color.white, hcLight: Color.white }, nls.localize('buttonForeground', "Button foreground color."));
-export const buttonSeparator = registerColor('button.separator', { dark: transparent(buttonForeground, .4), light: transparent(buttonForeground, .4), hcDark: transparent(buttonForeground, .4), hcLight: transparent(buttonForeground, .4) }, nls.localize('buttonSeparator', "Button separator color."));
-export const buttonBackground = registerColor('button.background', { dark: '#0E639C', light: '#007ACC', hcDark: null, hcLight: '#0F4A85' }, nls.localize('buttonBackground', "Button background color."));
-export const buttonHoverBackground = registerColor('button.hoverBackground', { dark: lighten(buttonBackground, 0.2), light: darken(buttonBackground, 0.2), hcDark: buttonBackground, hcLight: buttonBackground }, nls.localize('buttonHoverBackground', "Button background color when hovering."));
-export const buttonBorder = registerColor('button.border', { dark: contrastBorder, light: contrastBorder, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('buttonBorder', "Button border color."));
-export const buttonSecondaryForeground = registerColor('button.secondaryForeground', { dark: Color.white, light: Color.white, hcDark: Color.white, hcLight: foreground }, nls.localize('buttonSecondaryForeground', "Secondary button foreground color."));
-export const buttonSecondaryBackground = registerColor('button.secondaryBackground', { dark: '#3A3D41', light: '#5F6A79', hcDark: null, hcLight: Color.white }, nls.localize('buttonSecondaryBackground', "Secondary button background color."));
-export const buttonSecondaryHoverBackground = registerColor('button.secondaryHoverBackground', { dark: lighten(buttonSecondaryBackground, 0.2), light: darken(buttonSecondaryBackground, 0.2), hcDark: null, hcLight: null }, nls.localize('buttonSecondaryHoverBackground', "Secondary button background color when hovering."));
-export const badgeBackground = registerColor('badge.background', { dark: '#4D4D4D', light: '#C4C4C4', hcDark: Color.black, hcLight: '#0F4A85' }, nls.localize('badgeBackground', "Badge background color. Badges are small information labels, e.g. for search results count."));
-export const badgeForeground = registerColor('badge.foreground', { dark: Color.white, light: '#333', hcDark: Color.white, hcLight: Color.white }, nls.localize('badgeForeground', "Badge foreground color. Badges are small information labels, e.g. for search results count."));
-export const scrollbarShadow = registerColor('scrollbar.shadow', { dark: '#000000', light: '#DDDDDD', hcDark: null, hcLight: null }, nls.localize('scrollbarShadow', "Scrollbar shadow to indicate that the view is scrolled."));
-export const scrollbarSliderBackground = registerColor('scrollbarSlider.background', { dark: Color.fromHex('#797979').transparent(0.4), light: Color.fromHex('#646464').transparent(0.4), hcDark: transparent(contrastBorder, 0.6), hcLight: transparent(contrastBorder, 0.4) }, nls.localize('scrollbarSliderBackground', "Scrollbar slider background color."));
-export const scrollbarSliderHoverBackground = registerColor('scrollbarSlider.hoverBackground', { dark: Color.fromHex('#646464').transparent(0.7), light: Color.fromHex('#646464').transparent(0.7), hcDark: transparent(contrastBorder, 0.8), hcLight: transparent(contrastBorder, 0.8) }, nls.localize('scrollbarSliderHoverBackground', "Scrollbar slider background color when hovering."));
-export const scrollbarSliderActiveBackground = registerColor('scrollbarSlider.activeBackground', { dark: Color.fromHex('#BFBFBF').transparent(0.4), light: Color.fromHex('#000000').transparent(0.6), hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('scrollbarSliderActiveBackground', "Scrollbar slider background color when clicked on."));
-export const progressBarBackground = registerColor('progressBar.background', { dark: Color.fromHex('#0E70C0'), light: Color.fromHex('#0E70C0'), hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('progressBarBackground', "Background color of the progress bar that can show for long running operations."));
-export const editorErrorBackground = registerColor('editorError.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorError.background', 'Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const editorErrorForeground = registerColor('editorError.foreground', { dark: '#F14C4C', light: '#E51400', hcDark: '#F48771', hcLight: '#B5200D' }, nls.localize('editorError.foreground', 'Foreground color of error squigglies in the editor.'));
-export const editorErrorBorder = registerColor('editorError.border', { dark: null, light: null, hcDark: Color.fromHex('#E47777').transparent(0.8), hcLight: '#B5200D' }, nls.localize('errorBorder', 'If set, color of double underlines for errors in the editor.'));
-export const editorWarningBackground = registerColor('editorWarning.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorWarning.background', 'Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const editorWarningForeground = registerColor('editorWarning.foreground', { dark: '#CCA700', light: '#BF8803', hcDark: '#FFD370', hcLight: '#895503' }, nls.localize('editorWarning.foreground', 'Foreground color of warning squigglies in the editor.'));
-export const editorWarningBorder = registerColor('editorWarning.border', { dark: null, light: null, hcDark: Color.fromHex('#FFCC00').transparent(0.8), hcLight: Color.fromHex('#FFCC00').transparent(0.8) }, nls.localize('warningBorder', 'If set, color of double underlines for warnings in the editor.'));
-export const editorInfoBackground = registerColor('editorInfo.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorInfo.background', 'Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const editorInfoForeground = registerColor('editorInfo.foreground', { dark: '#3794FF', light: '#1a85ff', hcDark: '#3794FF', hcLight: '#1a85ff' }, nls.localize('editorInfo.foreground', 'Foreground color of info squigglies in the editor.'));
-export const editorInfoBorder = registerColor('editorInfo.border', { dark: null, light: null, hcDark: Color.fromHex('#3794FF').transparent(0.8), hcLight: '#292929' }, nls.localize('infoBorder', 'If set, color of double underlines for infos in the editor.'));
-export const editorHintForeground = registerColor('editorHint.foreground', { dark: Color.fromHex('#eeeeee').transparent(0.7), light: '#6c6c6c', hcDark: null, hcLight: null }, nls.localize('editorHint.foreground', 'Foreground color of hint squigglies in the editor.'));
-export const editorHintBorder = registerColor('editorHint.border', { dark: null, light: null, hcDark: Color.fromHex('#eeeeee').transparent(0.8), hcLight: '#292929' }, nls.localize('hintBorder', 'If set, color of double underlines for hints in the editor.'));
-export const sashHoverBorder = registerColor('sash.hoverBorder', { dark: focusBorder, light: focusBorder, hcDark: focusBorder, hcLight: focusBorder }, nls.localize('sashActiveBorder', "Border color of active sashes."));
+export const widgetShadow = registerColor('widget.shadow', { dark: transparent(Color.black, .36), light: transparent(Color.black, .16), hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'widgetShadow', 'Shadow color of widgets such as find/replace inside the editor.'));
+export const widgetBorder = registerColor('widget.border', { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'widgetBorder', 'Border color of widgets such as find/replace inside the editor.'));
+export const inputBackground = registerColor('input.background', { dark: '#3C3C3C', light: Color.white, hcDark: Color.black, hcLight: Color.white }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputBoxBackground', "Input box background."));
+export const inputForeground = registerColor('input.foreground', { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputBoxForeground', "Input box foreground."));
+export const inputBorder = registerColor('input.border', { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputBoxBorder', "Input box border."));
+export const inputActiveOptionBorder = registerColor('inputOption.activeBorder', { dark: '#007ACC', light: '#007ACC', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputBoxActiveOptionBorder', "Border color of activated options in input fields."));
+export const inputActiveOptionHoverBackground = registerColor('inputOption.hoverBackground', { dark: '#5a5d5e80', light: '#b8b8b850', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputOption.hoverBackground', "Background color of activated options in input fields."));
+export const inputActiveOptionBackground = registerColor('inputOption.activeBackground', { dark: transparent(focusBorder, 0.4), light: transparent(focusBorder, 0.2), hcDark: Color.transparent, hcLight: Color.transparent }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputOption.activeBackground', "Background hover color of options in input fields."));
+export const inputActiveOptionForeground = registerColor('inputOption.activeForeground', { dark: Color.white, light: Color.black, hcDark: foreground, hcLight: foreground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputOption.activeForeground', "Foreground color of activated options in input fields."));
+export const inputPlaceholderForeground = registerColor('input.placeholderForeground', { light: transparent(foreground, 0.5), dark: transparent(foreground, 0.5), hcDark: transparent(foreground, 0.7), hcLight: transparent(foreground, 0.7) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputPlaceholderForeground', "Input box foreground color for placeholder text."));
+export const inputValidationInfoBackground = registerColor('inputValidation.infoBackground', { dark: '#063B49', light: '#D6ECF2', hcDark: Color.black, hcLight: Color.white }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputValidationInfoBackground', "Input validation background color for information severity."));
+export const inputValidationInfoForeground = registerColor('inputValidation.infoForeground', { dark: null, light: null, hcDark: null, hcLight: foreground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputValidationInfoForeground', "Input validation foreground color for information severity."));
+export const inputValidationInfoBorder = registerColor('inputValidation.infoBorder', { dark: '#007acc', light: '#007acc', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputValidationInfoBorder', "Input validation border color for information severity."));
+export const inputValidationWarningBackground = registerColor('inputValidation.warningBackground', { dark: '#352A05', light: '#F6F5D2', hcDark: Color.black, hcLight: Color.white }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputValidationWarningBackground', "Input validation background color for warning severity."));
+export const inputValidationWarningForeground = registerColor('inputValidation.warningForeground', { dark: null, light: null, hcDark: null, hcLight: foreground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputValidationWarningForeground', "Input validation foreground color for warning severity."));
+export const inputValidationWarningBorder = registerColor('inputValidation.warningBorder', { dark: '#B89500', light: '#B89500', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputValidationWarningBorder', "Input validation border color for warning severity."));
+export const inputValidationErrorBackground = registerColor('inputValidation.errorBackground', { dark: '#5A1D1D', light: '#F2DEDE', hcDark: Color.black, hcLight: Color.white }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputValidationErrorBackground', "Input validation background color for error severity."));
+export const inputValidationErrorForeground = registerColor('inputValidation.errorForeground', { dark: null, light: null, hcDark: null, hcLight: foreground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputValidationErrorForeground', "Input validation foreground color for error severity."));
+export const inputValidationErrorBorder = registerColor('inputValidation.errorBorder', { dark: '#BE1100', light: '#BE1100', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'inputValidationErrorBorder', "Input validation border color for error severity."));
+export const selectBackground = registerColor('dropdown.background', { dark: '#3C3C3C', light: Color.white, hcDark: Color.black, hcLight: Color.white }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'dropdownBackground', "Dropdown background."));
+export const selectListBackground = registerColor('dropdown.listBackground', { dark: null, light: null, hcDark: Color.black, hcLight: Color.white }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'dropdownListBackground', "Dropdown list background."));
+export const selectForeground = registerColor('dropdown.foreground', { dark: '#F0F0F0', light: foreground, hcDark: Color.white, hcLight: foreground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'dropdownForeground', "Dropdown foreground."));
+export const selectBorder = registerColor('dropdown.border', { dark: selectBackground, light: '#CECECE', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'dropdownBorder', "Dropdown border."));
+export const buttonForeground = registerColor('button.foreground', { dark: Color.white, light: Color.white, hcDark: Color.white, hcLight: Color.white }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'buttonForeground', "Button foreground color."));
+export const buttonSeparator = registerColor('button.separator', { dark: transparent(buttonForeground, .4), light: transparent(buttonForeground, .4), hcDark: transparent(buttonForeground, .4), hcLight: transparent(buttonForeground, .4) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'buttonSeparator', "Button separator color."));
+export const buttonBackground = registerColor('button.background', { dark: '#0E639C', light: '#007ACC', hcDark: null, hcLight: '#0F4A85' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'buttonBackground', "Button background color."));
+export const buttonHoverBackground = registerColor('button.hoverBackground', { dark: lighten(buttonBackground, 0.2), light: darken(buttonBackground, 0.2), hcDark: buttonBackground, hcLight: buttonBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'buttonHoverBackground', "Button background color when hovering."));
+export const buttonBorder = registerColor('button.border', { dark: contrastBorder, light: contrastBorder, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'buttonBorder', "Button border color."));
+export const buttonSecondaryForeground = registerColor('button.secondaryForeground', { dark: Color.white, light: Color.white, hcDark: Color.white, hcLight: foreground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'buttonSecondaryForeground', "Secondary button foreground color."));
+export const buttonSecondaryBackground = registerColor('button.secondaryBackground', { dark: '#3A3D41', light: '#5F6A79', hcDark: null, hcLight: Color.white }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'buttonSecondaryBackground', "Secondary button background color."));
+export const buttonSecondaryHoverBackground = registerColor('button.secondaryHoverBackground', { dark: lighten(buttonSecondaryBackground, 0.2), light: darken(buttonSecondaryBackground, 0.2), hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'buttonSecondaryHoverBackground', "Secondary button background color when hovering."));
+export const badgeBackground = registerColor('badge.background', { dark: '#4D4D4D', light: '#C4C4C4', hcDark: Color.black, hcLight: '#0F4A85' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'badgeBackground', "Badge background color. Badges are small information labels, e.g. for search results count."));
+export const badgeForeground = registerColor('badge.foreground', { dark: Color.white, light: '#333', hcDark: Color.white, hcLight: Color.white }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'badgeForeground', "Badge foreground color. Badges are small information labels, e.g. for search results count."));
+export const scrollbarShadow = registerColor('scrollbar.shadow', { dark: '#000000', light: '#DDDDDD', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'scrollbarShadow', "Scrollbar shadow to indicate that the view is scrolled."));
+export const scrollbarSliderBackground = registerColor('scrollbarSlider.background', { dark: Color.fromHex('#797979').transparent(0.4), light: Color.fromHex('#646464').transparent(0.4), hcDark: transparent(contrastBorder, 0.6), hcLight: transparent(contrastBorder, 0.4) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'scrollbarSliderBackground', "Scrollbar slider background color."));
+export const scrollbarSliderHoverBackground = registerColor('scrollbarSlider.hoverBackground', { dark: Color.fromHex('#646464').transparent(0.7), light: Color.fromHex('#646464').transparent(0.7), hcDark: transparent(contrastBorder, 0.8), hcLight: transparent(contrastBorder, 0.8) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'scrollbarSliderHoverBackground', "Scrollbar slider background color when hovering."));
+export const scrollbarSliderActiveBackground = registerColor('scrollbarSlider.activeBackground', { dark: Color.fromHex('#BFBFBF').transparent(0.4), light: Color.fromHex('#000000').transparent(0.6), hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'scrollbarSliderActiveBackground', "Scrollbar slider background color when clicked on."));
+export const progressBarBackground = registerColor('progressBar.background', { dark: Color.fromHex('#0E70C0'), light: Color.fromHex('#0E70C0'), hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'progressBarBackground', "Background color of the progress bar that can show for long running operations."));
+export const editorErrorBackground = registerColor('editorError.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorError.background', 'Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const editorErrorForeground = registerColor('editorError.foreground', { dark: '#F14C4C', light: '#E51400', hcDark: '#F48771', hcLight: '#B5200D' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorError.foreground', 'Foreground color of error squigglies in the editor.'));
+export const editorErrorBorder = registerColor('editorError.border', { dark: null, light: null, hcDark: Color.fromHex('#E47777').transparent(0.8), hcLight: '#B5200D' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'errorBorder', 'If set, color of double underlines for errors in the editor.'));
+export const editorWarningBackground = registerColor('editorWarning.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorWarning.background', 'Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const editorWarningForeground = registerColor('editorWarning.foreground', { dark: '#CCA700', light: '#BF8803', hcDark: '#FFD370', hcLight: '#895503' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorWarning.foreground', 'Foreground color of warning squigglies in the editor.'));
+export const editorWarningBorder = registerColor('editorWarning.border', { dark: null, light: null, hcDark: Color.fromHex('#FFCC00').transparent(0.8), hcLight: Color.fromHex('#FFCC00').transparent(0.8) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'warningBorder', 'If set, color of double underlines for warnings in the editor.'));
+export const editorInfoBackground = registerColor('editorInfo.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorInfo.background', 'Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const editorInfoForeground = registerColor('editorInfo.foreground', { dark: '#3794FF', light: '#1a85ff', hcDark: '#3794FF', hcLight: '#1a85ff' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorInfo.foreground', 'Foreground color of info squigglies in the editor.'));
+export const editorInfoBorder = registerColor('editorInfo.border', { dark: null, light: null, hcDark: Color.fromHex('#3794FF').transparent(0.8), hcLight: '#292929' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'infoBorder', 'If set, color of double underlines for infos in the editor.'));
+export const editorHintForeground = registerColor('editorHint.foreground', { dark: Color.fromHex('#eeeeee').transparent(0.7), light: '#6c6c6c', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorHint.foreground', 'Foreground color of hint squigglies in the editor.'));
+export const editorHintBorder = registerColor('editorHint.border', { dark: null, light: null, hcDark: Color.fromHex('#eeeeee').transparent(0.8), hcLight: '#292929' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'hintBorder', 'If set, color of double underlines for hints in the editor.'));
+export const sashHoverBorder = registerColor('sash.hoverBorder', { dark: focusBorder, light: focusBorder, hcDark: focusBorder, hcLight: focusBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'sashActiveBorder', "Border color of active sashes."));
 /**
  * Editor background color.
  */
-export const editorBackground = registerColor('editor.background', { light: '#ffffff', dark: '#1E1E1E', hcDark: Color.black, hcLight: Color.white }, nls.localize('editorBackground', "Editor background color."));
+export const editorBackground = registerColor('editor.background', { light: '#ffffff', dark: '#1E1E1E', hcDark: Color.black, hcLight: Color.white }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorBackground', "Editor background color."));
 /**
  * Editor foreground color.
  */
-export const editorForeground = registerColor('editor.foreground', { light: '#333333', dark: '#BBBBBB', hcDark: Color.white, hcLight: foreground }, nls.localize('editorForeground', "Editor default foreground color."));
+export const editorForeground = registerColor('editor.foreground', { light: '#333333', dark: '#BBBBBB', hcDark: Color.white, hcLight: foreground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorForeground', "Editor default foreground color."));
 /**
  * Sticky scroll
  */
-export const editorStickyScrollBackground = registerColor('editorStickyScroll.background', { light: editorBackground, dark: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('editorStickyScrollBackground', "Sticky scroll background color for the editor"));
-export const editorStickyScrollHoverBackground = registerColor('editorStickyScrollHover.background', { dark: '#2A2D2E', light: '#F0F0F0', hcDark: null, hcLight: Color.fromHex('#0F4A85').transparent(0.1) }, nls.localize('editorStickyScrollHoverBackground', "Sticky scroll on hover background color for the editor"));
+export const editorStickyScrollBackground = registerColor('editorStickyScroll.background', { light: editorBackground, dark: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorStickyScrollBackground', "Sticky scroll background color for the editor"));
+export const editorStickyScrollHoverBackground = registerColor('editorStickyScrollHover.background', { dark: '#2A2D2E', light: '#F0F0F0', hcDark: null, hcLight: Color.fromHex('#0F4A85').transparent(0.1) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorStickyScrollHoverBackground', "Sticky scroll on hover background color for the editor"));
 /**
  * Editor widgets
  */
-export const editorWidgetBackground = registerColor('editorWidget.background', { dark: '#252526', light: '#F3F3F3', hcDark: '#0C141F', hcLight: Color.white }, nls.localize('editorWidgetBackground', 'Background color of editor widgets, such as find/replace.'));
-export const editorWidgetForeground = registerColor('editorWidget.foreground', { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, nls.localize('editorWidgetForeground', 'Foreground color of editor widgets, such as find/replace.'));
-export const editorWidgetBorder = registerColor('editorWidget.border', { dark: '#454545', light: '#C8C8C8', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorWidgetBorder', 'Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget.'));
-export const editorWidgetResizeBorder = registerColor('editorWidget.resizeBorder', { light: null, dark: null, hcDark: null, hcLight: null }, nls.localize('editorWidgetResizeBorder', "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget."));
+export const editorWidgetBackground = registerColor('editorWidget.background', { dark: '#252526', light: '#F3F3F3', hcDark: '#0C141F', hcLight: Color.white }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorWidgetBackground', 'Background color of editor widgets, such as find/replace.'));
+export const editorWidgetForeground = registerColor('editorWidget.foreground', { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorWidgetForeground', 'Foreground color of editor widgets, such as find/replace.'));
+export const editorWidgetBorder = registerColor('editorWidget.border', { dark: '#454545', light: '#C8C8C8', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorWidgetBorder', 'Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget.'));
+export const editorWidgetResizeBorder = registerColor('editorWidget.resizeBorder', { light: null, dark: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorWidgetResizeBorder', "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget."));
 /**
  * Quick pick widget
  */
-export const quickInputBackground = registerColor('quickInput.background', { dark: editorWidgetBackground, light: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localize('pickerBackground', "Quick picker background color. The quick picker widget is the container for pickers like the command palette."));
-export const quickInputForeground = registerColor('quickInput.foreground', { dark: editorWidgetForeground, light: editorWidgetForeground, hcDark: editorWidgetForeground, hcLight: editorWidgetForeground }, nls.localize('pickerForeground', "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette."));
-export const quickInputTitleBackground = registerColor('quickInputTitle.background', { dark: new Color(new RGBA(255, 255, 255, 0.105)), light: new Color(new RGBA(0, 0, 0, 0.06)), hcDark: '#000000', hcLight: Color.white }, nls.localize('pickerTitleBackground', "Quick picker title background color. The quick picker widget is the container for pickers like the command palette."));
-export const pickerGroupForeground = registerColor('pickerGroup.foreground', { dark: '#3794FF', light: '#0066BF', hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('pickerGroupForeground', "Quick picker color for grouping labels."));
-export const pickerGroupBorder = registerColor('pickerGroup.border', { dark: '#3F3F46', light: '#CCCEDB', hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('pickerGroupBorder', "Quick picker color for grouping borders."));
+export const quickInputBackground = registerColor('quickInput.background', { dark: editorWidgetBackground, light: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'pickerBackground', "Quick picker background color. The quick picker widget is the container for pickers like the command palette."));
+export const quickInputForeground = registerColor('quickInput.foreground', { dark: editorWidgetForeground, light: editorWidgetForeground, hcDark: editorWidgetForeground, hcLight: editorWidgetForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'pickerForeground', "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette."));
+export const quickInputTitleBackground = registerColor('quickInputTitle.background', { dark: new Color(new RGBA(255, 255, 255, 0.105)), light: new Color(new RGBA(0, 0, 0, 0.06)), hcDark: '#000000', hcLight: Color.white }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'pickerTitleBackground', "Quick picker title background color. The quick picker widget is the container for pickers like the command palette."));
+export const pickerGroupForeground = registerColor('pickerGroup.foreground', { dark: '#3794FF', light: '#0066BF', hcDark: Color.white, hcLight: '#0F4A85' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'pickerGroupForeground', "Quick picker color for grouping labels."));
+export const pickerGroupBorder = registerColor('pickerGroup.border', { dark: '#3F3F46', light: '#CCCEDB', hcDark: Color.white, hcLight: '#0F4A85' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'pickerGroupBorder', "Quick picker color for grouping borders."));
 /**
  * Keybinding label
  */
-export const keybindingLabelBackground = registerColor('keybindingLabel.background', { dark: new Color(new RGBA(128, 128, 128, 0.17)), light: new Color(new RGBA(221, 221, 221, 0.4)), hcDark: Color.transparent, hcLight: Color.transparent }, nls.localize('keybindingLabelBackground', "Keybinding label background color. The keybinding label is used to represent a keyboard shortcut."));
-export const keybindingLabelForeground = registerColor('keybindingLabel.foreground', { dark: Color.fromHex('#CCCCCC'), light: Color.fromHex('#555555'), hcDark: Color.white, hcLight: foreground }, nls.localize('keybindingLabelForeground', "Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut."));
-export const keybindingLabelBorder = registerColor('keybindingLabel.border', { dark: new Color(new RGBA(51, 51, 51, 0.6)), light: new Color(new RGBA(204, 204, 204, 0.4)), hcDark: new Color(new RGBA(111, 195, 223)), hcLight: contrastBorder }, nls.localize('keybindingLabelBorder', "Keybinding label border color. The keybinding label is used to represent a keyboard shortcut."));
-export const keybindingLabelBottomBorder = registerColor('keybindingLabel.bottomBorder', { dark: new Color(new RGBA(68, 68, 68, 0.6)), light: new Color(new RGBA(187, 187, 187, 0.4)), hcDark: new Color(new RGBA(111, 195, 223)), hcLight: foreground }, nls.localize('keybindingLabelBottomBorder', "Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut."));
+export const keybindingLabelBackground = registerColor('keybindingLabel.background', { dark: new Color(new RGBA(128, 128, 128, 0.17)), light: new Color(new RGBA(221, 221, 221, 0.4)), hcDark: Color.transparent, hcLight: Color.transparent }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'keybindingLabelBackground', "Keybinding label background color. The keybinding label is used to represent a keyboard shortcut."));
+export const keybindingLabelForeground = registerColor('keybindingLabel.foreground', { dark: Color.fromHex('#CCCCCC'), light: Color.fromHex('#555555'), hcDark: Color.white, hcLight: foreground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'keybindingLabelForeground', "Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut."));
+export const keybindingLabelBorder = registerColor('keybindingLabel.border', { dark: new Color(new RGBA(51, 51, 51, 0.6)), light: new Color(new RGBA(204, 204, 204, 0.4)), hcDark: new Color(new RGBA(111, 195, 223)), hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'keybindingLabelBorder', "Keybinding label border color. The keybinding label is used to represent a keyboard shortcut."));
+export const keybindingLabelBottomBorder = registerColor('keybindingLabel.bottomBorder', { dark: new Color(new RGBA(68, 68, 68, 0.6)), light: new Color(new RGBA(187, 187, 187, 0.4)), hcDark: new Color(new RGBA(111, 195, 223)), hcLight: foreground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'keybindingLabelBottomBorder', "Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut."));
 /**
  * Editor selection colors.
  */
-export const editorSelectionBackground = registerColor('editor.selectionBackground', { light: '#ADD6FF', dark: '#264F78', hcDark: '#f3f518', hcLight: '#0F4A85' }, nls.localize('editorSelectionBackground', "Color of the editor selection."));
-export const editorSelectionForeground = registerColor('editor.selectionForeground', { light: null, dark: null, hcDark: '#000000', hcLight: Color.white }, nls.localize('editorSelectionForeground', "Color of the selected text for high contrast."));
-export const editorInactiveSelection = registerColor('editor.inactiveSelectionBackground', { light: transparent(editorSelectionBackground, 0.5), dark: transparent(editorSelectionBackground, 0.5), hcDark: transparent(editorSelectionBackground, 0.7), hcLight: transparent(editorSelectionBackground, 0.5) }, nls.localize('editorInactiveSelection', "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), true);
-export const editorSelectionHighlight = registerColor('editor.selectionHighlightBackground', { light: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), dark: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), hcDark: null, hcLight: null }, nls.localize('editorSelectionHighlight', 'Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const editorSelectionHighlightBorder = registerColor('editor.selectionHighlightBorder', { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorSelectionHighlightBorder', "Border color for regions with the same content as the selection."));
+export const editorSelectionBackground = registerColor('editor.selectionBackground', { light: '#ADD6FF', dark: '#264F78', hcDark: '#f3f518', hcLight: '#0F4A85' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorSelectionBackground', "Color of the editor selection."));
+export const editorSelectionForeground = registerColor('editor.selectionForeground', { light: null, dark: null, hcDark: '#000000', hcLight: Color.white }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorSelectionForeground', "Color of the selected text for high contrast."));
+export const editorInactiveSelection = registerColor('editor.inactiveSelectionBackground', { light: transparent(editorSelectionBackground, 0.5), dark: transparent(editorSelectionBackground, 0.5), hcDark: transparent(editorSelectionBackground, 0.7), hcLight: transparent(editorSelectionBackground, 0.5) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorInactiveSelection', "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), true);
+export const editorSelectionHighlight = registerColor('editor.selectionHighlightBackground', { light: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), dark: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorSelectionHighlight', 'Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const editorSelectionHighlightBorder = registerColor('editor.selectionHighlightBorder', { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorSelectionHighlightBorder', "Border color for regions with the same content as the selection."));
 /**
  * Editor find match colors.
  */
-export const editorFindMatch = registerColor('editor.findMatchBackground', { light: '#A8AC94', dark: '#515C6A', hcDark: null, hcLight: null }, nls.localize('editorFindMatch', "Color of the current search match."));
-export const editorFindMatchHighlight = registerColor('editor.findMatchHighlightBackground', { light: '#EA5C0055', dark: '#EA5C0055', hcDark: null, hcLight: null }, nls.localize('findMatchHighlight', "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), true);
-export const editorFindRangeHighlight = registerColor('editor.findRangeHighlightBackground', { dark: '#3a3d4166', light: '#b4b4b44d', hcDark: null, hcLight: null }, nls.localize('findRangeHighlight', "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), true);
-export const editorFindMatchBorder = registerColor('editor.findMatchBorder', { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorFindMatchBorder', "Border color of the current search match."));
-export const editorFindMatchHighlightBorder = registerColor('editor.findMatchHighlightBorder', { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('findMatchHighlightBorder', "Border color of the other search matches."));
-export const editorFindRangeHighlightBorder = registerColor('editor.findRangeHighlightBorder', { dark: null, light: null, hcDark: transparent(activeContrastBorder, 0.4), hcLight: transparent(activeContrastBorder, 0.4) }, nls.localize('findRangeHighlightBorder', "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), true);
+export const editorFindMatch = registerColor('editor.findMatchBackground', { light: '#A8AC94', dark: '#515C6A', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorFindMatch', "Color of the current search match."));
+export const editorFindMatchHighlight = registerColor('editor.findMatchHighlightBackground', { light: '#EA5C0055', dark: '#EA5C0055', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'findMatchHighlight', "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), true);
+export const editorFindRangeHighlight = registerColor('editor.findRangeHighlightBackground', { dark: '#3a3d4166', light: '#b4b4b44d', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'findRangeHighlight', "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), true);
+export const editorFindMatchBorder = registerColor('editor.findMatchBorder', { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorFindMatchBorder', "Border color of the current search match."));
+export const editorFindMatchHighlightBorder = registerColor('editor.findMatchHighlightBorder', { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'findMatchHighlightBorder', "Border color of the other search matches."));
+export const editorFindRangeHighlightBorder = registerColor('editor.findRangeHighlightBorder', { dark: null, light: null, hcDark: transparent(activeContrastBorder, 0.4), hcLight: transparent(activeContrastBorder, 0.4) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'findRangeHighlightBorder', "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), true);
 /**
  * Search Editor query match colors.
  *
  * Distinct from normal editor find match to allow for better differentiation
  */
-export const searchEditorFindMatch = registerColor('searchEditor.findMatchBackground', { light: transparent(editorFindMatchHighlight, 0.66), dark: transparent(editorFindMatchHighlight, 0.66), hcDark: editorFindMatchHighlight, hcLight: editorFindMatchHighlight }, nls.localize('searchEditor.queryMatch', "Color of the Search Editor query matches."));
-export const searchEditorFindMatchBorder = registerColor('searchEditor.findMatchBorder', { light: transparent(editorFindMatchHighlightBorder, 0.66), dark: transparent(editorFindMatchHighlightBorder, 0.66), hcDark: editorFindMatchHighlightBorder, hcLight: editorFindMatchHighlightBorder }, nls.localize('searchEditor.editorFindMatchBorder', "Border color of the Search Editor query matches."));
+export const searchEditorFindMatch = registerColor('searchEditor.findMatchBackground', { light: transparent(editorFindMatchHighlight, 0.66), dark: transparent(editorFindMatchHighlight, 0.66), hcDark: editorFindMatchHighlight, hcLight: editorFindMatchHighlight }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'searchEditor.queryMatch', "Color of the Search Editor query matches."));
+export const searchEditorFindMatchBorder = registerColor('searchEditor.findMatchBorder', { light: transparent(editorFindMatchHighlightBorder, 0.66), dark: transparent(editorFindMatchHighlightBorder, 0.66), hcDark: editorFindMatchHighlightBorder, hcLight: editorFindMatchHighlightBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'searchEditor.editorFindMatchBorder', "Border color of the Search Editor query matches."));
 /**
  * Search Viewlet colors.
  */
-export const searchResultsInfoForeground = registerColor('search.resultsInfoForeground', { light: foreground, dark: transparent(foreground, 0.65), hcDark: foreground, hcLight: foreground }, nls.localize('search.resultsInfoForeground', "Color of the text in the search viewlet's completion message."));
+export const searchResultsInfoForeground = registerColor('search.resultsInfoForeground', { light: foreground, dark: transparent(foreground, 0.65), hcDark: foreground, hcLight: foreground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'search.resultsInfoForeground', "Color of the text in the search viewlet's completion message."));
 /**
  * Editor hover
  */
-export const editorHoverHighlight = registerColor('editor.hoverHighlightBackground', { light: '#ADD6FF26', dark: '#264f7840', hcDark: '#ADD6FF26', hcLight: null }, nls.localize('hoverHighlight', 'Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const editorHoverBackground = registerColor('editorHoverWidget.background', { light: editorWidgetBackground, dark: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localize('hoverBackground', 'Background color of the editor hover.'));
-export const editorHoverForeground = registerColor('editorHoverWidget.foreground', { light: editorWidgetForeground, dark: editorWidgetForeground, hcDark: editorWidgetForeground, hcLight: editorWidgetForeground }, nls.localize('hoverForeground', 'Foreground color of the editor hover.'));
-export const editorHoverBorder = registerColor('editorHoverWidget.border', { light: editorWidgetBorder, dark: editorWidgetBorder, hcDark: editorWidgetBorder, hcLight: editorWidgetBorder }, nls.localize('hoverBorder', 'Border color of the editor hover.'));
-export const editorHoverStatusBarBackground = registerColor('editorHoverWidget.statusBarBackground', { dark: lighten(editorHoverBackground, 0.2), light: darken(editorHoverBackground, 0.05), hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localize('statusBarBackground', "Background color of the editor hover status bar."));
+export const editorHoverHighlight = registerColor('editor.hoverHighlightBackground', { light: '#ADD6FF26', dark: '#264f7840', hcDark: '#ADD6FF26', hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'hoverHighlight', 'Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const editorHoverBackground = registerColor('editorHoverWidget.background', { light: editorWidgetBackground, dark: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'hoverBackground', 'Background color of the editor hover.'));
+export const editorHoverForeground = registerColor('editorHoverWidget.foreground', { light: editorWidgetForeground, dark: editorWidgetForeground, hcDark: editorWidgetForeground, hcLight: editorWidgetForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'hoverForeground', 'Foreground color of the editor hover.'));
+export const editorHoverBorder = registerColor('editorHoverWidget.border', { light: editorWidgetBorder, dark: editorWidgetBorder, hcDark: editorWidgetBorder, hcLight: editorWidgetBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'hoverBorder', 'Border color of the editor hover.'));
+export const editorHoverStatusBarBackground = registerColor('editorHoverWidget.statusBarBackground', { dark: lighten(editorHoverBackground, 0.2), light: darken(editorHoverBackground, 0.05), hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'statusBarBackground', "Background color of the editor hover status bar."));
 /**
  * Editor link colors
  */
-export const editorActiveLinkForeground = registerColor('editorLink.activeForeground', { dark: '#4E94CE', light: Color.blue, hcDark: Color.cyan, hcLight: '#292929' }, nls.localize('activeLinkForeground', 'Color of active links.'));
+export const editorActiveLinkForeground = registerColor('editorLink.activeForeground', { dark: '#4E94CE', light: Color.blue, hcDark: Color.cyan, hcLight: '#292929' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'activeLinkForeground', 'Color of active links.'));
 /**
  * Inline hints
  */
-export const editorInlayHintForeground = registerColor('editorInlayHint.foreground', { dark: '#969696', light: '#969696', hcDark: Color.white, hcLight: Color.black }, nls.localize('editorInlayHintForeground', 'Foreground color of inline hints'));
-export const editorInlayHintBackground = registerColor('editorInlayHint.background', { dark: transparent(badgeBackground, .10), light: transparent(badgeBackground, .10), hcDark: transparent(Color.white, .10), hcLight: transparent(badgeBackground, .10) }, nls.localize('editorInlayHintBackground', 'Background color of inline hints'));
-export const editorInlayHintTypeForeground = registerColor('editorInlayHint.typeForeground', { dark: editorInlayHintForeground, light: editorInlayHintForeground, hcDark: editorInlayHintForeground, hcLight: editorInlayHintForeground }, nls.localize('editorInlayHintForegroundTypes', 'Foreground color of inline hints for types'));
-export const editorInlayHintTypeBackground = registerColor('editorInlayHint.typeBackground', { dark: editorInlayHintBackground, light: editorInlayHintBackground, hcDark: editorInlayHintBackground, hcLight: editorInlayHintBackground }, nls.localize('editorInlayHintBackgroundTypes', 'Background color of inline hints for types'));
-export const editorInlayHintParameterForeground = registerColor('editorInlayHint.parameterForeground', { dark: editorInlayHintForeground, light: editorInlayHintForeground, hcDark: editorInlayHintForeground, hcLight: editorInlayHintForeground }, nls.localize('editorInlayHintForegroundParameter', 'Foreground color of inline hints for parameters'));
-export const editorInlayHintParameterBackground = registerColor('editorInlayHint.parameterBackground', { dark: editorInlayHintBackground, light: editorInlayHintBackground, hcDark: editorInlayHintBackground, hcLight: editorInlayHintBackground }, nls.localize('editorInlayHintBackgroundParameter', 'Background color of inline hints for parameters'));
+export const editorInlayHintForeground = registerColor('editorInlayHint.foreground', { dark: '#969696', light: '#969696', hcDark: Color.white, hcLight: Color.black }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorInlayHintForeground', 'Foreground color of inline hints'));
+export const editorInlayHintBackground = registerColor('editorInlayHint.background', { dark: transparent(badgeBackground, .10), light: transparent(badgeBackground, .10), hcDark: transparent(Color.white, .10), hcLight: transparent(badgeBackground, .10) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorInlayHintBackground', 'Background color of inline hints'));
+export const editorInlayHintTypeForeground = registerColor('editorInlayHint.typeForeground', { dark: editorInlayHintForeground, light: editorInlayHintForeground, hcDark: editorInlayHintForeground, hcLight: editorInlayHintForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorInlayHintForegroundTypes', 'Foreground color of inline hints for types'));
+export const editorInlayHintTypeBackground = registerColor('editorInlayHint.typeBackground', { dark: editorInlayHintBackground, light: editorInlayHintBackground, hcDark: editorInlayHintBackground, hcLight: editorInlayHintBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorInlayHintBackgroundTypes', 'Background color of inline hints for types'));
+export const editorInlayHintParameterForeground = registerColor('editorInlayHint.parameterForeground', { dark: editorInlayHintForeground, light: editorInlayHintForeground, hcDark: editorInlayHintForeground, hcLight: editorInlayHintForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorInlayHintForegroundParameter', 'Foreground color of inline hints for parameters'));
+export const editorInlayHintParameterBackground = registerColor('editorInlayHint.parameterBackground', { dark: editorInlayHintBackground, light: editorInlayHintBackground, hcDark: editorInlayHintBackground, hcLight: editorInlayHintBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorInlayHintBackgroundParameter', 'Background color of inline hints for parameters'));
 /**
  * Editor lightbulb icon colors
  */
-export const editorLightBulbForeground = registerColor('editorLightBulb.foreground', { dark: '#FFCC00', light: '#DDB100', hcDark: '#FFCC00', hcLight: '#007ACC' }, nls.localize('editorLightBulbForeground', "The color used for the lightbulb actions icon."));
-export const editorLightBulbAutoFixForeground = registerColor('editorLightBulbAutoFix.foreground', { dark: '#75BEFF', light: '#007ACC', hcDark: '#75BEFF', hcLight: '#007ACC' }, nls.localize('editorLightBulbAutoFixForeground', "The color used for the lightbulb auto fix actions icon."));
+export const editorLightBulbForeground = registerColor('editorLightBulb.foreground', { dark: '#FFCC00', light: '#DDB100', hcDark: '#FFCC00', hcLight: '#007ACC' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorLightBulbForeground', "The color used for the lightbulb actions icon."));
+export const editorLightBulbAutoFixForeground = registerColor('editorLightBulbAutoFix.foreground', { dark: '#75BEFF', light: '#007ACC', hcDark: '#75BEFF', hcLight: '#007ACC' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'editorLightBulbAutoFixForeground', "The color used for the lightbulb auto fix actions icon."));
 /**
  * Diff Editor Colors
  */
 export const defaultInsertColor = new Color(new RGBA(155, 185, 85, .2));
 export const defaultRemoveColor = new Color(new RGBA(255, 0, 0, .2));
-export const diffInserted = registerColor('diffEditor.insertedTextBackground', { dark: '#9ccc2c33', light: '#9ccc2c40', hcDark: null, hcLight: null }, nls.localize('diffEditorInserted', 'Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const diffRemoved = registerColor('diffEditor.removedTextBackground', { dark: '#ff000033', light: '#ff000033', hcDark: null, hcLight: null }, nls.localize('diffEditorRemoved', 'Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const diffInsertedLine = registerColor('diffEditor.insertedLineBackground', { dark: defaultInsertColor, light: defaultInsertColor, hcDark: null, hcLight: null }, nls.localize('diffEditorInsertedLines', 'Background color for lines that got inserted. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const diffRemovedLine = registerColor('diffEditor.removedLineBackground', { dark: defaultRemoveColor, light: defaultRemoveColor, hcDark: null, hcLight: null }, nls.localize('diffEditorRemovedLines', 'Background color for lines that got removed. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const diffInsertedLineGutter = registerColor('diffEditorGutter.insertedLineBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('diffEditorInsertedLineGutter', 'Background color for the margin where lines got inserted.'));
-export const diffRemovedLineGutter = registerColor('diffEditorGutter.removedLineBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('diffEditorRemovedLineGutter', 'Background color for the margin where lines got removed.'));
-export const diffOverviewRulerInserted = registerColor('diffEditorOverview.insertedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('diffEditorOverviewInserted', 'Diff overview ruler foreground for inserted content.'));
-export const diffOverviewRulerRemoved = registerColor('diffEditorOverview.removedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('diffEditorOverviewRemoved', 'Diff overview ruler foreground for removed content.'));
-export const diffInsertedOutline = registerColor('diffEditor.insertedTextBorder', { dark: null, light: null, hcDark: '#33ff2eff', hcLight: '#374E06' }, nls.localize('diffEditorInsertedOutline', 'Outline color for the text that got inserted.'));
-export const diffRemovedOutline = registerColor('diffEditor.removedTextBorder', { dark: null, light: null, hcDark: '#FF008F', hcLight: '#AD0707' }, nls.localize('diffEditorRemovedOutline', 'Outline color for text that got removed.'));
-export const diffBorder = registerColor('diffEditor.border', { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('diffEditorBorder', 'Border color between the two text editors.'));
-export const diffDiagonalFill = registerColor('diffEditor.diagonalFill', { dark: '#cccccc33', light: '#22222233', hcDark: null, hcLight: null }, nls.localize('diffDiagonalFill', "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views."));
-export const diffUnchangedRegionBackground = registerColor('diffEditor.unchangedRegionBackground', { dark: '#3e3e3e', light: '#e4e4e4', hcDark: null, hcLight: null }, nls.localize('diffEditor.unchangedRegionBackground', "The background color of unchanged blocks in the diff editor."));
-export const diffUnchangedRegionForeground = registerColor('diffEditor.unchangedRegionForeground', { dark: '#a3a2a2', light: '#4d4c4c', hcDark: null, hcLight: null }, nls.localize('diffEditor.unchangedRegionForeground', "The foreground color of unchanged blocks in the diff editor."));
-export const diffUnchangedTextBackground = registerColor('diffEditor.unchangedCodeBackground', { dark: '#74747429', light: '#b8b8b829', hcDark: null, hcLight: null }, nls.localize('diffEditor.unchangedCodeBackground', "The background color of unchanged code in the diff editor."));
+export const diffInserted = registerColor('diffEditor.insertedTextBackground', { dark: '#9ccc2c33', light: '#9ccc2c40', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditorInserted', 'Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const diffRemoved = registerColor('diffEditor.removedTextBackground', { dark: '#ff000033', light: '#ff000033', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditorRemoved', 'Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const diffInsertedLine = registerColor('diffEditor.insertedLineBackground', { dark: defaultInsertColor, light: defaultInsertColor, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditorInsertedLines', 'Background color for lines that got inserted. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const diffRemovedLine = registerColor('diffEditor.removedLineBackground', { dark: defaultRemoveColor, light: defaultRemoveColor, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditorRemovedLines', 'Background color for lines that got removed. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const diffInsertedLineGutter = registerColor('diffEditorGutter.insertedLineBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditorInsertedLineGutter', 'Background color for the margin where lines got inserted.'));
+export const diffRemovedLineGutter = registerColor('diffEditorGutter.removedLineBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditorRemovedLineGutter', 'Background color for the margin where lines got removed.'));
+export const diffOverviewRulerInserted = registerColor('diffEditorOverview.insertedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditorOverviewInserted', 'Diff overview ruler foreground for inserted content.'));
+export const diffOverviewRulerRemoved = registerColor('diffEditorOverview.removedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditorOverviewRemoved', 'Diff overview ruler foreground for removed content.'));
+export const diffInsertedOutline = registerColor('diffEditor.insertedTextBorder', { dark: null, light: null, hcDark: '#33ff2eff', hcLight: '#374E06' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditorInsertedOutline', 'Outline color for the text that got inserted.'));
+export const diffRemovedOutline = registerColor('diffEditor.removedTextBorder', { dark: null, light: null, hcDark: '#FF008F', hcLight: '#AD0707' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditorRemovedOutline', 'Outline color for text that got removed.'));
+export const diffBorder = registerColor('diffEditor.border', { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditorBorder', 'Border color between the two text editors.'));
+export const diffDiagonalFill = registerColor('diffEditor.diagonalFill', { dark: '#cccccc33', light: '#22222233', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffDiagonalFill', "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views."));
+export const diffUnchangedRegionBackground = registerColor('diffEditor.unchangedRegionBackground', { dark: '#3e3e3e', light: '#e4e4e4', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditor.unchangedRegionBackground', "The background color of unchanged blocks in the diff editor."));
+export const diffUnchangedRegionForeground = registerColor('diffEditor.unchangedRegionForeground', { dark: '#a3a2a2', light: '#4d4c4c', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditor.unchangedRegionForeground', "The foreground color of unchanged blocks in the diff editor."));
+export const diffUnchangedTextBackground = registerColor('diffEditor.unchangedCodeBackground', { dark: '#74747429', light: '#b8b8b829', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'diffEditor.unchangedCodeBackground', "The background color of unchanged code in the diff editor."));
 /**
  * List and tree colors
  */
-export const listFocusBackground = registerColor('list.focusBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listFocusBackground', "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
-export const listFocusForeground = registerColor('list.focusForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listFocusForeground', "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
-export const listFocusOutline = registerColor('list.focusOutline', { dark: focusBorder, light: focusBorder, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('listFocusOutline', "List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
-export const listFocusAndSelectionOutline = registerColor('list.focusAndSelectionOutline', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listFocusAndSelectionOutline', "List/Tree outline color for the focused item when the list/tree is active and selected. An active list/tree has keyboard focus, an inactive does not."));
-export const listActiveSelectionBackground = registerColor('list.activeSelectionBackground', { dark: '#04395E', light: '#0060C0', hcDark: null, hcLight: Color.fromHex('#0F4A85').transparent(0.1) }, nls.localize('listActiveSelectionBackground', "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
-export const listActiveSelectionForeground = registerColor('list.activeSelectionForeground', { dark: Color.white, light: Color.white, hcDark: null, hcLight: null }, nls.localize('listActiveSelectionForeground', "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
-export const listActiveSelectionIconForeground = registerColor('list.activeSelectionIconForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listActiveSelectionIconForeground', "List/Tree icon foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
-export const listInactiveSelectionBackground = registerColor('list.inactiveSelectionBackground', { dark: '#37373D', light: '#E4E6F1', hcDark: null, hcLight: Color.fromHex('#0F4A85').transparent(0.1) }, nls.localize('listInactiveSelectionBackground', "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
-export const listInactiveSelectionForeground = registerColor('list.inactiveSelectionForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listInactiveSelectionForeground', "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
-export const listInactiveSelectionIconForeground = registerColor('list.inactiveSelectionIconForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listInactiveSelectionIconForeground', "List/Tree icon foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
-export const listInactiveFocusBackground = registerColor('list.inactiveFocusBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listInactiveFocusBackground', "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
-export const listInactiveFocusOutline = registerColor('list.inactiveFocusOutline', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listInactiveFocusOutline', "List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
-export const listHoverBackground = registerColor('list.hoverBackground', { dark: '#2A2D2E', light: '#F0F0F0', hcDark: Color.white.transparent(0.1), hcLight: Color.fromHex('#0F4A85').transparent(0.1) }, nls.localize('listHoverBackground', "List/Tree background when hovering over items using the mouse."));
-export const listHoverForeground = registerColor('list.hoverForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listHoverForeground', "List/Tree foreground when hovering over items using the mouse."));
-export const listDropBackground = registerColor('list.dropBackground', { dark: '#062F4A', light: '#D6EBFF', hcDark: null, hcLight: null }, nls.localize('listDropBackground', "List/Tree drag and drop background when moving items around using the mouse."));
-export const listHighlightForeground = registerColor('list.highlightForeground', { dark: '#2AAAFF', light: '#0066BF', hcDark: focusBorder, hcLight: focusBorder }, nls.localize('highlight', 'List/Tree foreground color of the match highlights when searching inside the list/tree.'));
-export const listFocusHighlightForeground = registerColor('list.focusHighlightForeground', { dark: listHighlightForeground, light: ifDefinedThenElse(listActiveSelectionBackground, listHighlightForeground, '#BBE7FF'), hcDark: listHighlightForeground, hcLight: listHighlightForeground }, nls.localize('listFocusHighlightForeground', 'List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree.'));
-export const listInvalidItemForeground = registerColor('list.invalidItemForeground', { dark: '#B89500', light: '#B89500', hcDark: '#B89500', hcLight: '#B5200D' }, nls.localize('invalidItemForeground', 'List/Tree foreground color for invalid items, for example an unresolved root in explorer.'));
-export const listErrorForeground = registerColor('list.errorForeground', { dark: '#F88070', light: '#B01011', hcDark: null, hcLight: null }, nls.localize('listErrorForeground', 'Foreground color of list items containing errors.'));
-export const listWarningForeground = registerColor('list.warningForeground', { dark: '#CCA700', light: '#855F00', hcDark: null, hcLight: null }, nls.localize('listWarningForeground', 'Foreground color of list items containing warnings.'));
-export const listFilterWidgetBackground = registerColor('listFilterWidget.background', { light: darken(editorWidgetBackground, 0), dark: lighten(editorWidgetBackground, 0), hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localize('listFilterWidgetBackground', 'Background color of the type filter widget in lists and trees.'));
-export const listFilterWidgetOutline = registerColor('listFilterWidget.outline', { dark: Color.transparent, light: Color.transparent, hcDark: '#f38518', hcLight: '#007ACC' }, nls.localize('listFilterWidgetOutline', 'Outline color of the type filter widget in lists and trees.'));
-export const listFilterWidgetNoMatchesOutline = registerColor('listFilterWidget.noMatchesOutline', { dark: '#BE1100', light: '#BE1100', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('listFilterWidgetNoMatchesOutline', 'Outline color of the type filter widget in lists and trees, when there are no matches.'));
-export const listFilterWidgetShadow = registerColor('listFilterWidget.shadow', { dark: widgetShadow, light: widgetShadow, hcDark: widgetShadow, hcLight: widgetShadow }, nls.localize('listFilterWidgetShadow', 'Shadow color of the type filter widget in lists and trees.'));
-export const listFilterMatchHighlight = registerColor('list.filterMatchBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('listFilterMatchHighlight', 'Background color of the filtered match.'));
-export const listFilterMatchHighlightBorder = registerColor('list.filterMatchBorder', { dark: editorFindMatchHighlightBorder, light: editorFindMatchHighlightBorder, hcDark: contrastBorder, hcLight: activeContrastBorder }, nls.localize('listFilterMatchHighlightBorder', 'Border color of the filtered match.'));
-export const treeIndentGuidesStroke = registerColor('tree.indentGuidesStroke', { dark: '#585858', light: '#a9a9a9', hcDark: '#a9a9a9', hcLight: '#a5a5a5' }, nls.localize('treeIndentGuidesStroke', "Tree stroke color for the indentation guides."));
-export const treeInactiveIndentGuidesStroke = registerColor('tree.inactiveIndentGuidesStroke', { dark: transparent(treeIndentGuidesStroke, 0.4), light: transparent(treeIndentGuidesStroke, 0.4), hcDark: transparent(treeIndentGuidesStroke, 0.4), hcLight: transparent(treeIndentGuidesStroke, 0.4) }, nls.localize('treeInactiveIndentGuidesStroke', "Tree stroke color for the indentation guides that are not active."));
-export const tableColumnsBorder = registerColor('tree.tableColumnsBorder', { dark: '#CCCCCC20', light: '#61616120', hcDark: null, hcLight: null }, nls.localize('tableColumnsBorder', "Table border color between columns."));
-export const tableOddRowsBackgroundColor = registerColor('tree.tableOddRowsBackground', { dark: transparent(foreground, 0.04), light: transparent(foreground, 0.04), hcDark: null, hcLight: null }, nls.localize('tableOddRowsBackgroundColor', "Background color for odd table rows."));
-export const listDeemphasizedForeground = registerColor('list.deemphasizedForeground', { dark: '#8C8C8C', light: '#8E8E90', hcDark: '#A7A8A9', hcLight: '#666666' }, nls.localize('listDeemphasizedForeground', "List/Tree foreground color for items that are deemphasized. "));
+export const listFocusBackground = registerColor('list.focusBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listFocusBackground', "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
+export const listFocusForeground = registerColor('list.focusForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listFocusForeground', "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
+export const listFocusOutline = registerColor('list.focusOutline', { dark: focusBorder, light: focusBorder, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listFocusOutline', "List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
+export const listFocusAndSelectionOutline = registerColor('list.focusAndSelectionOutline', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listFocusAndSelectionOutline', "List/Tree outline color for the focused item when the list/tree is active and selected. An active list/tree has keyboard focus, an inactive does not."));
+export const listActiveSelectionBackground = registerColor('list.activeSelectionBackground', { dark: '#04395E', light: '#0060C0', hcDark: null, hcLight: Color.fromHex('#0F4A85').transparent(0.1) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listActiveSelectionBackground', "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
+export const listActiveSelectionForeground = registerColor('list.activeSelectionForeground', { dark: Color.white, light: Color.white, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listActiveSelectionForeground', "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
+export const listActiveSelectionIconForeground = registerColor('list.activeSelectionIconForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listActiveSelectionIconForeground', "List/Tree icon foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
+export const listInactiveSelectionBackground = registerColor('list.inactiveSelectionBackground', { dark: '#37373D', light: '#E4E6F1', hcDark: null, hcLight: Color.fromHex('#0F4A85').transparent(0.1) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listInactiveSelectionBackground', "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
+export const listInactiveSelectionForeground = registerColor('list.inactiveSelectionForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listInactiveSelectionForeground', "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
+export const listInactiveSelectionIconForeground = registerColor('list.inactiveSelectionIconForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listInactiveSelectionIconForeground', "List/Tree icon foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
+export const listInactiveFocusBackground = registerColor('list.inactiveFocusBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listInactiveFocusBackground', "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
+export const listInactiveFocusOutline = registerColor('list.inactiveFocusOutline', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listInactiveFocusOutline', "List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
+export const listHoverBackground = registerColor('list.hoverBackground', { dark: '#2A2D2E', light: '#F0F0F0', hcDark: Color.white.transparent(0.1), hcLight: Color.fromHex('#0F4A85').transparent(0.1) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listHoverBackground', "List/Tree background when hovering over items using the mouse."));
+export const listHoverForeground = registerColor('list.hoverForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listHoverForeground', "List/Tree foreground when hovering over items using the mouse."));
+export const listDropBackground = registerColor('list.dropBackground', { dark: '#062F4A', light: '#D6EBFF', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listDropBackground', "List/Tree drag and drop background when moving items around using the mouse."));
+export const listHighlightForeground = registerColor('list.highlightForeground', { dark: '#2AAAFF', light: '#0066BF', hcDark: focusBorder, hcLight: focusBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'highlight', 'List/Tree foreground color of the match highlights when searching inside the list/tree.'));
+export const listFocusHighlightForeground = registerColor('list.focusHighlightForeground', { dark: listHighlightForeground, light: ifDefinedThenElse(listActiveSelectionBackground, listHighlightForeground, '#BBE7FF'), hcDark: listHighlightForeground, hcLight: listHighlightForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listFocusHighlightForeground', 'List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree.'));
+export const listInvalidItemForeground = registerColor('list.invalidItemForeground', { dark: '#B89500', light: '#B89500', hcDark: '#B89500', hcLight: '#B5200D' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'invalidItemForeground', 'List/Tree foreground color for invalid items, for example an unresolved root in explorer.'));
+export const listErrorForeground = registerColor('list.errorForeground', { dark: '#F88070', light: '#B01011', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listErrorForeground', 'Foreground color of list items containing errors.'));
+export const listWarningForeground = registerColor('list.warningForeground', { dark: '#CCA700', light: '#855F00', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listWarningForeground', 'Foreground color of list items containing warnings.'));
+export const listFilterWidgetBackground = registerColor('listFilterWidget.background', { light: darken(editorWidgetBackground, 0), dark: lighten(editorWidgetBackground, 0), hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listFilterWidgetBackground', 'Background color of the type filter widget in lists and trees.'));
+export const listFilterWidgetOutline = registerColor('listFilterWidget.outline', { dark: Color.transparent, light: Color.transparent, hcDark: '#f38518', hcLight: '#007ACC' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listFilterWidgetOutline', 'Outline color of the type filter widget in lists and trees.'));
+export const listFilterWidgetNoMatchesOutline = registerColor('listFilterWidget.noMatchesOutline', { dark: '#BE1100', light: '#BE1100', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listFilterWidgetNoMatchesOutline', 'Outline color of the type filter widget in lists and trees, when there are no matches.'));
+export const listFilterWidgetShadow = registerColor('listFilterWidget.shadow', { dark: widgetShadow, light: widgetShadow, hcDark: widgetShadow, hcLight: widgetShadow }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listFilterWidgetShadow', 'Shadow color of the type filter widget in lists and trees.'));
+export const listFilterMatchHighlight = registerColor('list.filterMatchBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listFilterMatchHighlight', 'Background color of the filtered match.'));
+export const listFilterMatchHighlightBorder = registerColor('list.filterMatchBorder', { dark: editorFindMatchHighlightBorder, light: editorFindMatchHighlightBorder, hcDark: contrastBorder, hcLight: activeContrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listFilterMatchHighlightBorder', 'Border color of the filtered match.'));
+export const treeIndentGuidesStroke = registerColor('tree.indentGuidesStroke', { dark: '#585858', light: '#a9a9a9', hcDark: '#a9a9a9', hcLight: '#a5a5a5' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'treeIndentGuidesStroke', "Tree stroke color for the indentation guides."));
+export const treeInactiveIndentGuidesStroke = registerColor('tree.inactiveIndentGuidesStroke', { dark: transparent(treeIndentGuidesStroke, 0.4), light: transparent(treeIndentGuidesStroke, 0.4), hcDark: transparent(treeIndentGuidesStroke, 0.4), hcLight: transparent(treeIndentGuidesStroke, 0.4) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'treeInactiveIndentGuidesStroke', "Tree stroke color for the indentation guides that are not active."));
+export const tableColumnsBorder = registerColor('tree.tableColumnsBorder', { dark: '#CCCCCC20', light: '#61616120', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'tableColumnsBorder', "Table border color between columns."));
+export const tableOddRowsBackgroundColor = registerColor('tree.tableOddRowsBackground', { dark: transparent(foreground, 0.04), light: transparent(foreground, 0.04), hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'tableOddRowsBackgroundColor', "Background color for odd table rows."));
+export const listDeemphasizedForeground = registerColor('list.deemphasizedForeground', { dark: '#8C8C8C', light: '#8E8E90', hcDark: '#A7A8A9', hcLight: '#666666' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'listDeemphasizedForeground', "List/Tree foreground color for items that are deemphasized. "));
 /**
  * Checkboxes
  */
-export const checkboxBackground = registerColor('checkbox.background', { dark: selectBackground, light: selectBackground, hcDark: selectBackground, hcLight: selectBackground }, nls.localize('checkbox.background', "Background color of checkbox widget."));
-export const checkboxSelectBackground = registerColor('checkbox.selectBackground', { dark: editorWidgetBackground, light: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localize('checkbox.select.background', "Background color of checkbox widget when the element it's in is selected."));
-export const checkboxForeground = registerColor('checkbox.foreground', { dark: selectForeground, light: selectForeground, hcDark: selectForeground, hcLight: selectForeground }, nls.localize('checkbox.foreground', "Foreground color of checkbox widget."));
-export const checkboxBorder = registerColor('checkbox.border', { dark: selectBorder, light: selectBorder, hcDark: selectBorder, hcLight: selectBorder }, nls.localize('checkbox.border', "Border color of checkbox widget."));
-export const checkboxSelectBorder = registerColor('checkbox.selectBorder', { dark: iconForeground, light: iconForeground, hcDark: iconForeground, hcLight: iconForeground }, nls.localize('checkbox.select.border', "Border color of checkbox widget when the element it's in is selected."));
+export const checkboxBackground = registerColor('checkbox.background', { dark: selectBackground, light: selectBackground, hcDark: selectBackground, hcLight: selectBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'checkbox.background', "Background color of checkbox widget."));
+export const checkboxSelectBackground = registerColor('checkbox.selectBackground', { dark: editorWidgetBackground, light: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'checkbox.select.background', "Background color of checkbox widget when the element it's in is selected."));
+export const checkboxForeground = registerColor('checkbox.foreground', { dark: selectForeground, light: selectForeground, hcDark: selectForeground, hcLight: selectForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'checkbox.foreground', "Foreground color of checkbox widget."));
+export const checkboxBorder = registerColor('checkbox.border', { dark: selectBorder, light: selectBorder, hcDark: selectBorder, hcLight: selectBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'checkbox.border', "Border color of checkbox widget."));
+export const checkboxSelectBorder = registerColor('checkbox.selectBorder', { dark: iconForeground, light: iconForeground, hcDark: iconForeground, hcLight: iconForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'checkbox.select.border', "Border color of checkbox widget when the element it's in is selected."));
 /**
  * Quick pick widget (dependent on List and tree colors)
  */
-export const _deprecatedQuickInputListFocusBackground = registerColor('quickInput.list.focusBackground', { dark: null, light: null, hcDark: null, hcLight: null }, '', undefined, nls.localize('quickInput.list.focusBackground deprecation', "Please use quickInputList.focusBackground instead"));
-export const quickInputListFocusForeground = registerColor('quickInputList.focusForeground', { dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hcDark: listActiveSelectionForeground, hcLight: listActiveSelectionForeground }, nls.localize('quickInput.listFocusForeground', "Quick picker foreground color for the focused item."));
-export const quickInputListFocusIconForeground = registerColor('quickInputList.focusIconForeground', { dark: listActiveSelectionIconForeground, light: listActiveSelectionIconForeground, hcDark: listActiveSelectionIconForeground, hcLight: listActiveSelectionIconForeground }, nls.localize('quickInput.listFocusIconForeground', "Quick picker icon foreground color for the focused item."));
-export const quickInputListFocusBackground = registerColor('quickInputList.focusBackground', { dark: oneOf(_deprecatedQuickInputListFocusBackground, listActiveSelectionBackground), light: oneOf(_deprecatedQuickInputListFocusBackground, listActiveSelectionBackground), hcDark: null, hcLight: null }, nls.localize('quickInput.listFocusBackground', "Quick picker background color for the focused item."));
+export const _deprecatedQuickInputListFocusBackground = registerColor('quickInput.list.focusBackground', { dark: null, light: null, hcDark: null, hcLight: null }, '', undefined, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'quickInput.list.focusBackground deprecation', "Please use quickInputList.focusBackground instead"));
+export const quickInputListFocusForeground = registerColor('quickInputList.focusForeground', { dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hcDark: listActiveSelectionForeground, hcLight: listActiveSelectionForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'quickInput.listFocusForeground', "Quick picker foreground color for the focused item."));
+export const quickInputListFocusIconForeground = registerColor('quickInputList.focusIconForeground', { dark: listActiveSelectionIconForeground, light: listActiveSelectionIconForeground, hcDark: listActiveSelectionIconForeground, hcLight: listActiveSelectionIconForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'quickInput.listFocusIconForeground', "Quick picker icon foreground color for the focused item."));
+export const quickInputListFocusBackground = registerColor('quickInputList.focusBackground', { dark: oneOf(_deprecatedQuickInputListFocusBackground, listActiveSelectionBackground), light: oneOf(_deprecatedQuickInputListFocusBackground, listActiveSelectionBackground), hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'quickInput.listFocusBackground', "Quick picker background color for the focused item."));
 /**
  * Menu colors
  */
-export const menuBorder = registerColor('menu.border', { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('menuBorder', "Border color of menus."));
-export const menuForeground = registerColor('menu.foreground', { dark: selectForeground, light: selectForeground, hcDark: selectForeground, hcLight: selectForeground }, nls.localize('menuForeground', "Foreground color of menu items."));
-export const menuBackground = registerColor('menu.background', { dark: selectBackground, light: selectBackground, hcDark: selectBackground, hcLight: selectBackground }, nls.localize('menuBackground', "Background color of menu items."));
-export const menuSelectionForeground = registerColor('menu.selectionForeground', { dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hcDark: listActiveSelectionForeground, hcLight: listActiveSelectionForeground }, nls.localize('menuSelectionForeground', "Foreground color of the selected menu item in menus."));
-export const menuSelectionBackground = registerColor('menu.selectionBackground', { dark: listActiveSelectionBackground, light: listActiveSelectionBackground, hcDark: listActiveSelectionBackground, hcLight: listActiveSelectionBackground }, nls.localize('menuSelectionBackground', "Background color of the selected menu item in menus."));
-export const menuSelectionBorder = registerColor('menu.selectionBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('menuSelectionBorder', "Border color of the selected menu item in menus."));
-export const menuSeparatorBackground = registerColor('menu.separatorBackground', { dark: '#606060', light: '#D4D4D4', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('menuSeparatorBackground', "Color of a separator menu item in menus."));
+export const menuBorder = registerColor('menu.border', { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'menuBorder', "Border color of menus."));
+export const menuForeground = registerColor('menu.foreground', { dark: selectForeground, light: selectForeground, hcDark: selectForeground, hcLight: selectForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'menuForeground', "Foreground color of menu items."));
+export const menuBackground = registerColor('menu.background', { dark: selectBackground, light: selectBackground, hcDark: selectBackground, hcLight: selectBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'menuBackground', "Background color of menu items."));
+export const menuSelectionForeground = registerColor('menu.selectionForeground', { dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hcDark: listActiveSelectionForeground, hcLight: listActiveSelectionForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'menuSelectionForeground', "Foreground color of the selected menu item in menus."));
+export const menuSelectionBackground = registerColor('menu.selectionBackground', { dark: listActiveSelectionBackground, light: listActiveSelectionBackground, hcDark: listActiveSelectionBackground, hcLight: listActiveSelectionBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'menuSelectionBackground', "Background color of the selected menu item in menus."));
+export const menuSelectionBorder = registerColor('menu.selectionBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'menuSelectionBorder', "Border color of the selected menu item in menus."));
+export const menuSeparatorBackground = registerColor('menu.separatorBackground', { dark: '#606060', light: '#D4D4D4', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'menuSeparatorBackground', "Color of a separator menu item in menus."));
 /**
  * Toolbar colors
  */
-export const toolbarHoverBackground = registerColor('toolbar.hoverBackground', { dark: '#5a5d5e50', light: '#b8b8b850', hcDark: null, hcLight: null }, nls.localize('toolbarHoverBackground', "Toolbar background when hovering over actions using the mouse"));
-export const toolbarHoverOutline = registerColor('toolbar.hoverOutline', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('toolbarHoverOutline', "Toolbar outline when hovering over actions using the mouse"));
-export const toolbarActiveBackground = registerColor('toolbar.activeBackground', { dark: lighten(toolbarHoverBackground, 0.1), light: darken(toolbarHoverBackground, 0.1), hcDark: null, hcLight: null }, nls.localize('toolbarActiveBackground', "Toolbar background when holding the mouse over actions"));
+export const toolbarHoverBackground = registerColor('toolbar.hoverBackground', { dark: '#5a5d5e50', light: '#b8b8b850', hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'toolbarHoverBackground', "Toolbar background when hovering over actions using the mouse"));
+export const toolbarHoverOutline = registerColor('toolbar.hoverOutline', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'toolbarHoverOutline', "Toolbar outline when hovering over actions using the mouse"));
+export const toolbarActiveBackground = registerColor('toolbar.activeBackground', { dark: lighten(toolbarHoverBackground, 0.1), light: darken(toolbarHoverBackground, 0.1), hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'toolbarActiveBackground', "Toolbar background when holding the mouse over actions"));
 /**
  * Snippet placeholder colors
  */
-export const snippetTabstopHighlightBackground = registerColor('editor.snippetTabstopHighlightBackground', { dark: new Color(new RGBA(124, 124, 124, 0.3)), light: new Color(new RGBA(10, 50, 100, 0.2)), hcDark: new Color(new RGBA(124, 124, 124, 0.3)), hcLight: new Color(new RGBA(10, 50, 100, 0.2)) }, nls.localize('snippetTabstopHighlightBackground', "Highlight background color of a snippet tabstop."));
-export const snippetTabstopHighlightBorder = registerColor('editor.snippetTabstopHighlightBorder', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('snippetTabstopHighlightBorder', "Highlight border color of a snippet tabstop."));
-export const snippetFinalTabstopHighlightBackground = registerColor('editor.snippetFinalTabstopHighlightBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('snippetFinalTabstopHighlightBackground', "Highlight background color of the final tabstop of a snippet."));
-export const snippetFinalTabstopHighlightBorder = registerColor('editor.snippetFinalTabstopHighlightBorder', { dark: '#525252', light: new Color(new RGBA(10, 50, 100, 0.5)), hcDark: '#525252', hcLight: '#292929' }, nls.localize('snippetFinalTabstopHighlightBorder', "Highlight border color of the final tabstop of a snippet."));
+export const snippetTabstopHighlightBackground = registerColor('editor.snippetTabstopHighlightBackground', { dark: new Color(new RGBA(124, 124, 124, 0.3)), light: new Color(new RGBA(10, 50, 100, 0.2)), hcDark: new Color(new RGBA(124, 124, 124, 0.3)), hcLight: new Color(new RGBA(10, 50, 100, 0.2)) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'snippetTabstopHighlightBackground', "Highlight background color of a snippet tabstop."));
+export const snippetTabstopHighlightBorder = registerColor('editor.snippetTabstopHighlightBorder', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'snippetTabstopHighlightBorder', "Highlight border color of a snippet tabstop."));
+export const snippetFinalTabstopHighlightBackground = registerColor('editor.snippetFinalTabstopHighlightBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'snippetFinalTabstopHighlightBackground', "Highlight background color of the final tabstop of a snippet."));
+export const snippetFinalTabstopHighlightBorder = registerColor('editor.snippetFinalTabstopHighlightBorder', { dark: '#525252', light: new Color(new RGBA(10, 50, 100, 0.5)), hcDark: '#525252', hcLight: '#292929' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'snippetFinalTabstopHighlightBorder', "Highlight border color of the final tabstop of a snippet."));
 /**
  * Breadcrumb colors
  */
-export const breadcrumbsForeground = registerColor('breadcrumb.foreground', { light: transparent(foreground, 0.8), dark: transparent(foreground, 0.8), hcDark: transparent(foreground, 0.8), hcLight: transparent(foreground, 0.8) }, nls.localize('breadcrumbsFocusForeground', "Color of focused breadcrumb items."));
-export const breadcrumbsBackground = registerColor('breadcrumb.background', { light: editorBackground, dark: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('breadcrumbsBackground', "Background color of breadcrumb items."));
-export const breadcrumbsFocusForeground = registerColor('breadcrumb.focusForeground', { light: darken(foreground, 0.2), dark: lighten(foreground, 0.1), hcDark: lighten(foreground, 0.1), hcLight: lighten(foreground, 0.1) }, nls.localize('breadcrumbsFocusForeground', "Color of focused breadcrumb items."));
-export const breadcrumbsActiveSelectionForeground = registerColor('breadcrumb.activeSelectionForeground', { light: darken(foreground, 0.2), dark: lighten(foreground, 0.1), hcDark: lighten(foreground, 0.1), hcLight: lighten(foreground, 0.1) }, nls.localize('breadcrumbsSelectedForeground', "Color of selected breadcrumb items."));
-export const breadcrumbsPickerBackground = registerColor('breadcrumbPicker.background', { light: editorWidgetBackground, dark: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localize('breadcrumbsSelectedBackground', "Background color of breadcrumb item picker."));
+export const breadcrumbsForeground = registerColor('breadcrumb.foreground', { light: transparent(foreground, 0.8), dark: transparent(foreground, 0.8), hcDark: transparent(foreground, 0.8), hcLight: transparent(foreground, 0.8) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'breadcrumbsFocusForeground', "Color of focused breadcrumb items."));
+export const breadcrumbsBackground = registerColor('breadcrumb.background', { light: editorBackground, dark: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'breadcrumbsBackground', "Background color of breadcrumb items."));
+export const breadcrumbsFocusForeground = registerColor('breadcrumb.focusForeground', { light: darken(foreground, 0.2), dark: lighten(foreground, 0.1), hcDark: lighten(foreground, 0.1), hcLight: lighten(foreground, 0.1) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'breadcrumbsFocusForeground', "Color of focused breadcrumb items."));
+export const breadcrumbsActiveSelectionForeground = registerColor('breadcrumb.activeSelectionForeground', { light: darken(foreground, 0.2), dark: lighten(foreground, 0.1), hcDark: lighten(foreground, 0.1), hcLight: lighten(foreground, 0.1) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'breadcrumbsSelectedForeground', "Color of selected breadcrumb items."));
+export const breadcrumbsPickerBackground = registerColor('breadcrumbPicker.background', { light: editorWidgetBackground, dark: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'breadcrumbsSelectedBackground', "Background color of breadcrumb item picker."));
 /**
  * Merge-conflict colors
  */
@@ -347,59 +363,58 @@
 const commonBaseColor = Color.fromHex('#606060').transparent(0.4);
 const contentTransparency = 0.4;
 const rulerTransparency = 1;
-export const mergeCurrentHeaderBackground = registerColor('merge.currentHeaderBackground', { dark: currentBaseColor, light: currentBaseColor, hcDark: null, hcLight: null }, nls.localize('mergeCurrentHeaderBackground', 'Current header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const mergeCurrentContentBackground = registerColor('merge.currentContentBackground', { dark: transparent(mergeCurrentHeaderBackground, contentTransparency), light: transparent(mergeCurrentHeaderBackground, contentTransparency), hcDark: transparent(mergeCurrentHeaderBackground, contentTransparency), hcLight: transparent(mergeCurrentHeaderBackground, contentTransparency) }, nls.localize('mergeCurrentContentBackground', 'Current content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const mergeIncomingHeaderBackground = registerColor('merge.incomingHeaderBackground', { dark: incomingBaseColor, light: incomingBaseColor, hcDark: null, hcLight: null }, nls.localize('mergeIncomingHeaderBackground', 'Incoming header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const mergeIncomingContentBackground = registerColor('merge.incomingContentBackground', { dark: transparent(mergeIncomingHeaderBackground, contentTransparency), light: transparent(mergeIncomingHeaderBackground, contentTransparency), hcDark: transparent(mergeIncomingHeaderBackground, contentTransparency), hcLight: transparent(mergeIncomingHeaderBackground, contentTransparency) }, nls.localize('mergeIncomingContentBackground', 'Incoming content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const mergeCommonHeaderBackground = registerColor('merge.commonHeaderBackground', { dark: commonBaseColor, light: commonBaseColor, hcDark: null, hcLight: null }, nls.localize('mergeCommonHeaderBackground', 'Common ancestor header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const mergeCommonContentBackground = registerColor('merge.commonContentBackground', { dark: transparent(mergeCommonHeaderBackground, contentTransparency), light: transparent(mergeCommonHeaderBackground, contentTransparency), hcDark: transparent(mergeCommonHeaderBackground, contentTransparency), hcLight: transparent(mergeCommonHeaderBackground, contentTransparency) }, nls.localize('mergeCommonContentBackground', 'Common ancestor content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const mergeBorder = registerColor('merge.border', { dark: null, light: null, hcDark: '#C3DF6F', hcLight: '#007ACC' }, nls.localize('mergeBorder', 'Border color on headers and the splitter in inline merge-conflicts.'));
-export const overviewRulerCurrentContentForeground = registerColor('editorOverviewRuler.currentContentForeground', { dark: transparent(mergeCurrentHeaderBackground, rulerTransparency), light: transparent(mergeCurrentHeaderBackground, rulerTransparency), hcDark: mergeBorder, hcLight: mergeBorder }, nls.localize('overviewRulerCurrentContentForeground', 'Current overview ruler foreground for inline merge-conflicts.'));
-export const overviewRulerIncomingContentForeground = registerColor('editorOverviewRuler.incomingContentForeground', { dark: transparent(mergeIncomingHeaderBackground, rulerTransparency), light: transparent(mergeIncomingHeaderBackground, rulerTransparency), hcDark: mergeBorder, hcLight: mergeBorder }, nls.localize('overviewRulerIncomingContentForeground', 'Incoming overview ruler foreground for inline merge-conflicts.'));
-export const overviewRulerCommonContentForeground = registerColor('editorOverviewRuler.commonContentForeground', { dark: transparent(mergeCommonHeaderBackground, rulerTransparency), light: transparent(mergeCommonHeaderBackground, rulerTransparency), hcDark: mergeBorder, hcLight: mergeBorder }, nls.localize('overviewRulerCommonContentForeground', 'Common ancestor overview ruler foreground for inline merge-conflicts.'));
-export const overviewRulerFindMatchForeground = registerColor('editorOverviewRuler.findMatchForeground', { dark: '#d186167e', light: '#d186167e', hcDark: '#AB5A00', hcLight: '' }, nls.localize('overviewRulerFindMatchForeground', 'Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const overviewRulerSelectionHighlightForeground = registerColor('editorOverviewRuler.selectionHighlightForeground', { dark: '#A0A0A0CC', light: '#A0A0A0CC', hcDark: '#A0A0A0CC', hcLight: '#A0A0A0CC' }, nls.localize('overviewRulerSelectionHighlightForeground', 'Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations.'), true);
-export const minimapFindMatch = registerColor('minimap.findMatchHighlight', { light: '#d18616', dark: '#d18616', hcDark: '#AB5A00', hcLight: '#0F4A85' }, nls.localize('minimapFindMatchHighlight', 'Minimap marker color for find matches.'), true);
-export const minimapSelectionOccurrenceHighlight = registerColor('minimap.selectionOccurrenceHighlight', { light: '#c9c9c9', dark: '#676767', hcDark: '#ffffff', hcLight: '#0F4A85' }, nls.localize('minimapSelectionOccurrenceHighlight', 'Minimap marker color for repeating editor selections.'), true);
-export const minimapSelection = registerColor('minimap.selectionHighlight', { light: '#ADD6FF', dark: '#264F78', hcDark: '#ffffff', hcLight: '#0F4A85' }, nls.localize('minimapSelectionHighlight', 'Minimap marker color for the editor selection.'), true);
-export const minimapInfo = registerColor('minimap.infoHighlight', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('minimapInfo', 'Minimap marker color for infos.'));
-export const minimapWarning = registerColor('minimap.warningHighlight', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Minimap marker color for warnings.'));
-export const minimapError = registerColor('minimap.errorHighlight', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('minimapError', 'Minimap marker color for errors.'));
-export const minimapBackground = registerColor('minimap.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('minimapBackground', "Minimap background color."));
-export const minimapForegroundOpacity = registerColor('minimap.foregroundOpacity', { dark: Color.fromHex('#000f'), light: Color.fromHex('#000f'), hcDark: Color.fromHex('#000f'), hcLight: Color.fromHex('#000f') }, nls.localize('minimapForegroundOpacity', 'Opacity of foreground elements rendered in the minimap. For example, "#000000c0" will render the elements with 75% opacity.'));
-export const minimapSliderBackground = registerColor('minimapSlider.background', { light: transparent(scrollbarSliderBackground, 0.5), dark: transparent(scrollbarSliderBackground, 0.5), hcDark: transparent(scrollbarSliderBackground, 0.5), hcLight: transparent(scrollbarSliderBackground, 0.5) }, nls.localize('minimapSliderBackground', "Minimap slider background color."));
-export const minimapSliderHoverBackground = registerColor('minimapSlider.hoverBackground', { light: transparent(scrollbarSliderHoverBackground, 0.5), dark: transparent(scrollbarSliderHoverBackground, 0.5), hcDark: transparent(scrollbarSliderHoverBackground, 0.5), hcLight: transparent(scrollbarSliderHoverBackground, 0.5) }, nls.localize('minimapSliderHoverBackground', "Minimap slider background color when hovering."));
-export const minimapSliderActiveBackground = registerColor('minimapSlider.activeBackground', { light: transparent(scrollbarSliderActiveBackground, 0.5), dark: transparent(scrollbarSliderActiveBackground, 0.5), hcDark: transparent(scrollbarSliderActiveBackground, 0.5), hcLight: transparent(scrollbarSliderActiveBackground, 0.5) }, nls.localize('minimapSliderActiveBackground', "Minimap slider background color when clicked on."));
-export const problemsErrorIconForeground = registerColor('problemsErrorIcon.foreground', { dark: editorErrorForeground, light: editorErrorForeground, hcDark: editorErrorForeground, hcLight: editorErrorForeground }, nls.localize('problemsErrorIconForeground', "The color used for the problems error icon."));
-export const problemsWarningIconForeground = registerColor('problemsWarningIcon.foreground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningForeground, hcLight: editorWarningForeground }, nls.localize('problemsWarningIconForeground', "The color used for the problems warning icon."));
-export const problemsInfoIconForeground = registerColor('problemsInfoIcon.foreground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoForeground, hcLight: editorInfoForeground }, nls.localize('problemsInfoIconForeground', "The color used for the problems info icon."));
+export const mergeCurrentHeaderBackground = registerColor('merge.currentHeaderBackground', { dark: currentBaseColor, light: currentBaseColor, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'mergeCurrentHeaderBackground', 'Current header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const mergeCurrentContentBackground = registerColor('merge.currentContentBackground', { dark: transparent(mergeCurrentHeaderBackground, contentTransparency), light: transparent(mergeCurrentHeaderBackground, contentTransparency), hcDark: transparent(mergeCurrentHeaderBackground, contentTransparency), hcLight: transparent(mergeCurrentHeaderBackground, contentTransparency) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'mergeCurrentContentBackground', 'Current content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const mergeIncomingHeaderBackground = registerColor('merge.incomingHeaderBackground', { dark: incomingBaseColor, light: incomingBaseColor, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'mergeIncomingHeaderBackground', 'Incoming header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const mergeIncomingContentBackground = registerColor('merge.incomingContentBackground', { dark: transparent(mergeIncomingHeaderBackground, contentTransparency), light: transparent(mergeIncomingHeaderBackground, contentTransparency), hcDark: transparent(mergeIncomingHeaderBackground, contentTransparency), hcLight: transparent(mergeIncomingHeaderBackground, contentTransparency) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'mergeIncomingContentBackground', 'Incoming content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const mergeCommonHeaderBackground = registerColor('merge.commonHeaderBackground', { dark: commonBaseColor, light: commonBaseColor, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'mergeCommonHeaderBackground', 'Common ancestor header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const mergeCommonContentBackground = registerColor('merge.commonContentBackground', { dark: transparent(mergeCommonHeaderBackground, contentTransparency), light: transparent(mergeCommonHeaderBackground, contentTransparency), hcDark: transparent(mergeCommonHeaderBackground, contentTransparency), hcLight: transparent(mergeCommonHeaderBackground, contentTransparency) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'mergeCommonContentBackground', 'Common ancestor content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const mergeBorder = registerColor('merge.border', { dark: null, light: null, hcDark: '#C3DF6F', hcLight: '#007ACC' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'mergeBorder', 'Border color on headers and the splitter in inline merge-conflicts.'));
+export const overviewRulerCurrentContentForeground = registerColor('editorOverviewRuler.currentContentForeground', { dark: transparent(mergeCurrentHeaderBackground, rulerTransparency), light: transparent(mergeCurrentHeaderBackground, rulerTransparency), hcDark: mergeBorder, hcLight: mergeBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'overviewRulerCurrentContentForeground', 'Current overview ruler foreground for inline merge-conflicts.'));
+export const overviewRulerIncomingContentForeground = registerColor('editorOverviewRuler.incomingContentForeground', { dark: transparent(mergeIncomingHeaderBackground, rulerTransparency), light: transparent(mergeIncomingHeaderBackground, rulerTransparency), hcDark: mergeBorder, hcLight: mergeBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'overviewRulerIncomingContentForeground', 'Incoming overview ruler foreground for inline merge-conflicts.'));
+export const overviewRulerCommonContentForeground = registerColor('editorOverviewRuler.commonContentForeground', { dark: transparent(mergeCommonHeaderBackground, rulerTransparency), light: transparent(mergeCommonHeaderBackground, rulerTransparency), hcDark: mergeBorder, hcLight: mergeBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'overviewRulerCommonContentForeground', 'Common ancestor overview ruler foreground for inline merge-conflicts.'));
+export const overviewRulerFindMatchForeground = registerColor('editorOverviewRuler.findMatchForeground', { dark: '#d186167e', light: '#d186167e', hcDark: '#AB5A00', hcLight: '' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'overviewRulerFindMatchForeground', 'Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const overviewRulerSelectionHighlightForeground = registerColor('editorOverviewRuler.selectionHighlightForeground', { dark: '#A0A0A0CC', light: '#A0A0A0CC', hcDark: '#A0A0A0CC', hcLight: '#A0A0A0CC' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'overviewRulerSelectionHighlightForeground', 'Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations.'), true);
+export const minimapFindMatch = registerColor('minimap.findMatchHighlight', { light: '#d18616', dark: '#d18616', hcDark: '#AB5A00', hcLight: '#0F4A85' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'minimapFindMatchHighlight', 'Minimap marker color for find matches.'), true);
+export const minimapSelectionOccurrenceHighlight = registerColor('minimap.selectionOccurrenceHighlight', { light: '#c9c9c9', dark: '#676767', hcDark: '#ffffff', hcLight: '#0F4A85' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'minimapSelectionOccurrenceHighlight', 'Minimap marker color for repeating editor selections.'), true);
+export const minimapSelection = registerColor('minimap.selectionHighlight', { light: '#ADD6FF', dark: '#264F78', hcDark: '#ffffff', hcLight: '#0F4A85' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'minimapSelectionHighlight', 'Minimap marker color for the editor selection.'), true);
+export const minimapInfo = registerColor('minimap.infoHighlight', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'minimapInfo', 'Minimap marker color for infos.'));
+export const minimapWarning = registerColor('minimap.warningHighlight', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'overviewRuleWarning', 'Minimap marker color for warnings.'));
+export const minimapError = registerColor('minimap.errorHighlight', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'minimapError', 'Minimap marker color for errors.'));
+export const minimapBackground = registerColor('minimap.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'minimapBackground', "Minimap background color."));
+export const minimapForegroundOpacity = registerColor('minimap.foregroundOpacity', { dark: Color.fromHex('#000f'), light: Color.fromHex('#000f'), hcDark: Color.fromHex('#000f'), hcLight: Color.fromHex('#000f') }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'minimapForegroundOpacity', 'Opacity of foreground elements rendered in the minimap. For example, "#000000c0" will render the elements with 75% opacity.'));
+export const minimapSliderBackground = registerColor('minimapSlider.background', { light: transparent(scrollbarSliderBackground, 0.5), dark: transparent(scrollbarSliderBackground, 0.5), hcDark: transparent(scrollbarSliderBackground, 0.5), hcLight: transparent(scrollbarSliderBackground, 0.5) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'minimapSliderBackground', "Minimap slider background color."));
+export const minimapSliderHoverBackground = registerColor('minimapSlider.hoverBackground', { light: transparent(scrollbarSliderHoverBackground, 0.5), dark: transparent(scrollbarSliderHoverBackground, 0.5), hcDark: transparent(scrollbarSliderHoverBackground, 0.5), hcLight: transparent(scrollbarSliderHoverBackground, 0.5) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'minimapSliderHoverBackground', "Minimap slider background color when hovering."));
+export const minimapSliderActiveBackground = registerColor('minimapSlider.activeBackground', { light: transparent(scrollbarSliderActiveBackground, 0.5), dark: transparent(scrollbarSliderActiveBackground, 0.5), hcDark: transparent(scrollbarSliderActiveBackground, 0.5), hcLight: transparent(scrollbarSliderActiveBackground, 0.5) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'minimapSliderActiveBackground', "Minimap slider background color when clicked on."));
+export const problemsErrorIconForeground = registerColor('problemsErrorIcon.foreground', { dark: editorErrorForeground, light: editorErrorForeground, hcDark: editorErrorForeground, hcLight: editorErrorForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'problemsErrorIconForeground', "The color used for the problems error icon."));
+export const problemsWarningIconForeground = registerColor('problemsWarningIcon.foreground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningForeground, hcLight: editorWarningForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'problemsWarningIconForeground', "The color used for the problems warning icon."));
+export const problemsInfoIconForeground = registerColor('problemsInfoIcon.foreground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoForeground, hcLight: editorInfoForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'problemsInfoIconForeground', "The color used for the problems info icon."));
 /**
  * Chart colors
  */
-export const chartsForeground = registerColor('charts.foreground', { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, nls.localize('chartsForeground', "The foreground color used in charts."));
-export const chartsLines = registerColor('charts.lines', { dark: transparent(foreground, .5), light: transparent(foreground, .5), hcDark: transparent(foreground, .5), hcLight: transparent(foreground, .5) }, nls.localize('chartsLines', "The color used for horizontal lines in charts."));
-export const chartsRed = registerColor('charts.red', { dark: editorErrorForeground, light: editorErrorForeground, hcDark: editorErrorForeground, hcLight: editorErrorForeground }, nls.localize('chartsRed', "The red color used in chart visualizations."));
-export const chartsBlue = registerColor('charts.blue', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoForeground, hcLight: editorInfoForeground }, nls.localize('chartsBlue', "The blue color used in chart visualizations."));
-export const chartsYellow = registerColor('charts.yellow', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningForeground, hcLight: editorWarningForeground }, nls.localize('chartsYellow', "The yellow color used in chart visualizations."));
-export const chartsOrange = registerColor('charts.orange', { dark: minimapFindMatch, light: minimapFindMatch, hcDark: minimapFindMatch, hcLight: minimapFindMatch }, nls.localize('chartsOrange', "The orange color used in chart visualizations."));
-export const chartsGreen = registerColor('charts.green', { dark: '#89D185', light: '#388A34', hcDark: '#89D185', hcLight: '#374e06' }, nls.localize('chartsGreen', "The green color used in chart visualizations."));
-export const chartsPurple = registerColor('charts.purple', { dark: '#B180D7', light: '#652D90', hcDark: '#B180D7', hcLight: '#652D90' }, nls.localize('chartsPurple', "The purple color used in chart visualizations."));
+export const chartsForeground = registerColor('charts.foreground', { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'chartsForeground', "The foreground color used in charts."));
+export const chartsLines = registerColor('charts.lines', { dark: transparent(foreground, .5), light: transparent(foreground, .5), hcDark: transparent(foreground, .5), hcLight: transparent(foreground, .5) }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'chartsLines', "The color used for horizontal lines in charts."));
+export const chartsRed = registerColor('charts.red', { dark: editorErrorForeground, light: editorErrorForeground, hcDark: editorErrorForeground, hcLight: editorErrorForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'chartsRed', "The red color used in chart visualizations."));
+export const chartsBlue = registerColor('charts.blue', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoForeground, hcLight: editorInfoForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'chartsBlue', "The blue color used in chart visualizations."));
+export const chartsYellow = registerColor('charts.yellow', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningForeground, hcLight: editorWarningForeground }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'chartsYellow', "The yellow color used in chart visualizations."));
+export const chartsOrange = registerColor('charts.orange', { dark: minimapFindMatch, light: minimapFindMatch, hcDark: minimapFindMatch, hcLight: minimapFindMatch }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'chartsOrange', "The orange color used in chart visualizations."));
+export const chartsGreen = registerColor('charts.green', { dark: '#89D185', light: '#388A34', hcDark: '#89D185', hcLight: '#374e06' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'chartsGreen', "The green color used in chart visualizations."));
+export const chartsPurple = registerColor('charts.purple', { dark: '#B180D7', light: '#652D90', hcDark: '#B180D7', hcLight: '#652D90' }, nls.localizeWithPath('vs/platform/theme/common/colorRegistry', 'chartsPurple', "The purple color used in chart visualizations."));
 // ----- color functions
 export function executeTransform(transform, theme) {
-    var _a, _b, _c, _d;
     switch (transform.op) {
         case 0 /* ColorTransformType.Darken */:
-            return (_a = resolveColorValue(transform.value, theme)) === null || _a === void 0 ? void 0 : _a.darken(transform.factor);
+            return resolveColorValue(transform.value, theme)?.darken(transform.factor);
         case 1 /* ColorTransformType.Lighten */:
-            return (_b = resolveColorValue(transform.value, theme)) === null || _b === void 0 ? void 0 : _b.lighten(transform.factor);
+            return resolveColorValue(transform.value, theme)?.lighten(transform.factor);
         case 2 /* ColorTransformType.Transparent */:
-            return (_c = resolveColorValue(transform.value, theme)) === null || _c === void 0 ? void 0 : _c.transparent(transform.factor);
+            return resolveColorValue(transform.value, theme)?.transparent(transform.factor);
         case 3 /* ColorTransformType.Opaque */: {
             const backgroundColor = resolveColorValue(transform.background, theme);
             if (!backgroundColor) {
                 return resolveColorValue(transform.value, theme);
             }
-            return (_d = resolveColorValue(transform.value, theme)) === null || _d === void 0 ? void 0 : _d.makeOpaque(backgroundColor);
+            return resolveColorValue(transform.value, theme)?.makeOpaque(backgroundColor);
         }
         case 4 /* ColorTransformType.OneOf */:
             for (const candidate of transform.values) {
@@ -437,6 +452,9 @@
 export function transparent(colorValue, factor) {
     return { op: 2 /* ColorTransformType.Transparent */, value: colorValue, factor };
 }
+export function opaque(colorValue, background) {
+    return { op: 3 /* ColorTransformType.Opaque */, value: colorValue, background };
+}
 export function oneOf(...colorValues) {
     return { op: 4 /* ColorTransformType.OneOf */, values: colorValues };
 }
diff -urN -x '*.map' a/vs/platform/theme/common/iconRegistry.js b/vs/platform/theme/common/iconRegistry.js
--- a/vs/platform/theme/common/iconRegistry.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/theme/common/iconRegistry.js	2023-12-06 14:23:14.391854805 +0000
@@ -8,7 +8,7 @@
 import { Emitter } from '../../../base/common/event.js';
 import { isString } from '../../../base/common/types.js';
 import { URI } from '../../../base/common/uri.js';
-import { localize } from '../../../nls.js';
+import { localizeWithPath } from '../../../nls.js';
 import { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';
 import * as platform from '../../registry/common/platform.js';
 //  ------ API types
@@ -63,8 +63,8 @@
                 icons: {
                     type: 'object',
                     properties: {
-                        fontId: { type: 'string', description: localize('iconDefinition.fontId', 'The id of the font to use. If not set, the font that is defined first is used.') },
-                        fontCharacter: { type: 'string', description: localize('iconDefinition.fontCharacter', 'The font character associated with the icon definition.') }
+                        fontId: { type: 'string', description: localizeWithPath('vs/platform/theme/common/iconRegistry', 'iconDefinition.fontId', 'The id of the font to use. If not set, the font that is defined first is used.') },
+                        fontCharacter: { type: 'string', description: localizeWithPath('vs/platform/theme/common/iconRegistry', 'iconDefinition.fontCharacter', 'The font character associated with the icon definition.') }
                     },
                     additionalProperties: false,
                     defaultSnippets: [{ body: { fontCharacter: '\\\\e030' } }]
@@ -106,6 +106,16 @@
         this._onDidChange.fire();
         return { id };
     }
+    deregisterIcon(id) {
+        delete this.iconsById[id];
+        delete this.iconSchema.properties[id];
+        const index = this.iconReferenceSchema.enum.indexOf(id);
+        if (index !== -1) {
+            this.iconReferenceSchema.enum.splice(index, 1);
+            this.iconReferenceSchema.enumDescriptions.splice(index, 1);
+        }
+        this._onDidChange.fire();
+    }
     getIcons() {
         return Object.keys(this.iconsById).map(id => this.iconsById[id]);
     }
@@ -115,6 +125,24 @@
     getIconSchema() {
         return this.iconSchema;
     }
+    getIconReferenceSchema() {
+        return this.iconReferenceSchema;
+    }
+    registerIconFont(id, definition) {
+        const existing = this.iconFontsById[id];
+        if (existing) {
+            return existing;
+        }
+        this.iconFontsById[id] = definition;
+        this._onDidChange.fire();
+        return definition;
+    }
+    deregisterIconFont(id) {
+        delete this.iconFontsById[id];
+    }
+    getIconFont(id) {
+        return this.iconFontsById[id];
+    }
     toString() {
         const sorter = (i1, i2) => {
             return i1.id.localeCompare(i2.id);
@@ -167,8 +195,8 @@
 });
 //setTimeout(_ => console.log(iconRegistry.toString()), 5000);
 // common icons
-export const widgetClose = registerIcon('widget-close', Codicon.close, localize('widgetClose', 'Icon for the close action in widgets.'));
-export const gotoPreviousLocation = registerIcon('goto-previous-location', Codicon.arrowUp, localize('previousChangeIcon', 'Icon for goto previous editor location.'));
-export const gotoNextLocation = registerIcon('goto-next-location', Codicon.arrowDown, localize('nextChangeIcon', 'Icon for goto next editor location.'));
+export const widgetClose = registerIcon('widget-close', Codicon.close, localizeWithPath('vs/platform/theme/common/iconRegistry', 'widgetClose', 'Icon for the close action in widgets.'));
+export const gotoPreviousLocation = registerIcon('goto-previous-location', Codicon.arrowUp, localizeWithPath('vs/platform/theme/common/iconRegistry', 'previousChangeIcon', 'Icon for goto previous editor location.'));
+export const gotoNextLocation = registerIcon('goto-next-location', Codicon.arrowDown, localizeWithPath('vs/platform/theme/common/iconRegistry', 'nextChangeIcon', 'Icon for goto next editor location.'));
 export const syncing = ThemeIcon.modify(Codicon.sync, 'spin');
 export const spinningLoading = ThemeIcon.modify(Codicon.loading, 'spin');
diff -urN -x '*.map' a/vs/platform/theme/common/themeService.js b/vs/platform/theme/common/themeService.js
--- a/vs/platform/theme/common/themeService.js	2023-12-06 14:22:33.839782480 +0000
+++ b/vs/platform/theme/common/themeService.js	2023-12-06 14:23:14.391854805 +0000
@@ -1,3 +1,8 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { Codicon } from '../../../base/common/codicons.js';
 import { Emitter } from '../../../base/common/event.js';
 import { Disposable, toDisposable } from '../../../base/common/lifecycle.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
@@ -7,6 +12,8 @@
 export function themeColorFromId(id) {
     return { id };
 }
+export const FileThemeIcon = Codicon.file;
+export const FolderThemeIcon = Codicon.folder;
 export function getThemeTypeSelector(type) {
     switch (type) {
         case ColorScheme.DARK: return 'vs-dark';
@@ -33,6 +40,9 @@
             this.themingParticipants.splice(idx, 1);
         });
     }
+    get onThemingParticipantAdded() {
+        return this.onThemingParticipantAddedEmitter.event;
+    }
     getThemingParticipants() {
         return this.themingParticipants;
     }
@@ -60,4 +70,11 @@
     updateStyles() {
         // Subclasses to override
     }
+    getColor(id, modify) {
+        let color = this.theme.getColor(id);
+        if (color && modify) {
+            color = modify(color, this.theme);
+        }
+        return color ? color.toString() : null;
+    }
 }
diff -urN -x '*.map' a/vs/platform/undoRedo/common/undoRedoService.js b/vs/platform/undoRedo/common/undoRedoService.js
--- a/vs/platform/undoRedo/common/undoRedoService.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/undoRedo/common/undoRedoService.js	2023-12-06 14:23:14.391854805 +0000
@@ -11,15 +11,6 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 import { onUnexpectedError } from '../../../base/common/errors.js';
 import { Disposable, isDisposable } from '../../../base/common/lifecycle.js';
 import { Schemas } from '../../../base/common/network.js';
@@ -79,10 +70,10 @@
         }
         const messages = [];
         if (externalRemoval.length > 0) {
-            messages.push(nls.localize({ key: 'externalRemoval', comment: ['{0} is a list of filenames'] }, "The following files have been closed and modified on disk: {0}.", externalRemoval.join(', ')));
+            messages.push(nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'externalRemoval', comment: ['{0} is a list of filenames'] }, "The following files have been closed and modified on disk: {0}.", externalRemoval.join(', ')));
         }
         if (noParallelUniverses.length > 0) {
-            messages.push(nls.localize({ key: 'noParallelUniverses', comment: ['{0} is a list of filenames'] }, "The following files have been modified in an incompatible way: {0}.", noParallelUniverses.join(', ')));
+            messages.push(nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'noParallelUniverses', comment: ['{0} is a list of filenames'] }, "The following files have been modified in an incompatible way: {0}.", noParallelUniverses.join(', ')));
         }
         return messages.join('\n');
     }
@@ -186,6 +177,24 @@
         this._future = [];
         this.versionId++;
     }
+    setElementsIsValid(isValid) {
+        for (const element of this._past) {
+            if (element.type === 1 /* UndoRedoElementType.Workspace */) {
+                element.setValid(this.resourceLabel, this.strResource, isValid);
+            }
+            else {
+                element.setValid(isValid);
+            }
+        }
+        for (const element of this._future) {
+            if (element.type === 1 /* UndoRedoElementType.Workspace */) {
+                element.setValid(this.resourceLabel, this.strResource, isValid);
+            }
+            else {
+                element.setValid(isValid);
+            }
+        }
+    }
     _setElementValidFlag(element, isValid) {
         if (element.type === 1 /* UndoRedoElementType.Workspace */) {
             element.setValid(this.resourceLabel, this.strResource, isValid);
@@ -365,6 +374,19 @@
         this._editStacks = new Map();
         this._uriComparisonKeyComputers = [];
     }
+    registerUriComparisonKeyComputer(scheme, uriComparisonKeyComputer) {
+        this._uriComparisonKeyComputers.push([scheme, uriComparisonKeyComputer]);
+        return {
+            dispose: () => {
+                for (let i = 0, len = this._uriComparisonKeyComputers.length; i < len; i++) {
+                    if (this._uriComparisonKeyComputers[i][1] === uriComparisonKeyComputer) {
+                        this._uriComparisonKeyComputers.splice(i, 1);
+                        return;
+                    }
+                }
+            }
+        };
+    }
     getUriComparisonKey(resource) {
         for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {
             if (uriComparisonKeyComputer[0] === resource.scheme) {
@@ -495,6 +517,14 @@
             this._print('setElementsValidFlag');
         }
     }
+    hasElements(resource) {
+        const strResource = this.getUriComparisonKey(resource);
+        if (this._editStacks.has(strResource)) {
+            const editStack = this._editStacks.get(strResource);
+            return (editStack.hasPastElements() || editStack.hasFutureElements());
+        }
+        return false;
+    }
     createSnapshot(resource) {
         const strResource = this.getUriComparisonKey(resource);
         if (this._editStacks.has(strResource)) {
@@ -615,17 +645,15 @@
             return continuation();
         }
     }
-    _invokeWorkspacePrepare(element) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (typeof element.actual.prepareUndoRedo === 'undefined') {
-                return Disposable.None;
-            }
-            const result = element.actual.prepareUndoRedo();
-            if (typeof result === 'undefined') {
-                return Disposable.None;
-            }
-            return result;
-        });
+    async _invokeWorkspacePrepare(element) {
+        if (typeof element.actual.prepareUndoRedo === 'undefined') {
+            return Disposable.None;
+        }
+        const result = element.actual.prepareUndoRedo();
+        if (typeof result === 'undefined') {
+            return Disposable.None;
+        }
+        return result;
     }
     _invokeResourcePrepare(element, callback) {
         if (element.actual.type !== 1 /* UndoRedoElementType.Workspace */ || typeof element.actual.prepareUndoRedo === 'undefined') {
@@ -668,10 +696,10 @@
     }
     _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {
         if (element.removedResources) {
-            return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, "Could not undo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
+            return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, "Could not undo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
         }
         if (checkInvalidatedResources && element.invalidatedResources) {
-            return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, "Could not undo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
+            return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, "Could not undo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
         }
         // this must be the last past element in all the impacted resources!
         const cannotUndoDueToResources = [];
@@ -681,7 +709,7 @@
             }
         }
         if (cannotUndoDueToResources.length > 0) {
-            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, "Could not undo '{0}' across all files because changes were made to {1}", element.label, cannotUndoDueToResources.join(', ')));
+            return this._tryToSplitAndUndo(strResource, element, null, nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'cannotWorkspaceUndoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, "Could not undo '{0}' across all files because changes were made to {1}", element.label, cannotUndoDueToResources.join(', ')));
         }
         const cannotLockDueToResources = [];
         for (const editStack of editStackSnapshot.editStacks) {
@@ -690,11 +718,11 @@
             }
         }
         if (cannotLockDueToResources.length > 0) {
-            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, cannotLockDueToResources.join(', ')));
+            return this._tryToSplitAndUndo(strResource, element, null, nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'cannotWorkspaceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, cannotLockDueToResources.join(', ')));
         }
         // check if new stack elements were added in the meantime...
         if (!editStackSnapshot.isValid()) {
-            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
+            return this._tryToSplitAndUndo(strResource, element, null, nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
         }
         return null;
     }
@@ -730,69 +758,67 @@
         }
         return false;
     }
-    _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {
-        return __awaiter(this, void 0, void 0, function* () {
-            if (element.canSplit() && !this._isPartOfUndoGroup(element)) {
-                // this element can be split
-                let UndoChoice;
-                (function (UndoChoice) {
-                    UndoChoice[UndoChoice["All"] = 0] = "All";
-                    UndoChoice[UndoChoice["This"] = 1] = "This";
-                    UndoChoice[UndoChoice["Cancel"] = 2] = "Cancel";
-                })(UndoChoice || (UndoChoice = {}));
-                const { result } = yield this._dialogService.prompt({
-                    type: Severity.Info,
-                    message: nls.localize('confirmWorkspace', "Would you like to undo '{0}' across all files?", element.label),
-                    buttons: [
-                        {
-                            label: nls.localize({ key: 'ok', comment: ['{0} denotes a number that is > 1, && denotes a mnemonic'] }, "&&Undo in {0} Files", editStackSnapshot.editStacks.length),
-                            run: () => UndoChoice.All
-                        },
-                        {
-                            label: nls.localize({ key: 'nok', comment: ['&& denotes a mnemonic'] }, "Undo this &&File"),
-                            run: () => UndoChoice.This
-                        }
-                    ],
-                    cancelButton: {
-                        run: () => UndoChoice.Cancel
+    async _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {
+        if (element.canSplit() && !this._isPartOfUndoGroup(element)) {
+            // this element can be split
+            let UndoChoice;
+            (function (UndoChoice) {
+                UndoChoice[UndoChoice["All"] = 0] = "All";
+                UndoChoice[UndoChoice["This"] = 1] = "This";
+                UndoChoice[UndoChoice["Cancel"] = 2] = "Cancel";
+            })(UndoChoice || (UndoChoice = {}));
+            const { result } = await this._dialogService.prompt({
+                type: Severity.Info,
+                message: nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', 'confirmWorkspace', "Would you like to undo '{0}' across all files?", element.label),
+                buttons: [
+                    {
+                        label: nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'ok', comment: ['{0} denotes a number that is > 1, && denotes a mnemonic'] }, "&&Undo in {0} Files", editStackSnapshot.editStacks.length),
+                        run: () => UndoChoice.All
+                    },
+                    {
+                        label: nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'nok', comment: ['&& denotes a mnemonic'] }, "Undo this &&File"),
+                        run: () => UndoChoice.This
                     }
-                });
-                if (result === UndoChoice.Cancel) {
-                    // choice: cancel
-                    return;
-                }
-                if (result === UndoChoice.This) {
-                    // choice: undo this file
-                    this._splitPastWorkspaceElement(element, null);
-                    return this._undo(strResource, 0, true);
-                }
-                // choice: undo in all files
-                // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)
-                const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*invalidated resources will be checked after the prepare call*/ false);
-                if (verificationError1) {
-                    return verificationError1.returnValue;
-                }
-                undoConfirmed = true;
-            }
-            // prepare
-            let cleanup;
-            try {
-                cleanup = yield this._invokeWorkspacePrepare(element);
-            }
-            catch (err) {
-                return this._onError(err, element);
-            }
-            // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)
-            const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);
-            if (verificationError2) {
-                cleanup.dispose();
-                return verificationError2.returnValue;
+                ],
+                cancelButton: {
+                    run: () => UndoChoice.Cancel
+                }
+            });
+            if (result === UndoChoice.Cancel) {
+                // choice: cancel
+                return;
             }
-            for (const editStack of editStackSnapshot.editStacks) {
-                editStack.moveBackward(element);
+            if (result === UndoChoice.This) {
+                // choice: undo this file
+                this._splitPastWorkspaceElement(element, null);
+                return this._undo(strResource, 0, true);
+            }
+            // choice: undo in all files
+            // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)
+            const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*invalidated resources will be checked after the prepare call*/ false);
+            if (verificationError1) {
+                return verificationError1.returnValue;
             }
-            return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));
-        });
+            undoConfirmed = true;
+        }
+        // prepare
+        let cleanup;
+        try {
+            cleanup = await this._invokeWorkspacePrepare(element);
+        }
+        catch (err) {
+            return this._onError(err, element);
+        }
+        // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)
+        const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);
+        if (verificationError2) {
+            cleanup.dispose();
+            return verificationError2.returnValue;
+        }
+        for (const editStack of editStackSnapshot.editStacks) {
+            editStack.moveBackward(element);
+        }
+        return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));
     }
     _resourceUndo(editStack, element, undoConfirmed) {
         if (!element.isValid) {
@@ -801,7 +827,7 @@
             return;
         }
         if (editStack.locked) {
-            const message = nls.localize({ key: 'cannotResourceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, "Could not undo '{0}' because there is already an undo or redo operation running.", element.label);
+            const message = nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'cannotResourceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, "Could not undo '{0}' because there is already an undo or redo operation running.", element.label);
             this._notificationService.warn(message);
             return;
         }
@@ -886,18 +912,16 @@
             }
         }
     }
-    _confirmAndContinueUndo(strResource, sourceId, element) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const result = yield this._dialogService.confirm({
-                message: nls.localize('confirmDifferentSource', "Would you like to undo '{0}'?", element.label),
-                primaryButton: nls.localize({ key: 'confirmDifferentSource.yes', comment: ['&& denotes a mnemonic'] }, "&&Yes"),
-                cancelButton: nls.localize('confirmDifferentSource.no', "No")
-            });
-            if (!result.confirmed) {
-                return;
-            }
-            return this._undo(strResource, sourceId, true);
+    async _confirmAndContinueUndo(strResource, sourceId, element) {
+        const result = await this._dialogService.confirm({
+            message: nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', 'confirmDifferentSource', "Would you like to undo '{0}'?", element.label),
+            primaryButton: nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'confirmDifferentSource.yes', comment: ['&& denotes a mnemonic'] }, "&&Yes"),
+            cancelButton: nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', 'confirmDifferentSource.no', "No")
         });
+        if (!result.confirmed) {
+            return;
+        }
+        return this._undo(strResource, sourceId, true);
     }
     _findClosestRedoElementWithSource(sourceId) {
         if (!sourceId) {
@@ -949,10 +973,10 @@
     }
     _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {
         if (element.removedResources) {
-            return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, "Could not redo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
+            return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, "Could not redo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
         }
         if (checkInvalidatedResources && element.invalidatedResources) {
-            return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, "Could not redo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
+            return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, "Could not redo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
         }
         // this must be the last future element in all the impacted resources!
         const cannotRedoDueToResources = [];
@@ -962,7 +986,7 @@
             }
         }
         if (cannotRedoDueToResources.length > 0) {
-            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, "Could not redo '{0}' across all files because changes were made to {1}", element.label, cannotRedoDueToResources.join(', ')));
+            return this._tryToSplitAndRedo(strResource, element, null, nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'cannotWorkspaceRedoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, "Could not redo '{0}' across all files because changes were made to {1}", element.label, cannotRedoDueToResources.join(', ')));
         }
         const cannotLockDueToResources = [];
         for (const editStack of editStackSnapshot.editStacks) {
@@ -971,11 +995,11 @@
             }
         }
         if (cannotLockDueToResources.length > 0) {
-            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, cannotLockDueToResources.join(', ')));
+            return this._tryToSplitAndRedo(strResource, element, null, nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'cannotWorkspaceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, cannotLockDueToResources.join(', ')));
         }
         // check if new stack elements were added in the meantime...
         if (!editStackSnapshot.isValid()) {
-            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
+            return this._tryToSplitAndRedo(strResource, element, null, nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
         }
         return null;
     }
@@ -987,27 +1011,25 @@
         }
         return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);
     }
-    _executeWorkspaceRedo(strResource, element, editStackSnapshot) {
-        return __awaiter(this, void 0, void 0, function* () {
-            // prepare
-            let cleanup;
-            try {
-                cleanup = yield this._invokeWorkspacePrepare(element);
-            }
-            catch (err) {
-                return this._onError(err, element);
-            }
-            // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)
-            const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);
-            if (verificationError) {
-                cleanup.dispose();
-                return verificationError.returnValue;
-            }
-            for (const editStack of editStackSnapshot.editStacks) {
-                editStack.moveForward(element);
-            }
-            return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));
-        });
+    async _executeWorkspaceRedo(strResource, element, editStackSnapshot) {
+        // prepare
+        let cleanup;
+        try {
+            cleanup = await this._invokeWorkspacePrepare(element);
+        }
+        catch (err) {
+            return this._onError(err, element);
+        }
+        // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)
+        const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);
+        if (verificationError) {
+            cleanup.dispose();
+            return verificationError.returnValue;
+        }
+        for (const editStack of editStackSnapshot.editStacks) {
+            editStack.moveForward(element);
+        }
+        return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));
     }
     _resourceRedo(editStack, element) {
         if (!element.isValid) {
@@ -1016,7 +1038,7 @@
             return;
         }
         if (editStack.locked) {
-            const message = nls.localize({ key: 'cannotResourceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, "Could not redo '{0}' because there is already an undo or redo operation running.", element.label);
+            const message = nls.localizeWithPath('vs/platform/undoRedo/common/undoRedoService', { key: 'cannotResourceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, "Could not redo '{0}' because there is already an undo or redo operation running.", element.label);
             this._notificationService.warn(message);
             return;
         }
diff -urN -x '*.map' a/vs/platform/uriIdentity/common/uriIdentity.js b/vs/platform/uriIdentity/common/uriIdentity.js
--- a/vs/platform/uriIdentity/common/uriIdentity.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/uriIdentity/common/uriIdentity.js	2023-12-06 14:23:14.391854805 +0000
@@ -0,0 +1,6 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { createDecorator } from '../../instantiation/common/instantiation.js';
+export const IUriIdentityService = createDecorator('IUriIdentityService');
diff -urN -x '*.map' a/vs/platform/userDataProfile/common/userDataProfile.js b/vs/platform/userDataProfile/common/userDataProfile.js
--- a/vs/platform/userDataProfile/common/userDataProfile.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/userDataProfile/common/userDataProfile.js	2023-12-06 14:23:14.391854805 +0000
@@ -0,0 +1,475 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
+    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
+    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
+    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
+    return c > 3 && r && Object.defineProperty(target, key, r), r;
+};
+var __param = (this && this.__param) || function (paramIndex, decorator) {
+    return function (target, key) { decorator(target, key, paramIndex); }
+};
+import { hash } from '../../../base/common/hash.js';
+import { Emitter } from '../../../base/common/event.js';
+import { Disposable } from '../../../base/common/lifecycle.js';
+import { basename, joinPath } from '../../../base/common/resources.js';
+import { URI } from '../../../base/common/uri.js';
+import { localizeWithPath } from '../../../nls.js';
+import { IEnvironmentService } from '../../environment/common/environment.js';
+import { IFileService, toFileOperationResult } from '../../files/common/files.js';
+import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { ILogService } from '../../log/common/log.js';
+import { isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier } from '../../workspace/common/workspace.js';
+import { ResourceMap } from '../../../base/common/map.js';
+import { IUriIdentityService } from '../../uriIdentity/common/uriIdentity.js';
+import { Promises } from '../../../base/common/async.js';
+import { generateUuid } from '../../../base/common/uuid.js';
+import { escapeRegExpCharacters } from '../../../base/common/strings.js';
+import { isString } from '../../../base/common/types.js';
+export function isUserDataProfile(thing) {
+    const candidate = thing;
+    return !!(candidate && typeof candidate === 'object'
+        && typeof candidate.id === 'string'
+        && typeof candidate.isDefault === 'boolean'
+        && typeof candidate.name === 'string'
+        && URI.isUri(candidate.location)
+        && URI.isUri(candidate.globalStorageHome)
+        && URI.isUri(candidate.settingsResource)
+        && URI.isUri(candidate.keybindingsResource)
+        && URI.isUri(candidate.tasksResource)
+        && URI.isUri(candidate.snippetsHome)
+        && URI.isUri(candidate.extensionsResource));
+}
+export const IUserDataProfilesService = createDecorator('IUserDataProfilesService');
+export function reviveProfile(profile, scheme) {
+    return {
+        id: profile.id,
+        isDefault: profile.isDefault,
+        name: profile.name,
+        shortName: profile.shortName,
+        icon: profile.icon,
+        location: URI.revive(profile.location).with({ scheme }),
+        globalStorageHome: URI.revive(profile.globalStorageHome).with({ scheme }),
+        settingsResource: URI.revive(profile.settingsResource).with({ scheme }),
+        keybindingsResource: URI.revive(profile.keybindingsResource).with({ scheme }),
+        tasksResource: URI.revive(profile.tasksResource).with({ scheme }),
+        snippetsHome: URI.revive(profile.snippetsHome).with({ scheme }),
+        extensionsResource: URI.revive(profile.extensionsResource).with({ scheme }),
+        cacheHome: URI.revive(profile.cacheHome).with({ scheme }),
+        useDefaultFlags: profile.useDefaultFlags,
+        isTransient: profile.isTransient,
+    };
+}
+export function toUserDataProfile(id, name, location, profilesCacheHome, options, defaultProfile) {
+    return {
+        id,
+        name,
+        location,
+        isDefault: false,
+        shortName: options?.shortName,
+        icon: options?.icon,
+        globalStorageHome: defaultProfile && options?.useDefaultFlags?.globalState ? defaultProfile.globalStorageHome : joinPath(location, 'globalStorage'),
+        settingsResource: defaultProfile && options?.useDefaultFlags?.settings ? defaultProfile.settingsResource : joinPath(location, 'settings.json'),
+        keybindingsResource: defaultProfile && options?.useDefaultFlags?.keybindings ? defaultProfile.keybindingsResource : joinPath(location, 'keybindings.json'),
+        tasksResource: defaultProfile && options?.useDefaultFlags?.tasks ? defaultProfile.tasksResource : joinPath(location, 'tasks.json'),
+        snippetsHome: defaultProfile && options?.useDefaultFlags?.snippets ? defaultProfile.snippetsHome : joinPath(location, 'snippets'),
+        extensionsResource: defaultProfile && options?.useDefaultFlags?.extensions ? defaultProfile.extensionsResource : joinPath(location, 'extensions.json'),
+        cacheHome: joinPath(profilesCacheHome, id),
+        useDefaultFlags: options?.useDefaultFlags,
+        isTransient: options?.transient
+    };
+}
+let UserDataProfilesService = class UserDataProfilesService extends Disposable {
+    get defaultProfile() { return this.profiles[0]; }
+    get profiles() { return [...this.profilesObject.profiles, ...this.transientProfilesObject.profiles]; }
+    constructor(environmentService, fileService, uriIdentityService, logService) {
+        super();
+        this.environmentService = environmentService;
+        this.fileService = fileService;
+        this.uriIdentityService = uriIdentityService;
+        this.logService = logService;
+        this.enabled = true;
+        this._onDidChangeProfiles = this._register(new Emitter());
+        this.onDidChangeProfiles = this._onDidChangeProfiles.event;
+        this._onWillCreateProfile = this._register(new Emitter());
+        this.onWillCreateProfile = this._onWillCreateProfile.event;
+        this._onWillRemoveProfile = this._register(new Emitter());
+        this.onWillRemoveProfile = this._onWillRemoveProfile.event;
+        this._onDidResetWorkspaces = this._register(new Emitter());
+        this.onDidResetWorkspaces = this._onDidResetWorkspaces.event;
+        this.profileCreationPromises = new Map();
+        this.transientProfilesObject = {
+            profiles: [],
+            workspaces: new ResourceMap(),
+            emptyWindows: new Map()
+        };
+        this.profilesHome = joinPath(this.environmentService.userRoamingDataHome, 'profiles');
+        this.profilesCacheHome = joinPath(this.environmentService.cacheHome, 'CachedProfilesData');
+    }
+    init() {
+        this._profilesObject = undefined;
+    }
+    setEnablement(enabled) {
+        if (this.enabled !== enabled) {
+            this._profilesObject = undefined;
+            this.enabled = enabled;
+        }
+    }
+    isEnabled() {
+        return this.enabled;
+    }
+    get profilesObject() {
+        if (!this._profilesObject) {
+            const defaultProfile = this.createDefaultProfile();
+            const profiles = [defaultProfile];
+            if (this.enabled) {
+                try {
+                    for (const storedProfile of this.getStoredProfiles()) {
+                        if (!storedProfile.name || !isString(storedProfile.name) || !storedProfile.location) {
+                            this.logService.warn('Skipping the invalid stored profile', storedProfile.location || storedProfile.name);
+                            continue;
+                        }
+                        profiles.push(toUserDataProfile(basename(storedProfile.location), storedProfile.name, storedProfile.location, this.profilesCacheHome, { shortName: storedProfile.shortName, icon: storedProfile.icon, useDefaultFlags: storedProfile.useDefaultFlags }, defaultProfile));
+                    }
+                }
+                catch (error) {
+                    this.logService.error(error);
+                }
+            }
+            const workspaces = new ResourceMap();
+            const emptyWindows = new Map();
+            if (profiles.length) {
+                try {
+                    const profileAssociaitions = this.getStoredProfileAssociations();
+                    if (profileAssociaitions.workspaces) {
+                        for (const [workspacePath, profileId] of Object.entries(profileAssociaitions.workspaces)) {
+                            const workspace = URI.parse(workspacePath);
+                            const profile = profiles.find(p => p.id === profileId);
+                            if (profile) {
+                                workspaces.set(workspace, profile);
+                            }
+                        }
+                    }
+                    if (profileAssociaitions.emptyWindows) {
+                        for (const [windowId, profileId] of Object.entries(profileAssociaitions.emptyWindows)) {
+                            const profile = profiles.find(p => p.id === profileId);
+                            if (profile) {
+                                emptyWindows.set(windowId, profile);
+                            }
+                        }
+                    }
+                }
+                catch (error) {
+                    this.logService.error(error);
+                }
+            }
+            this._profilesObject = { profiles, workspaces, emptyWindows };
+        }
+        return this._profilesObject;
+    }
+    createDefaultProfile() {
+        const defaultProfile = toUserDataProfile('__default__profile__', localizeWithPath('vs/platform/userDataProfile/common/userDataProfile', 'defaultProfile', "Default"), this.environmentService.userRoamingDataHome, this.profilesCacheHome);
+        return { ...defaultProfile, extensionsResource: this.getDefaultProfileExtensionsLocation() ?? defaultProfile.extensionsResource, isDefault: true };
+    }
+    async createTransientProfile(workspaceIdentifier) {
+        const namePrefix = `Temp`;
+        const nameRegEx = new RegExp(`${escapeRegExpCharacters(namePrefix)}\\s(\\d+)`);
+        let nameIndex = 0;
+        for (const profile of this.profiles) {
+            const matches = nameRegEx.exec(profile.name);
+            const index = matches ? parseInt(matches[1]) : 0;
+            nameIndex = index > nameIndex ? index : nameIndex;
+        }
+        const name = `${namePrefix} ${nameIndex + 1}`;
+        return this.createProfile(hash(generateUuid()).toString(16), name, { transient: true }, workspaceIdentifier);
+    }
+    async createNamedProfile(name, options, workspaceIdentifier) {
+        return this.createProfile(hash(generateUuid()).toString(16), name, options, workspaceIdentifier);
+    }
+    async createProfile(id, name, options, workspaceIdentifier) {
+        if (!this.enabled) {
+            throw new Error(`Profiles are disabled in the current environment.`);
+        }
+        const profile = await this.doCreateProfile(id, name, options);
+        if (workspaceIdentifier) {
+            await this.setProfileForWorkspace(workspaceIdentifier, profile);
+        }
+        return profile;
+    }
+    async doCreateProfile(id, name, options) {
+        if (!isString(name) || !name) {
+            throw new Error('Name of the profile is mandatory and must be of type `string`');
+        }
+        let profileCreationPromise = this.profileCreationPromises.get(name);
+        if (!profileCreationPromise) {
+            profileCreationPromise = (async () => {
+                try {
+                    const existing = this.profiles.find(p => p.name === name || p.id === id);
+                    if (existing) {
+                        return existing;
+                    }
+                    const profile = toUserDataProfile(id, name, joinPath(this.profilesHome, id), this.profilesCacheHome, options, this.defaultProfile);
+                    await this.fileService.createFolder(profile.location);
+                    const joiners = [];
+                    this._onWillCreateProfile.fire({
+                        profile,
+                        join(promise) {
+                            joiners.push(promise);
+                        }
+                    });
+                    await Promises.settled(joiners);
+                    this.updateProfiles([profile], [], []);
+                    return profile;
+                }
+                finally {
+                    this.profileCreationPromises.delete(name);
+                }
+            })();
+            this.profileCreationPromises.set(name, profileCreationPromise);
+        }
+        return profileCreationPromise;
+    }
+    async updateProfile(profileToUpdate, options) {
+        if (!this.enabled) {
+            throw new Error(`Profiles are disabled in the current environment.`);
+        }
+        let profile = this.profiles.find(p => p.id === profileToUpdate.id);
+        if (!profile) {
+            throw new Error(`Profile '${profileToUpdate.name}' does not exist`);
+        }
+        profile = toUserDataProfile(profile.id, options.name ?? profile.name, profile.location, this.profilesCacheHome, {
+            shortName: options.shortName ?? profile.shortName,
+            icon: options.icon === null ? undefined : options.icon ?? profile.icon,
+            transient: options.transient ?? profile.isTransient,
+            useDefaultFlags: options.useDefaultFlags ?? profile.useDefaultFlags
+        }, this.defaultProfile);
+        this.updateProfiles([], [], [profile]);
+        return profile;
+    }
+    async removeProfile(profileToRemove) {
+        if (!this.enabled) {
+            throw new Error(`Profiles are disabled in the current environment.`);
+        }
+        if (profileToRemove.isDefault) {
+            throw new Error('Cannot remove default profile');
+        }
+        const profile = this.profiles.find(p => p.id === profileToRemove.id);
+        if (!profile) {
+            throw new Error(`Profile '${profileToRemove.name}' does not exist`);
+        }
+        const joiners = [];
+        this._onWillRemoveProfile.fire({
+            profile,
+            join(promise) {
+                joiners.push(promise);
+            }
+        });
+        try {
+            await Promise.allSettled(joiners);
+        }
+        catch (error) {
+            this.logService.error(error);
+        }
+        for (const windowId of [...this.profilesObject.emptyWindows.keys()]) {
+            if (profile.id === this.profilesObject.emptyWindows.get(windowId)?.id) {
+                this.profilesObject.emptyWindows.delete(windowId);
+            }
+        }
+        for (const workspace of [...this.profilesObject.workspaces.keys()]) {
+            if (profile.id === this.profilesObject.workspaces.get(workspace)?.id) {
+                this.profilesObject.workspaces.delete(workspace);
+            }
+        }
+        this.updateStoredProfileAssociations();
+        this.updateProfiles([], [profile], []);
+        try {
+            await this.fileService.del(profile.cacheHome, { recursive: true });
+        }
+        catch (error) {
+            if (toFileOperationResult(error) !== 1 /* FileOperationResult.FILE_NOT_FOUND */) {
+                this.logService.error(error);
+            }
+        }
+    }
+    async setProfileForWorkspace(workspaceIdentifier, profileToSet) {
+        if (!this.enabled) {
+            throw new Error(`Profiles are disabled in the current environment.`);
+        }
+        const profile = this.profiles.find(p => p.id === profileToSet.id);
+        if (!profile) {
+            throw new Error(`Profile '${profileToSet.name}' does not exist`);
+        }
+        this.updateWorkspaceAssociation(workspaceIdentifier, profile);
+    }
+    unsetWorkspace(workspaceIdentifier, transient) {
+        if (!this.enabled) {
+            throw new Error(`Profiles are disabled in the current environment.`);
+        }
+        this.updateWorkspaceAssociation(workspaceIdentifier, undefined, transient);
+    }
+    async resetWorkspaces() {
+        this.transientProfilesObject.workspaces.clear();
+        this.transientProfilesObject.emptyWindows.clear();
+        this.profilesObject.workspaces.clear();
+        this.profilesObject.emptyWindows.clear();
+        this.updateStoredProfileAssociations();
+        this._onDidResetWorkspaces.fire();
+    }
+    async cleanUp() {
+        if (!this.enabled) {
+            return;
+        }
+        if (await this.fileService.exists(this.profilesHome)) {
+            const stat = await this.fileService.resolve(this.profilesHome);
+            await Promise.all((stat.children || [])
+                .filter(child => child.isDirectory && this.profiles.every(p => !this.uriIdentityService.extUri.isEqual(p.location, child.resource)))
+                .map(child => this.fileService.del(child.resource, { recursive: true })));
+        }
+    }
+    async cleanUpTransientProfiles() {
+        if (!this.enabled) {
+            return;
+        }
+        const unAssociatedTransientProfiles = this.transientProfilesObject.profiles.filter(p => !this.isProfileAssociatedToWorkspace(p));
+        await Promise.allSettled(unAssociatedTransientProfiles.map(p => this.removeProfile(p)));
+    }
+    getProfileForWorkspace(workspaceIdentifier) {
+        const workspace = this.getWorkspace(workspaceIdentifier);
+        return URI.isUri(workspace) ? this.transientProfilesObject.workspaces.get(workspace) ?? this.profilesObject.workspaces.get(workspace) : this.transientProfilesObject.emptyWindows.get(workspace) ?? this.profilesObject.emptyWindows.get(workspace);
+    }
+    getWorkspace(workspaceIdentifier) {
+        if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
+            return workspaceIdentifier.uri;
+        }
+        if (isWorkspaceIdentifier(workspaceIdentifier)) {
+            return workspaceIdentifier.configPath;
+        }
+        return workspaceIdentifier.id;
+    }
+    isProfileAssociatedToWorkspace(profile) {
+        if ([...this.transientProfilesObject.emptyWindows.values()].some(windowProfile => this.uriIdentityService.extUri.isEqual(windowProfile.location, profile.location))) {
+            return true;
+        }
+        if ([...this.transientProfilesObject.workspaces.values()].some(workspaceProfile => this.uriIdentityService.extUri.isEqual(workspaceProfile.location, profile.location))) {
+            return true;
+        }
+        if ([...this.profilesObject.emptyWindows.values()].some(windowProfile => this.uriIdentityService.extUri.isEqual(windowProfile.location, profile.location))) {
+            return true;
+        }
+        if ([...this.profilesObject.workspaces.values()].some(workspaceProfile => this.uriIdentityService.extUri.isEqual(workspaceProfile.location, profile.location))) {
+            return true;
+        }
+        return false;
+    }
+    updateProfiles(added, removed, updated) {
+        const allProfiles = [...this.profiles, ...added];
+        const storedProfiles = [];
+        this.transientProfilesObject.profiles = [];
+        for (let profile of allProfiles) {
+            if (profile.isDefault) {
+                continue;
+            }
+            if (removed.some(p => profile.id === p.id)) {
+                continue;
+            }
+            profile = updated.find(p => profile.id === p.id) ?? profile;
+            if (profile.isTransient) {
+                this.transientProfilesObject.profiles.push(profile);
+            }
+            else {
+                storedProfiles.push({ location: profile.location, name: profile.name, shortName: profile.shortName, icon: profile.icon, useDefaultFlags: profile.useDefaultFlags });
+            }
+        }
+        this.saveStoredProfiles(storedProfiles);
+        this._profilesObject = undefined;
+        this.triggerProfilesChanges(added, removed, updated);
+    }
+    triggerProfilesChanges(added, removed, updated) {
+        this._onDidChangeProfiles.fire({ added, removed, updated, all: this.profiles });
+    }
+    updateWorkspaceAssociation(workspaceIdentifier, newProfile, transient) {
+        // Force transient if the new profile to associate is transient
+        transient = newProfile?.isTransient ? true : transient;
+        if (!transient) {
+            // Unset the transiet workspace association if any
+            this.updateWorkspaceAssociation(workspaceIdentifier, undefined, true);
+        }
+        const workspace = this.getWorkspace(workspaceIdentifier);
+        const profilesObject = transient ? this.transientProfilesObject : this.profilesObject;
+        // Folder or Multiroot workspace
+        if (URI.isUri(workspace)) {
+            profilesObject.workspaces.delete(workspace);
+            if (newProfile) {
+                profilesObject.workspaces.set(workspace, newProfile);
+            }
+        }
+        // Empty Window
+        else {
+            profilesObject.emptyWindows.delete(workspace);
+            if (newProfile) {
+                profilesObject.emptyWindows.set(workspace, newProfile);
+            }
+        }
+        if (!transient) {
+            this.updateStoredProfileAssociations();
+        }
+    }
+    updateStoredProfileAssociations() {
+        const workspaces = {};
+        for (const [workspace, profile] of this.profilesObject.workspaces.entries()) {
+            workspaces[workspace.toString()] = profile.id;
+        }
+        const emptyWindows = {};
+        for (const [windowId, profile] of this.profilesObject.emptyWindows.entries()) {
+            emptyWindows[windowId.toString()] = profile.id;
+        }
+        this.saveStoredProfileAssociations({ workspaces, emptyWindows });
+        this._profilesObject = undefined;
+    }
+    // TODO: @sandy081 Remove migration after couple of releases
+    migrateStoredProfileAssociations(storedProfileAssociations) {
+        const workspaces = {};
+        const defaultProfile = this.createDefaultProfile();
+        if (storedProfileAssociations.workspaces) {
+            for (const [workspace, location] of Object.entries(storedProfileAssociations.workspaces)) {
+                const uri = URI.parse(location);
+                workspaces[workspace] = this.uriIdentityService.extUri.isEqual(uri, defaultProfile.location) ? defaultProfile.id : this.uriIdentityService.extUri.basename(uri);
+            }
+        }
+        const emptyWindows = {};
+        if (storedProfileAssociations.emptyWindows) {
+            for (const [workspace, location] of Object.entries(storedProfileAssociations.emptyWindows)) {
+                const uri = URI.parse(location);
+                emptyWindows[workspace] = this.uriIdentityService.extUri.isEqual(uri, defaultProfile.location) ? defaultProfile.id : this.uriIdentityService.extUri.basename(uri);
+            }
+        }
+        return { workspaces, emptyWindows };
+    }
+    getStoredProfiles() { return []; }
+    saveStoredProfiles(storedProfiles) { throw new Error('not implemented'); }
+    getStoredProfileAssociations() { return {}; }
+    saveStoredProfileAssociations(storedProfileAssociations) { throw new Error('not implemented'); }
+    getDefaultProfileExtensionsLocation() { return undefined; }
+};
+UserDataProfilesService.PROFILES_KEY = 'userDataProfiles';
+UserDataProfilesService.PROFILE_ASSOCIATIONS_KEY = 'profileAssociations';
+UserDataProfilesService = __decorate([
+    __param(0, IEnvironmentService),
+    __param(1, IFileService),
+    __param(2, IUriIdentityService),
+    __param(3, ILogService)
+], UserDataProfilesService);
+export { UserDataProfilesService };
+export class InMemoryUserDataProfilesService extends UserDataProfilesService {
+    constructor() {
+        super(...arguments);
+        this.storedProfiles = [];
+        this.storedProfileAssociations = {};
+    }
+    getStoredProfiles() { return this.storedProfiles; }
+    saveStoredProfiles(storedProfiles) { this.storedProfiles = storedProfiles; }
+    getStoredProfileAssociations() { return this.storedProfileAssociations; }
+    saveStoredProfileAssociations(storedProfileAssociations) { this.storedProfileAssociations = storedProfileAssociations; }
+}
diff -urN -x '*.map' a/vs/platform/workspace/common/workspace.js b/vs/platform/workspace/common/workspace.js
--- a/vs/platform/workspace/common/workspace.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/workspace/common/workspace.js	2023-12-06 14:23:14.391854805 +0000
@@ -2,19 +2,21 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-import { localize } from '../../../nls.js';
-import { basename } from '../../../base/common/path.js';
+import { localizeWithPath } from '../../../nls.js';
+import { basename, extname } from '../../../base/common/path.js';
 import { TernarySearchTree } from '../../../base/common/ternarySearchTree.js';
+import { extname as resourceExtname, basenameOrAuthority, joinPath, extUriBiasedIgnorePathCase } from '../../../base/common/resources.js';
 import { URI } from '../../../base/common/uri.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { Schemas } from '../../../base/common/network.js';
 export const IWorkspaceContextService = createDecorator('contextService');
 export function isSingleFolderWorkspaceIdentifier(obj) {
     const singleFolderIdentifier = obj;
-    return typeof (singleFolderIdentifier === null || singleFolderIdentifier === void 0 ? void 0 : singleFolderIdentifier.id) === 'string' && URI.isUri(singleFolderIdentifier.uri);
+    return typeof singleFolderIdentifier?.id === 'string' && URI.isUri(singleFolderIdentifier.uri);
 }
 export function isEmptyWorkspaceIdentifier(obj) {
     const emptyWorkspaceIdentifier = obj;
-    return typeof (emptyWorkspaceIdentifier === null || emptyWorkspaceIdentifier === void 0 ? void 0 : emptyWorkspaceIdentifier.id) === 'string'
+    return typeof emptyWorkspaceIdentifier?.id === 'string'
         && !isSingleFolderWorkspaceIdentifier(obj)
         && !isWorkspaceIdentifier(obj);
 }
@@ -59,7 +61,37 @@
 }
 export function isWorkspaceIdentifier(obj) {
     const workspaceIdentifier = obj;
-    return typeof (workspaceIdentifier === null || workspaceIdentifier === void 0 ? void 0 : workspaceIdentifier.id) === 'string' && URI.isUri(workspaceIdentifier.configPath);
+    return typeof workspaceIdentifier?.id === 'string' && URI.isUri(workspaceIdentifier.configPath);
+}
+export function reviveIdentifier(identifier) {
+    // Single Folder
+    const singleFolderIdentifierCandidate = identifier;
+    if (singleFolderIdentifierCandidate?.uri) {
+        return { id: singleFolderIdentifierCandidate.id, uri: URI.revive(singleFolderIdentifierCandidate.uri) };
+    }
+    // Multi folder
+    const workspaceIdentifierCandidate = identifier;
+    if (workspaceIdentifierCandidate?.configPath) {
+        return { id: workspaceIdentifierCandidate.id, configPath: URI.revive(workspaceIdentifierCandidate.configPath) };
+    }
+    // Empty
+    if (identifier?.id) {
+        return { id: identifier.id };
+    }
+    return undefined;
+}
+export function isWorkspace(thing) {
+    const candidate = thing;
+    return !!(candidate && typeof candidate === 'object'
+        && typeof candidate.id === 'string'
+        && Array.isArray(candidate.folders));
+}
+export function isWorkspaceFolder(thing) {
+    const candidate = thing;
+    return !!(candidate && typeof candidate === 'object'
+        && URI.isUri(candidate.uri)
+        && typeof candidate.name === 'string'
+        && typeof candidate.toResource === 'function');
 }
 export class Workspace {
     constructor(_id, folders, _transient, _configuration, _ignorePathCasing) {
@@ -70,6 +102,13 @@
         this._foldersMap = TernarySearchTree.forUris(this._ignorePathCasing, () => true);
         this.folders = folders;
     }
+    update(workspace) {
+        this._id = workspace.id;
+        this._configuration = workspace.configuration;
+        this._transient = workspace.transient;
+        this._ignorePathCasing = workspace._ignorePathCasing;
+        this.folders = workspace.folders;
+    }
     get folders() {
         return this._folders;
     }
@@ -120,13 +159,41 @@
         this.index = data.index;
         this.name = data.name;
     }
+    toResource(relativePath) {
+        return joinPath(this.uri, relativePath);
+    }
     toJSON() {
         return { uri: this.uri, name: this.name, index: this.index };
     }
 }
+export function toWorkspaceFolder(resource) {
+    return new WorkspaceFolder({ uri: resource, index: 0, name: basenameOrAuthority(resource) }, { uri: resource.toString() });
+}
 export const WORKSPACE_EXTENSION = 'code-workspace';
-export const WORKSPACE_FILTER = [{ name: localize('codeWorkspace', "Code Workspace"), extensions: [WORKSPACE_EXTENSION] }];
+export const WORKSPACE_SUFFIX = `.${WORKSPACE_EXTENSION}`;
+export const WORKSPACE_FILTER = [{ name: localizeWithPath('vs/platform/workspace/common/workspace', 'codeWorkspace', "Code Workspace"), extensions: [WORKSPACE_EXTENSION] }];
+export const UNTITLED_WORKSPACE_NAME = 'workspace.json';
+export function isUntitledWorkspace(path, environmentService) {
+    return extUriBiasedIgnorePathCase.isEqualOrParent(path, environmentService.untitledWorkspacesHome);
+}
+export function isTemporaryWorkspace(arg1) {
+    let path;
+    if (URI.isUri(arg1)) {
+        path = arg1;
+    }
+    else {
+        path = arg1.configuration;
+    }
+    return path?.scheme === Schemas.tmp;
+}
 export const STANDALONE_EDITOR_WORKSPACE_ID = '4064f6ec-cb38-4ad0-af64-ee6467e63c82';
 export function isStandaloneEditorWorkspace(workspace) {
     return workspace.id === STANDALONE_EDITOR_WORKSPACE_ID;
 }
+export function isSavedWorkspace(path, environmentService) {
+    return !isUntitledWorkspace(path, environmentService) && !isTemporaryWorkspace(path);
+}
+export function hasWorkspaceFileExtension(path) {
+    const ext = (typeof path === 'string') ? extname(path) : resourceExtname(path);
+    return ext === WORKSPACE_SUFFIX;
+}
diff -urN -x '*.map' a/vs/platform/workspace/common/workspaceTrust.js b/vs/platform/workspace/common/workspaceTrust.js
--- a/vs/platform/workspace/common/workspaceTrust.js	2023-12-06 14:22:33.843782486 +0000
+++ b/vs/platform/workspace/common/workspaceTrust.js	2023-12-06 14:23:14.391854805 +0000
@@ -2,5 +2,21 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+import { localizeWithPath } from '../../../nls.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
+export var WorkspaceTrustScope;
+(function (WorkspaceTrustScope) {
+    WorkspaceTrustScope[WorkspaceTrustScope["Local"] = 0] = "Local";
+    WorkspaceTrustScope[WorkspaceTrustScope["Remote"] = 1] = "Remote";
+})(WorkspaceTrustScope || (WorkspaceTrustScope = {}));
+export function workspaceTrustToString(trustState) {
+    if (trustState) {
+        return localizeWithPath('vs/platform/workspace/common/workspaceTrust', 'trusted', "Trusted");
+    }
+    else {
+        return localizeWithPath('vs/platform/workspace/common/workspaceTrust', 'untrusted', "Restricted Mode");
+    }
+}
+export const IWorkspaceTrustEnablementService = createDecorator('workspaceTrustEnablementService');
 export const IWorkspaceTrustManagementService = createDecorator('workspaceTrustManagementService');
+export const IWorkspaceTrustRequestService = createDecorator('workspaceTrustRequestService');
