import { __decorate, __param } from './external/tslib/tslib.es6.js';
import './missing-services.js';
import './vscode/src/vs/workbench/api/common/extHost.common.services.js';
import { ExtensionHostMain } from './vscode/src/vs/workbench/api/common/extensionHostMain.js';
import { BufferedEmitter } from './vscode/src/vs/base/parts/ipc/common/ipc.net.js';
import { isLoggingOnly } from './vscode/src/vs/platform/telemetry/common/telemetryUtils.js';
import { joinPath } from 'monaco-editor/esm/vs/base/common/resources.js';
import { UIKind } from './vscode/src/vs/workbench/services/extensions/common/extensionHostProtocol.js';
import * as platform from 'monaco-editor/esm/vs/base/common/platform.js';
import { IExtHostExtensionService } from './vscode/src/vs/workbench/api/common/extHostExtensionService.js';
import { nullExtensionDescription, IExtensionService } from './vscode/src/vs/workbench/services/extensions/common/extensions.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { ILabelService } from 'monaco-editor/esm/vs/platform/label/common/label.js';
import { ILogService, ILoggerService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { IBrowserWorkbenchEnvironmentService } from './vscode/src/vs/workbench/services/environment/browser/environmentService.js';
import { IProductService } from 'monaco-editor/esm/vs/platform/product/common/productService.js';
import { IUserDataProfilesService } from 'monaco-editor/esm/vs/platform/userDataProfile/common/userDataProfile.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { registerSingleton } from 'monaco-editor/esm/vs/platform/instantiation/common/extensions.js';
import { IExtensionStoragePaths, ExtensionStoragePaths } from './vscode/src/vs/workbench/api/common/extHostStoragePaths.js';
import { ExtHostExtensionService } from './vscode/src/vs/workbench/api/worker/extHostExtensionService.js';
import { ExtensionIdentifierMap } from 'monaco-editor/esm/vs/platform/extensions/common/extensions.js';
import { DeferredPromise } from 'monaco-editor/esm/vs/base/common/async.js';
import { setLocalExtensionHost } from '@codingame/monaco-vscode-extensions-service-override';
import { unsupported } from './tools.js';
import { registerLocalApiFactory } from './extensions.js';
import { setDefaultApi } from './api.js';
import { registerServiceInitializePostParticipant } from './lifecycle.js';
const apiFactoryDeferred = new DeferredPromise();
class LocalExtHostExtensionService extends ExtHostExtensionService {
    constructor() {
        super(...arguments);
        this._extApiImpl = new ExtensionIdentifierMap();
    }
    async getApi(extensionId) {
        const [myRegistry, configProvider] = await Promise.all([
            this.getExtensionRegistry(),
            this._extHostConfiguration.getConfigProvider()
        ]);
        const extensionRegistry = { mine: myRegistry, all: this._globalRegistry };
        const ext = extensionId != null ? myRegistry.getExtensionDescription(extensionId) : undefined;
        if (ext != null) {
            let apiImpl = this._extApiImpl.get(ext.identifier);
            if (apiImpl == null) {
                apiImpl = this._apiFactory(ext, extensionRegistry, configProvider);
                this._extApiImpl.set(ext.identifier, apiImpl);
            }
            return apiImpl;
        }
        if (this._defaultApiImpl == null) {
            this._defaultApiImpl = this._apiFactory(nullExtensionDescription, extensionRegistry, configProvider);
        }
        return this._defaultApiImpl;
    }
}
registerSingleton(IExtHostExtensionService, LocalExtHostExtensionService, 0 );
registerSingleton(IExtensionStoragePaths, ExtensionStoragePaths, 0 );
function createMessagePassingProtocolPair() {
    const emitterA = new BufferedEmitter();
    const emitterB = new BufferedEmitter();
    class SimpleMessagePassingProtocol {
        constructor(emitterIn, emitterOut) {
            this.emitterIn = emitterIn;
            this.emitterOut = emitterOut;
            this.onMessage = this.emitterIn.event;
        }
        send(buffer) {
            this.emitterOut.fire(buffer);
        }
    }
    return [new SimpleMessagePassingProtocol(emitterA, emitterB), new SimpleMessagePassingProtocol(emitterB, emitterA)];
}
const hostUtil = new class {
    constructor() {
        this.pid = undefined;
        this.exit = unsupported;
    }
    async exists(_path) {
        return true;
    }
    async realpath(path) {
        return path;
    }
}();
let LocalExtensionHost = class LocalExtensionHost {
    constructor(runningLocation, startup, _initDataProvider, _telemetryService, _contextService, _labelService, _logService, _loggerService, _environmentService, _productService, _userDataProfilesService) {
        this.runningLocation = runningLocation;
        this.startup = startup;
        this._initDataProvider = _initDataProvider;
        this._telemetryService = _telemetryService;
        this._contextService = _contextService;
        this._labelService = _labelService;
        this._logService = _logService;
        this._loggerService = _loggerService;
        this._environmentService = _environmentService;
        this._productService = _productService;
        this._userDataProfilesService = _userDataProfilesService;
        this.remoteAuthority = null;
        this.extensions = null;
        this.onExit = Event.None;
        this._protocolPromise = null;
        this._extensionHostLogsLocation = joinPath(this._environmentService.extHostLogsPath, 'local');
    }
    async start() {
        if (this._protocolPromise == null) {
            this._protocolPromise = this._start();
        }
        return this._protocolPromise;
    }
    async _start() {
        const [mainThreadMessagePassingProtocol, extHostMessagePassingProtocol] = createMessagePassingProtocolPair();
        const initData = await this._createExtHostInitData();
        const hostMain = new ExtensionHostMain(extHostMessagePassingProtocol, initData, hostUtil, null);
        const localExtHostExtensionService = hostMain.getExtHostExtensionService();
        await apiFactoryDeferred.complete((extensionId) => localExtHostExtensionService.getApi(extensionId));
        return mainThreadMessagePassingProtocol;
    }
    async _createExtHostInitData() {
        const initData = await this._initDataProvider.getInitData();
        this.extensions = initData.extensions;
        const workspace = this._contextService.getWorkspace();
        const nlsBaseUrl = this._productService.extensionsGallery?.nlsBaseUrl;
        let nlsUrlWithDetails;
        if (nlsBaseUrl != null && this._productService.commit != null && !platform.Language.isDefaultVariant()) {
            nlsUrlWithDetails = URI.joinPath(( URI.parse(nlsBaseUrl)), this._productService.commit, this._productService.version, platform.Language.value());
        }
        return {
            commit: this._productService.commit,
            version: this._productService.version,
            quality: this._productService.quality,
            parentPid: 0,
            environment: {
                isExtensionDevelopmentDebug: this._environmentService.debugRenderer,
                appName: this._productService.nameLong,
                appHost: this._productService.embedderIdentifier ?? (platform.isWeb ? 'web' : 'desktop'),
                appUriScheme: this._productService.urlProtocol,
                appLanguage: platform.language,
                extensionTelemetryLogResource: this._environmentService.extHostTelemetryLogFile,
                isExtensionTelemetryLoggingOnly: isLoggingOnly(this._productService, this._environmentService),
                extensionDevelopmentLocationURI: this._environmentService.extensionDevelopmentLocationURI,
                extensionTestsLocationURI: this._environmentService.extensionTestsLocationURI,
                globalStorageHome: this._userDataProfilesService.defaultProfile.globalStorageHome,
                workspaceStorageHome: this._environmentService.workspaceStorageHome,
                extensionLogLevel: this._environmentService.extensionLogLevel
            },
            workspace: this._contextService.getWorkbenchState() === 1
                ? undefined
                : {
                    configuration: workspace.configuration ?? undefined,
                    id: workspace.id,
                    name: this._labelService.getWorkspaceLabel(workspace),
                    transient: workspace.transient
                },
            consoleForward: {
                includeStack: false,
                logNative: this._environmentService.debugRenderer
            },
            extensions: initData.extensions.toSnapshot(),
            nlsBaseUrl: nlsUrlWithDetails,
            telemetryInfo: {
                sessionId: this._telemetryService.sessionId,
                machineId: this._telemetryService.machineId,
                firstSessionDate: this._telemetryService.firstSessionDate,
                msftInternal: this._telemetryService.msftInternal
            },
            logLevel: this._logService.getLevel(),
            loggers: [...this._loggerService.getRegisteredLoggers()],
            logsLocation: this._extensionHostLogsLocation,
            autoStart: ((this.startup === 1) ),
            remote: {
                authority: this._environmentService.remoteAuthority,
                connectionData: null,
                isRemote: false
            },
            uiKind: platform.isWeb ? UIKind.Web : UIKind.Desktop
        };
    }
    getInspectPort() {
        return undefined;
    }
    enableInspectPort() {
        return Promise.resolve(false);
    }
    dispose() {
    }
};
LocalExtensionHost = __decorate([
    ( __param(3, ITelemetryService)),
    ( __param(4, IWorkspaceContextService)),
    ( __param(5, ILabelService)),
    ( __param(6, ILogService)),
    ( __param(7, ILoggerService)),
    ( __param(8, IBrowserWorkbenchEnvironmentService)),
    ( __param(9, IProductService)),
    ( __param(10, IUserDataProfilesService))
], LocalExtensionHost);
async function createLocalApi(extensionId) {
    const apiFactory = await apiFactoryDeferred.p;
    return apiFactory(extensionId);
}
setLocalExtensionHost(LocalExtensionHost);
registerLocalApiFactory(createLocalApi);
registerServiceInitializePostParticipant(async (accessor) => {
    accessor.get(IExtensionService);
    setDefaultApi(await createLocalApi());
});
