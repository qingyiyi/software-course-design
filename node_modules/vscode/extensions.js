import { IExtensionService } from './vscode/src/vs/workbench/services/extensions/common/extensions.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { getExtensionId } from './vscode/src/vs/platform/extensionManagement/common/extensionManagementUtil.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { joinPath } from 'monaco-editor/esm/vs/base/common/resources.js';
import { Schemas, FileAccess } from 'monaco-editor/esm/vs/base/common/network.js';
export { ExtensionHostKind } from './vscode/src/vs/workbench/services/extensions/common/extensionHostKind.js';
import { IWorkbenchEnvironmentService } from './vscode/src/vs/workbench/services/environment/common/environmentService.js';
import { parse } from 'monaco-editor/esm/vs/base/common/json.js';
import { IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { CustomSchemas, registerExtensionFile } from '@codingame/monaco-vscode-files-service-override';
import { getService } from './services.js';
import { ExtensionManifestTranslator } from './tools/l10n.js';
import { throttle } from './tools.js';
import { setDefaultApi } from './api.js';
let apiFactory;
function registerLocalApiFactory(_apiFactory) {
    apiFactory = _apiFactory;
}
function registerExtensionFileUrl(extensionLocation, filePath, url, mimeType) {
    const fileDisposable = new DisposableStore();
    fileDisposable.add(FileAccess.registerStaticBrowserUri(joinPath(extensionLocation, filePath), ( URI.parse(url))));
    fileDisposable.add(registerExtensionFile(extensionLocation, filePath, async () => {
        const response = await fetch(url, {
            headers: mimeType != null
                ? {
                    Accept: mimeType
                }
                : {}
        });
        if (response.status !== 200) {
            throw new Error(response.statusText);
        }
        return new Uint8Array(await response.arrayBuffer());
    }));
    return fileDisposable;
}
const deltaExtensions = throttle(async ({ toAdd, toRemove }) => {
    const extensionService = await getService(IExtensionService);
    await extensionService.deltaExtensions(toAdd, toRemove);
}, (a, b) => ({ toAdd: [...a.toAdd, ...b.toAdd], toRemove: [...a.toRemove, ...b.toRemove] }), 0);
async function registerRemoteExtension(directory) {
    const fileService = await getService(IFileService);
    const remoteAuthority = (await getService(IWorkbenchEnvironmentService)).remoteAuthority;
    const content = await fileService.readFile(joinPath(( URI.from(
        { scheme: Schemas.vscodeRemote, authority: remoteAuthority, path: directory }
    )), 'package.json'));
    const manifest = parse(( content.value.toString()));
    return registerExtension(manifest, 3 , { path: directory });
}
function registerExtension(manifest, extHostKind, { builtin = manifest.publisher === 'vscode', path = '/' } = {}) {
    const disposableStore = new DisposableStore();
    const id = getExtensionId(manifest.publisher, manifest.name);
    const location = ( URI.from({ scheme: CustomSchemas.extensionFile, authority: id, path }));
    const addExtensionPromise = (async () => {
        const remoteAuthority = (await getService(IWorkbenchEnvironmentService)).remoteAuthority;
        let realLocation = location;
        if (extHostKind === 3 ) {
            realLocation = ( URI.from({ scheme: Schemas.vscodeRemote, authority: remoteAuthority, path }));
        }
        const instantiationService = await getService(IInstantiationService);
        const translator = instantiationService.createInstance(ExtensionManifestTranslator);
        const localizedManifest = await translator.translateManifest(realLocation, manifest);
        const extension = {
            manifest: localizedManifest,
            type: builtin ? 0  : 1 ,
            isBuiltin: builtin,
            identifier: { id },
            location: realLocation,
            targetPlatform: "web" ,
            isValid: true,
            validations: [],
            extHostKind
        };
        await deltaExtensions({ toAdd: [extension], toRemove: [] });
        return extension;
    })();
    let api = {
        id,
        async whenReady() {
            await addExtensionPromise;
        },
        async dispose() {
            const extension = await addExtensionPromise;
            await deltaExtensions({ toAdd: [], toRemove: [extension] });
            disposableStore.dispose();
        }
    };
    if (extHostKind !== 3 ) {
        function registerFileUrl(path, url, mimeType) {
            return registerExtensionFileUrl(location, path, url, mimeType);
        }
        api = {
            ...api,
            registerFileUrl
        };
    }
    if (extHostKind === 1 ) {
        async function getApi() {
            await addExtensionPromise;
            if (apiFactory == null) {
                throw new Error('The local api can\'t be used without registering the local extension host by importing `vscode/localExtensionHost`');
            }
            return apiFactory(id);
        }
        api = {
            ...api,
            getApi,
            async setAsDefaultApi() {
                setDefaultApi(await getApi());
            }
        };
    }
    return api;
}
export { registerExtension, registerLocalApiFactory, registerRemoteExtension };
