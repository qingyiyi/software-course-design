import { __decorate, __param } from '../external/tslib/tslib.es6.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { parse, getNodeType } from 'monaco-editor/esm/vs/base/common/json.js';
import { joinPath } from 'monaco-editor/esm/vs/base/common/resources.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { localizeManifest } from '../vscode/src/vs/platform/extensionManagement/common/extensionNls.js';
import { getParseErrorMessage } from '../vscode/src/vs/base/common/jsonErrorMessages.js';
import * as platform from 'monaco-editor/esm/vs/base/common/platform.js';
import { getBuiltInExtensionTranslationsUris } from '../l10n.js';
let ExtensionManifestTranslator = class ExtensionManifestTranslator {
    constructor(fileService, logService) {
        this.fileService = fileService;
        this.logService = logService;
    }
    async resolveOriginalMessageBundle(originalMessageBundle, errors) {
        if (originalMessageBundle != null) {
            try {
                const originalBundleContent = ( (await this.fileService.readFile(originalMessageBundle)).value.toString());
                return parse(originalBundleContent, errors);
            }
            catch (error) {
            }
        }
        return undefined;
    }
    findMessageBundles(extensionLocation, nlsConfiguration) {
        return new Promise((resolve) => {
            const loop = (locale) => {
                const toCheck = joinPath(extensionLocation, `package.nls.${locale}.json`);
                void this.fileService.exists(toCheck).then(exists => {
                    if (exists) {
                        resolve({ localized: toCheck, original: joinPath(extensionLocation, 'package.nls.json') });
                    }
                    const index = locale.lastIndexOf('-');
                    if (index === -1) {
                        resolve({ localized: joinPath(extensionLocation, 'package.nls.json'), original: null });
                    }
                    else {
                        locale = locale.substring(0, index);
                        loop(locale);
                    }
                });
            };
            if (nlsConfiguration.devMode || nlsConfiguration.pseudo || nlsConfiguration.language == null) {
                return resolve({ localized: joinPath(extensionLocation, 'package.nls.json'), original: null });
            }
            loop(nlsConfiguration.language);
        });
    }
    formatMessage(extensionLocation, message) {
        return `[${extensionLocation.path}]: ${message}`;
    }
    async translateManifest(extensionLocation, extensionManifest) {
        const nlsConfiguration = {
            devMode: false,
            language: platform.language,
            pseudo: platform.language === 'pseudo',
            translations: getBuiltInExtensionTranslationsUris(platform.language) ?? {}
        };
        const localizedMessages = await this.getLocalizedMessages(extensionLocation, extensionManifest, nlsConfiguration);
        if (localizedMessages != null) {
            try {
                const errors = [];
                const defaults = await this.resolveOriginalMessageBundle(localizedMessages.default, errors);
                if (errors.length > 0) {
                    errors.forEach((error) => {
                        this.logService.error(this.formatMessage(extensionLocation, ( localize(
                            'jsonsParseReportErrors',
                            'Failed to parse {0}: {1}.',
                            localizedMessages.default?.path,
                            getParseErrorMessage(error.error)
                        ))));
                    });
                    return extensionManifest;
                }
                else if (getNodeType(localizedMessages) !== 'object') {
                    this.logService.error(this.formatMessage(extensionLocation, ( localize(
                        'jsonInvalidFormat',
                        'Invalid format {0}: JSON object expected.',
                        localizedMessages.default?.path
                    ))));
                    return extensionManifest;
                }
                const localized = localizedMessages.values ?? Object.create(null);
                return localizeManifest(this.logService, extensionManifest, localized, defaults);
            }
            catch (error) {
            }
        }
        return extensionManifest;
    }
    async getLocalizedMessages(extensionLocation, extensionManifest, nlsConfiguration) {
        const defaultPackageNLS = joinPath(extensionLocation, 'package.nls.json');
        const reportErrors = (localized, errors) => {
            errors.forEach((error) => {
                this.logService.error(this.formatMessage(extensionLocation, ( localize(
                    'jsonsParseReportErrors',
                    'Failed to parse {0}: {1}.',
                    localized?.path,
                    getParseErrorMessage(error.error)
                ))));
            });
        };
        const reportInvalidFormat = (localized) => {
            this.logService.error(this.formatMessage(extensionLocation, ( localize(
                'jsonInvalidFormat',
                'Invalid format {0}: JSON object expected.',
                localized?.path
            ))));
        };
        const translationId = `${extensionManifest.publisher}.${extensionManifest.name}`;
        const translationUri = nlsConfiguration.translations[translationId];
        if (translationUri != null) {
            try {
                const translationResource = ( URI.parse(translationUri));
                const content = ( (await this.fileService.readFile(translationResource)).value.toString());
                const errors = [];
                const translationBundle = parse(content, errors);
                if (errors.length > 0) {
                    reportErrors(translationResource, errors);
                    return { values: undefined, default: defaultPackageNLS };
                }
                else if (getNodeType(translationBundle) !== 'object') {
                    reportInvalidFormat(translationResource);
                    return { values: undefined, default: defaultPackageNLS };
                }
                else {
                    const values = translationBundle.contents?.package;
                    return { values, default: defaultPackageNLS };
                }
            }
            catch (error) {
                return { values: undefined, default: defaultPackageNLS };
            }
        }
        else {
            const exists = await this.fileService.exists(defaultPackageNLS);
            if (!exists) {
                return undefined;
            }
            let messageBundle;
            try {
                messageBundle = await this.findMessageBundles(extensionLocation, nlsConfiguration);
            }
            catch (error) {
                return undefined;
            }
            if (messageBundle.localized == null) {
                return { values: undefined, default: messageBundle.original };
            }
            try {
                const messageBundleContent = ( (await this.fileService.readFile(messageBundle.localized)).value.toString());
                const errors = [];
                const messages = parse(messageBundleContent, errors);
                if (errors.length > 0) {
                    reportErrors(messageBundle.localized, errors);
                    return { values: undefined, default: messageBundle.original };
                }
                else if (getNodeType(messages) !== 'object') {
                    reportInvalidFormat(messageBundle.localized);
                    return { values: undefined, default: messageBundle.original };
                }
                return { values: messages, default: messageBundle.original };
            }
            catch (error) {
                return { values: undefined, default: messageBundle.original };
            }
        }
    }
};
ExtensionManifestTranslator = __decorate([
    ( __param(0, IFileService)),
    ( __param(1, ILogService))
], ExtensionManifestTranslator);
export { ExtensionManifestTranslator };
