import { IEditorOverrideServices } from 'vscode/vscode/vs/editor/standalone/browser/standaloneServices';
import { Emitter, Event } from 'vscode/vscode/vs/base/common/event';
import { Disposable, IDisposable } from 'vscode/vscode/vs/base/common/lifecycle';
import { URI } from 'vscode/vscode/vs/base/common/uri';
import { FileType, IStat, IFileSystemProviderWithFileReadWriteCapability, IFileChange, IFileSystemProvider, FileSystemProviderCapabilities, FileChangeType, IFileWriteOptions, IWatchOptions, IFileDeleteOptions, IFileOverwriteOptions } from 'vscode/vscode/vs/platform/files/common/files';
export { FileChangeType, FilePermission, FileSystemProviderCapabilities, FileSystemProviderError, FileSystemProviderErrorCode, FileType, IFileChange, IFileDeleteOptions, IFileOverwriteOptions, IFileSystemProviderWithFileReadWriteCapability, IFileWriteOptions, IStat, IWatchOptions } from 'vscode/vscode/vs/platform/files/common/files';
import { IndexedDBFileSystemProvider } from './vscode/src/vs/platform/files/browser/indexedDBFileSystemProvider.js';

declare abstract class RegisteredFile {
    uri: URI;
    private readonly;
    private ctime;
    private mtime;
    readonly type: FileType;
    protected _onDidChange: Emitter<void>;
    onDidChange: Event<void>;
    protected _onDidDelete: Emitter<void>;
    onDidDelete: Event<void>;
    protected _onDidRename: Emitter<{
        from: URI;
        to: URI;
    }>;
    onDidRename: Event<{
        from: URI;
        to: URI;
    }>;
    constructor(uri: URI, readonly: boolean);
    stats(): Promise<IStat>;
    getSize(): Promise<number>;
    abstract read(): Promise<string | Uint8Array>;
    abstract write(content: string): Promise<void>;
    delete(): Promise<void>;
    rename(to: URI): Promise<void>;
}
declare class RegisteredReadOnlyFile extends RegisteredFile {
    read: () => Promise<string | Uint8Array>;
    constructor(uri: URI, read: () => Promise<string | Uint8Array>);
    write(): Promise<void>;
    delete(): Promise<void>;
    rename(): Promise<void>;
}
declare class RegisteredMemoryFile extends RegisteredFile {
    private content;
    constructor(uri: URI, content: string);
    read(): Promise<string | Uint8Array>;
    write(content: string): Promise<void>;
}
declare class RegisteredFileSystemProvider extends Disposable implements IFileSystemProviderWithFileReadWriteCapability {
    private files;
    capabilities: number;
    constructor(readonly: boolean);
    onDidChangeCapabilities: Event<any>;
    _onDidChangeFile: Emitter<readonly IFileChange[]>;
    onDidChangeFile: Event<readonly IFileChange[]>;
    registerFile(file: RegisteredFile): IDisposable;
    stat(resource: URI): Promise<IStat>;
    readdir(resource: URI): Promise<[string, FileType][]>;
    readFile(resource: URI): Promise<Uint8Array>;
    watch(): IDisposable;
    writeFile(resource: URI, content: Uint8Array): Promise<void>;
    delete(resource: URI): Promise<void>;
    rename(from: URI, to: URI): Promise<void>;
    mkdir(): Promise<never>;
}
declare class DelegateFileSystemProvider implements IFileSystemProvider {
    private options;
    constructor(options: {
        delegate: IFileSystemProvider;
        toDelegate: (uri: URI) => URI;
        fromDeletate: (uri: URI) => URI;
    });
    get capabilities(): FileSystemProviderCapabilities;
    onDidChangeCapabilities: Event<void>;
    onDidChangeFile: Event<{
        type: FileChangeType;
        resource: URI;
    }[]>;
    readFile: ((resource: URI) => Promise<Uint8Array>) | undefined;
    writeFile: ((resource: URI, content: Uint8Array, opts: IFileWriteOptions) => Promise<void>) | undefined;
    watch(resource: URI, opts: IWatchOptions): IDisposable;
    stat(resource: URI): Promise<IStat>;
    mkdir(resource: URI): Promise<void>;
    readdir(resource: URI): Promise<[string, FileType][]>;
    delete(resource: URI, opts: IFileDeleteOptions): Promise<void>;
    rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;
}
declare namespace CustomSchemas {
    /**
     * A schema that is used for models that exist in memory
     * only and that have no correspondence on a server or such.
     */
    const extensionFile = "extension-file";
}
declare function getServiceOverride(): IEditorOverrideServices;
/**
 * Register a custom file system provider for the given scheme. This allows us to override
 * the default file system provider for a given scheme.
 */
declare function registerCustomProvider(scheme: string, provider: IFileSystemProvider): void;
declare function registerExtensionFile(extensionLocation: URI, filePath: string, getContent: () => Promise<string | Uint8Array>): IDisposable;
/**
 * Can be used to create a file before the fileService is initialized
 */
declare function initFile(file: URI, content: Uint8Array | string, options?: Partial<IFileWriteOptions>): Promise<void>;
/**
 * Can be used to replace memory providers by indexeddb providers before the fileService is initialized
 */
declare function createIndexedDBProviders(): Promise<IndexedDBFileSystemProvider>;
/**
 * Register a file system overlay
 *
 * By default, a memory filesystem is used to read and write file
 *
 * This method allows to register another fileSystemProvider in front OR behind the default memory one.
 *
 * The default one is registered as priority: 0, so:
 * - any provider registered with a positive priority will be in front of the default one
 * - any provider registered with a negative priority will be behind the default one
 */
declare function registerFileSystemOverlay(priority: number, provider: IFileSystemProviderWithFileReadWriteCapability): IDisposable;

export { CustomSchemas, DelegateFileSystemProvider, IndexedDBFileSystemProvider, RegisteredFile, RegisteredFileSystemProvider, RegisteredMemoryFile, RegisteredReadOnlyFile, createIndexedDBProviders, getServiceOverride as default, initFile, registerCustomProvider, registerExtensionFile, registerFileSystemOverlay };
