import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';
import { DeferredPromise } from 'monaco-editor/esm/vs/base/common/async.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { Disposable, DisposableMap } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { revive } from 'monaco-editor/esm/vs/base/common/marshalling.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { MainContext, ExtHostContext } from 'vscode/vscode/vs/workbench/api/common/extHost.protocol';
import { IChatWidgetService } from 'vscode/vscode/vs/workbench/contrib/chat/browser/chat';
import { IChatContributionService } from 'vscode/vscode/vs/workbench/contrib/chat/common/chatContributionService';
import { isCompleteInteractiveProgressTreeData } from '../../contrib/chat/common/chatModel.js';
import { IChatService } from 'vscode/vscode/vs/workbench/contrib/chat/common/chatService';
import { extHostNamedCustomer } from '../../services/extensions/common/extHostCustomers.js';

let MainThreadChat = class MainThreadChat extends Disposable {
    constructor(extHostContext, _chatService, _chatWidgetService, chatContribService) {
        super();
        this._chatService = _chatService;
        this._chatWidgetService = _chatWidgetService;
        this.chatContribService = chatContribService;
        this._providerRegistrations = this._register(( new DisposableMap()));
        this._activeRequestProgressCallbacks = ( new Map());
        this._stateEmitters = ( new Map());
        this._responsePartHandlePool = 0;
        this._activeResponsePartPromises = ( new Map());
        this._proxy = ( extHostContext.getProxy(ExtHostContext.ExtHostChat));
        this._register(this._chatService.onDidPerformUserAction(e => {
            this._proxy.$onDidPerformUserAction(e);
        }));
    }
    $transferChatSession(sessionId, toWorkspace) {
        const sessionIdStr = this._chatService.getSessionId(sessionId);
        if (!sessionIdStr) {
            throw new Error(`Failed to transfer session. Unknown session provider ID: ${sessionId}`);
        }
        const widget = this._chatWidgetService.getWidgetBySessionId(sessionIdStr);
        const inputValue = widget?.inputEditor.getValue() ?? '';
        this._chatService.transferChatSession({ sessionId: sessionIdStr, inputValue: inputValue }, URI.revive(toWorkspace));
    }
    async $registerChatProvider(handle, id) {
        const registration = this.chatContribService.registeredProviders.find(staticProvider => staticProvider.id === id);
        if (!registration) {
            throw new Error(`Provider ${id} must be declared in the package.json.`);
        }
        const unreg = this._chatService.registerProvider({
            id,
            displayName: registration.label,
            prepareSession: async (initialState, token) => {
                const session = await this._proxy.$prepareChat(handle, initialState, token);
                if (!session) {
                    return undefined;
                }
                const responderAvatarIconUri = session.responderAvatarIconUri ?
                    URI.revive(session.responderAvatarIconUri) :
                    registration.extensionIcon;
                const emitter = ( new Emitter());
                this._stateEmitters.set(session.id, emitter);
                return {
                    id: session.id,
                    requesterUsername: session.requesterUsername,
                    requesterAvatarIconUri: URI.revive(session.requesterAvatarIconUri),
                    responderUsername: session.responderUsername,
                    responderAvatarIconUri,
                    inputPlaceholder: session.inputPlaceholder,
                    onDidChangeState: emitter.event,
                    dispose: () => {
                        emitter.dispose();
                        this._stateEmitters.delete(session.id);
                        this._proxy.$releaseSession(session.id);
                    }
                };
            },
            resolveRequest: async (session, context, token) => {
                const dto = await this._proxy.$resolveRequest(handle, session.id, context, token);
                return {
                    session,
                    ...dto
                };
            },
            provideReply: async (request, progress, token) => {
                const id = `${handle}_${request.session.id}`;
                this._activeRequestProgressCallbacks.set(id, progress);
                try {
                    const requestDto = {
                        message: request.message,
                        variables: request.variables
                    };
                    const dto = await this._proxy.$provideReply(handle, request.session.id, requestDto, token);
                    return {
                        session: request.session,
                        ...dto
                    };
                }
                finally {
                    this._activeRequestProgressCallbacks.delete(id);
                }
            },
            provideWelcomeMessage: (token) => {
                return this._proxy.$provideWelcomeMessage(handle, token);
            },
            provideSlashCommands: (session, token) => {
                return this._proxy.$provideSlashCommands(handle, session.id, token);
            },
            provideFollowups: (session, token) => {
                return this._proxy.$provideFollowups(handle, session.id, token);
            },
            removeRequest: (session, requestId) => {
                return this._proxy.$removeRequest(handle, session.id, requestId);
            }
        });
        this._providerRegistrations.set(handle, unreg);
    }
    async $acceptResponseProgress(handle, sessionId, progress, responsePartHandle) {
        const id = `${handle}_${sessionId}`;
        if ('placeholder' in progress) {
            const responsePartId = `${id}_${++this._responsePartHandlePool}`;
            const deferredContentPromise = ( new DeferredPromise());
            this._activeResponsePartPromises.set(responsePartId, deferredContentPromise);
            this._activeRequestProgressCallbacks.get(id)?.({ ...progress, resolvedContent: deferredContentPromise.p });
            return this._responsePartHandlePool;
        }
        else if (responsePartHandle) {
            const responsePartId = `${id}_${responsePartHandle}`;
            const deferredContentPromise = this._activeResponsePartPromises.get(responsePartId);
            if (deferredContentPromise && isCompleteInteractiveProgressTreeData(progress)) {
                const withRevivedUris = revive(progress);
                deferredContentPromise.complete(withRevivedUris);
                this._activeResponsePartPromises.delete(responsePartId);
            }
            else if (deferredContentPromise && 'content' in progress) {
                deferredContentPromise.complete(progress.content);
                this._activeResponsePartPromises.delete(responsePartId);
            }
            return;
        }
        if (isCompleteInteractiveProgressTreeData(progress)) {
            return;
        }
        if ('documents' in progress) {
            const usedContext = {
                documents: ( progress.documents.map(({ uri, version, ranges }) => ({
                    uri: URI.revive(uri),
                    version,
                    ranges,
                }))),
            };
            this._activeRequestProgressCallbacks.get(id)?.(usedContext);
            return;
        }
        this._activeRequestProgressCallbacks.get(id)?.(progress);
    }
    async $acceptChatState(sessionId, state) {
        this._stateEmitters.get(sessionId)?.fire(state);
    }
    $addRequest(context) {
        this._chatService.addRequest(context);
    }
    async $sendRequestToProvider(providerId, message) {
        const widget = await this._chatWidgetService.revealViewForProvider(providerId);
        if (widget && widget.viewModel) {
            this._chatService.sendRequestToProvider(widget.viewModel.sessionId, message);
        }
    }
    async $unregisterChatProvider(handle) {
        this._providerRegistrations.deleteAndDispose(handle);
    }
};
MainThreadChat = __decorate([
    extHostNamedCustomer(MainContext.MainThreadChat),
    ( __param(1, IChatService)),
    ( __param(2, IChatWidgetService)),
    ( __param(3, IChatContributionService))
], MainThreadChat);

export { MainThreadChat };
